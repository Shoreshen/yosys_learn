!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/shore/OneDrive/yosys/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210905.0/
$(BINTEST)/%	yosys/tests/unit/Makefile	/^$(BINTEST)\/%: $(OBJTEST)\/%.o$/;"	t
$(MAKECMDGOALS)	yosys/tests/tools/autotest.mk	/^$(MAKECMDGOALS):$/;"	t
$(OBJTEST)/%.o	yosys/tests/unit/Makefile	/^$(OBJTEST)\/%.o: $(basename $(subst $(OBJTEST),.,%)).cc$/;"	t
$(PROGRAM_PREFIX)yosys$(EXE)	yosys/Makefile	/^$(PROGRAM_PREFIX)yosys$(EXE): $(OBJS)$/;"	t
$(PROGRAM_PREFIX)yosys-abc$(EXE)	yosys/Makefile	/^$(PROGRAM_PREFIX)yosys-abc$(EXE): abc\/abc-$(ABCREV)$(EXE)$/;"	t
$(PROGRAM_PREFIX)yosys-config	yosys/Makefile	/^$(PROGRAM_PREFIX)yosys-config: misc\/yosys-config.in$/;"	t
$(PROGRAM_PREFIX)yosys-libabc.a	yosys/Makefile	/^$(PROGRAM_PREFIX)yosys-libabc.a: abc\/libabc-$(ABCREV).a$/;"	t
$(PY_WRAPPER_FILE).cc	yosys/Makefile	/^$(PY_WRAPPER_FILE).cc: misc\/$(PY_GEN_SCRIPT).py $(PY_WRAP_INCLUDES)$/;"	t
$(library-objects)	yosys/libs/bigint/Makefile	/^$(library-objects): $(library-headers)$/;"	t
$(program)	yosys/libs/bigint/Makefile	/^$(program) : $(program-objects) $(library-objects)$/;"	t
$(program-objects)	yosys/libs/bigint/Makefile	/^$(program-objects) : $(library-headers)$/;"	t
%.o	yosys/Makefile	/^%.o: %.cc$/;"	t
%.o	yosys/Makefile	/^%.o: %.cpp$/;"	t
%.o	yosys/libs/bigint/Makefile	/^%.o: %.cc$/;"	t
%.ok	yosys/tests/sva/Makefile	/^%.ok:$/;"	t
%.pyh	yosys/Makefile	/^%.pyh: %.h$/;"	t
A	yosys/frontends/aiger/aigerparse.h	/^    unsigned M, I, L, O, A;$/;"	m	struct:AigerReader	typeref:typename:unsigned
ABCEXTERNAL	yosys/Makefile	/^ABCEXTERNAL ?=$/;"	m
ABCMKARGS	yosys/Makefile	/^ABCMKARGS = CC="$(CC)" CXX="$(CXX)" LD="$(LD)" ABC_USE_LIBSTDCXX=1 LIBS="-lm -lpthread -static" /;"	m
ABCMKARGS	yosys/Makefile	/^ABCMKARGS = CC="$(CXX)" CXX="$(CXX)" ABC_USE_LIBSTDCXX=1 VERBOSE=$(Q)$/;"	m
ABCOPT	yosys/Makefile	/^ABCOPT=""$/;"	m
ABCOPT	yosys/Makefile	/^ABCOPT="-A $(ABCEXTERNAL)"$/;"	m
ABCPULL	yosys/Makefile	/^ABCPULL = 1$/;"	m
ABCREV	yosys/Makefile	/^ABCREV = 00b674d$/;"	m
ABCURL	yosys/Makefile	/^ABCURL ?= https:\/\/github.com\/YosysHQ\/abc$/;"	m
ABC_AIGERPARSE	yosys/frontends/aiger/aigerparse.h	/^#define ABC_AIGERPARSE$/;"	d
ABC_BLIFPARSE	yosys/frontends/blif/blifparse.h	/^#define ABC_BLIFPARSE$/;"	d
ABC_COMMAND_CTR	yosys/passes/techmap/abc.cc	/^#define ABC_COMMAND_CTR /;"	d	file:
ABC_COMMAND_DFL	yosys/passes/techmap/abc.cc	/^#define ABC_COMMAND_DFL /;"	d	file:
ABC_COMMAND_LIB	yosys/passes/techmap/abc.cc	/^#define ABC_COMMAND_LIB /;"	d	file:
ABC_COMMAND_LUT	yosys/passes/techmap/abc.cc	/^#define ABC_COMMAND_LUT /;"	d	file:
ABC_COMMAND_SOP	yosys/passes/techmap/abc.cc	/^#define ABC_COMMAND_SOP /;"	d	file:
ABC_FAST_COMMAND_CTR	yosys/passes/techmap/abc.cc	/^#define ABC_FAST_COMMAND_CTR /;"	d	file:
ABC_FAST_COMMAND_DFL	yosys/passes/techmap/abc.cc	/^#define ABC_FAST_COMMAND_DFL /;"	d	file:
ABC_FAST_COMMAND_LIB	yosys/passes/techmap/abc.cc	/^#define ABC_FAST_COMMAND_LIB /;"	d	file:
ABC_FAST_COMMAND_LUT	yosys/passes/techmap/abc.cc	/^#define ABC_FAST_COMMAND_LUT /;"	d	file:
ABC_FAST_COMMAND_SOP	yosys/passes/techmap/abc.cc	/^#define ABC_FAST_COMMAND_SOP /;"	d	file:
ACCELERATION_DEFAULT	yosys/libs/fst/lz4.cc	/^#define ACCELERATION_DEFAULT /;"	d	file:
ACTION_DO	yosys/passes/opt/opt_expr.cc	/^#define ACTION_DO(/;"	d	file:
ACTION_DO_Y	yosys/passes/opt/opt_expr.cc	/^#define ACTION_DO_Y(/;"	d	file:
AIWWriter	yosys/passes/sat/sim.cc	/^	AIWWriter(SimWorker *worker, std::string filename) : OutputWriter(worker) {$/;"	f	struct:AIWWriter	file:
AIWWriter	yosys/passes/sat/sim.cc	/^struct AIWWriter : public OutputWriter$/;"	s	file:
ALIAS	yosys/backends/cxxrtl/cxxrtl.h	/^		ALIAS   = CXXRTL_ALIAS,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40303
ALIAS	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		ALIAS,$/;"	e	enum:WireType::Type	file:
ALLOCATOR	yosys/libs/fst/lz4.cc	/^#define ALLOCATOR(/;"	d	file:
ALLTESTFILE	yosys/tests/unit/Makefile	/^ALLTESTFILE := $(shell find -name '*Test.cc' -printf '%P ')$/;"	m
AND	yosys/libs/ezsat/ezsat.h	/^	int AND(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {$/;"	f	class:ezSAT	typeref:typename:int
ARRAY	yosys/libs/json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::Json::Type
AST	yosys/frontends/ast/ast.cc	/^namespace AST {$/;"	n	file:
AST	yosys/frontends/ast/ast.h	/^namespace AST$/;"	n
AST	yosys/frontends/ast/ast_binding.h	/^namespace AST$/;"	n
AST	yosys/kernel/yosys.h	/^namespace AST {$/;"	n
AST_ADD	yosys/frontends/ast/ast.h	/^		AST_ADD,$/;"	e	enum:AST::AstNodeType
AST_ALWAYS	yosys/frontends/ast/ast.h	/^		AST_ALWAYS,$/;"	e	enum:AST::AstNodeType
AST_ARGUMENT	yosys/frontends/ast/ast.h	/^		AST_ARGUMENT,$/;"	e	enum:AST::AstNodeType
AST_ASSERT	yosys/frontends/ast/ast.h	/^		AST_ASSERT,$/;"	e	enum:AST::AstNodeType
AST_ASSIGN	yosys/frontends/ast/ast.h	/^		AST_ASSIGN,$/;"	e	enum:AST::AstNodeType
AST_ASSIGN_EQ	yosys/frontends/ast/ast.h	/^		AST_ASSIGN_EQ,$/;"	e	enum:AST::AstNodeType
AST_ASSIGN_LE	yosys/frontends/ast/ast.h	/^		AST_ASSIGN_LE,$/;"	e	enum:AST::AstNodeType
AST_ASSUME	yosys/frontends/ast/ast.h	/^		AST_ASSUME,$/;"	e	enum:AST::AstNodeType
AST_AUTOWIRE	yosys/frontends/ast/ast.h	/^		AST_AUTOWIRE,$/;"	e	enum:AST::AstNodeType
AST_BIND	yosys/frontends/ast/ast.h	/^		AST_BIND$/;"	e	enum:AST::AstNodeType
AST_BINDING_H	yosys/frontends/ast/ast_binding.h	/^#define AST_BINDING_H$/;"	d
AST_BIT_AND	yosys/frontends/ast/ast.h	/^		AST_BIT_AND,$/;"	e	enum:AST::AstNodeType
AST_BIT_NOT	yosys/frontends/ast/ast.h	/^		AST_BIT_NOT,$/;"	e	enum:AST::AstNodeType
AST_BIT_OR	yosys/frontends/ast/ast.h	/^		AST_BIT_OR,$/;"	e	enum:AST::AstNodeType
AST_BIT_XNOR	yosys/frontends/ast/ast.h	/^		AST_BIT_XNOR,$/;"	e	enum:AST::AstNodeType
AST_BIT_XOR	yosys/frontends/ast/ast.h	/^		AST_BIT_XOR,$/;"	e	enum:AST::AstNodeType
AST_BLOCK	yosys/frontends/ast/ast.h	/^		AST_BLOCK,$/;"	e	enum:AST::AstNodeType
AST_CASE	yosys/frontends/ast/ast.h	/^		AST_CASE,$/;"	e	enum:AST::AstNodeType
AST_CAST_SIZE	yosys/frontends/ast/ast.h	/^		AST_CAST_SIZE,$/;"	e	enum:AST::AstNodeType
AST_CELL	yosys/frontends/ast/ast.h	/^		AST_CELL,$/;"	e	enum:AST::AstNodeType
AST_CELLARRAY	yosys/frontends/ast/ast.h	/^		AST_CELLARRAY,$/;"	e	enum:AST::AstNodeType
AST_CELLTYPE	yosys/frontends/ast/ast.h	/^		AST_CELLTYPE,$/;"	e	enum:AST::AstNodeType
AST_CONCAT	yosys/frontends/ast/ast.h	/^		AST_CONCAT,$/;"	e	enum:AST::AstNodeType
AST_COND	yosys/frontends/ast/ast.h	/^		AST_COND,$/;"	e	enum:AST::AstNodeType
AST_CONDX	yosys/frontends/ast/ast.h	/^		AST_CONDX,$/;"	e	enum:AST::AstNodeType
AST_CONDZ	yosys/frontends/ast/ast.h	/^		AST_CONDZ,$/;"	e	enum:AST::AstNodeType
AST_CONSTANT	yosys/frontends/ast/ast.h	/^		AST_CONSTANT,$/;"	e	enum:AST::AstNodeType
AST_COVER	yosys/frontends/ast/ast.h	/^		AST_COVER,$/;"	e	enum:AST::AstNodeType
AST_DEFAULT	yosys/frontends/ast/ast.h	/^		AST_DEFAULT,$/;"	e	enum:AST::AstNodeType
AST_DEFPARAM	yosys/frontends/ast/ast.h	/^		AST_DEFPARAM,$/;"	e	enum:AST::AstNodeType
AST_DESIGN	yosys/frontends/ast/ast.h	/^		AST_DESIGN,$/;"	e	enum:AST::AstNodeType
AST_DIV	yosys/frontends/ast/ast.h	/^		AST_DIV,$/;"	e	enum:AST::AstNodeType
AST_DPI_FUNCTION	yosys/frontends/ast/ast.h	/^		AST_DPI_FUNCTION,$/;"	e	enum:AST::AstNodeType
AST_EDGE	yosys/frontends/ast/ast.h	/^		AST_EDGE,$/;"	e	enum:AST::AstNodeType
AST_ENUM	yosys/frontends/ast/ast.h	/^		AST_ENUM,$/;"	e	enum:AST::AstNodeType
AST_ENUM_ITEM	yosys/frontends/ast/ast.h	/^		AST_ENUM_ITEM,$/;"	e	enum:AST::AstNodeType
AST_EQ	yosys/frontends/ast/ast.h	/^		AST_EQ,$/;"	e	enum:AST::AstNodeType
AST_EQX	yosys/frontends/ast/ast.h	/^		AST_EQX,$/;"	e	enum:AST::AstNodeType
AST_FAIR	yosys/frontends/ast/ast.h	/^		AST_FAIR,$/;"	e	enum:AST::AstNodeType
AST_FCALL	yosys/frontends/ast/ast.h	/^		AST_FCALL,$/;"	e	enum:AST::AstNodeType
AST_FOR	yosys/frontends/ast/ast.h	/^		AST_FOR,$/;"	e	enum:AST::AstNodeType
AST_FUNCTION	yosys/frontends/ast/ast.h	/^		AST_FUNCTION,$/;"	e	enum:AST::AstNodeType
AST_GE	yosys/frontends/ast/ast.h	/^		AST_GE,$/;"	e	enum:AST::AstNodeType
AST_GENBLOCK	yosys/frontends/ast/ast.h	/^		AST_GENBLOCK,$/;"	e	enum:AST::AstNodeType
AST_GENCASE	yosys/frontends/ast/ast.h	/^		AST_GENCASE,$/;"	e	enum:AST::AstNodeType
AST_GENFOR	yosys/frontends/ast/ast.h	/^		AST_GENFOR,$/;"	e	enum:AST::AstNodeType
AST_GENIF	yosys/frontends/ast/ast.h	/^		AST_GENIF,$/;"	e	enum:AST::AstNodeType
AST_GENVAR	yosys/frontends/ast/ast.h	/^		AST_GENVAR,$/;"	e	enum:AST::AstNodeType
AST_GT	yosys/frontends/ast/ast.h	/^		AST_GT,$/;"	e	enum:AST::AstNodeType
AST_H	yosys/frontends/ast/ast.h	/^#define AST_H$/;"	d
AST_IDENTIFIER	yosys/frontends/ast/ast.h	/^		AST_IDENTIFIER,$/;"	e	enum:AST::AstNodeType
AST_INITIAL	yosys/frontends/ast/ast.h	/^		AST_INITIAL,$/;"	e	enum:AST::AstNodeType
AST_INTERFACE	yosys/frontends/ast/ast.h	/^		AST_INTERFACE,$/;"	e	enum:AST::AstNodeType
AST_INTERFACEPORT	yosys/frontends/ast/ast.h	/^		AST_INTERFACEPORT,$/;"	e	enum:AST::AstNodeType
AST_INTERFACEPORTTYPE	yosys/frontends/ast/ast.h	/^		AST_INTERFACEPORTTYPE,$/;"	e	enum:AST::AstNodeType
AST_INTERNAL	yosys/frontends/ast/ast.cc	/^namespace AST_INTERNAL {$/;"	n	file:
AST_INTERNAL	yosys/frontends/ast/ast.h	/^namespace AST_INTERNAL$/;"	n
AST_LE	yosys/frontends/ast/ast.h	/^		AST_LE,$/;"	e	enum:AST::AstNodeType
AST_LIVE	yosys/frontends/ast/ast.h	/^		AST_LIVE,$/;"	e	enum:AST::AstNodeType
AST_LOCALPARAM	yosys/frontends/ast/ast.h	/^		AST_LOCALPARAM,$/;"	e	enum:AST::AstNodeType
AST_LOGIC_AND	yosys/frontends/ast/ast.h	/^		AST_LOGIC_AND,$/;"	e	enum:AST::AstNodeType
AST_LOGIC_NOT	yosys/frontends/ast/ast.h	/^		AST_LOGIC_NOT,$/;"	e	enum:AST::AstNodeType
AST_LOGIC_OR	yosys/frontends/ast/ast.h	/^		AST_LOGIC_OR,$/;"	e	enum:AST::AstNodeType
AST_LT	yosys/frontends/ast/ast.h	/^		AST_LT,$/;"	e	enum:AST::AstNodeType
AST_MEMINIT	yosys/frontends/ast/ast.h	/^		AST_MEMINIT,$/;"	e	enum:AST::AstNodeType
AST_MEMORY	yosys/frontends/ast/ast.h	/^		AST_MEMORY,$/;"	e	enum:AST::AstNodeType
AST_MEMRD	yosys/frontends/ast/ast.h	/^		AST_MEMRD,$/;"	e	enum:AST::AstNodeType
AST_MEMWR	yosys/frontends/ast/ast.h	/^		AST_MEMWR,$/;"	e	enum:AST::AstNodeType
AST_MOD	yosys/frontends/ast/ast.h	/^		AST_MOD,$/;"	e	enum:AST::AstNodeType
AST_MODPORT	yosys/frontends/ast/ast.h	/^		AST_MODPORT,$/;"	e	enum:AST::AstNodeType
AST_MODPORTMEMBER	yosys/frontends/ast/ast.h	/^		AST_MODPORTMEMBER,$/;"	e	enum:AST::AstNodeType
AST_MODULE	yosys/frontends/ast/ast.h	/^		AST_MODULE,$/;"	e	enum:AST::AstNodeType
AST_MUL	yosys/frontends/ast/ast.h	/^		AST_MUL,$/;"	e	enum:AST::AstNodeType
AST_MULTIRANGE	yosys/frontends/ast/ast.h	/^		AST_MULTIRANGE,$/;"	e	enum:AST::AstNodeType
AST_NE	yosys/frontends/ast/ast.h	/^		AST_NE,$/;"	e	enum:AST::AstNodeType
AST_NEG	yosys/frontends/ast/ast.h	/^		AST_NEG,$/;"	e	enum:AST::AstNodeType
AST_NEGEDGE	yosys/frontends/ast/ast.h	/^		AST_NEGEDGE,$/;"	e	enum:AST::AstNodeType
AST_NEX	yosys/frontends/ast/ast.h	/^		AST_NEX,$/;"	e	enum:AST::AstNodeType
AST_NONE	yosys/frontends/ast/ast.h	/^		AST_NONE,$/;"	e	enum:AST::AstNodeType
AST_PACKAGE	yosys/frontends/ast/ast.h	/^		AST_PACKAGE,$/;"	e	enum:AST::AstNodeType
AST_PARAMETER	yosys/frontends/ast/ast.h	/^		AST_PARAMETER,$/;"	e	enum:AST::AstNodeType
AST_PARASET	yosys/frontends/ast/ast.h	/^		AST_PARASET,$/;"	e	enum:AST::AstNodeType
AST_POS	yosys/frontends/ast/ast.h	/^		AST_POS,$/;"	e	enum:AST::AstNodeType
AST_POSEDGE	yosys/frontends/ast/ast.h	/^		AST_POSEDGE,$/;"	e	enum:AST::AstNodeType
AST_POW	yosys/frontends/ast/ast.h	/^		AST_POW,$/;"	e	enum:AST::AstNodeType
AST_PREFIX	yosys/frontends/ast/ast.h	/^		AST_PREFIX,$/;"	e	enum:AST::AstNodeType
AST_PRIMITIVE	yosys/frontends/ast/ast.h	/^		AST_PRIMITIVE,$/;"	e	enum:AST::AstNodeType
AST_RANGE	yosys/frontends/ast/ast.h	/^		AST_RANGE,$/;"	e	enum:AST::AstNodeType
AST_REALVALUE	yosys/frontends/ast/ast.h	/^		AST_REALVALUE,$/;"	e	enum:AST::AstNodeType
AST_REDUCE_AND	yosys/frontends/ast/ast.h	/^		AST_REDUCE_AND,$/;"	e	enum:AST::AstNodeType
AST_REDUCE_BOOL	yosys/frontends/ast/ast.h	/^		AST_REDUCE_BOOL,$/;"	e	enum:AST::AstNodeType
AST_REDUCE_OR	yosys/frontends/ast/ast.h	/^		AST_REDUCE_OR,$/;"	e	enum:AST::AstNodeType
AST_REDUCE_XNOR	yosys/frontends/ast/ast.h	/^		AST_REDUCE_XNOR,$/;"	e	enum:AST::AstNodeType
AST_REDUCE_XOR	yosys/frontends/ast/ast.h	/^		AST_REDUCE_XOR,$/;"	e	enum:AST::AstNodeType
AST_REPEAT	yosys/frontends/ast/ast.h	/^		AST_REPEAT,$/;"	e	enum:AST::AstNodeType
AST_REPLICATE	yosys/frontends/ast/ast.h	/^		AST_REPLICATE,$/;"	e	enum:AST::AstNodeType
AST_SELFSZ	yosys/frontends/ast/ast.h	/^		AST_SELFSZ,$/;"	e	enum:AST::AstNodeType
AST_SHIFT	yosys/frontends/ast/ast.h	/^		AST_SHIFT,$/;"	e	enum:AST::AstNodeType
AST_SHIFTX	yosys/frontends/ast/ast.h	/^		AST_SHIFTX,$/;"	e	enum:AST::AstNodeType
AST_SHIFT_LEFT	yosys/frontends/ast/ast.h	/^		AST_SHIFT_LEFT,$/;"	e	enum:AST::AstNodeType
AST_SHIFT_RIGHT	yosys/frontends/ast/ast.h	/^		AST_SHIFT_RIGHT,$/;"	e	enum:AST::AstNodeType
AST_SHIFT_SLEFT	yosys/frontends/ast/ast.h	/^		AST_SHIFT_SLEFT,$/;"	e	enum:AST::AstNodeType
AST_SHIFT_SRIGHT	yosys/frontends/ast/ast.h	/^		AST_SHIFT_SRIGHT,$/;"	e	enum:AST::AstNodeType
AST_STRUCT	yosys/frontends/ast/ast.h	/^		AST_STRUCT,$/;"	e	enum:AST::AstNodeType
AST_STRUCT_ITEM	yosys/frontends/ast/ast.h	/^		AST_STRUCT_ITEM,$/;"	e	enum:AST::AstNodeType
AST_SUB	yosys/frontends/ast/ast.h	/^		AST_SUB,$/;"	e	enum:AST::AstNodeType
AST_TASK	yosys/frontends/ast/ast.h	/^		AST_TASK,$/;"	e	enum:AST::AstNodeType
AST_TCALL	yosys/frontends/ast/ast.h	/^		AST_TCALL,$/;"	e	enum:AST::AstNodeType
AST_TECALL	yosys/frontends/ast/ast.h	/^		AST_TECALL,$/;"	e	enum:AST::AstNodeType
AST_TERNARY	yosys/frontends/ast/ast.h	/^		AST_TERNARY,$/;"	e	enum:AST::AstNodeType
AST_TO_BITS	yosys/frontends/ast/ast.h	/^		AST_TO_BITS,$/;"	e	enum:AST::AstNodeType
AST_TO_SIGNED	yosys/frontends/ast/ast.h	/^		AST_TO_SIGNED,$/;"	e	enum:AST::AstNodeType
AST_TO_UNSIGNED	yosys/frontends/ast/ast.h	/^		AST_TO_UNSIGNED,$/;"	e	enum:AST::AstNodeType
AST_TYPEDEF	yosys/frontends/ast/ast.h	/^		AST_TYPEDEF,$/;"	e	enum:AST::AstNodeType
AST_UNION	yosys/frontends/ast/ast.h	/^		AST_UNION,$/;"	e	enum:AST::AstNodeType
AST_WHILE	yosys/frontends/ast/ast.h	/^		AST_WHILE,$/;"	e	enum:AST::AstNodeType
AST_WIRE	yosys/frontends/ast/ast.h	/^		AST_WIRE,$/;"	e	enum:AST::AstNodeType
AST_WIRETYPE	yosys/frontends/ast/ast.h	/^		AST_WIRETYPE,$/;"	e	enum:AST::AstNodeType
AWK	yosys/Makefile	/^AWK ?= awk$/;"	m
Abc9ExePass	yosys/passes/techmap/abc9_exe.cc	/^	Abc9ExePass() : Pass("abc9_exe", "use ABC9 for technology mapping") { }$/;"	f	struct:Abc9ExePass	file:
Abc9ExePass	yosys/passes/techmap/abc9_exe.cc	/^struct Abc9ExePass : public Pass {$/;"	s	file:
Abc9ExePass	yosys/passes/techmap/abc9_exe.cc	/^} Abc9ExePass;$/;"	v	typeref:struct:Abc9ExePass
Abc9OpsPass	yosys/passes/techmap/abc9_ops.cc	/^	Abc9OpsPass() : Pass("abc9_ops", "helper functions for ABC9") { }$/;"	f	struct:Abc9OpsPass	file:
Abc9OpsPass	yosys/passes/techmap/abc9_ops.cc	/^struct Abc9OpsPass : public Pass {$/;"	s	file:
Abc9OpsPass	yosys/passes/techmap/abc9_ops.cc	/^} Abc9OpsPass;$/;"	v	typeref:struct:Abc9OpsPass
Abc9Pass	yosys/passes/techmap/abc9.cc	/^	Abc9Pass() : ScriptPass("abc9", "use ABC9 for technology mapping") { }$/;"	f	struct:Abc9Pass	file:
Abc9Pass	yosys/passes/techmap/abc9.cc	/^struct Abc9Pass : public ScriptPass$/;"	s	file:
Abc9Pass	yosys/passes/techmap/abc9.cc	/^} Abc9Pass;$/;"	v	typeref:struct:Abc9Pass
AbcPass	yosys/passes/techmap/abc.cc	/^	AbcPass() : Pass("abc", "use ABC for technology mapping") { }$/;"	f	struct:AbcPass	file:
AbcPass	yosys/passes/techmap/abc.cc	/^struct AbcPass : public Pass {$/;"	s	file:
AbcPass	yosys/passes/techmap/abc.cc	/^} AbcPass;$/;"	v	typeref:struct:AbcPass
AbstractCellEdgesDatabase	yosys/kernel/celledges.h	/^struct AbstractCellEdgesDatabase$/;"	s
AddPass	yosys/passes/cmds/add.cc	/^	AddPass() : Pass("add", "add objects to the design") { }$/;"	f	struct:AddPass	file:
AddPass	yosys/passes/cmds/add.cc	/^struct AddPass : public Pass {$/;"	s	file:
AddPass	yosys/passes/cmds/add.cc	/^} AddPass;$/;"	v	typeref:struct:AddPass
Aig	yosys/kernel/cellaigs.cc	/^Aig::Aig(Cell *cell)$/;"	f	class:Aig
Aig	yosys/kernel/cellaigs.h	/^struct Aig$/;"	s
AigMaker	yosys/kernel/cellaigs.cc	/^	AigMaker(Aig *aig, Cell *cell) : aig(aig), cell(cell)$/;"	f	struct:AigMaker	file:
AigMaker	yosys/kernel/cellaigs.cc	/^struct AigMaker$/;"	s	file:
AigNode	yosys/kernel/cellaigs.cc	/^AigNode::AigNode()$/;"	f	class:AigNode	typeref:typename:YOSYS_NAMESPACE_BEGIN
AigNode	yosys/kernel/cellaigs.h	/^struct AigNode$/;"	s
AigerBackend	yosys/backends/aiger/aiger.cc	/^	AigerBackend() : Backend("aiger", "write design to AIGER file") { }$/;"	f	struct:AigerBackend	file:
AigerBackend	yosys/backends/aiger/aiger.cc	/^struct AigerBackend : public Backend {$/;"	s	file:
AigerBackend	yosys/backends/aiger/aiger.cc	/^} AigerBackend;$/;"	v	typeref:struct:AigerBackend
AigerFrontend	yosys/frontends/aiger/aigerparse.cc	/^	AigerFrontend() : Frontend("aiger", "read AIGER file") { }$/;"	f	struct:AigerFrontend	file:
AigerFrontend	yosys/frontends/aiger/aigerparse.cc	/^struct AigerFrontend : public Frontend {$/;"	s	file:
AigerFrontend	yosys/frontends/aiger/aigerparse.cc	/^} AigerFrontend;$/;"	v	typeref:struct:AigerFrontend
AigerReader	yosys/frontends/aiger/aigerparse.cc	/^AigerReader::AigerReader(RTLIL::Design *design, std::istream &f, RTLIL::IdString module_name, RT/;"	f	class:AigerReader
AigerReader	yosys/frontends/aiger/aigerparse.h	/^struct AigerReader$/;"	s
AigerWriter	yosys/backends/aiger/aiger.cc	/^	AigerWriter(Module *module, bool zinit_mode, bool imode, bool omode, bool bmode, bool lmode) : /;"	f	struct:AigerWriter	file:
AigerWriter	yosys/backends/aiger/aiger.cc	/^struct AigerWriter$/;"	s	file:
AigmapPass	yosys/passes/techmap/aigmap.cc	/^	AigmapPass() : Pass("aigmap", "map logic to and-inverter-graph circuit") { }$/;"	f	struct:AigmapPass	file:
AigmapPass	yosys/passes/techmap/aigmap.cc	/^struct AigmapPass : public Pass {$/;"	s	file:
AigmapPass	yosys/passes/techmap/aigmap.cc	/^} AigmapPass;$/;"	v	typeref:struct:AigmapPass
Allconst	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec RTLIL::Module::Allconst(RTLIL::IdString name, int width, const std::string &src)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::SigSpec
Allseq	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec RTLIL::Module::Allseq(RTLIL::IdString name, int width, const std::string &src)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::SigSpec
AlumaccPass	yosys/passes/techmap/alumacc.cc	/^	AlumaccPass() : Pass("alumacc", "extract ALU and MACC cells") { }$/;"	f	struct:AlumaccPass	file:
AlumaccPass	yosys/passes/techmap/alumacc.cc	/^struct AlumaccPass : public Pass {$/;"	s	file:
AlumaccPass	yosys/passes/techmap/alumacc.cc	/^} AlumaccPass;$/;"	v	typeref:struct:AlumaccPass
AlumaccWorker	yosys/passes/techmap/alumacc.cc	/^	AlumaccWorker(RTLIL::Module *module) : module(module), sigmap(module)$/;"	f	struct:AlumaccWorker	file:
AlumaccWorker	yosys/passes/techmap/alumacc.cc	/^struct AlumaccWorker$/;"	s	file:
And	yosys/passes/techmap/extract_reduce.cc	/^		And,$/;"	e	enum:ExtractReducePass::GateType	file:
AnlogicCarryFixPass	yosys/techlibs/anlogic/anlogic_fixcarry.cc	/^	AnlogicCarryFixPass() : Pass("anlogic_fixcarry", "Anlogic: fix carry chain") { }$/;"	f	struct:AnlogicCarryFixPass	file:
AnlogicCarryFixPass	yosys/techlibs/anlogic/anlogic_fixcarry.cc	/^struct AnlogicCarryFixPass : public Pass {$/;"	s	file:
AnlogicCarryFixPass	yosys/techlibs/anlogic/anlogic_fixcarry.cc	/^} AnlogicCarryFixPass;$/;"	v	typeref:struct:AnlogicCarryFixPass
AnlogicEqnPass	yosys/techlibs/anlogic/anlogic_eqn.cc	/^	AnlogicEqnPass() : Pass("anlogic_eqn", "Anlogic: Calculate equations for luts") { }$/;"	f	struct:AnlogicEqnPass	file:
AnlogicEqnPass	yosys/techlibs/anlogic/anlogic_eqn.cc	/^struct AnlogicEqnPass : public Pass {$/;"	s	file:
AnlogicEqnPass	yosys/techlibs/anlogic/anlogic_eqn.cc	/^} AnlogicEqnPass;$/;"	v	typeref:struct:AnlogicEqnPass
Anyconst	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec RTLIL::Module::Anyconst(RTLIL::IdString name, int width, const std::string &src)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::SigSpec
Anyseq	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec RTLIL::Module::Anyseq(RTLIL::IdString name, int width, const std::string &src)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::SigSpec
AssertpmuxPass	yosys/passes/sat/assertpmux.cc	/^	AssertpmuxPass() : Pass("assertpmux", "adds asserts for parallel muxes") { }$/;"	f	struct:AssertpmuxPass	file:
AssertpmuxPass	yosys/passes/sat/assertpmux.cc	/^struct AssertpmuxPass : public Pass {$/;"	s	file:
AssertpmuxPass	yosys/passes/sat/assertpmux.cc	/^} AssertpmuxPass;$/;"	v	typeref:struct:AssertpmuxPass
AssertpmuxWorker	yosys/passes/sat/assertpmux.cc	/^	AssertpmuxWorker(Module *module, bool flag_noinit, bool flag_always) :$/;"	f	struct:AssertpmuxWorker	file:
AssertpmuxWorker	yosys/passes/sat/assertpmux.cc	/^struct AssertpmuxWorker$/;"	s	file:
Assigned	yosys/frontends/ast/simplify.cc	/^	Assigned, \/\/ target variable is always assigned before use$/;"	e	enum:IdentUsage	file:
AstModule	yosys/frontends/ast/ast.h	/^	struct AstModule : RTLIL::Module {$/;"	s	namespace:AST
AstNode	yosys/frontends/ast/ast.cc	/^AstNode::AstNode(AstNodeType type, AstNode *child1, AstNode *child2, AstNode *child3, AstNode *c/;"	f	class:AstNode
AstNode	yosys/frontends/ast/ast.h	/^	struct AstNode$/;"	s	namespace:AST
AstNodeType	yosys/frontends/ast/ast.h	/^	enum AstNodeType$/;"	g	namespace:AST
AstSrcLocType	yosys/frontends/ast/ast.h	/^		AstSrcLocType() : first_line(0), last_line(0), first_column(0), last_column(0) {}$/;"	f	struct:AST::AstSrcLocType
AstSrcLocType	yosys/frontends/ast/ast.h	/^		AstSrcLocType(int _first_line, int _first_column, int _last_line, int _last_column) : first_li/;"	f	struct:AST::AstSrcLocType
AstSrcLocType	yosys/frontends/ast/ast.h	/^	struct AstSrcLocType {$/;"	s	namespace:AST
Async2syncPass	yosys/passes/sat/async2sync.cc	/^	Async2syncPass() : Pass("async2sync", "convert async FF inputs to sync circuits") { }$/;"	f	struct:Async2syncPass	file:
Async2syncPass	yosys/passes/sat/async2sync.cc	/^struct Async2syncPass : public Pass {$/;"	s	file:
Async2syncPass	yosys/passes/sat/async2sync.cc	/^} Async2syncPass;$/;"	v	typeref:struct:Async2syncPass
AttrObject	yosys/kernel/rtlil.h	/^struct RTLIL::AttrObject$/;"	s	class:RTLIL
AttrmapAction	yosys/passes/techmap/attrmap.cc	/^struct AttrmapAction {$/;"	s	file:
AttrmapMap	yosys/passes/techmap/attrmap.cc	/^struct AttrmapMap : AttrmapAction {$/;"	s	file:
AttrmapPass	yosys/passes/techmap/attrmap.cc	/^	AttrmapPass() : Pass("attrmap", "renaming attributes") { }$/;"	f	struct:AttrmapPass	file:
AttrmapPass	yosys/passes/techmap/attrmap.cc	/^struct AttrmapPass : public Pass {$/;"	s	file:
AttrmapPass	yosys/passes/techmap/attrmap.cc	/^} AttrmapPass;$/;"	v	typeref:struct:AttrmapPass
AttrmapRemove	yosys/passes/techmap/attrmap.cc	/^struct AttrmapRemove : AttrmapAction {$/;"	s	file:
AttrmapRename	yosys/passes/techmap/attrmap.cc	/^struct AttrmapRename : AttrmapAction {$/;"	s	file:
AttrmapTocase	yosys/passes/techmap/attrmap.cc	/^struct AttrmapTocase : AttrmapAction {$/;"	s	file:
AttrmvcpPass	yosys/passes/techmap/attrmvcp.cc	/^	AttrmvcpPass() : Pass("attrmvcp", "move or copy attributes from wires to driving cells") { }$/;"	f	struct:AttrmvcpPass	file:
AttrmvcpPass	yosys/passes/techmap/attrmvcp.cc	/^struct AttrmvcpPass : public Pass {$/;"	s	file:
AttrmvcpPass	yosys/passes/techmap/attrmvcp.cc	/^} AttrmvcpPass;$/;"	v	typeref:struct:AttrmvcpPass
AutonamePass	yosys/passes/cmds/autoname.cc	/^	AutonamePass() : Pass("autoname", "automatically assign names to objects") { }$/;"	f	struct:AutonamePass	file:
AutonamePass	yosys/passes/cmds/autoname.cc	/^struct AutonamePass : public Pass {$/;"	s	file:
AutonamePass	yosys/passes/cmds/autoname.cc	/^} AutonamePass;$/;"	v	typeref:struct:AutonamePass
B	yosys/frontends/aiger/aigerparse.h	/^    unsigned B, C, J, F; \/\/ Optional in AIGER 1.9$/;"	m	struct:AigerReader	typeref:typename:unsigned
BIGINTEGERALGORITHMS_H	yosys/libs/bigint/BigIntegerAlgorithms.hh	/^#define BIGINTEGERALGORITHMS_H$/;"	d
BIGINTEGERUTILS_H	yosys/libs/bigint/BigIntegerUtils.hh	/^#define BIGINTEGERUTILS_H$/;"	d
BIGINTEGER_H	yosys/libs/bigint/BigInteger.hh	/^#define BIGINTEGER_H$/;"	d
BIGUNSIGNEDINABASE_H	yosys/libs/bigint/BigUnsignedInABase.hh	/^#define BIGUNSIGNEDINABASE_H$/;"	d
BIGUNSIGNED_H	yosys/libs/bigint/BigUnsigned.hh	/^#define BIGUNSIGNED_H$/;"	d
BINDING_H	yosys/kernel/binding.h	/^#define BINDING_H$/;"	d
BINDIR	yosys/Makefile	/^BINDIR := $(PREFIX)\/bin$/;"	m
BINTEST	yosys/tests/unit/Makefile	/^BINTEST := bintest$/;"	m
BISON	yosys/Makefile	/^BISON ?= bison$/;"	m
BITPATTERN_H	yosys/kernel/bitpattern.h	/^#define BITPATTERN_H$/;"	d
BITWISE_OPS	yosys/passes/opt/opt_share.cc	/^#define BITWISE_OPS /;"	d	file:
BLOCK_BYTES	yosys/libs/sha1/sha1.h	/^    static constexpr unsigned int BLOCK_BYTES = BLOCK_INTS * 4;$/;"	m	class:SHA1	typeref:typename:unsigned int
BLOCK_INTS	yosys/libs/sha1/sha1.h	/^    static constexpr unsigned int BLOCK_INTS = 16;  \/* number of 32bit integers per SHA1 block /;"	m	class:SHA1	typeref:typename:unsigned int
BOOL	yosys/libs/json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::Json::Type
BOOST_PYTHON_LIB	yosys/Makefile	/^BOOST_PYTHON_LIB ?= $(shell \\$/;"	m
BREW_PREFIX	yosys/Makefile	/^BREW_PREFIX := $(shell brew --prefix)\/opt$/;"	m
BUFFERED	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		BUFFERED,$/;"	e	enum:WireType::Type	file:
BYTE	yosys/libs/fst/lz4.cc	/^typedef uint8_t BYTE;$/;"	t	typeref:typename:uint8_t	file:
BYTE	yosys/libs/fst/lz4.cc	/^typedef unsigned char BYTE;$/;"	t	typeref:typename:unsigned char	file:
Backend	yosys/kernel/register.cc	/^Backend::Backend(std::string name, std::string short_help) :$/;"	f	class:Backend
Backend	yosys/kernel/register.h	/^struct Backend : Pass$/;"	s
Base	yosys/libs/bigint/BigUnsignedInABase.hh	/^	typedef Digit Base;$/;"	t	class:BigUnsignedInABase	typeref:typename:Digit
BigInteger	yosys/libs/bigint/BigInteger.cc	/^BigInteger::BigInteger(const BigUnsigned &x, Sign s) : mag(x) {$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.cc	/^BigInteger::BigInteger(const Blk *b, Index blen, Sign s) : mag(b, blen) {$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.cc	/^BigInteger::BigInteger(int   x) : sign(signOf(x)), mag(magOf<int  , unsigned int  >(x)) {}$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.cc	/^BigInteger::BigInteger(long  x) : sign(signOf(x)), mag(magOf<long , unsigned long >(x)) {}$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.cc	/^BigInteger::BigInteger(short x) : sign(signOf(x)), mag(magOf<short, unsigned short>(x)) {}$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.cc	/^BigInteger::BigInteger(unsigned int   x) : mag(x) { sign = mag.isZero() ? zero : positive; }$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.cc	/^BigInteger::BigInteger(unsigned long  x) : mag(x) { sign = mag.isZero() ? zero : positive; }$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.cc	/^BigInteger::BigInteger(unsigned short x) : mag(x) { sign = mag.isZero() ? zero : positive; }$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.hh	/^	BigInteger() : sign(zero), mag() {}$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.hh	/^	BigInteger(const BigInteger &x) : sign(x.sign), mag(x.mag) {};$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.hh	/^	BigInteger(const BigUnsigned &x) : mag(x) {$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.hh	/^	BigInteger(const Blk *b, Index blen) : mag(b, blen) {$/;"	f	class:BigInteger
BigInteger	yosys/libs/bigint/BigInteger.hh	/^class BigInteger {$/;"	c
BigUnsigned	yosys/libs/bigint/BigUnsigned.cc	/^BigUnsigned::BigUnsigned(         int   x) { initFromSignedPrimitive(x); }$/;"	f	class:BigUnsigned
BigUnsigned	yosys/libs/bigint/BigUnsigned.cc	/^BigUnsigned::BigUnsigned(         long  x) { initFromSignedPrimitive(x); }$/;"	f	class:BigUnsigned
BigUnsigned	yosys/libs/bigint/BigUnsigned.cc	/^BigUnsigned::BigUnsigned(         short x) { initFromSignedPrimitive(x); }$/;"	f	class:BigUnsigned
BigUnsigned	yosys/libs/bigint/BigUnsigned.cc	/^BigUnsigned::BigUnsigned(unsigned int   x) { initFromPrimitive      (x); }$/;"	f	class:BigUnsigned
BigUnsigned	yosys/libs/bigint/BigUnsigned.cc	/^BigUnsigned::BigUnsigned(unsigned long  x) { initFromPrimitive      (x); }$/;"	f	class:BigUnsigned
BigUnsigned	yosys/libs/bigint/BigUnsigned.cc	/^BigUnsigned::BigUnsigned(unsigned short x) { initFromPrimitive      (x); }$/;"	f	class:BigUnsigned
BigUnsigned	yosys/libs/bigint/BigUnsigned.hh	/^	BigUnsigned() : NumberlikeArray<Blk>() {}$/;"	f	class:BigUnsigned
BigUnsigned	yosys/libs/bigint/BigUnsigned.hh	/^	BigUnsigned(const BigUnsigned &x) : NumberlikeArray<Blk>(x) {}$/;"	f	class:BigUnsigned
BigUnsigned	yosys/libs/bigint/BigUnsigned.hh	/^	BigUnsigned(const Blk *b, Index blen) : NumberlikeArray<Blk>(b, blen) {$/;"	f	class:BigUnsigned
BigUnsigned	yosys/libs/bigint/BigUnsigned.hh	/^	BigUnsigned(int, Index c) : NumberlikeArray<Blk>(0, c) {}$/;"	f	class:BigUnsigned
BigUnsigned	yosys/libs/bigint/BigUnsigned.hh	/^class BigUnsigned : protected NumberlikeArray<unsigned long> {$/;"	c
BigUnsignedInABase	yosys/libs/bigint/BigUnsignedInABase.cc	/^BigUnsignedInABase::BigUnsignedInABase(const BigUnsigned &x, Base base) {$/;"	f	class:BigUnsignedInABase
BigUnsignedInABase	yosys/libs/bigint/BigUnsignedInABase.cc	/^BigUnsignedInABase::BigUnsignedInABase(const Digit *d, Index l, Base base)$/;"	f	class:BigUnsignedInABase
BigUnsignedInABase	yosys/libs/bigint/BigUnsignedInABase.cc	/^BigUnsignedInABase::BigUnsignedInABase(const std::string &s, Base base) {$/;"	f	class:BigUnsignedInABase
BigUnsignedInABase	yosys/libs/bigint/BigUnsignedInABase.hh	/^	BigUnsignedInABase() : NumberlikeArray<Digit>(), base(2) {}$/;"	f	class:BigUnsignedInABase
BigUnsignedInABase	yosys/libs/bigint/BigUnsignedInABase.hh	/^	BigUnsignedInABase(const BigUnsignedInABase &x) : NumberlikeArray<Digit>(x), base(x.base) {}$/;"	f	class:BigUnsignedInABase
BigUnsignedInABase	yosys/libs/bigint/BigUnsignedInABase.hh	/^	BigUnsignedInABase(int, Index c) : NumberlikeArray<Digit>(0, c) {}$/;"	f	class:BigUnsignedInABase
BigUnsignedInABase	yosys/libs/bigint/BigUnsignedInABase.hh	/^class BigUnsignedInABase : protected NumberlikeArray<unsigned short> {$/;"	c
Binding	yosys/frontends/ast/ast_binding.cc	/^AST::Binding::Binding(RTLIL::IdString  target_type,$/;"	f	class:AST::Binding
Binding	yosys/frontends/ast/ast_binding.h	/^	class Binding : public RTLIL::Binding$/;"	c	namespace:AST
Binding	yosys/kernel/binding.cc	/^RTLIL::Binding::Binding(RTLIL::IdString target_type,$/;"	f	class:RTLIL::Binding	typeref:typename:YOSYS_NAMESPACE_BEGIN
Binding	yosys/kernel/binding.h	/^struct RTLIL::Binding$/;"	s	class:RTLIL
BitBit	yosys/kernel/timinginfo.h	/^		BitBit(const NameBit &first, const NameBit &second) : first(first), second(second) {}$/;"	f	struct:TimingInfo::BitBit
BitBit	yosys/kernel/timinginfo.h	/^		BitBit(const SigBit &first, const SigBit &second) : first(first), second(second) {}$/;"	f	struct:TimingInfo::BitBit
BitBit	yosys/kernel/timinginfo.h	/^	struct BitBit$/;"	s	struct:TimingInfo
BitPatternPool	yosys/kernel/bitpattern.h	/^	BitPatternPool(RTLIL::SigSpec sig)$/;"	f	struct:BitPatternPool
BitPatternPool	yosys/kernel/bitpattern.h	/^	BitPatternPool(int width)$/;"	f	struct:BitPatternPool
BitPatternPool	yosys/kernel/bitpattern.h	/^struct BitPatternPool$/;"	s
BitRef	yosys/libs/subcircuit/subcircuit.h	/^			BitRef(int nodeIdx = -1, int portIdx = -1, int bitIdx = -1) : nodeIdx(nodeIdx), portIdx(portI/;"	f	struct:SubCircuit::Graph::BitRef
BitRef	yosys/libs/subcircuit/subcircuit.h	/^		struct BitRef {$/;"	s	class:SubCircuit::Graph
BlackboxPass	yosys/passes/cmds/blackbox.cc	/^	BlackboxPass() : Pass("blackbox", "convert modules into blackbox modules") { }$/;"	f	struct:BlackboxPass	file:
BlackboxPass	yosys/passes/cmds/blackbox.cc	/^struct BlackboxPass : public Pass {$/;"	s	file:
BlackboxPass	yosys/passes/cmds/blackbox.cc	/^} BlackboxPass;$/;"	v	typeref:struct:BlackboxPass
BlifBackend	yosys/backends/blif/blif.cc	/^	BlifBackend() : Backend("blif", "write design to BLIF file") { }$/;"	f	struct:BlifBackend	file:
BlifBackend	yosys/backends/blif/blif.cc	/^struct BlifBackend : public Backend {$/;"	s	file:
BlifBackend	yosys/backends/blif/blif.cc	/^} BlifBackend;$/;"	v	typeref:struct:BlifBackend
BlifDumper	yosys/backends/blif/blif.cc	/^	BlifDumper(std::ostream &f, RTLIL::Module *module, RTLIL::Design *design, BlifDumperConfig *con/;"	f	struct:BlifDumper	file:
BlifDumper	yosys/backends/blif/blif.cc	/^struct BlifDumper$/;"	s	file:
BlifDumperConfig	yosys/backends/blif/blif.cc	/^	BlifDumperConfig() : icells_mode(false), conn_mode(false), impltf_mode(false), gates_mode(false/;"	f	struct:BlifDumperConfig	file:
BlifDumperConfig	yosys/backends/blif/blif.cc	/^struct BlifDumperConfig$/;"	s	file:
BlifFrontend	yosys/frontends/blif/blifparse.cc	/^	BlifFrontend() : Frontend("blif", "read BLIF file") { }$/;"	f	struct:BlifFrontend	file:
BlifFrontend	yosys/frontends/blif/blifparse.cc	/^struct BlifFrontend : public Frontend {$/;"	s	file:
BlifFrontend	yosys/frontends/blif/blifparse.cc	/^} BlifFrontend;$/;"	v	typeref:struct:BlifFrontend
Blk	yosys/libs/bigint/BigInteger.hh	/^	typedef BigUnsigned::Blk Blk;$/;"	t	class:BigInteger	typeref:typename:BigUnsigned::Blk
Blk	yosys/libs/bigint/BigUnsigned.hh	/^	typedef unsigned long Blk;$/;"	t	class:BigUnsigned	typeref:typename:unsigned long
BmuxmapPass	yosys/passes/techmap/bmuxmap.cc	/^	BmuxmapPass() : Pass("bmuxmap", "transform $bmux cells to trees of $mux cells") { }$/;"	f	struct:BmuxmapPass	file:
BmuxmapPass	yosys/passes/techmap/bmuxmap.cc	/^struct BmuxmapPass : public Pass {$/;"	s	file:
BmuxmapPass	yosys/passes/techmap/bmuxmap.cc	/^} BmuxmapPass;$/;"	v	typeref:struct:BmuxmapPass
BoolOption	yosys/libs/minisat/Options.h	/^    BoolOption(const char* c, const char* n, const char* d, bool v) $/;"	f	class:Minisat::BoolOption
BoolOption	yosys/libs/minisat/Options.h	/^class BoolOption : public Option$/;"	c	namespace:Minisat
BruteForceEquivChecker	yosys/passes/sat/eval.cc	/^	BruteForceEquivChecker(RTLIL::Module *mod1, RTLIL::Module *mod2, bool ignore_x_mod1) :$/;"	f	struct:BruteForceEquivChecker	file:
BruteForceEquivChecker	yosys/passes/sat/eval.cc	/^struct BruteForceEquivChecker$/;"	s	file:
BtorBackend	yosys/backends/btor/btor.cc	/^	BtorBackend() : Backend("btor", "write design to BTOR file") { }$/;"	f	struct:BtorBackend	file:
BtorBackend	yosys/backends/btor/btor.cc	/^struct BtorBackend : public Backend {$/;"	s	file:
BtorBackend	yosys/backends/btor/btor.cc	/^} BtorBackend;$/;"	v	typeref:struct:BtorBackend
BtorWorker	yosys/backends/btor/btor.cc	/^	BtorWorker(std::ostream &f, RTLIL::Module *module, bool verbose, bool single_bad, bool cover_mo/;"	f	struct:BtorWorker	file:
BtorWorker	yosys/backends/btor/btor.cc	/^struct BtorWorker$/;"	s	file:
BugpointPass	yosys/passes/cmds/bugpoint.cc	/^	BugpointPass() : Pass("bugpoint", "minimize testcases") { }$/;"	f	struct:BugpointPass	file:
BugpointPass	yosys/passes/cmds/bugpoint.cc	/^struct BugpointPass : public Pass {$/;"	s	file:
BugpointPass	yosys/passes/cmds/bugpoint.cc	/^} BugpointPass;$/;"	v	typeref:struct:BugpointPass
C	yosys/frontends/aiger/aigerparse.h	/^    unsigned B, C, J, F; \/\/ Optional in AIGER 1.9$/;"	m	struct:AigerReader	typeref:typename:unsigned
CC	yosys/libs/ezsat/Makefile	/^CC = clang$/;"	m
CC	yosys/libs/subcircuit/Makefile	/^CC = clang$/;"	m
CC	yosys/libs/subcircuit/Makefile	/^CC = gcc$/;"	m
CELLAIGS_H	yosys/kernel/cellaigs.h	/^#define CELLAIGS_H$/;"	d
CELLEDGES_H	yosys/kernel/celledges.h	/^#define CELLEDGES_H$/;"	d
CELLTYPES_H	yosys/kernel/celltypes.h	/^#define CELLTYPES_H$/;"	d
CELL_EVAL	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^			CELL_EVAL,$/;"	e	enum:FlowGraph::Node::Type	file:
CELL_SYNC	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^			CELL_SYNC,$/;"	e	enum:FlowGraph::Node::Type	file:
CHECK	yosys/libs/ezsat/testbench.cc	/^#define CHECK(/;"	d	file:
CHECK_BOOST_PYTHON	yosys/Makefile	/^CHECK_BOOST_PYTHON = (echo "int main(int argc, char ** argv) {return 0;}" | $(CXX) -xc -o \/dev\//;"	m
CHECK_COND	yosys/passes/techmap/libparse.cc	/^#define CHECK_COND(/;"	d	file:
CHECK_NV	yosys/passes/techmap/libparse.cc	/^#define CHECK_NV(/;"	d	file:
CMap	yosys/libs/minisat/SolverTypes.h	/^class CMap$/;"	c	namespace:Minisat
COMB	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	COMB = 1,$/;"	e	enum:CxxrtlPortType	file:
COMMENTS	yosys/libs/json11/json11.hpp	/^    STANDARD, COMMENTS$/;"	e	enum:json11::JsonParse
CONFIG	yosys/Makefile	/^CONFIG := clang$/;"	m
CONFIG	yosys/libs/subcircuit/Makefile	/^CONFIG := clang-debug$/;"	m
CONNECT	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^			CONNECT,$/;"	e	enum:FlowGraph::Node::Type	file:
CONST	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		CONST,$/;"	e	enum:WireType::Type	file:
CONSTEVAL_H	yosys/kernel/consteval.h	/^#define CONSTEVAL_H$/;"	d
CONST_FALSE	yosys/libs/ezsat/ezsat.cc	/^const int ezSAT::CONST_FALSE = 2;$/;"	m	class:ezSAT	typeref:typename:const int
CONST_FALSE	yosys/libs/ezsat/ezsat.h	/^	static const int CONST_FALSE;$/;"	m	class:ezSAT	typeref:typename:const int
CONST_FLAG_NONE	yosys/kernel/rtlil.h	/^		CONST_FLAG_NONE   = 0,$/;"	e	enum:RTLIL::ConstFlags
CONST_FLAG_REAL	yosys/kernel/rtlil.h	/^		CONST_FLAG_REAL   = 4   \/\/ only used for parameters$/;"	e	enum:RTLIL::ConstFlags
CONST_FLAG_SIGNED	yosys/kernel/rtlil.h	/^		CONST_FLAG_SIGNED = 2,  \/\/ only used for parameters$/;"	e	enum:RTLIL::ConstFlags
CONST_FLAG_STRING	yosys/kernel/rtlil.h	/^		CONST_FLAG_STRING = 1,$/;"	e	enum:RTLIL::ConstFlags
CONST_TRUE	yosys/libs/ezsat/ezsat.cc	/^const int ezSAT::CONST_TRUE = 1;$/;"	m	class:ezSAT	typeref:typename:const int
CONST_TRUE	yosys/libs/ezsat/ezsat.h	/^	static const int CONST_TRUE;$/;"	m	class:ezSAT	typeref:typename:const int
COPYLENGTH	yosys/libs/fst/lz4.cc	/^#define COPYLENGTH /;"	d	file:
COST_DMUX	yosys/passes/techmap/muxcover.cc	/^#define COST_DMUX /;"	d	file:
COST_H	yosys/kernel/cost.h	/^#define COST_H$/;"	d
COST_MUX16	yosys/passes/techmap/muxcover.cc	/^#define COST_MUX16 /;"	d	file:
COST_MUX2	yosys/passes/techmap/muxcover.cc	/^#define COST_MUX2 /;"	d	file:
COST_MUX4	yosys/passes/techmap/muxcover.cc	/^#define COST_MUX4 /;"	d	file:
COST_MUX8	yosys/passes/techmap/muxcover.cc	/^#define COST_MUX8 /;"	d	file:
CRef	yosys/libs/minisat/SolverTypes.h	/^typedef RegionAllocator<uint32_t>::Ref CRef;$/;"	t	namespace:Minisat	typeref:typename:RegionAllocator<uint32_t>::Ref
CRefHash	yosys/libs/minisat/SolverTypes.h	/^    struct CRefHash {$/;"	s	class:Minisat::CMap
CRef_Undef	yosys/libs/minisat/SolverTypes.h	/^const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;$/;"	v	namespace:Minisat	typeref:typename:const CRef
CVC4	yosys/passes/sat/qbfsat.h	/^	enum Solver{Z3, Yices, CVC4} solver = Yices;$/;"	e	enum:QbfSolveOptions::Solver
CXX	yosys/Makefile	/^CXX := ccache $(CXX)$/;"	m
CXX	yosys/Makefile	/^CXX := sccache $(CXX)$/;"	m
CXX	yosys/Makefile	/^CXX = $(WASI_SDK)\/bin\/clang$/;"	m
CXX	yosys/Makefile	/^CXX = AFL_QUIET=1 AFL_HARDEN=1 afl-gcc$/;"	m
CXX	yosys/Makefile	/^CXX = \/usr\/local\/src\/mxe\/usr\/bin\/i686-w64-mingw32.static-g++$/;"	m
CXX	yosys/Makefile	/^CXX = clang$/;"	m
CXX	yosys/Makefile	/^CXX = emcc$/;"	m
CXX	yosys/Makefile	/^CXX = gcc$/;"	m
CXX	yosys/Makefile	/^CXX = gcc-4.8$/;"	m
CXX	yosys/Makefile	/^CXX = i686-w64-mingw32-g++$/;"	m
CXX	yosys/Makefile	/^CXX = x86_64-w64-mingw32-g++$/;"	m
CXX	yosys/libs/ezsat/Makefile	/^CXX = clang$/;"	m
CXX	yosys/libs/subcircuit/Makefile	/^CXX = clang$/;"	m
CXX	yosys/libs/subcircuit/Makefile	/^CXX = gcc$/;"	m
CXXFLAGS	yosys/Makefile	/^CXXFLAGS := $(WASIFLAGS) -std=$(CXXSTD) -Os $(filter-out -fPIC,$(CXXFLAGS))$/;"	m
CXXFLAGS	yosys/Makefile	/^CXXFLAGS := $(filter-out -fPIC,$(CXXFLAGS))$/;"	m
CXXFLAGS	yosys/Makefile	/^CXXFLAGS := -O0 -DDEBUG $(filter-out -Os,$(CXXFLAGS))$/;"	m
CXXFLAGS	yosys/Makefile	/^CXXFLAGS := -O3 -DNDEBUG $(filter-out -Os -ggdb,$(CXXFLAGS))$/;"	m
CXXFLAGS	yosys/Makefile	/^CXXFLAGS := -Og -DDEBUG $(filter-out -Os,$(CXXFLAGS))$/;"	m
CXXFLAGS	yosys/Makefile	/^CXXFLAGS := -std=$(CXXSTD) $(filter-out -fPIC -ggdb,$(CXXFLAGS))$/;"	m
CXXFLAGS	yosys/libs/ezsat/Makefile	/^CXXFLAGS = -MD -Wall -Wextra -ggdb$/;"	m
CXXFLAGS	yosys/libs/subcircuit/Makefile	/^CXXFLAGS = -MD -Wall -Wextra -ggdb$/;"	m
CXXFLAGS	yosys/manual/PRESENTATION_Prog/Makefile	/^CXXFLAGS=$(shell ..\/..\/yosys-config --cxxflags)$/;"	m
CXXFLAGS_NOVERIFIC	yosys/Makefile	/^CXXFLAGS_NOVERIFIC = $(CXXFLAGS)$/;"	m
CXXFLAGS_NOVERIFIC	yosys/Makefile	/^CXXFLAGS_NOVERIFIC = $(foreach v,$(CXXFLAGS),$(if $(findstring $(VERIFIC_DIR),$(v)),,$(v)))$/;"	m
CXXRTL_ALIAS	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_ALIAS = 3,$/;"	e	enum:cxxrtl_type
CXXRTL_ALWAYS_INLINE	yosys/backends/cxxrtl/cxxrtl.h	/^#define CXXRTL_ALWAYS_INLINE /;"	d
CXXRTL_ASSERT	yosys/backends/cxxrtl/cxxrtl.h	/^#define CXXRTL_ASSERT(/;"	d
CXXRTL_CAPI_H	yosys/backends/cxxrtl/cxxrtl_capi.h	/^#define CXXRTL_CAPI_H$/;"	d
CXXRTL_DRIVEN_COMB	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_DRIVEN_COMB = 1 << 3,$/;"	e	enum:cxxrtl_flag
CXXRTL_DRIVEN_SYNC	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_DRIVEN_SYNC = 1 << 2,$/;"	e	enum:cxxrtl_flag
CXXRTL_EXTREMELY_COLD	yosys/backends/cxxrtl/cxxrtl.h	/^#define CXXRTL_EXTREMELY_COLD /;"	d
CXXRTL_EXTREMELY_COLD	yosys/backends/cxxrtl/cxxrtl.h	/^#define CXXRTL_EXTREMELY_COLD$/;"	d
CXXRTL_H	yosys/backends/cxxrtl/cxxrtl.h	/^#define CXXRTL_H$/;"	d
CXXRTL_INOUT	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_INOUT = (CXXRTL_INPUT|CXXRTL_OUTPUT),$/;"	e	enum:cxxrtl_flag
CXXRTL_INPUT	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_INPUT = 1 << 0,$/;"	e	enum:cxxrtl_flag
CXXRTL_MEMORY	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_MEMORY = 2,$/;"	e	enum:cxxrtl_type
CXXRTL_OUTLINE	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_OUTLINE = 4,$/;"	e	enum:cxxrtl_type
CXXRTL_OUTPUT	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_OUTPUT = 1 << 1,$/;"	e	enum:cxxrtl_flag
CXXRTL_UNDRIVEN	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_UNDRIVEN = 1 << 4,$/;"	e	enum:cxxrtl_flag
CXXRTL_VALUE	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_VALUE = 0,$/;"	e	enum:cxxrtl_type
CXXRTL_VCD_CAPI_H	yosys/backends/cxxrtl/cxxrtl_vcd_capi.h	/^#define CXXRTL_VCD_CAPI_H$/;"	d
CXXRTL_VCD_H	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^#define CXXRTL_VCD_H$/;"	d
CXXRTL_WIRE	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	CXXRTL_WIRE = 1,$/;"	e	enum:cxxrtl_type
CXXSTD	yosys/Makefile	/^CXXSTD ?= c++11$/;"	m
CallbackFunction	yosys/kernel/fstdata.h	/^typedef std::function<void(uint64_t)> CallbackFunction;$/;"	t
CaseRule	yosys/kernel/rtlil.h	/^struct RTLIL::CaseRule : public RTLIL::AttrObject$/;"	s	class:RTLIL
CdPass	yosys/passes/cmds/select.cc	/^	CdPass() : Pass("cd", "a shortcut for 'select -module <name>'") { }$/;"	f	struct:CdPass	file:
CdPass	yosys/passes/cmds/select.cc	/^struct CdPass : public Pass {$/;"	s	file:
CdPass	yosys/passes/cmds/select.cc	/^} CdPass;$/;"	v	typeref:struct:CdPass
Cell	yosys/kernel/rtlil.cc	/^RTLIL::Cell::Cell() : module(nullptr)$/;"	f	class:RTLIL::Cell
Cell	yosys/kernel/rtlil.h	/^struct RTLIL::Cell : public RTLIL::AttrObject$/;"	s	class:RTLIL
CellCosts	yosys/kernel/cost.h	/^struct CellCosts$/;"	s
CellHelpMessages	yosys/kernel/register.cc	/^	CellHelpMessages() {$/;"	f	struct:CellHelpMessages	file:
CellHelpMessages	yosys/kernel/register.cc	/^static struct CellHelpMessages {$/;"	s	file:
CellType	yosys/kernel/celltypes.h	/^struct CellType$/;"	s
CellTypes	yosys/kernel/celltypes.h	/^	CellTypes()$/;"	f	struct:CellTypes
CellTypes	yosys/kernel/celltypes.h	/^	CellTypes(RTLIL::Design *design)$/;"	f	struct:CellTypes
CellTypes	yosys/kernel/celltypes.h	/^struct CellTypes$/;"	s
CheckPass	yosys/passes/cmds/check.cc	/^	CheckPass() : Pass("check", "check for obvious problems in the design") { }$/;"	f	struct:CheckPass	file:
CheckPass	yosys/passes/cmds/check.cc	/^struct CheckPass : public Pass {$/;"	s	file:
CheckPass	yosys/passes/cmds/check.cc	/^} CheckPass;$/;"	v	typeref:struct:CheckPass
ChformalPass	yosys/passes/cmds/chformal.cc	/^	ChformalPass() : Pass("chformal", "change formal constraints of the design") { }$/;"	f	struct:ChformalPass	file:
ChformalPass	yosys/passes/cmds/chformal.cc	/^struct ChformalPass : public Pass {$/;"	s	file:
ChformalPass	yosys/passes/cmds/chformal.cc	/^} ChformalPass;$/;"	v	typeref:struct:ChformalPass
ChparamPass	yosys/passes/cmds/setattr.cc	/^	ChparamPass() : Pass("chparam", "re-evaluate modules with new parameters") { }$/;"	f	struct:ChparamPass	file:
ChparamPass	yosys/passes/cmds/setattr.cc	/^struct ChparamPass : public Pass {$/;"	s	file:
ChparamPass	yosys/passes/cmds/setattr.cc	/^} ChparamPass;$/;"	v	typeref:struct:ChparamPass
ChtypePass	yosys/passes/cmds/chtype.cc	/^	ChtypePass() : Pass("chtype", "change type of cells in the design") { }$/;"	f	struct:ChtypePass	file:
ChtypePass	yosys/passes/cmds/chtype.cc	/^struct ChtypePass : public Pass {$/;"	s	file:
ChtypePass	yosys/passes/cmds/chtype.cc	/^} ChtypePass;$/;"	v	typeref:struct:ChtypePass
Clause	yosys/libs/minisat/SolverTypes.h	/^    Clause(const Clause& from, bool use_extra){$/;"	f	class:Minisat::Clause
Clause	yosys/libs/minisat/SolverTypes.h	/^    Clause(const vec<Lit>& ps, bool use_extra, bool learnt) {$/;"	f	class:Minisat::Clause
Clause	yosys/libs/minisat/SolverTypes.h	/^class Clause {$/;"	c	namespace:Minisat
ClauseAllocator	yosys/libs/minisat/SolverTypes.h	/^    ClauseAllocator() : extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator
ClauseAllocator	yosys/libs/minisat/SolverTypes.h	/^    ClauseAllocator(uint32_t start_cap) : ra(start_cap), extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator
ClauseAllocator	yosys/libs/minisat/SolverTypes.h	/^class ClauseAllocator$/;"	c	namespace:Minisat
ClauseDeleted	yosys/libs/minisat/SimpSolver.h	/^        explicit ClauseDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Minisat::SimpSolver::ClauseDeleted
ClauseDeleted	yosys/libs/minisat/SimpSolver.h	/^    struct ClauseDeleted {$/;"	s	class:Minisat::SimpSolver
ClauseIterator	yosys/libs/minisat/SolverTypes.h	/^    ClauseIterator(const ClauseAllocator& _ca, const CRef* _crefs) : ca(_ca), crefs(_crefs){}$/;"	f	class:Minisat::ClauseIterator
ClauseIterator	yosys/libs/minisat/SolverTypes.h	/^class ClauseIterator {$/;"	c	namespace:Minisat
CleanPass	yosys/passes/opt/opt_clean.cc	/^	CleanPass() : Pass("clean", "remove unused cells and wires") { }$/;"	f	struct:CleanPass	file:
CleanPass	yosys/passes/opt/opt_clean.cc	/^struct CleanPass : public Pass {$/;"	s	file:
CleanPass	yosys/passes/opt/opt_clean.cc	/^} CleanPass;$/;"	v	typeref:struct:CleanPass
CleanZeroWidthPass	yosys/passes/cmds/clean_zerowidth.cc	/^	CleanZeroWidthPass() : Pass("clean_zerowidth", "clean zero-width connections from the design") /;"	f	struct:CleanZeroWidthPass	file:
CleanZeroWidthPass	yosys/passes/cmds/clean_zerowidth.cc	/^struct CleanZeroWidthPass : public Pass {$/;"	s	file:
CleanZeroWidthPass	yosys/passes/cmds/clean_zerowidth.cc	/^} CleanZeroWidthPass;$/;"	v	typeref:struct:CleanZeroWidthPass
CleanupModule	yosys/passes/opt/rmports.cc	/^	void CleanupModule(Module *module, dict<IdString, pool<IdString>> &removed_ports)$/;"	f	struct:RmportsPassPass	typeref:typename:void	file:
Clk2fflogicPass	yosys/passes/sat/clk2fflogic.cc	/^	Clk2fflogicPass() : Pass("clk2fflogic", "convert clocked FFs to generic $ff cells") { }$/;"	f	struct:Clk2fflogicPass	file:
Clk2fflogicPass	yosys/passes/sat/clk2fflogic.cc	/^struct Clk2fflogicPass : public Pass {$/;"	s	file:
Clk2fflogicPass	yosys/passes/sat/clk2fflogic.cc	/^} Clk2fflogicPass;$/;"	v	typeref:struct:Clk2fflogicPass
ClkbufmapPass	yosys/passes/techmap/clkbufmap.cc	/^	ClkbufmapPass() : Pass("clkbufmap", "insert clock buffers on clock networks") { }$/;"	f	struct:ClkbufmapPass	file:
ClkbufmapPass	yosys/passes/techmap/clkbufmap.cc	/^struct ClkbufmapPass : public Pass {$/;"	s	file:
ClkbufmapPass	yosys/passes/techmap/clkbufmap.cc	/^} ClkbufmapPass;$/;"	v	typeref:struct:ClkbufmapPass
CmpRes	yosys/libs/bigint/BigInteger.hh	/^	typedef BigUnsigned::CmpRes CmpRes;$/;"	t	class:BigInteger	typeref:typename:BigUnsigned::CmpRes
CmpRes	yosys/libs/bigint/BigUnsigned.hh	/^	enum CmpRes { less = -1, equal = 0, greater = 1 };$/;"	g	class:BigUnsigned
ConnectPass	yosys/passes/cmds/connect.cc	/^	ConnectPass() : Pass("connect", "create or remove connections") { }$/;"	f	struct:ConnectPass	file:
ConnectPass	yosys/passes/cmds/connect.cc	/^struct ConnectPass : public Pass {$/;"	s	file:
ConnectPass	yosys/passes/cmds/connect.cc	/^} ConnectPass;$/;"	v	typeref:struct:ConnectPass
ConnwrappersPass	yosys/passes/cmds/connwrappers.cc	/^	ConnwrappersPass() : Pass("connwrappers", "match width of input-output port pairs") { }$/;"	f	struct:ConnwrappersPass	file:
ConnwrappersPass	yosys/passes/cmds/connwrappers.cc	/^struct ConnwrappersPass : public Pass {$/;"	s	file:
ConnwrappersPass	yosys/passes/cmds/connwrappers.cc	/^} ConnwrappersPass;$/;"	v	typeref:struct:ConnwrappersPass
ConnwrappersWorker	yosys/passes/cmds/connwrappers.cc	/^struct ConnwrappersWorker$/;"	s	file:
Const	yosys/kernel/rtlil.cc	/^RTLIL::Const::Const()$/;"	f	class:RTLIL::Const
Const	yosys/kernel/rtlil.cc	/^RTLIL::Const::Const(RTLIL::State bit, int width)$/;"	f	class:RTLIL::Const
Const	yosys/kernel/rtlil.cc	/^RTLIL::Const::Const(const RTLIL::Const &c)$/;"	f	class:RTLIL::Const
Const	yosys/kernel/rtlil.cc	/^RTLIL::Const::Const(const std::vector<bool> &bits)$/;"	f	class:RTLIL::Const
Const	yosys/kernel/rtlil.cc	/^RTLIL::Const::Const(int val, int width)$/;"	f	class:RTLIL::Const
Const	yosys/kernel/rtlil.cc	/^RTLIL::Const::Const(std::string str)$/;"	f	class:RTLIL::Const
Const	yosys/kernel/rtlil.h	/^	Const(const std::vector<RTLIL::State> &bits) : bits(bits) { flags = CONST_FLAG_NONE; }$/;"	f	struct:RTLIL::Const
Const	yosys/kernel/rtlil.h	/^struct RTLIL::Const$/;"	s	class:RTLIL
ConstEval	yosys/kernel/consteval.h	/^	ConstEval(RTLIL::Module *module, RTLIL::State defaultval = RTLIL::State::Sm) : module(module), /;"	f	struct:ConstEval
ConstEval	yosys/kernel/consteval.h	/^struct ConstEval$/;"	s
ConstEvalAig	yosys/frontends/aiger/aigerparse.cc	/^	ConstEvalAig(RTLIL::Module *module) : module(module)$/;"	f	struct:ConstEvalAig	file:
ConstEvalAig	yosys/frontends/aiger/aigerparse.cc	/^struct ConstEvalAig$/;"	s	file:
ConstFlags	yosys/kernel/rtlil.h	/^	enum ConstFlags : unsigned char {$/;"	g	namespace:RTLIL	typeref:typename:unsigned char
Coolrunner2FixupPass	yosys/techlibs/coolrunner2/coolrunner2_fixup.cc	/^	Coolrunner2FixupPass() : Pass("coolrunner2_fixup", "insert necessary buffer cells for CoolRunne/;"	f	struct:Coolrunner2FixupPass	file:
Coolrunner2FixupPass	yosys/techlibs/coolrunner2/coolrunner2_fixup.cc	/^struct Coolrunner2FixupPass : public Pass {$/;"	s	file:
Coolrunner2FixupPass	yosys/techlibs/coolrunner2/coolrunner2_fixup.cc	/^} Coolrunner2FixupPass;$/;"	v	typeref:struct:Coolrunner2FixupPass
Coolrunner2SopPass	yosys/techlibs/coolrunner2/coolrunner2_sop.cc	/^	Coolrunner2SopPass() : Pass("coolrunner2_sop", "break $sop cells into ANDTERM\/ORTERM cells") {/;"	f	struct:Coolrunner2SopPass	file:
Coolrunner2SopPass	yosys/techlibs/coolrunner2/coolrunner2_sop.cc	/^struct Coolrunner2SopPass : public Pass {$/;"	s	file:
Coolrunner2SopPass	yosys/techlibs/coolrunner2/coolrunner2_sop.cc	/^} Coolrunner2SopPass;$/;"	v	typeref:struct:Coolrunner2SopPass
CopyPass	yosys/passes/cmds/copy.cc	/^	CopyPass() : Pass("copy", "copy modules in the design") { }$/;"	f	struct:CopyPass	file:
CopyPass	yosys/passes/cmds/copy.cc	/^struct CopyPass : public Pass {$/;"	s	file:
CopyPass	yosys/passes/cmds/copy.cc	/^} CopyPass;$/;"	v	typeref:struct:CopyPass
CountBitUsage	yosys/passes/sat/freduce.cc	/^	CountBitUsage(SigMap &sigmap, std::map<RTLIL::SigBit, int> &cache) : sigmap(sigmap), cache(cach/;"	f	struct:CountBitUsage	file:
CountBitUsage	yosys/passes/sat/freduce.cc	/^struct CountBitUsage$/;"	s	file:
CounterExtraction	yosys/passes/techmap/extract_counter.cc	/^struct CounterExtraction$/;"	s	file:
CounterExtractionSettings	yosys/passes/techmap/extract_counter.cc	/^struct CounterExtractionSettings$/;"	s	file:
CoverData	yosys/kernel/log.h	/^struct CoverData {$/;"	s
CoverPass	yosys/passes/cmds/cover.cc	/^	CoverPass() : Pass("cover", "print code coverage counters") { }$/;"	f	struct:CoverPass	file:
CoverPass	yosys/passes/cmds/cover.cc	/^struct CoverPass : public Pass {$/;"	s	file:
CoverPass	yosys/passes/cmds/cover.cc	/^} CoverPass;$/;"	v	typeref:struct:CoverPass
Cut	yosys/passes/techmap/flowmap.cc	/^		Cut,$/;"	e	enum:FlowmapWorker::GraphMode	file:
CutpointPass	yosys/passes/sat/cutpoint.cc	/^	CutpointPass() : Pass("cutpoint", "adds formal cut points to the design") { }$/;"	f	struct:CutpointPass	file:
CutpointPass	yosys/passes/sat/cutpoint.cc	/^struct CutpointPass : public Pass {$/;"	s	file:
CutpointPass	yosys/passes/sat/cutpoint.cc	/^} CutpointPass;$/;"	v	typeref:struct:CutpointPass
CxxrtlBackend	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	CxxrtlBackend() : Backend("cxxrtl", "convert design to C++ RTL simulation") { }$/;"	f	struct:CxxrtlBackend	file:
CxxrtlBackend	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^struct CxxrtlBackend : public Backend {$/;"	s	file:
CxxrtlBackend	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^} CxxrtlBackend;$/;"	v	typeref:struct:CxxrtlBackend
CxxrtlPortType	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^enum class CxxrtlPortType {$/;"	g	file:
CxxrtlWorker	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^struct CxxrtlWorker {$/;"	s	file:
DATDIR	yosys/Makefile	/^DATDIR := $(PREFIX)\/share\/$(PROGRAM_PREFIX)yosys$/;"	m
DATDIR	yosys/manual/PRESENTATION_Prog/Makefile	/^DATDIR=$(shell ..\/..\/yosys-config --datdir)$/;"	m
DEFAULT_DEBUG_LEVEL	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	static const int DEFAULT_DEBUG_LEVEL = 4;$/;"	m	struct:CxxrtlBackend	typeref:typename:const int	file:
DEFAULT_OPT_LEVEL	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	static const int DEFAULT_OPT_LEVEL = 6;$/;"	m	struct:CxxrtlBackend	typeref:typename:const int	file:
DEF_METHOD	yosys/kernel/rtlil.cc	/^#define DEF_METHOD(/;"	d	file:
DEF_METHOD_2	yosys/kernel/rtlil.cc	/^#define DEF_METHOD_2(/;"	d	file:
DEF_METHOD_2	yosys/kernel/rtlil.cc	/^DEF_METHOD_2(BufGate,    ID($_BUF_),    A, Y)$/;"	f
DEF_METHOD_3	yosys/kernel/rtlil.cc	/^#define DEF_METHOD_3(/;"	d	file:
DEF_METHOD_4	yosys/kernel/rtlil.cc	/^#define DEF_METHOD_4(/;"	d	file:
DEF_METHOD_5	yosys/kernel/rtlil.cc	/^#define DEF_METHOD_5(/;"	d	file:
DIGEST_INTS	yosys/libs/sha1/sha1.h	/^    static constexpr unsigned int DIGEST_INTS = 5;  \/* number of 32bit integers per SHA1 digest/;"	m	class:SHA1	typeref:typename:unsigned int
DIM_X	yosys/libs/ezsat/puzzle3d.cc	/^#define DIM_X /;"	d	file:
DIM_Y	yosys/libs/ezsat/puzzle3d.cc	/^#define DIM_Y /;"	d	file:
DIM_Z	yosys/libs/ezsat/puzzle3d.cc	/^#define DIM_Z /;"	d	file:
DISABLE_ABC_THREADS	yosys/Makefile	/^DISABLE_ABC_THREADS := 0$/;"	m
DISABLE_ABC_THREADS	yosys/Makefile	/^DISABLE_ABC_THREADS := 1$/;"	m
DISABLE_SPAWN	yosys/Makefile	/^DISABLE_SPAWN := 0$/;"	m
DISABLE_SPAWN	yosys/Makefile	/^DISABLE_SPAWN := 1$/;"	m
DISABLE_VERIFIC_EXTENSIONS	yosys/Makefile	/^DISABLE_VERIFIC_EXTENSIONS := 0$/;"	m
DISABLE_VERIFIC_VHDL	yosys/Makefile	/^DISABLE_VERIFIC_VHDL := 0$/;"	m
DOT_CMD	yosys/passes/cmds/show.cc	/^				#define DOT_CMD /;"	d	file:
DOUBLE	yosys/backends/cxxrtl/cxxrtl.h	/^		DOUBLE 	= 4,$/;"	e	enum:cxxrtl::metadata::__anon481ec9d40203
DRIVEN_COMB	yosys/backends/cxxrtl/cxxrtl.h	/^		DRIVEN_COMB = CXXRTL_DRIVEN_COMB,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40403
DRIVEN_SYNC	yosys/backends/cxxrtl/cxxrtl.h	/^		DRIVEN_SYNC = CXXRTL_DRIVEN_SYNC,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40403
DSPRule	yosys/techlibs/nexus/synth_nexus.cc	/^	struct DSPRule {$/;"	s	struct:SynthNexusPass	file:
DTRT_ALIASED	yosys/libs/bigint/BigInteger.cc	/^#define DTRT_ALIASED(/;"	d	file:
DTRT_ALIASED	yosys/libs/bigint/BigUnsigned.cc	/^#define DTRT_ALIASED(/;"	d	file:
DebugPass	yosys/passes/cmds/trace.cc	/^	DebugPass() : Pass("debug", "run command with debug log messages enabled") { }$/;"	f	struct:DebugPass	file:
DebugPass	yosys/passes/cmds/trace.cc	/^struct DebugPass : public Pass {$/;"	s	file:
DebugPass	yosys/passes/cmds/trace.cc	/^} DebugPass;$/;"	v	typeref:struct:DebugPass
DeepEqual	yosys/libs/minisat/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { retur/;"	s	namespace:Minisat
DeepHash	yosys/libs/minisat/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { retur/;"	s	namespace:Minisat
DeletePass	yosys/passes/cmds/delete.cc	/^	DeletePass() : Pass("delete", "delete objects in the design") { }$/;"	f	struct:DeletePass	file:
DeletePass	yosys/passes/cmds/delete.cc	/^struct DeletePass : public Pass {$/;"	s	file:
DeletePass	yosys/passes/cmds/delete.cc	/^} DeletePass;$/;"	v	typeref:struct:DeletePass
DeleteWireWorker	yosys/kernel/rtlil.cc	/^	struct DeleteWireWorker$/;"	s	function:RTLIL::Module::remove	file:
DeminoutPass	yosys/passes/techmap/deminout.cc	/^	DeminoutPass() : Pass("deminout", "demote inout ports to input or output") { }$/;"	f	struct:DeminoutPass	file:
DeminoutPass	yosys/passes/techmap/deminout.cc	/^struct DeminoutPass : public Pass {$/;"	s	file:
DeminoutPass	yosys/passes/techmap/deminout.cc	/^} DeminoutPass;$/;"	v	typeref:struct:DeminoutPass
DemuxmapPass	yosys/passes/techmap/demuxmap.cc	/^	DemuxmapPass() : Pass("demuxmap", "transform $demux cells to $eq + $mux cells") { }$/;"	f	struct:DemuxmapPass	file:
DemuxmapPass	yosys/passes/techmap/demuxmap.cc	/^struct DemuxmapPass : public Pass {$/;"	s	file:
DemuxmapPass	yosys/passes/techmap/demuxmap.cc	/^} DemuxmapPass;$/;"	v	typeref:struct:DemuxmapPass
Design	yosys/kernel/rtlil.cc	/^RTLIL::Design::Design()$/;"	f	class:RTLIL::Design
Design	yosys/kernel/rtlil.h	/^struct RTLIL::Design$/;"	s	class:RTLIL
DesignPass	yosys/passes/cmds/design.cc	/^	DesignPass() : Pass("design", "save, restore and reset current design") { }$/;"	f	struct:DesignPass	file:
DesignPass	yosys/passes/cmds/design.cc	/^struct DesignPass : public Pass {$/;"	s	file:
DesignPass	yosys/passes/cmds/design.cc	/^} DesignPass;$/;"	v	typeref:struct:DesignPass
DffLegalizePass	yosys/passes/techmap/dfflegalize.cc	/^	DffLegalizePass() : Pass("dfflegalize", "convert FFs to types supported by the target") { }$/;"	f	struct:DffLegalizePass	file:
DffLegalizePass	yosys/passes/techmap/dfflegalize.cc	/^struct DffLegalizePass : public Pass {$/;"	s	file:
DffLegalizePass	yosys/passes/techmap/dfflegalize.cc	/^} DffLegalizePass;$/;"	v	typeref:struct:DffLegalizePass
DffinitPass	yosys/passes/techmap/dffinit.cc	/^	DffinitPass() : Pass("dffinit", "set INIT param on FF cells") { }$/;"	f	struct:DffinitPass	file:
DffinitPass	yosys/passes/techmap/dffinit.cc	/^struct DffinitPass : public Pass {$/;"	s	file:
DffinitPass	yosys/passes/techmap/dffinit.cc	/^} DffinitPass;$/;"	v	typeref:struct:DffinitPass
DfflibmapPass	yosys/passes/techmap/dfflibmap.cc	/^	DfflibmapPass() : Pass("dfflibmap", "technology mapping of flip-flops") { }$/;"	f	struct:DfflibmapPass	file:
DfflibmapPass	yosys/passes/techmap/dfflibmap.cc	/^struct DfflibmapPass : public Pass {$/;"	s	file:
DfflibmapPass	yosys/passes/techmap/dfflibmap.cc	/^} DfflibmapPass;$/;"	v	typeref:struct:DfflibmapPass
DffunmapPass	yosys/passes/techmap/dffunmap.cc	/^	DffunmapPass() : Pass("dffunmap", "unmap clock enable and synchronous reset from FFs") { }$/;"	f	struct:DffunmapPass	file:
DffunmapPass	yosys/passes/techmap/dffunmap.cc	/^struct DffunmapPass : public Pass {$/;"	s	file:
DffunmapPass	yosys/passes/techmap/dffunmap.cc	/^} DffunmapPass;$/;"	v	typeref:struct:DffunmapPass
DiBit	yosys/libs/subcircuit/subcircuit.cc	/^		DiBit() : fromPort(), toPort(), fromBit(-1), toBit(-1) { }$/;"	f	struct:SubCircuit::SolverWorker::DiBit	file:
DiBit	yosys/libs/subcircuit/subcircuit.cc	/^		DiBit(std::string fromPort, int fromBit, std::string toPort, int toBit) : fromPort(fromPort), /;"	f	struct:SubCircuit::SolverWorker::DiBit	file:
DiBit	yosys/libs/subcircuit/subcircuit.cc	/^	struct DiBit$/;"	s	class:SubCircuit::SolverWorker	file:
DiCache	yosys/libs/subcircuit/subcircuit.cc	/^	struct DiCache$/;"	s	class:SubCircuit::SolverWorker	file:
DiEdge	yosys/libs/subcircuit/subcircuit.cc	/^	struct DiEdge$/;"	s	class:SubCircuit::SolverWorker	file:
DiNode	yosys/libs/subcircuit/subcircuit.cc	/^		DiNode()$/;"	f	struct:SubCircuit::SolverWorker::DiNode	file:
DiNode	yosys/libs/subcircuit/subcircuit.cc	/^		DiNode(const Graph &graph, int nodeIdx)$/;"	f	struct:SubCircuit::SolverWorker::DiNode	file:
DiNode	yosys/libs/subcircuit/subcircuit.cc	/^	struct DiNode$/;"	s	class:SubCircuit::SolverWorker	file:
Digit	yosys/libs/bigint/BigUnsignedInABase.hh	/^	typedef unsigned short Digit;$/;"	t	class:BigUnsignedInABase	typeref:typename:unsigned short
DoubleOption	yosys/libs/minisat/Options.h	/^    DoubleOption(const char* c, const char* n, const char* d, double def = double(), DoubleRange/;"	f	class:Minisat::DoubleOption
DoubleOption	yosys/libs/minisat/Options.h	/^class DoubleOption : public Option$/;"	c	namespace:Minisat
DoubleRange	yosys/libs/minisat/Options.h	/^    DoubleRange(double b, bool binc, double e, bool einc) : begin(b), end(e), begin_inclusive(bi/;"	f	struct:Minisat::DoubleRange
DoubleRange	yosys/libs/minisat/Options.h	/^struct DoubleRange {$/;"	s	namespace:Minisat
DumpPass	yosys/backends/rtlil/rtlil_backend.cc	/^	DumpPass() : Pass("dump", "print parts of the design in RTLIL format") { }$/;"	f	struct:DumpPass	file:
DumpPass	yosys/backends/rtlil/rtlil_backend.cc	/^struct DumpPass : public Pass {$/;"	s	file:
DumpPass	yosys/backends/rtlil/rtlil_backend.cc	/^} DumpPass;$/;"	v	typeref:struct:DumpPass
EDIF_DEF	yosys/backends/edif/edif.cc	/^#define EDIF_DEF(/;"	d	file:
EDIF_DEFR	yosys/backends/edif/edif.cc	/^#define EDIF_DEFR(/;"	d	file:
EDIF_REF	yosys/backends/edif/edif.cc	/^#define EDIF_REF(/;"	d	file:
EMCCFLAGS	yosys/Makefile	/^EMCCFLAGS := -Os -Wno-warn-absolute-paths$/;"	m
ENABLE_ABC	yosys/Makefile	/^ENABLE_ABC := 1$/;"	m
ENABLE_CCACHE	yosys/Makefile	/^ENABLE_CCACHE := 0$/;"	m
ENABLE_COVER	yosys/Makefile	/^ENABLE_COVER := 0$/;"	m
ENABLE_COVER	yosys/Makefile	/^ENABLE_COVER := 1$/;"	m
ENABLE_DEBUG	yosys/Makefile	/^ENABLE_DEBUG := 0$/;"	m
ENABLE_EDITLINE	yosys/Makefile	/^ENABLE_EDITLINE := 0$/;"	m
ENABLE_GCOV	yosys/Makefile	/^ENABLE_GCOV := 0$/;"	m
ENABLE_GHDL	yosys/Makefile	/^ENABLE_GHDL := 0$/;"	m
ENABLE_GLOB	yosys/Makefile	/^ENABLE_GLOB := 1$/;"	m
ENABLE_GPROF	yosys/Makefile	/^ENABLE_GPROF := 0$/;"	m
ENABLE_LIBYOSYS	yosys/Makefile	/^ENABLE_LIBYOSYS := 0$/;"	m
ENABLE_LIBYOSYS	yosys/Makefile	/^ENABLE_LIBYOSYS := 1$/;"	m
ENABLE_NDEBUG	yosys/Makefile	/^ENABLE_NDEBUG := 0$/;"	m
ENABLE_PLUGINS	yosys/Makefile	/^ENABLE_PLUGINS := 1$/;"	m
ENABLE_PROTOBUF	yosys/Makefile	/^ENABLE_PROTOBUF := 0$/;"	m
ENABLE_PYOSYS	yosys/Makefile	/^ENABLE_PYOSYS := 0$/;"	m
ENABLE_PYTHON_CONFIG_EMBED	yosys/Makefile	/^ENABLE_PYTHON_CONFIG_EMBED ?= $(shell $(PYTHON_EXECUTABLE)-config --embed --libs > \/dev\/null &/;"	m
ENABLE_READLINE	yosys/Makefile	/^ENABLE_READLINE := 1$/;"	m
ENABLE_SCCACHE	yosys/Makefile	/^ENABLE_SCCACHE := 0$/;"	m
ENABLE_TCL	yosys/Makefile	/^ENABLE_TCL := 1$/;"	m
ENABLE_VERIFIC	yosys/Makefile	/^ENABLE_VERIFIC := 0$/;"	m
ENABLE_ZLIB	yosys/Makefile	/^ENABLE_ZLIB := 1$/;"	m
EXE	yosys/Makefile	/^EXE = .exe$/;"	m
EXE	yosys/Makefile	/^EXE = .js$/;"	m
EXE	yosys/Makefile	/^EXE = .wasm$/;"	m
EXE	yosys/Makefile	/^EXE =$/;"	m
EXTRAFLAGS	yosys/tests/unit/Makefile	/^EXTRAFLAGS := -lyosys -pthreads$/;"	m
EXTRA_OBJS	yosys/Makefile	/^EXTRA_OBJS =$/;"	m
EXTRA_TARGETS	yosys/Makefile	/^EXTRA_TARGETS =$/;"	m
EZMINISAT_H	yosys/libs/ezsat/ezminisat.h	/^#define EZMINISAT_H$/;"	d
EZMINISAT_INCREMENTAL	yosys/libs/ezsat/ezminisat.h	/^#define EZMINISAT_INCREMENTAL /;"	d
EZMINISAT_SIMPSOLVER	yosys/libs/ezsat/ezminisat.h	/^#define EZMINISAT_SIMPSOLVER /;"	d
EZMINISAT_VERBOSITY	yosys/libs/ezsat/ezminisat.h	/^#define EZMINISAT_VERBOSITY /;"	d
EZSAT_H	yosys/libs/ezsat/ezsat.h	/^#define EZSAT_H$/;"	d
EchoPass	yosys/kernel/register.cc	/^	EchoPass() : Pass("echo", "turning echoing back of commands on and off") { }$/;"	f	struct:EchoPass	file:
EchoPass	yosys/kernel/register.cc	/^struct EchoPass : public Pass {$/;"	s	file:
EchoPass	yosys/kernel/register.cc	/^} EchoPass;$/;"	v	typeref:struct:EchoPass
Ecp5GsrPass	yosys/techlibs/ecp5/ecp5_gsr.cc	/^	Ecp5GsrPass() : Pass("ecp5_gsr", "ECP5: handle GSR") { }$/;"	f	struct:Ecp5GsrPass	file:
Ecp5GsrPass	yosys/techlibs/ecp5/ecp5_gsr.cc	/^struct Ecp5GsrPass : public Pass {$/;"	s	file:
Ecp5GsrPass	yosys/techlibs/ecp5/ecp5_gsr.cc	/^} Ecp5GsrPass;$/;"	v	typeref:struct:Ecp5GsrPass
Edge	yosys/libs/subcircuit/subcircuit.h	/^			Edge() : constValue(0), isExtern(false) { };$/;"	f	struct:SubCircuit::Graph::Edge
Edge	yosys/libs/subcircuit/subcircuit.h	/^		struct Edge {$/;"	s	class:SubCircuit::Graph
EdgetypePass	yosys/passes/cmds/edgetypes.cc	/^	EdgetypePass() : Pass("edgetypes", "list all types of edges in selection") { }$/;"	f	struct:EdgetypePass	file:
EdgetypePass	yosys/passes/cmds/edgetypes.cc	/^struct EdgetypePass : public Pass {$/;"	s	file:
EdgetypePass	yosys/passes/cmds/edgetypes.cc	/^} EdgetypePass;$/;"	v	typeref:struct:EdgetypePass
EdifBackend	yosys/backends/edif/edif.cc	/^	EdifBackend() : Backend("edif", "write design to EDIF netlist file") { }$/;"	f	struct:EdifBackend	file:
EdifBackend	yosys/backends/edif/edif.cc	/^struct EdifBackend : public Backend {$/;"	s	file:
EdifBackend	yosys/backends/edif/edif.cc	/^} EdifBackend;$/;"	v	typeref:struct:EdifBackend
EdifNames	yosys/backends/edif/edif.cc	/^	EdifNames() : counter(1), delim_left('['), delim_right(']') { }$/;"	f	struct:EdifNames	file:
EdifNames	yosys/backends/edif/edif.cc	/^struct EdifNames$/;"	s	file:
EfinixCarryFixPass	yosys/techlibs/efinix/efinix_fixcarry.cc	/^	EfinixCarryFixPass() : Pass("efinix_fixcarry", "Efinix: fix carry chain") { }$/;"	f	struct:EfinixCarryFixPass	file:
EfinixCarryFixPass	yosys/techlibs/efinix/efinix_fixcarry.cc	/^struct EfinixCarryFixPass : public Pass {$/;"	s	file:
EfinixCarryFixPass	yosys/techlibs/efinix/efinix_fixcarry.cc	/^} EfinixCarryFixPass;$/;"	v	typeref:struct:EfinixCarryFixPass
ElimLt	yosys/libs/minisat/SimpSolver.h	/^        explicit ElimLt(const LMap<int>& no) : n_occ(no) {}$/;"	f	struct:Minisat::SimpSolver::ElimLt
ElimLt	yosys/libs/minisat/SimpSolver.h	/^    struct ElimLt {$/;"	s	class:Minisat::SimpSolver
Equal	yosys/libs/minisat/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1/;"	s	namespace:Minisat
EquivAddPass	yosys/passes/equiv/equiv_add.cc	/^	EquivAddPass() : Pass("equiv_add", "add a $equiv cell") { }$/;"	f	struct:EquivAddPass	file:
EquivAddPass	yosys/passes/equiv/equiv_add.cc	/^struct EquivAddPass : public Pass {$/;"	s	file:
EquivAddPass	yosys/passes/equiv/equiv_add.cc	/^} EquivAddPass;$/;"	v	typeref:struct:EquivAddPass
EquivInductPass	yosys/passes/equiv/equiv_induct.cc	/^	EquivInductPass() : Pass("equiv_induct", "proving $equiv cells using temporal induction") { }$/;"	f	struct:EquivInductPass	file:
EquivInductPass	yosys/passes/equiv/equiv_induct.cc	/^struct EquivInductPass : public Pass {$/;"	s	file:
EquivInductPass	yosys/passes/equiv/equiv_induct.cc	/^} EquivInductPass;$/;"	v	typeref:struct:EquivInductPass
EquivInductWorker	yosys/passes/equiv/equiv_induct.cc	/^	EquivInductWorker(Module *module, const pool<Cell*> &unproven_equiv_cells, bool model_undef, in/;"	f	struct:EquivInductWorker	file:
EquivInductWorker	yosys/passes/equiv/equiv_induct.cc	/^struct EquivInductWorker$/;"	s	file:
EquivMakePass	yosys/passes/equiv/equiv_make.cc	/^	EquivMakePass() : Pass("equiv_make", "prepare a circuit for equivalence checking") { }$/;"	f	struct:EquivMakePass	file:
EquivMakePass	yosys/passes/equiv/equiv_make.cc	/^struct EquivMakePass : public Pass {$/;"	s	file:
EquivMakePass	yosys/passes/equiv/equiv_make.cc	/^} EquivMakePass;$/;"	v	typeref:struct:EquivMakePass
EquivMakeWorker	yosys/passes/equiv/equiv_make.cc	/^	EquivMakeWorker()$/;"	f	struct:EquivMakeWorker	file:
EquivMakeWorker	yosys/passes/equiv/equiv_make.cc	/^struct EquivMakeWorker$/;"	s	file:
EquivMarkPass	yosys/passes/equiv/equiv_mark.cc	/^	EquivMarkPass() : Pass("equiv_mark", "mark equivalence checking regions") { }$/;"	f	struct:EquivMarkPass	file:
EquivMarkPass	yosys/passes/equiv/equiv_mark.cc	/^struct EquivMarkPass : public Pass {$/;"	s	file:
EquivMarkPass	yosys/passes/equiv/equiv_mark.cc	/^} EquivMarkPass;$/;"	v	typeref:struct:EquivMarkPass
EquivMarkWorker	yosys/passes/equiv/equiv_mark.cc	/^	EquivMarkWorker(Module *module) : module(module), sigmap(module)$/;"	f	struct:EquivMarkWorker	file:
EquivMarkWorker	yosys/passes/equiv/equiv_mark.cc	/^struct EquivMarkWorker$/;"	s	file:
EquivMiterPass	yosys/passes/equiv/equiv_miter.cc	/^	EquivMiterPass() : Pass("equiv_miter", "extract miter from equiv circuit") { }$/;"	f	struct:EquivMiterPass	file:
EquivMiterPass	yosys/passes/equiv/equiv_miter.cc	/^struct EquivMiterPass : public Pass {$/;"	s	file:
EquivMiterPass	yosys/passes/equiv/equiv_miter.cc	/^} EquivMiterPass;$/;"	v	typeref:struct:EquivMiterPass
EquivMiterWorker	yosys/passes/equiv/equiv_miter.cc	/^struct EquivMiterWorker$/;"	s	file:
EquivOptPass	yosys/passes/equiv/equiv_opt.cc	/^	EquivOptPass() : ScriptPass("equiv_opt", "prove equivalence for optimized circuit") { }$/;"	f	struct:EquivOptPass	file:
EquivOptPass	yosys/passes/equiv/equiv_opt.cc	/^struct EquivOptPass:public ScriptPass$/;"	s	file:
EquivOptPass	yosys/passes/equiv/equiv_opt.cc	/^} EquivOptPass;$/;"	v	typeref:struct:EquivOptPass
EquivPurgePass	yosys/passes/equiv/equiv_purge.cc	/^	EquivPurgePass() : Pass("equiv_purge", "purge equivalence checking module") { }$/;"	f	struct:EquivPurgePass	file:
EquivPurgePass	yosys/passes/equiv/equiv_purge.cc	/^struct EquivPurgePass : public Pass {$/;"	s	file:
EquivPurgePass	yosys/passes/equiv/equiv_purge.cc	/^} EquivPurgePass;$/;"	v	typeref:struct:EquivPurgePass
EquivPurgeWorker	yosys/passes/equiv/equiv_purge.cc	/^	EquivPurgeWorker(Module *module) : module(module), sigmap(module), name_cnt(0) { }$/;"	f	struct:EquivPurgeWorker	file:
EquivPurgeWorker	yosys/passes/equiv/equiv_purge.cc	/^struct EquivPurgeWorker$/;"	s	file:
EquivRemovePass	yosys/passes/equiv/equiv_remove.cc	/^	EquivRemovePass() : Pass("equiv_remove", "remove $equiv cells") { }$/;"	f	struct:EquivRemovePass	file:
EquivRemovePass	yosys/passes/equiv/equiv_remove.cc	/^struct EquivRemovePass : public Pass {$/;"	s	file:
EquivRemovePass	yosys/passes/equiv/equiv_remove.cc	/^} EquivRemovePass;$/;"	v	typeref:struct:EquivRemovePass
EquivSimplePass	yosys/passes/equiv/equiv_simple.cc	/^	EquivSimplePass() : Pass("equiv_simple", "try proving simple $equiv instances") { }$/;"	f	struct:EquivSimplePass	file:
EquivSimplePass	yosys/passes/equiv/equiv_simple.cc	/^struct EquivSimplePass : public Pass {$/;"	s	file:
EquivSimplePass	yosys/passes/equiv/equiv_simple.cc	/^} EquivSimplePass;$/;"	v	typeref:struct:EquivSimplePass
EquivSimpleWorker	yosys/passes/equiv/equiv_simple.cc	/^	EquivSimpleWorker(const vector<Cell*> &equiv_cells, SigMap &sigmap, dict<SigBit, Cell*> &bit2dr/;"	f	struct:EquivSimpleWorker	file:
EquivSimpleWorker	yosys/passes/equiv/equiv_simple.cc	/^struct EquivSimpleWorker$/;"	s	file:
EquivStatusPass	yosys/passes/equiv/equiv_status.cc	/^	EquivStatusPass() : Pass("equiv_status", "print status of equivalent checking module") { }$/;"	f	struct:EquivStatusPass	file:
EquivStatusPass	yosys/passes/equiv/equiv_status.cc	/^struct EquivStatusPass : public Pass {$/;"	s	file:
EquivStatusPass	yosys/passes/equiv/equiv_status.cc	/^} EquivStatusPass;$/;"	v	typeref:struct:EquivStatusPass
EquivStructPass	yosys/passes/equiv/equiv_struct.cc	/^	EquivStructPass() : Pass("equiv_struct", "structural equivalence checking") { }$/;"	f	struct:EquivStructPass	file:
EquivStructPass	yosys/passes/equiv/equiv_struct.cc	/^struct EquivStructPass : public Pass {$/;"	s	file:
EquivStructPass	yosys/passes/equiv/equiv_struct.cc	/^} EquivStructPass;$/;"	v	typeref:struct:EquivStructPass
EquivStructWorker	yosys/passes/equiv/equiv_struct.cc	/^	EquivStructWorker(Module *module, bool mode_fwd, bool mode_icells, const pool<IdString> &fwonly/;"	f	struct:EquivStructWorker	file:
EquivStructWorker	yosys/passes/equiv/equiv_struct.cc	/^struct EquivStructWorker$/;"	s	file:
EvalDemoPass	yosys/examples/cxx-api/evaldemo.cc	/^	EvalDemoPass() : Pass("evaldemo") { }$/;"	f	struct:EvalDemoPass	file:
EvalDemoPass	yosys/examples/cxx-api/evaldemo.cc	/^struct EvalDemoPass : public Pass$/;"	s	file:
EvalDemoPass	yosys/examples/cxx-api/evaldemo.cc	/^} EvalDemoPass;$/;"	v	typeref:struct:EvalDemoPass
EvalPass	yosys/passes/sat/eval.cc	/^	EvalPass() : Pass("eval", "evaluate the circuit given an input") { }$/;"	f	struct:EvalPass	file:
EvalPass	yosys/passes/sat/eval.cc	/^struct EvalPass : public Pass {$/;"	s	file:
EvalPass	yosys/passes/sat/eval.cc	/^} EvalPass;$/;"	v	typeref:struct:EvalPass
ExclusiveDatabase	yosys/passes/opt/muxpack.cc	/^	ExclusiveDatabase(Module *module, const SigMap &sigmap) : module(module), sigmap(sigmap)$/;"	f	struct:ExclusiveDatabase	file:
ExclusiveDatabase	yosys/passes/opt/muxpack.cc	/^struct ExclusiveDatabase$/;"	s	file:
ExecPass	yosys/passes/cmds/exec.cc	/^	ExecPass() : Pass("exec", "execute commands in the operating system shell") { }$/;"	f	struct:ExecPass	file:
ExecPass	yosys/passes/cmds/exec.cc	/^struct ExecPass : public Pass {$/;"	s	file:
ExecPass	yosys/passes/cmds/exec.cc	/^} ExecPass;$/;"	v	typeref:struct:ExecPass
ExposePass	yosys/passes/sat/expose.cc	/^	ExposePass() : Pass("expose", "convert internal signals to module ports") { }$/;"	f	struct:ExposePass	file:
ExposePass	yosys/passes/sat/expose.cc	/^struct ExposePass : public Pass {$/;"	s	file:
ExposePass	yosys/passes/sat/expose.cc	/^} ExposePass;$/;"	v	typeref:struct:ExposePass
ExtSigSpec	yosys/passes/opt/opt_share.cc	/^	ExtSigSpec() {}$/;"	f	struct:ExtSigSpec	file:
ExtSigSpec	yosys/passes/opt/opt_share.cc	/^	ExtSigSpec(RTLIL::SigSpec s, RTLIL::SigSpec sign = RTLIL::Const(0, 1), bool is_signed = false, /;"	f	struct:ExtSigSpec	file:
ExtSigSpec	yosys/passes/opt/opt_share.cc	/^struct ExtSigSpec {$/;"	s	file:
ExtractCounterPass	yosys/passes/techmap/extract_counter.cc	/^	ExtractCounterPass() : Pass("extract_counter", "Extract GreenPak4 counter cells") { }$/;"	f	struct:ExtractCounterPass	file:
ExtractCounterPass	yosys/passes/techmap/extract_counter.cc	/^struct ExtractCounterPass : public Pass {$/;"	s	file:
ExtractCounterPass	yosys/passes/techmap/extract_counter.cc	/^} ExtractCounterPass;$/;"	v	typeref:struct:ExtractCounterPass
ExtractFaConfig	yosys/passes/techmap/extract_fa.cc	/^struct ExtractFaConfig$/;"	s	file:
ExtractFaPass	yosys/passes/techmap/extract_fa.cc	/^	ExtractFaPass() : Pass("extract_fa", "find and extract full\/half adders") { }$/;"	f	struct:ExtractFaPass	file:
ExtractFaPass	yosys/passes/techmap/extract_fa.cc	/^struct ExtractFaPass : public Pass {$/;"	s	file:
ExtractFaPass	yosys/passes/techmap/extract_fa.cc	/^} ExtractFaPass;$/;"	v	typeref:struct:ExtractFaPass
ExtractFaWorker	yosys/passes/techmap/extract_fa.cc	/^	ExtractFaWorker(const ExtractFaConfig &config, Module *module) :$/;"	f	struct:ExtractFaWorker	file:
ExtractFaWorker	yosys/passes/techmap/extract_fa.cc	/^struct ExtractFaWorker$/;"	s	file:
ExtractPass	yosys/passes/techmap/extract.cc	/^	ExtractPass() : Pass("extract", "find subcircuits and replace them with cells") { }$/;"	f	struct:ExtractPass	file:
ExtractPass	yosys/passes/techmap/extract.cc	/^struct ExtractPass : public Pass {$/;"	s	file:
ExtractPass	yosys/passes/techmap/extract.cc	/^} ExtractPass;$/;"	v	typeref:struct:ExtractPass
ExtractReducePass	yosys/passes/techmap/extract_reduce.cc	/^	ExtractReducePass() : Pass("extract_reduce", "converts gate chains into $reduce_* cells") { }$/;"	f	struct:ExtractReducePass	file:
ExtractReducePass	yosys/passes/techmap/extract_reduce.cc	/^struct ExtractReducePass : public Pass$/;"	s	file:
ExtractReducePass	yosys/passes/techmap/extract_reduce.cc	/^} ExtractReducePass;$/;"	v	typeref:struct:ExtractReducePass
ExtractinvPass	yosys/passes/techmap/extractinv.cc	/^	ExtractinvPass() : Pass("extractinv", "extract explicit inverter cells for invertible cell pins/;"	f	struct:ExtractinvPass	file:
ExtractinvPass	yosys/passes/techmap/extractinv.cc	/^struct ExtractinvPass : public Pass {$/;"	s	file:
ExtractinvPass	yosys/passes/techmap/extractinv.cc	/^} ExtractinvPass;$/;"	v	typeref:struct:ExtractinvPass
F	yosys/frontends/aiger/aigerparse.h	/^    unsigned B, C, J, F; \/\/ Optional in AIGER 1.9$/;"	m	struct:AigerReader	typeref:typename:unsigned
FASTLZ_COMPRESSOR	yosys/libs/fst/fastlz.cc	/^#define FASTLZ_COMPRESSOR /;"	d	file:
FASTLZ_COMPRESSOR	yosys/libs/fst/fastlz.cc	/^static FASTLZ_INLINE int FASTLZ_COMPRESSOR(const void *input, int length, void *output)$/;"	f	typeref:typename:FASTLZ_INLINE int	file:
FASTLZ_DECOMPRESSOR	yosys/libs/fst/fastlz.cc	/^#define FASTLZ_DECOMPRESSOR /;"	d	file:
FASTLZ_DECOMPRESSOR	yosys/libs/fst/fastlz.cc	/^static FASTLZ_INLINE int FASTLZ_DECOMPRESSOR(const void *input, int length, void *output, int ma/;"	f	typeref:typename:FASTLZ_INLINE int	file:
FASTLZ_EXPECT_CONDITIONAL	yosys/libs/fst/fastlz.cc	/^#define FASTLZ_EXPECT_CONDITIONAL(/;"	d	file:
FASTLZ_H	yosys/libs/fst/fastlz.h	/^#define FASTLZ_H$/;"	d
FASTLZ_INLINE	yosys/libs/fst/fastlz.cc	/^#define FASTLZ_INLINE /;"	d	file:
FASTLZ_INLINE	yosys/libs/fst/fastlz.cc	/^#define FASTLZ_INLINE$/;"	d	file:
FASTLZ_LEVEL	yosys/libs/fst/fastlz.cc	/^#define FASTLZ_LEVEL /;"	d	file:
FASTLZ_READU16	yosys/libs/fst/fastlz.cc	/^#define FASTLZ_READU16(/;"	d	file:
FASTLZ_SAFE	yosys/libs/fst/fastlz.cc	/^#define FASTLZ_SAFE$/;"	d	file:
FASTLZ_STRICT_ALIGN	yosys/libs/fst/fastlz.cc	/^#define FASTLZ_STRICT_ALIGN$/;"	d	file:
FASTLZ_UNEXPECT_CONDITIONAL	yosys/libs/fst/fastlz.cc	/^#define FASTLZ_UNEXPECT_CONDITIONAL(/;"	d	file:
FASTLZ_VERSION	yosys/libs/fst/fastlz.h	/^#define FASTLZ_VERSION /;"	d
FASTLZ_VERSION_MAJOR	yosys/libs/fst/fastlz.h	/^#define FASTLZ_VERSION_MAJOR /;"	d
FASTLZ_VERSION_MINOR	yosys/libs/fst/fastlz.h	/^#define FASTLZ_VERSION_MINOR /;"	d
FASTLZ_VERSION_REVISION	yosys/libs/fst/fastlz.h	/^#define FASTLZ_VERSION_REVISION /;"	d
FASTLZ_VERSION_STRING	yosys/libs/fst/fastlz.h	/^#define FASTLZ_VERSION_STRING /;"	d
FD_IN	yosys/backends/firrtl/firrtl.cc	/^static const FDirection FD_IN = 0x1;$/;"	v	typeref:typename:const FDirection	file:
FD_INOUT	yosys/backends/firrtl/firrtl.cc	/^static const FDirection FD_INOUT = 0x3;$/;"	v	typeref:typename:const FDirection	file:
FD_NODIRECTION	yosys/backends/firrtl/firrtl.cc	/^static const FDirection FD_NODIRECTION = 0x0;$/;"	v	typeref:typename:const FDirection	file:
FD_OUT	yosys/backends/firrtl/firrtl.cc	/^static const FDirection FD_OUT = 0x2;$/;"	v	typeref:typename:const FDirection	file:
FDirection	yosys/backends/firrtl/firrtl.cc	/^typedef unsigned FDirection;$/;"	t	typeref:typename:unsigned	file:
FFINIT_H	yosys/kernel/ffinit.h	/^#define FFINIT_H$/;"	d
FFMERGE_H	yosys/kernel/ffmerge.h	/^#define FFMERGE_H$/;"	d
FF_ADFF	yosys/passes/techmap/dfflegalize.cc	/^	FF_ADFF,$/;"	e	enum:FfType	file:
FF_ADFFE	yosys/passes/techmap/dfflegalize.cc	/^	FF_ADFFE,$/;"	e	enum:FfType	file:
FF_ADLATCH	yosys/passes/techmap/dfflegalize.cc	/^	FF_ADLATCH,$/;"	e	enum:FfType	file:
FF_ALDFF	yosys/passes/techmap/dfflegalize.cc	/^	FF_ALDFF,$/;"	e	enum:FfType	file:
FF_ALDFFE	yosys/passes/techmap/dfflegalize.cc	/^	FF_ALDFFE,$/;"	e	enum:FfType	file:
FF_DFF	yosys/passes/techmap/dfflegalize.cc	/^	FF_DFF,$/;"	e	enum:FfType	file:
FF_DFFE	yosys/passes/techmap/dfflegalize.cc	/^	FF_DFFE,$/;"	e	enum:FfType	file:
FF_DFFSR	yosys/passes/techmap/dfflegalize.cc	/^	FF_DFFSR,$/;"	e	enum:FfType	file:
FF_DFFSRE	yosys/passes/techmap/dfflegalize.cc	/^	FF_DFFSRE,$/;"	e	enum:FfType	file:
FF_DLATCH	yosys/passes/techmap/dfflegalize.cc	/^	FF_DLATCH,$/;"	e	enum:FfType	file:
FF_DLATCHSR	yosys/passes/techmap/dfflegalize.cc	/^	FF_DLATCHSR,$/;"	e	enum:FfType	file:
FF_H	yosys/kernel/ff.h	/^#define FF_H$/;"	d
FF_RLATCH	yosys/passes/techmap/dfflegalize.cc	/^	FF_RLATCH,$/;"	e	enum:FfType	file:
FF_SDFF	yosys/passes/techmap/dfflegalize.cc	/^	FF_SDFF,$/;"	e	enum:FfType	file:
FF_SDFFCE	yosys/passes/techmap/dfflegalize.cc	/^	FF_SDFFCE,$/;"	e	enum:FfType	file:
FF_SDFFE	yosys/passes/techmap/dfflegalize.cc	/^	FF_SDFFE,$/;"	e	enum:FfType	file:
FF_SR	yosys/passes/techmap/dfflegalize.cc	/^	FF_SR,$/;"	e	enum:FfType	file:
FILTERED_OUT	yosys/frontends/verific/verific.cc	/^	#define FILTERED_OUT /;"	d	file:
FILTERLIB	yosys/passes/techmap/filterlib.cc	/^#define FILTERLIB$/;"	d	file:
FINE_BITWISE_OPS	yosys/passes/opt/opt_share.cc	/^#define FINE_BITWISE_OPS /;"	d	file:
FIRRTL_MAX_DSH_WIDTH_ERROR	yosys/backends/firrtl/firrtl.cc	/^static const int FIRRTL_MAX_DSH_WIDTH_ERROR = 20; \/\/ For historic reasons, this is actually on/;"	v	typeref:typename:const int	file:
FOLD_1ARG_CELL	yosys/passes/opt/opt_expr.cc	/^#define FOLD_1ARG_CELL(/;"	d	file:
FOLD_2ARG_CELL	yosys/passes/opt/opt_expr.cc	/^#define FOLD_2ARG_CELL(/;"	d	file:
FORCE_INLINE	yosys/libs/fst/lz4.cc	/^#define FORCE_INLINE /;"	d	file:
FREEMEM	yosys/libs/fst/lz4.cc	/^#define FREEMEM /;"	d	file:
FSMDATA_H	yosys/passes/fsm/fsmdata.h	/^#define FSMDATA_H$/;"	d
FSTDATA_H	yosys/kernel/fstdata.h	/^#define FSTDATA_H$/;"	d
FSTWriter	yosys/passes/sat/sim.cc	/^	FSTWriter(SimWorker *worker, std::string filename) : OutputWriter(worker) {$/;"	f	struct:FSTWriter	file:
FSTWriter	yosys/passes/sat/sim.cc	/^struct FSTWriter : public OutputWriter$/;"	s	file:
FST_ACTIVATE_HUGE_BREAK	yosys/libs/fst/fstapi.cc	/^#define FST_ACTIVATE_HUGE_BREAK /;"	d	file:
FST_ACTIVATE_HUGE_INC	yosys/libs/fst/fstapi.cc	/^#define FST_ACTIVATE_HUGE_INC /;"	d	file:
FST_APIMESS	yosys/libs/fst/fstapi.cc	/^#define FST_APIMESS /;"	d	file:
FST_API_H	yosys/libs/fst/fstapi.h	/^#define FST_API_H$/;"	d
FST_AR_MAX	yosys/libs/fst/fstapi.h	/^    FST_AR_MAX = 3$/;"	e	enum:fstArrayType
FST_AR_MIN	yosys/libs/fst/fstapi.h	/^    FST_AR_MIN = 0,$/;"	e	enum:fstArrayType
FST_AR_NONE	yosys/libs/fst/fstapi.h	/^    FST_AR_NONE = 0,$/;"	e	enum:fstArrayType
FST_AR_PACKED	yosys/libs/fst/fstapi.h	/^    FST_AR_PACKED = 2,$/;"	e	enum:fstArrayType
FST_AR_SPARSE	yosys/libs/fst/fstapi.h	/^    FST_AR_SPARSE = 3,$/;"	e	enum:fstArrayType
FST_AR_UNPACKED	yosys/libs/fst/fstapi.h	/^    FST_AR_UNPACKED = 1,$/;"	e	enum:fstArrayType
FST_AT_ARRAY	yosys/libs/fst/fstapi.h	/^    FST_AT_ARRAY = 1,$/;"	e	enum:fstAttrType
FST_AT_ENUM	yosys/libs/fst/fstapi.h	/^    FST_AT_ENUM = 2,$/;"	e	enum:fstAttrType
FST_AT_MAX	yosys/libs/fst/fstapi.h	/^    FST_AT_MAX = 3$/;"	e	enum:fstAttrType
FST_AT_MIN	yosys/libs/fst/fstapi.h	/^    FST_AT_MIN = 0,$/;"	e	enum:fstAttrType
FST_AT_MISC	yosys/libs/fst/fstapi.h	/^    FST_AT_MISC = 0, \/* self-contained: does not need matching FST_HT_ATTREND *\/$/;"	e	enum:fstAttrType
FST_AT_PACK	yosys/libs/fst/fstapi.h	/^    FST_AT_PACK = 3,$/;"	e	enum:fstAttrType
FST_BL_BLACKOUT	yosys/libs/fst/fstapi.h	/^    FST_BL_BLACKOUT = 2,$/;"	e	enum:fstBlockType
FST_BL_GEOM	yosys/libs/fst/fstapi.h	/^    FST_BL_GEOM = 3,$/;"	e	enum:fstBlockType
FST_BL_HDR	yosys/libs/fst/fstapi.h	/^    FST_BL_HDR = 0,$/;"	e	enum:fstBlockType
FST_BL_HIER	yosys/libs/fst/fstapi.h	/^    FST_BL_HIER = 4,$/;"	e	enum:fstBlockType
FST_BL_HIER_LZ4	yosys/libs/fst/fstapi.h	/^    FST_BL_HIER_LZ4 = 6,$/;"	e	enum:fstBlockType
FST_BL_HIER_LZ4DUO	yosys/libs/fst/fstapi.h	/^    FST_BL_HIER_LZ4DUO = 7,$/;"	e	enum:fstBlockType
FST_BL_SKIP	yosys/libs/fst/fstapi.h	/^    FST_BL_SKIP = 255      \/* used while block is being written *\/$/;"	e	enum:fstBlockType
FST_BL_VCDATA	yosys/libs/fst/fstapi.h	/^    FST_BL_VCDATA = 1,$/;"	e	enum:fstBlockType
FST_BL_VCDATA_DYN_ALIAS	yosys/libs/fst/fstapi.h	/^    FST_BL_VCDATA_DYN_ALIAS = 5,$/;"	e	enum:fstBlockType
FST_BL_VCDATA_DYN_ALIAS2	yosys/libs/fst/fstapi.h	/^    FST_BL_VCDATA_DYN_ALIAS2 = 8,$/;"	e	enum:fstBlockType
FST_BL_ZWRAPPER	yosys/libs/fst/fstapi.h	/^    FST_BL_ZWRAPPER = 254, \/* indicates that whole trace is gz wrapped *\/$/;"	e	enum:fstBlockType
FST_BREAK_ADD_SIZE	yosys/libs/fst/fstapi.cc	/^#define FST_BREAK_ADD_SIZE /;"	d	file:
FST_BREAK_SIZE	yosys/libs/fst/fstapi.cc	/^#define FST_BREAK_SIZE /;"	d	file:
FST_BREAK_SIZE_MAX	yosys/libs/fst/fstapi.cc	/^#define FST_BREAK_SIZE_MAX /;"	d	file:
FST_CADDR_T_CAST	yosys/libs/fst/fstapi.cc	/^#define FST_CADDR_T_CAST /;"	d	file:
FST_CADDR_T_CAST	yosys/libs/fst/fstapi.cc	/^#define FST_CADDR_T_CAST$/;"	d	file:
FST_CONFIG_INCLUDE	yosys/libs/fst/fstapi.cc	/^#define FST_CONFIG_INCLUDE /;"	d	file:
FST_DOUBLE_ENDTEST	yosys/libs/fst/fstapi.cc	/^#define FST_DOUBLE_ENDTEST /;"	d	file:
FST_DO_MISALIGNED_OPS	yosys/libs/fst/fstapi.cc	/^#define FST_DO_MISALIGNED_OPS$/;"	d	file:
FST_EV_MAX	yosys/libs/fst/fstapi.h	/^    FST_EV_MAX = 15$/;"	e	enum:fstEnumValueType
FST_EV_REG	yosys/libs/fst/fstapi.h	/^    FST_EV_REG = 14,$/;"	e	enum:fstEnumValueType
FST_EV_SV_BIT	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_BIT = 1,$/;"	e	enum:fstEnumValueType
FST_EV_SV_BYTE	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_BYTE = 6,$/;"	e	enum:fstEnumValueType
FST_EV_SV_INT	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_INT = 3,$/;"	e	enum:fstEnumValueType
FST_EV_SV_INTEGER	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_INTEGER = 0,$/;"	e	enum:fstEnumValueType
FST_EV_SV_LOGIC	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_LOGIC = 2,$/;"	e	enum:fstEnumValueType
FST_EV_SV_LONGINT	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_LONGINT = 5,$/;"	e	enum:fstEnumValueType
FST_EV_SV_SHORTINT	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_SHORTINT = 4,$/;"	e	enum:fstEnumValueType
FST_EV_SV_UNSIGNED_BIT	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_UNSIGNED_BIT = 8,$/;"	e	enum:fstEnumValueType
FST_EV_SV_UNSIGNED_BYTE	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_UNSIGNED_BYTE = 13,$/;"	e	enum:fstEnumValueType
FST_EV_SV_UNSIGNED_INT	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_UNSIGNED_INT = 10,$/;"	e	enum:fstEnumValueType
FST_EV_SV_UNSIGNED_INTEGER	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_UNSIGNED_INTEGER = 7,$/;"	e	enum:fstEnumValueType
FST_EV_SV_UNSIGNED_LOGIC	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_UNSIGNED_LOGIC = 9,$/;"	e	enum:fstEnumValueType
FST_EV_SV_UNSIGNED_LONGINT	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_UNSIGNED_LONGINT = 12,$/;"	e	enum:fstEnumValueType
FST_EV_SV_UNSIGNED_SHORTINT	yosys/libs/fst/fstapi.h	/^    FST_EV_SV_UNSIGNED_SHORTINT = 11,$/;"	e	enum:fstEnumValueType
FST_EV_TIME	yosys/libs/fst/fstapi.h	/^    FST_EV_TIME = 15,$/;"	e	enum:fstEnumValueType
FST_FT_MAX	yosys/libs/fst/fstapi.h	/^    FST_FT_MAX = 2$/;"	e	enum:fstFileType
FST_FT_MIN	yosys/libs/fst/fstapi.h	/^    FST_FT_MIN = 0,$/;"	e	enum:fstFileType
FST_FT_VERILOG	yosys/libs/fst/fstapi.h	/^    FST_FT_VERILOG = 0,$/;"	e	enum:fstFileType
FST_FT_VERILOG_VHDL	yosys/libs/fst/fstapi.h	/^    FST_FT_VERILOG_VHDL = 2,$/;"	e	enum:fstFileType
FST_FT_VHDL	yosys/libs/fst/fstapi.h	/^    FST_FT_VHDL = 1,$/;"	e	enum:fstFileType
FST_GZIO_LEN	yosys/libs/fst/fstapi.cc	/^#define FST_GZIO_LEN /;"	d	file:
FST_HDR_DATE_SIZE	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_DATE_SIZE /;"	d	file:
FST_HDR_FILETYPE_SIZE	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_FILETYPE_SIZE /;"	d	file:
FST_HDR_FOURPACK_DUO_SIZE	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_FOURPACK_DUO_SIZE /;"	d	file:
FST_HDR_LENGTH	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_LENGTH /;"	d	file:
FST_HDR_OFFS_DATE	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_DATE /;"	d	file:
FST_HDR_OFFS_ENDIAN_TEST	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_ENDIAN_TEST /;"	d	file:
FST_HDR_OFFS_END_TIME	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_END_TIME /;"	d	file:
FST_HDR_OFFS_FILETYPE	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_FILETYPE /;"	d	file:
FST_HDR_OFFS_MAXHANDLE	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_MAXHANDLE /;"	d	file:
FST_HDR_OFFS_MEM_USED	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_MEM_USED /;"	d	file:
FST_HDR_OFFS_NUM_SCOPES	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_NUM_SCOPES /;"	d	file:
FST_HDR_OFFS_NUM_VARS	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_NUM_VARS /;"	d	file:
FST_HDR_OFFS_SECLEN	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_SECLEN /;"	d	file:
FST_HDR_OFFS_SECTION_CNT	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_SECTION_CNT /;"	d	file:
FST_HDR_OFFS_SIM_VERSION	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_SIM_VERSION /;"	d	file:
FST_HDR_OFFS_START_TIME	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_START_TIME /;"	d	file:
FST_HDR_OFFS_TAG	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_TAG /;"	d	file:
FST_HDR_OFFS_TIMESCALE	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_TIMESCALE /;"	d	file:
FST_HDR_OFFS_TIMEZERO	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_OFFS_TIMEZERO /;"	d	file:
FST_HDR_SIM_VERSION_SIZE	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_SIM_VERSION_SIZE /;"	d	file:
FST_HDR_TIMEZERO_SIZE	yosys/libs/fst/fstapi.cc	/^#define FST_HDR_TIMEZERO_SIZE /;"	d	file:
FST_HT_ATTRBEGIN	yosys/libs/fst/fstapi.h	/^    FST_HT_ATTRBEGIN = 3,$/;"	e	enum:fstHierType
FST_HT_ATTREND	yosys/libs/fst/fstapi.h	/^    FST_HT_ATTREND = 4,$/;"	e	enum:fstHierType
FST_HT_MAX	yosys/libs/fst/fstapi.h	/^    FST_HT_MAX = 6$/;"	e	enum:fstHierType
FST_HT_MIN	yosys/libs/fst/fstapi.h	/^    FST_HT_MIN = 0,$/;"	e	enum:fstHierType
FST_HT_SCOPE	yosys/libs/fst/fstapi.h	/^    FST_HT_SCOPE = 0,$/;"	e	enum:fstHierType
FST_HT_TREEBEGIN	yosys/libs/fst/fstapi.h	/^    FST_HT_TREEBEGIN = 5,$/;"	e	enum:fstHierType
FST_HT_TREEEND	yosys/libs/fst/fstapi.h	/^    FST_HT_TREEEND = 6,$/;"	e	enum:fstHierType
FST_HT_UPSCOPE	yosys/libs/fst/fstapi.h	/^    FST_HT_UPSCOPE = 1,$/;"	e	enum:fstHierType
FST_HT_VAR	yosys/libs/fst/fstapi.h	/^    FST_HT_VAR = 2,$/;"	e	enum:fstHierType
FST_ID_NAM_ATTR_SIZ	yosys/libs/fst/fstapi.cc	/^#define FST_ID_NAM_ATTR_SIZ /;"	d	file:
FST_ID_NAM_SIZ	yosys/libs/fst/fstapi.cc	/^#define FST_ID_NAM_SIZ /;"	d	file:
FST_LIKELY	yosys/libs/fst/fstapi.cc	/^#define FST_LIKELY(/;"	d	file:
FST_MACOSX	yosys/libs/fst/fstapi.cc	/^#define FST_MACOSX$/;"	d	file:
FST_MT_COMMENT	yosys/libs/fst/fstapi.h	/^    FST_MT_COMMENT = 0,     \/* use fstWriterSetComment() to emit *\/$/;"	e	enum:fstMiscType
FST_MT_ENUMTABLE	yosys/libs/fst/fstapi.h	/^    FST_MT_ENUMTABLE = 7,   \/* use fstWriterCreateEnumTable() and fstWriterEmitEnumTableRef() t/;"	e	enum:fstMiscType
FST_MT_ENVVAR	yosys/libs/fst/fstapi.h	/^    FST_MT_ENVVAR = 1,      \/* use fstWriterSetEnvVar() to emit *\/$/;"	e	enum:fstMiscType
FST_MT_MAX	yosys/libs/fst/fstapi.h	/^    FST_MT_MAX = 8$/;"	e	enum:fstMiscType
FST_MT_MIN	yosys/libs/fst/fstapi.h	/^    FST_MT_MIN = 0,$/;"	e	enum:fstMiscType
FST_MT_PATHNAME	yosys/libs/fst/fstapi.h	/^    FST_MT_PATHNAME = 3,    \/* reserved for fstWriterSetSourceStem() string -> number managemen/;"	e	enum:fstMiscType
FST_MT_SOURCEISTEM	yosys/libs/fst/fstapi.h	/^    FST_MT_SOURCEISTEM = 5, \/* use fstWriterSetSourceInstantiationStem() to emit *\/$/;"	e	enum:fstMiscType
FST_MT_SOURCESTEM	yosys/libs/fst/fstapi.h	/^    FST_MT_SOURCESTEM = 4,  \/* use fstWriterSetSourceStem() to emit *\/$/;"	e	enum:fstMiscType
FST_MT_SUPVAR	yosys/libs/fst/fstapi.h	/^    FST_MT_SUPVAR = 2,      \/* use fstWriterCreateVar2() to emit *\/$/;"	e	enum:fstMiscType
FST_MT_UNKNOWN	yosys/libs/fst/fstapi.h	/^    FST_MT_UNKNOWN = 8,$/;"	e	enum:fstMiscType
FST_MT_VALUELIST	yosys/libs/fst/fstapi.h	/^    FST_MT_VALUELIST = 6,   \/* use fstWriterSetValueList() to emit, followed by fstWriterCreate/;"	e	enum:fstMiscType
FST_PATH_HASHMASK	yosys/libs/fst/fstapi.cc	/^#define FST_PATH_HASHMASK /;"	d	file:
FST_PT_MAX	yosys/libs/fst/fstapi.h	/^    FST_PT_MAX = 3$/;"	e	enum:fstPackType
FST_PT_NONE	yosys/libs/fst/fstapi.h	/^    FST_PT_NONE = 0,$/;"	e	enum:fstPackType
FST_PT_PACKED	yosys/libs/fst/fstapi.h	/^    FST_PT_PACKED = 2,$/;"	e	enum:fstPackType
FST_PT_TAGGED_PACKED	yosys/libs/fst/fstapi.h	/^    FST_PT_TAGGED_PACKED = 3,$/;"	e	enum:fstPackType
FST_PT_UNPACKED	yosys/libs/fst/fstapi.h	/^    FST_PT_UNPACKED = 1,$/;"	e	enum:fstPackType
FST_RCV_D	yosys/libs/fst/fstapi.cc	/^#define FST_RCV_D /;"	d	file:
FST_RCV_H	yosys/libs/fst/fstapi.cc	/^#define FST_RCV_H /;"	d	file:
FST_RCV_L	yosys/libs/fst/fstapi.cc	/^#define FST_RCV_L /;"	d	file:
FST_RCV_Q	yosys/libs/fst/fstapi.cc	/^#define FST_RCV_Q /;"	d	file:
FST_RCV_STR	yosys/libs/fst/fstapi.cc	/^#define FST_RCV_STR /;"	d	file:
FST_RCV_U	yosys/libs/fst/fstapi.cc	/^#define FST_RCV_U /;"	d	file:
FST_RCV_W	yosys/libs/fst/fstapi.cc	/^#define FST_RCV_W /;"	d	file:
FST_RCV_X	yosys/libs/fst/fstapi.cc	/^#define FST_RCV_X /;"	d	file:
FST_RCV_Z	yosys/libs/fst/fstapi.cc	/^#define FST_RCV_Z /;"	d	file:
FST_RDLOAD	yosys/libs/fst/fstapi.h	/^#define FST_RDLOAD /;"	d
FST_SDT_ABS_MAX	yosys/libs/fst/fstapi.h	/^    FST_SDT_ABS_MAX = ((1 << (FST_SDT_SVT_SHIFT_COUNT)) - 1)$/;"	e	enum:fstSupplementalDataType
FST_SDT_MAX	yosys/libs/fst/fstapi.h	/^    FST_SDT_MAX = 16,$/;"	e	enum:fstSupplementalDataType
FST_SDT_MIN	yosys/libs/fst/fstapi.h	/^    FST_SDT_MIN = 0,$/;"	e	enum:fstSupplementalDataType
FST_SDT_NONE	yosys/libs/fst/fstapi.h	/^    FST_SDT_NONE = 0,$/;"	e	enum:fstSupplementalDataType
FST_SDT_SVT_SHIFT_COUNT	yosys/libs/fst/fstapi.h	/^    FST_SDT_SVT_SHIFT_COUNT =$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_BIT	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_BIT = 2,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_BIT_VECTOR	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_BIT_VECTOR = 3,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_BOOLEAN	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_BOOLEAN = 1,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_CHARACTER	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_CHARACTER = 15,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_INTEGER	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_INTEGER = 10,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_NATURAL	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_NATURAL = 12,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_POSITIVE	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_POSITIVE = 13,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_REAL	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_REAL = 11,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_SIGNED	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_SIGNED = 9,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_STD_LOGIC	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_STD_LOGIC = 6,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_STD_LOGIC_VECTOR	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_STD_LOGIC_VECTOR = 7,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_STD_ULOGIC	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_STD_ULOGIC = 4,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_STD_ULOGIC_VECTOR	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_STD_ULOGIC_VECTOR = 5,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_STRING	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_STRING = 16,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_TIME	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_TIME = 14,$/;"	e	enum:fstSupplementalDataType
FST_SDT_VHDL_UNSIGNED	yosys/libs/fst/fstapi.h	/^    FST_SDT_VHDL_UNSIGNED = 8,$/;"	e	enum:fstSupplementalDataType
FST_ST_GEN_ATTRBEGIN	yosys/libs/fst/fstapi.h	/^    FST_ST_GEN_ATTRBEGIN = 252,$/;"	e	enum:fstScopeType
FST_ST_GEN_ATTREND	yosys/libs/fst/fstapi.h	/^    FST_ST_GEN_ATTREND = 253,$/;"	e	enum:fstScopeType
FST_ST_MAX	yosys/libs/fst/fstapi.h	/^    FST_ST_MAX = 21,$/;"	e	enum:fstScopeType
FST_ST_MIN	yosys/libs/fst/fstapi.h	/^    FST_ST_MIN = 0,$/;"	e	enum:fstScopeType
FST_ST_VCD_BEGIN	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_BEGIN = 3,$/;"	e	enum:fstScopeType
FST_ST_VCD_CLASS	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_CLASS = 8,$/;"	e	enum:fstScopeType
FST_ST_VCD_FORK	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_FORK = 4,$/;"	e	enum:fstScopeType
FST_ST_VCD_FUNCTION	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_FUNCTION = 2,$/;"	e	enum:fstScopeType
FST_ST_VCD_GENERATE	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_GENERATE = 5,$/;"	e	enum:fstScopeType
FST_ST_VCD_INTERFACE	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_INTERFACE = 9,$/;"	e	enum:fstScopeType
FST_ST_VCD_MODULE	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_MODULE = 0,$/;"	e	enum:fstScopeType
FST_ST_VCD_PACKAGE	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_PACKAGE = 10,$/;"	e	enum:fstScopeType
FST_ST_VCD_PROGRAM	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_PROGRAM = 11,$/;"	e	enum:fstScopeType
FST_ST_VCD_SCOPE	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_SCOPE = 254,$/;"	e	enum:fstScopeType
FST_ST_VCD_STRUCT	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_STRUCT = 6,$/;"	e	enum:fstScopeType
FST_ST_VCD_TASK	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_TASK = 1,$/;"	e	enum:fstScopeType
FST_ST_VCD_UNION	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_UNION = 7,$/;"	e	enum:fstScopeType
FST_ST_VCD_UPSCOPE	yosys/libs/fst/fstapi.h	/^    FST_ST_VCD_UPSCOPE = 255$/;"	e	enum:fstScopeType
FST_ST_VHDL_ARCHITECTURE	yosys/libs/fst/fstapi.h	/^    FST_ST_VHDL_ARCHITECTURE = 12,$/;"	e	enum:fstScopeType
FST_ST_VHDL_BLOCK	yosys/libs/fst/fstapi.h	/^    FST_ST_VHDL_BLOCK = 17,$/;"	e	enum:fstScopeType
FST_ST_VHDL_FOR_GENERATE	yosys/libs/fst/fstapi.h	/^    FST_ST_VHDL_FOR_GENERATE = 18,$/;"	e	enum:fstScopeType
FST_ST_VHDL_FUNCTION	yosys/libs/fst/fstapi.h	/^    FST_ST_VHDL_FUNCTION = 14,$/;"	e	enum:fstScopeType
FST_ST_VHDL_GENERATE	yosys/libs/fst/fstapi.h	/^    FST_ST_VHDL_GENERATE = 20,$/;"	e	enum:fstScopeType
FST_ST_VHDL_IF_GENERATE	yosys/libs/fst/fstapi.h	/^    FST_ST_VHDL_IF_GENERATE = 19,$/;"	e	enum:fstScopeType
FST_ST_VHDL_PACKAGE	yosys/libs/fst/fstapi.h	/^    FST_ST_VHDL_PACKAGE = 21,$/;"	e	enum:fstScopeType
FST_ST_VHDL_PROCEDURE	yosys/libs/fst/fstapi.h	/^    FST_ST_VHDL_PROCEDURE = 13,$/;"	e	enum:fstScopeType
FST_ST_VHDL_PROCESS	yosys/libs/fst/fstapi.h	/^    FST_ST_VHDL_PROCESS = 16,$/;"	e	enum:fstScopeType
FST_ST_VHDL_RECORD	yosys/libs/fst/fstapi.h	/^    FST_ST_VHDL_RECORD = 15,$/;"	e	enum:fstScopeType
FST_SVT_MAX	yosys/libs/fst/fstapi.h	/^    FST_SVT_MAX = 5$/;"	e	enum:fstSupplementalVarType
FST_SVT_MIN	yosys/libs/fst/fstapi.h	/^    FST_SVT_MIN = 0,$/;"	e	enum:fstSupplementalVarType
FST_SVT_NONE	yosys/libs/fst/fstapi.h	/^    FST_SVT_NONE = 0,$/;"	e	enum:fstSupplementalVarType
FST_SVT_VHDL_CONSTANT	yosys/libs/fst/fstapi.h	/^    FST_SVT_VHDL_CONSTANT = 3,$/;"	e	enum:fstSupplementalVarType
FST_SVT_VHDL_FILE	yosys/libs/fst/fstapi.h	/^    FST_SVT_VHDL_FILE = 4,$/;"	e	enum:fstSupplementalVarType
FST_SVT_VHDL_MEMORY	yosys/libs/fst/fstapi.h	/^    FST_SVT_VHDL_MEMORY = 5,$/;"	e	enum:fstSupplementalVarType
FST_SVT_VHDL_SIGNAL	yosys/libs/fst/fstapi.h	/^    FST_SVT_VHDL_SIGNAL = 1,$/;"	e	enum:fstSupplementalVarType
FST_SVT_VHDL_VARIABLE	yosys/libs/fst/fstapi.h	/^    FST_SVT_VHDL_VARIABLE = 2,$/;"	e	enum:fstSupplementalVarType
FST_UNLIKELY	yosys/libs/fst/fstapi.cc	/^#define FST_UNLIKELY(/;"	d	file:
FST_VD_BUFFER	yosys/libs/fst/fstapi.h	/^    FST_VD_BUFFER = 4,$/;"	e	enum:fstVarDir
FST_VD_IMPLICIT	yosys/libs/fst/fstapi.h	/^    FST_VD_IMPLICIT = 0,$/;"	e	enum:fstVarDir
FST_VD_INOUT	yosys/libs/fst/fstapi.h	/^    FST_VD_INOUT = 3,$/;"	e	enum:fstVarDir
FST_VD_INPUT	yosys/libs/fst/fstapi.h	/^    FST_VD_INPUT = 1,$/;"	e	enum:fstVarDir
FST_VD_LINKAGE	yosys/libs/fst/fstapi.h	/^    FST_VD_LINKAGE = 5,$/;"	e	enum:fstVarDir
FST_VD_MAX	yosys/libs/fst/fstapi.h	/^    FST_VD_MAX = 5$/;"	e	enum:fstVarDir
FST_VD_MIN	yosys/libs/fst/fstapi.h	/^    FST_VD_MIN = 0,$/;"	e	enum:fstVarDir
FST_VD_OUTPUT	yosys/libs/fst/fstapi.h	/^    FST_VD_OUTPUT = 2,$/;"	e	enum:fstVarDir
FST_VT_GEN_STRING	yosys/libs/fst/fstapi.h	/^    FST_VT_GEN_STRING =$/;"	e	enum:fstVarType
FST_VT_MAX	yosys/libs/fst/fstapi.h	/^    FST_VT_MAX = 29 \/* end of vartypes *\/$/;"	e	enum:fstVarType
FST_VT_MIN	yosys/libs/fst/fstapi.h	/^    FST_VT_MIN = 0, \/* start of vartypes *\/$/;"	e	enum:fstVarType
FST_VT_SV_BIT	yosys/libs/fst/fstapi.h	/^    FST_VT_SV_BIT = 22,$/;"	e	enum:fstVarType
FST_VT_SV_BYTE	yosys/libs/fst/fstapi.h	/^    FST_VT_SV_BYTE = 27,     \/* declare as size = 8  *\/$/;"	e	enum:fstVarType
FST_VT_SV_ENUM	yosys/libs/fst/fstapi.h	/^    FST_VT_SV_ENUM = 28,     \/* declare as appropriate type range *\/$/;"	e	enum:fstVarType
FST_VT_SV_INT	yosys/libs/fst/fstapi.h	/^    FST_VT_SV_INT = 24,      \/* declare as size = 32 *\/$/;"	e	enum:fstVarType
FST_VT_SV_LOGIC	yosys/libs/fst/fstapi.h	/^    FST_VT_SV_LOGIC = 23,$/;"	e	enum:fstVarType
FST_VT_SV_LONGINT	yosys/libs/fst/fstapi.h	/^    FST_VT_SV_LONGINT = 26,  \/* declare as size = 64 *\/$/;"	e	enum:fstVarType
FST_VT_SV_SHORTINT	yosys/libs/fst/fstapi.h	/^    FST_VT_SV_SHORTINT = 25, \/* declare as size = 16 *\/$/;"	e	enum:fstVarType
FST_VT_SV_SHORTREAL	yosys/libs/fst/fstapi.h	/^    FST_VT_SV_SHORTREAL =$/;"	e	enum:fstVarType
FST_VT_VCD_EVENT	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_EVENT = 0,$/;"	e	enum:fstVarType
FST_VT_VCD_INTEGER	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_INTEGER = 1,$/;"	e	enum:fstVarType
FST_VT_VCD_PARAMETER	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_PARAMETER = 2,$/;"	e	enum:fstVarType
FST_VT_VCD_PORT	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_PORT = 18,$/;"	e	enum:fstVarType
FST_VT_VCD_REAL	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_REAL = 3,$/;"	e	enum:fstVarType
FST_VT_VCD_REALTIME	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_REALTIME = 20,$/;"	e	enum:fstVarType
FST_VT_VCD_REAL_PARAMETER	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_REAL_PARAMETER = 4,$/;"	e	enum:fstVarType
FST_VT_VCD_REG	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_REG = 5,$/;"	e	enum:fstVarType
FST_VT_VCD_SPARRAY	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_SPARRAY = 19, \/* used to define the rownum (index) port for a sparse array *\/$/;"	e	enum:fstVarType
FST_VT_VCD_SUPPLY0	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_SUPPLY0 = 6,$/;"	e	enum:fstVarType
FST_VT_VCD_SUPPLY1	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_SUPPLY1 = 7,$/;"	e	enum:fstVarType
FST_VT_VCD_TIME	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_TIME = 8,$/;"	e	enum:fstVarType
FST_VT_VCD_TRI	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_TRI = 9,$/;"	e	enum:fstVarType
FST_VT_VCD_TRI0	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_TRI0 = 13,$/;"	e	enum:fstVarType
FST_VT_VCD_TRI1	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_TRI1 = 14,$/;"	e	enum:fstVarType
FST_VT_VCD_TRIAND	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_TRIAND = 10,$/;"	e	enum:fstVarType
FST_VT_VCD_TRIOR	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_TRIOR = 11,$/;"	e	enum:fstVarType
FST_VT_VCD_TRIREG	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_TRIREG = 12,$/;"	e	enum:fstVarType
FST_VT_VCD_WAND	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_WAND = 15,$/;"	e	enum:fstVarType
FST_VT_VCD_WIRE	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_WIRE = 16,$/;"	e	enum:fstVarType
FST_VT_VCD_WOR	yosys/libs/fst/fstapi.h	/^    FST_VT_VCD_WOR = 17,$/;"	e	enum:fstVarType
FST_WRITER_STR	yosys/libs/fst/fstapi.cc	/^#define FST_WRITER_STR /;"	d	file:
FST_WRITEX_MAX	yosys/libs/fst/fstapi.cc	/^#define FST_WRITEX_MAX /;"	d	file:
FST_WR_PT_FASTLZ	yosys/libs/fst/fstapi.h	/^    FST_WR_PT_FASTLZ = 1,$/;"	e	enum:fstWriterPackType
FST_WR_PT_LZ4	yosys/libs/fst/fstapi.h	/^    FST_WR_PT_LZ4 = 2$/;"	e	enum:fstWriterPackType
FST_WR_PT_ZLIB	yosys/libs/fst/fstapi.h	/^    FST_WR_PT_ZLIB = 0,$/;"	e	enum:fstWriterPackType
FdRpcServer	yosys/frontends/rpc/rpc_frontend.cc	/^	FdRpcServer(const std::string &name, int fdsend, int fdrecv, pid_t pid = -1)$/;"	f	struct:FdRpcServer	file:
FdRpcServer	yosys/frontends/rpc/rpc_frontend.cc	/^struct FdRpcServer : RpcServer {$/;"	s	file:
FeedbackPath	yosys/passes/opt/opt_mem_feedback.cc	/^	FeedbackPath(int wrport_idx, int data_bit_idx, dict<RTLIL::SigBit, bool> condition, SigBit feed/;"	f	struct:FeedbackPath	file:
FeedbackPath	yosys/passes/opt/opt_mem_feedback.cc	/^struct FeedbackPath {$/;"	s	file:
FfData	yosys/kernel/ff.cc	/^FfData::FfData(FfInitVals *initvals, Cell *cell_) : FfData(cell_->module, initvals, cell_->name)$/;"	f	class:FfData	typeref:typename:USING_YOSYS_NAMESPACE
FfData	yosys/kernel/ff.h	/^	FfData(Module *module = nullptr, FfInitVals *initvals = nullptr, IdString name = IdString()) : /;"	f	struct:FfData
FfData	yosys/kernel/ff.h	/^struct FfData {$/;"	s
FfInit	yosys/passes/techmap/dfflegalize.cc	/^enum FfInit {$/;"	g	file:
FfInitVals	yosys/kernel/ffinit.h	/^	FfInitVals () {}$/;"	f	struct:FfInitVals
FfInitVals	yosys/kernel/ffinit.h	/^	FfInitVals (const SigMap *sigmap, RTLIL::Module *module)$/;"	f	struct:FfInitVals
FfInitVals	yosys/kernel/ffinit.h	/^struct FfInitVals$/;"	s
FfMergeHelper	yosys/kernel/ffmerge.h	/^	FfMergeHelper() {}$/;"	f	struct:FfMergeHelper
FfMergeHelper	yosys/kernel/ffmerge.h	/^	FfMergeHelper(FfInitVals *initvals, RTLIL::Module *module) {$/;"	f	struct:FfMergeHelper
FfMergeHelper	yosys/kernel/ffmerge.h	/^struct FfMergeHelper$/;"	s
FfNeg	yosys/passes/techmap/dfflegalize.cc	/^enum FfNeg {$/;"	g	file:
FfType	yosys/passes/techmap/dfflegalize.cc	/^enum FfType {$/;"	g	file:
FindReducedInputs	yosys/passes/sat/freduce.cc	/^	FindReducedInputs(SigMap &sigmap, drivers_t &drivers) :$/;"	f	struct:FindReducedInputs	file:
FindReducedInputs	yosys/passes/sat/freduce.cc	/^struct FindReducedInputs$/;"	s	file:
FirrtlBackend	yosys/backends/firrtl/firrtl.cc	/^	FirrtlBackend() : Backend("firrtl", "write design to a FIRRTL file") { }$/;"	f	struct:FirrtlBackend	file:
FirrtlBackend	yosys/backends/firrtl/firrtl.cc	/^struct FirrtlBackend : public Backend {$/;"	s	file:
FirrtlBackend	yosys/backends/firrtl/firrtl.cc	/^} FirrtlBackend;$/;"	v	typeref:struct:FirrtlBackend
FirrtlWorker	yosys/backends/firrtl/firrtl.cc	/^	FirrtlWorker(Module *module, std::ostream &f, RTLIL::Design *theDesign) : module(module), f(f),/;"	f	struct:FirrtlWorker	file:
FirrtlWorker	yosys/backends/firrtl/firrtl.cc	/^struct FirrtlWorker$/;"	s	file:
FlattenPass	yosys/passes/techmap/flatten.cc	/^	FlattenPass() : Pass("flatten", "flatten design") { }$/;"	f	struct:FlattenPass	file:
FlattenPass	yosys/passes/techmap/flatten.cc	/^struct FlattenPass : public Pass {$/;"	s	file:
FlattenPass	yosys/passes/techmap/flatten.cc	/^} FlattenPass;$/;"	v	typeref:struct:FlattenPass
FlattenWorker	yosys/passes/techmap/flatten.cc	/^struct FlattenWorker$/;"	s	file:
FlowGraph	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^struct FlowGraph {$/;"	s	file:
FlowGraph	yosys/passes/techmap/flowmap.cc	/^struct FlowGraph$/;"	s	file:
FlowmapPass	yosys/passes/techmap/flowmap.cc	/^	FlowmapPass() : Pass("flowmap", "pack LUTs with FlowMap") { }$/;"	f	struct:FlowmapPass	file:
FlowmapPass	yosys/passes/techmap/flowmap.cc	/^struct FlowmapPass : public Pass {$/;"	s	file:
FlowmapPass	yosys/passes/techmap/flowmap.cc	/^} FlowmapPass;$/;"	v	typeref:struct:FlowmapPass
FlowmapWorker	yosys/passes/techmap/flowmap.cc	/^	FlowmapWorker(int order, int minlut, pool<IdString> cell_types, int r_alpha, int r_beta, int r_/;"	f	struct:FlowmapWorker	file:
FlowmapWorker	yosys/passes/techmap/flowmap.cc	/^struct FlowmapWorker$/;"	s	file:
FmcombinePass	yosys/passes/sat/fmcombine.cc	/^	FmcombinePass() : Pass("fmcombine", "combine two instances of a cell into one") { }$/;"	f	struct:FmcombinePass	file:
FmcombinePass	yosys/passes/sat/fmcombine.cc	/^struct FmcombinePass : public Pass {$/;"	s	file:
FmcombinePass	yosys/passes/sat/fmcombine.cc	/^} FmcombinePass;$/;"	v	typeref:struct:FmcombinePass
FmcombineWorker	yosys/passes/sat/fmcombine.cc	/^	FmcombineWorker(Design *design, IdString orig_type, const opts_t &opts) :$/;"	f	struct:FmcombineWorker	file:
FmcombineWorker	yosys/passes/sat/fmcombine.cc	/^struct FmcombineWorker$/;"	s	file:
FminitPass	yosys/passes/sat/fminit.cc	/^	FminitPass() : Pass("fminit", "set init values\/sequences for formal") { }$/;"	f	struct:FminitPass	file:
FminitPass	yosys/passes/sat/fminit.cc	/^struct FminitPass : public Pass {$/;"	s	file:
FminitPass	yosys/passes/sat/fminit.cc	/^} FminitPass;$/;"	v	typeref:struct:FminitPass
FreducePass	yosys/passes/sat/freduce.cc	/^	FreducePass() : Pass("freduce", "perform functional reduction") { }$/;"	f	struct:FreducePass	file:
FreducePass	yosys/passes/sat/freduce.cc	/^struct FreducePass : public Pass {$/;"	s	file:
FreducePass	yosys/passes/sat/freduce.cc	/^} FreducePass;$/;"	v	typeref:struct:FreducePass
FreduceWorker	yosys/passes/sat/freduce.cc	/^	FreduceWorker(RTLIL::Design *design, RTLIL::Module *module) : design(design), module(module), s/;"	f	struct:FreduceWorker	file:
FreduceWorker	yosys/passes/sat/freduce.cc	/^struct FreduceWorker$/;"	s	file:
Frontend	yosys/kernel/register.cc	/^Frontend::Frontend(std::string name, std::string short_help) :$/;"	f	class:Frontend
Frontend	yosys/kernel/register.h	/^struct Frontend : Pass$/;"	s
FsmData	yosys/passes/fsm/fsmdata.h	/^struct FsmData$/;"	s
FsmDetectPass	yosys/passes/fsm/fsm_detect.cc	/^	FsmDetectPass() : Pass("fsm_detect", "finding FSMs in design") { }$/;"	f	struct:FsmDetectPass	file:
FsmDetectPass	yosys/passes/fsm/fsm_detect.cc	/^struct FsmDetectPass : public Pass {$/;"	s	file:
FsmDetectPass	yosys/passes/fsm/fsm_detect.cc	/^} FsmDetectPass;$/;"	v	typeref:struct:FsmDetectPass
FsmExpand	yosys/passes/fsm/fsm_expand.cc	/^	FsmExpand(RTLIL::Cell *cell, RTLIL::Design *design, RTLIL::Module *mod, bool full)$/;"	f	struct:FsmExpand	file:
FsmExpand	yosys/passes/fsm/fsm_expand.cc	/^struct FsmExpand$/;"	s	file:
FsmExpandPass	yosys/passes/fsm/fsm_expand.cc	/^	FsmExpandPass() : Pass("fsm_expand", "expand FSM cells by merging logic into it") { }$/;"	f	struct:FsmExpandPass	file:
FsmExpandPass	yosys/passes/fsm/fsm_expand.cc	/^struct FsmExpandPass : public Pass {$/;"	s	file:
FsmExpandPass	yosys/passes/fsm/fsm_expand.cc	/^} FsmExpandPass;$/;"	v	typeref:struct:FsmExpandPass
FsmExportPass	yosys/passes/fsm/fsm_export.cc	/^	FsmExportPass() : Pass("fsm_export", "exporting FSMs to KISS2 files") { }$/;"	f	struct:FsmExportPass	file:
FsmExportPass	yosys/passes/fsm/fsm_export.cc	/^struct FsmExportPass : public Pass {$/;"	s	file:
FsmExportPass	yosys/passes/fsm/fsm_export.cc	/^} FsmExportPass;$/;"	v	typeref:struct:FsmExportPass
FsmExtractPass	yosys/passes/fsm/fsm_extract.cc	/^	FsmExtractPass() : Pass("fsm_extract", "extracting FSMs in design") { }$/;"	f	struct:FsmExtractPass	file:
FsmExtractPass	yosys/passes/fsm/fsm_extract.cc	/^struct FsmExtractPass : public Pass {$/;"	s	file:
FsmExtractPass	yosys/passes/fsm/fsm_extract.cc	/^} FsmExtractPass;$/;"	v	typeref:struct:FsmExtractPass
FsmInfoPass	yosys/passes/fsm/fsm_info.cc	/^	FsmInfoPass() : Pass("fsm_info", "print information on finite state machines") { }$/;"	f	struct:FsmInfoPass	file:
FsmInfoPass	yosys/passes/fsm/fsm_info.cc	/^struct FsmInfoPass : public Pass {$/;"	s	file:
FsmInfoPass	yosys/passes/fsm/fsm_info.cc	/^} FsmInfoPass;$/;"	v	typeref:struct:FsmInfoPass
FsmMapPass	yosys/passes/fsm/fsm_map.cc	/^	FsmMapPass() : Pass("fsm_map", "mapping FSMs to basic logic") { }$/;"	f	struct:FsmMapPass	file:
FsmMapPass	yosys/passes/fsm/fsm_map.cc	/^struct FsmMapPass : public Pass {$/;"	s	file:
FsmMapPass	yosys/passes/fsm/fsm_map.cc	/^} FsmMapPass;$/;"	v	typeref:struct:FsmMapPass
FsmOpt	yosys/passes/fsm/fsm_opt.cc	/^	FsmOpt(RTLIL::Cell *cell, RTLIL::Module *module)$/;"	f	struct:FsmOpt	file:
FsmOpt	yosys/passes/fsm/fsm_opt.cc	/^struct FsmOpt$/;"	s	file:
FsmOptPass	yosys/passes/fsm/fsm_opt.cc	/^	FsmOptPass() : Pass("fsm_opt", "optimize finite state machines") { }$/;"	f	struct:FsmOptPass	file:
FsmOptPass	yosys/passes/fsm/fsm_opt.cc	/^struct FsmOptPass : public Pass {$/;"	s	file:
FsmOptPass	yosys/passes/fsm/fsm_opt.cc	/^} FsmOptPass;$/;"	v	typeref:struct:FsmOptPass
FsmPass	yosys/passes/fsm/fsm.cc	/^	FsmPass() : Pass("fsm", "extract and optimize finite state machines") { }$/;"	f	struct:FsmPass	file:
FsmPass	yosys/passes/fsm/fsm.cc	/^struct FsmPass : public Pass {$/;"	s	file:
FsmPass	yosys/passes/fsm/fsm.cc	/^} FsmPass;$/;"	v	typeref:struct:FsmPass
FsmRecodePass	yosys/passes/fsm/fsm_recode.cc	/^	FsmRecodePass() : Pass("fsm_recode", "recoding finite state machines") { }$/;"	f	struct:FsmRecodePass	file:
FsmRecodePass	yosys/passes/fsm/fsm_recode.cc	/^struct FsmRecodePass : public Pass {$/;"	s	file:
FsmRecodePass	yosys/passes/fsm/fsm_recode.cc	/^} FsmRecodePass;$/;"	v	typeref:struct:FsmRecodePass
Fst2TbPass	yosys/passes/sat/sim.cc	/^	Fst2TbPass() : Pass("fst2tb", "generate testbench out of fst file") { }$/;"	f	struct:Fst2TbPass	file:
Fst2TbPass	yosys/passes/sat/sim.cc	/^struct Fst2TbPass : public Pass {$/;"	s	file:
Fst2TbPass	yosys/passes/sat/sim.cc	/^} Fst2TbPass;$/;"	v	typeref:struct:Fst2TbPass
FstData	yosys/kernel/fstdata.cc	/^FstData::FstData(std::string filename) : ctx(nullptr)$/;"	f	class:FstData
FstData	yosys/kernel/fstdata.h	/^class FstData$/;"	c
FstVar	yosys/kernel/fstdata.h	/^struct FstVar$/;"	s
FullyDefinedPool	yosys/passes/proc/proc_rmdead.cc	/^	FullyDefinedPool(const RTLIL::SigSpec &signal)$/;"	f	struct:FullyDefinedPool	file:
FullyDefinedPool	yosys/passes/proc/proc_rmdead.cc	/^struct FullyDefinedPool$/;"	s	file:
FwdCellEdgesDatabase	yosys/kernel/celledges.h	/^	FwdCellEdgesDatabase(SigMap &sigmap) : sigmap(sigmap) { }$/;"	f	struct:FwdCellEdgesDatabase
FwdCellEdgesDatabase	yosys/kernel/celledges.h	/^struct FwdCellEdgesDatabase : AbstractCellEdgesDatabase$/;"	s
G	yosys/passes/techmap/abc.cc	/^#define G(/;"	d	file:
GB	yosys/libs/fst/lz4.cc	/^#define GB /;"	d	file:
GENERATE_PATTERN	yosys/passes/pmgen/generate.h	/^#define GENERATE_PATTERN(/;"	d
GENFILES	yosys/Makefile	/^GENFILES =$/;"	m
GHDL_INCLUDE_DIR	yosys/Makefile	/^GHDL_INCLUDE_DIR ?= $(GHDL_PREFIX)\/include$/;"	m
GHDL_LIB_DIR	yosys/Makefile	/^GHDL_LIB_DIR ?= $(GHDL_PREFIX)\/lib$/;"	m
GHDL_PREFIX	yosys/Makefile	/^GHDL_PREFIX ?= $(PREFIX)$/;"	m
GRP_CONST_A	yosys/passes/opt/opt_expr.cc	/^	enum { GRP_DYN, GRP_CONST_A, GRP_CONST_B, GRP_CONST_AB, GRP_N };$/;"	e	enum:group_cell_inputs::__anon438a1a400103	file:
GRP_CONST_AB	yosys/passes/opt/opt_expr.cc	/^	enum { GRP_DYN, GRP_CONST_A, GRP_CONST_B, GRP_CONST_AB, GRP_N };$/;"	e	enum:group_cell_inputs::__anon438a1a400103	file:
GRP_CONST_B	yosys/passes/opt/opt_expr.cc	/^	enum { GRP_DYN, GRP_CONST_A, GRP_CONST_B, GRP_CONST_AB, GRP_N };$/;"	e	enum:group_cell_inputs::__anon438a1a400103	file:
GRP_DYN	yosys/passes/opt/opt_expr.cc	/^	enum { GRP_DYN, GRP_CONST_A, GRP_CONST_B, GRP_CONST_AB, GRP_N };$/;"	e	enum:group_cell_inputs::__anon438a1a400103	file:
GRP_N	yosys/passes/opt/opt_expr.cc	/^	enum { GRP_DYN, GRP_CONST_A, GRP_CONST_B, GRP_CONST_AB, GRP_N };$/;"	e	enum:group_cell_inputs::__anon438a1a400103	file:
GTESTFLAG	yosys/tests/unit/Makefile	/^GTESTFLAG := -lgtest -lgtest_main$/;"	m
GZ_BUFFER_SIZE	yosys/kernel/register.cc	/^#define GZ_BUFFER_SIZE /;"	d	file:
G_AND	yosys/passes/techmap/abc.cc	/^	G_AND,$/;"	e	enum:gate_type_t	file:
G_ANDNOT	yosys/passes/techmap/abc.cc	/^	G_ANDNOT,$/;"	e	enum:gate_type_t	file:
G_AOI3	yosys/passes/techmap/abc.cc	/^	G_AOI3,$/;"	e	enum:gate_type_t	file:
G_AOI4	yosys/passes/techmap/abc.cc	/^	G_AOI4,$/;"	e	enum:gate_type_t	file:
G_BUF	yosys/passes/techmap/abc.cc	/^	G_BUF,$/;"	e	enum:gate_type_t	file:
G_FF	yosys/passes/techmap/abc.cc	/^	G_FF,$/;"	e	enum:gate_type_t	file:
G_FF0	yosys/passes/techmap/abc.cc	/^	G_FF0,$/;"	e	enum:gate_type_t	file:
G_FF1	yosys/passes/techmap/abc.cc	/^	G_FF1,$/;"	e	enum:gate_type_t	file:
G_MUX	yosys/passes/techmap/abc.cc	/^	G_MUX,$/;"	e	enum:gate_type_t	file:
G_NAND	yosys/passes/techmap/abc.cc	/^	G_NAND,$/;"	e	enum:gate_type_t	file:
G_NMUX	yosys/passes/techmap/abc.cc	/^	G_NMUX,$/;"	e	enum:gate_type_t	file:
G_NONE	yosys/passes/techmap/abc.cc	/^	G_NONE,$/;"	e	enum:gate_type_t	file:
G_NOR	yosys/passes/techmap/abc.cc	/^	G_NOR,$/;"	e	enum:gate_type_t	file:
G_NOT	yosys/passes/techmap/abc.cc	/^	G_NOT,$/;"	e	enum:gate_type_t	file:
G_OAI3	yosys/passes/techmap/abc.cc	/^	G_OAI3,$/;"	e	enum:gate_type_t	file:
G_OAI4	yosys/passes/techmap/abc.cc	/^	G_OAI4$/;"	e	enum:gate_type_t	file:
G_OR	yosys/passes/techmap/abc.cc	/^	G_OR,$/;"	e	enum:gate_type_t	file:
G_ORNOT	yosys/passes/techmap/abc.cc	/^	G_ORNOT,$/;"	e	enum:gate_type_t	file:
G_XNOR	yosys/passes/techmap/abc.cc	/^	G_XNOR,$/;"	e	enum:gate_type_t	file:
G_XOR	yosys/passes/techmap/abc.cc	/^	G_XOR,$/;"	e	enum:gate_type_t	file:
GateType	yosys/passes/techmap/extract_reduce.cc	/^	enum GateType {$/;"	g	struct:ExtractReducePass	file:
GetSize	yosys/kernel/yosys.cc	/^int GetSize(RTLIL::Wire *wire)$/;"	f	typeref:typename:int
GetSize	yosys/kernel/yosys.h	/^template<typename T> int GetSize(const T &obj) { return obj.size(); }$/;"	f	typeref:typename:int
GliftPass	yosys/passes/cmds/glift.cc	/^	GliftPass() : Pass("glift", "create GLIFT models and optimization problems") {}$/;"	f	struct:GliftPass	file:
GliftPass	yosys/passes/cmds/glift.cc	/^struct GliftPass : public Pass {$/;"	s	file:
GliftPass	yosys/passes/cmds/glift.cc	/^} GliftPass;$/;"	v	typeref:struct:GliftPass
GliftWorker	yosys/passes/cmds/glift.cc	/^	GliftWorker(RTLIL::Module *_module, bool _is_top_module, bool _opt_create_precise_model, bool _/;"	f	struct:GliftWorker	file:
GliftWorker	yosys/passes/cmds/glift.cc	/^struct GliftWorker {$/;"	s	file:
Graph	yosys/libs/subcircuit/subcircuit.cc	/^SubCircuit::Graph::Graph(const Graph &other, const std::vector<std::string> &otherNodes)$/;"	f	class:SubCircuit::Graph
Graph	yosys/libs/subcircuit/subcircuit.h	/^		Graph() : allExtern(false) { };$/;"	f	class:SubCircuit::Graph
Graph	yosys/libs/subcircuit/subcircuit.h	/^	class Graph$/;"	c	namespace:SubCircuit
GraphData	yosys/libs/subcircuit/subcircuit.cc	/^	struct GraphData {$/;"	s	class:SubCircuit::SolverWorker	file:
GraphMode	yosys/passes/techmap/flowmap.cc	/^	enum class GraphMode {$/;"	g	struct:FlowmapWorker	file:
GraphStyle	yosys/passes/techmap/flowmap.cc	/^	GraphStyle(string label = "", string color = "black", string fillcolor = "") :$/;"	f	struct:GraphStyle	file:
GraphStyle	yosys/passes/techmap/flowmap.cc	/^struct GraphStyle$/;"	s	file:
Greenpak4DffInvPass	yosys/techlibs/greenpak4/greenpak4_dffinv.cc	/^	Greenpak4DffInvPass() : Pass("greenpak4_dffinv", "merge greenpak4 inverters and DFF\/latches") /;"	f	struct:Greenpak4DffInvPass	file:
Greenpak4DffInvPass	yosys/techlibs/greenpak4/greenpak4_dffinv.cc	/^struct Greenpak4DffInvPass : public Pass {$/;"	s	file:
Greenpak4DffInvPass	yosys/techlibs/greenpak4/greenpak4_dffinv.cc	/^} Greenpak4DffInvPass;$/;"	v	typeref:struct:Greenpak4DffInvPass
HANDLE_BINOP	yosys/backends/verilog/verilog_backend.cc	/^#define HANDLE_BINOP(/;"	d	file:
HANDLE_CELL_TYPE	yosys/kernel/celltypes.h	/^#define HANDLE_CELL_TYPE(/;"	d
HANDLE_UNIOP	yosys/backends/verilog/verilog_backend.cc	/^#define HANDLE_UNIOP(/;"	d	file:
HASHLIB_H	yosys/kernel/hashlib.h	/^#define HASHLIB_H$/;"	d
HASHTABLESIZE	yosys/libs/fst/lz4.cc	/^#define HASHTABLESIZE /;"	d	file:
HASH_FUNCTION	yosys/libs/fst/fastlz.cc	/^#define HASH_FUNCTION(/;"	d	file:
HASH_LOG	yosys/libs/fst/fastlz.cc	/^#define HASH_LOG /;"	d	file:
HASH_MASK	yosys/libs/fst/fastlz.cc	/^#define HASH_MASK /;"	d	file:
HASH_SIZE	yosys/libs/fst/fastlz.cc	/^#define HASH_SIZE /;"	d	file:
HASH_SIZE_U32	yosys/libs/fst/lz4.cc	/^#define HASH_SIZE_U32 /;"	d	file:
HASH_UNIT	yosys/libs/fst/lz4.cc	/^#define HASH_UNIT /;"	d	file:
HAS_ALARM	yosys/libs/ezsat/ezminisat.cc	/^#  define HAS_ALARM$/;"	d	file:
HAVE_ALLOCA_H	yosys/libs/fst/config.h	/^#define HAVE_ALLOCA_H /;"	d
HAVE_FSEEKO	yosys/libs/fst/config.h	/^#define HAVE_FSEEKO /;"	d
HAVE_LIBPTHREAD	yosys/libs/fst/config.h	/^#define HAVE_LIBPTHREAD /;"	d
HAVE_REALPATH	yosys/libs/fst/config.h	/^#define HAVE_REALPATH /;"	d
HEAPMODE	yosys/libs/fst/lz4.cc	/^#define HEAPMODE /;"	d	file:
HandleRpcServer	yosys/frontends/rpc/rpc_frontend.cc	/^	HandleRpcServer(const std::string &name, HANDLE hsend, HANDLE hrecv)$/;"	f	struct:HandleRpcServer	file:
HandleRpcServer	yosys/frontends/rpc/rpc_frontend.cc	/^struct HandleRpcServer : RpcServer {$/;"	s	file:
Hash	yosys/libs/minisat/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return ha/;"	s	namespace:Minisat
HashTable	yosys/libs/minisat/SolverTypes.h	/^    typedef Map<CRef, T, CRefHash> HashTable;$/;"	t	class:Minisat::CMap	typeref:typename:Map<CRef,T,CRefHash>
Heap	yosys/libs/minisat/Heap.h	/^    Heap(const Comp& c, MkIndex _index = MkIndex()) : indices(_index), lt(c) {}$/;"	f	class:Minisat::Heap
Heap	yosys/libs/minisat/Heap.h	/^class Heap {$/;"	c	namespace:Minisat
HelpPass	yosys/kernel/register.cc	/^	HelpPass() : Pass("help", "display help messages") { }$/;"	f	struct:HelpPass	file:
HelpPass	yosys/kernel/register.cc	/^struct HelpPass : public Pass {$/;"	s	file:
HelpPass	yosys/kernel/register.cc	/^} HelpPass;$/;"	v	typeref:struct:HelpPass
HierDirtyFlags	yosys/backends/simplec/simplec.cc	/^	HierDirtyFlags(Module *module, IdString hiername, HierDirtyFlags *parent, const string &prefix,/;"	f	struct:HierDirtyFlags	file:
HierDirtyFlags	yosys/backends/simplec/simplec.cc	/^struct HierDirtyFlags$/;"	s	file:
HierarchyPass	yosys/passes/hierarchy/hierarchy.cc	/^	HierarchyPass() : Pass("hierarchy", "check, expand and clean up design hierarchy") { }$/;"	f	struct:HierarchyPass	file:
HierarchyPass	yosys/passes/hierarchy/hierarchy.cc	/^struct HierarchyPass : public Pass {$/;"	s	file:
HierarchyPass	yosys/passes/hierarchy/hierarchy.cc	/^} HierarchyPass;$/;"	v	typeref:struct:HierarchyPass
HilomapPass	yosys/passes/techmap/hilomap.cc	/^	HilomapPass() : Pass("hilomap", "technology mapping of constant hi- and\/or lo-drivers") { }$/;"	f	struct:HilomapPass	file:
HilomapPass	yosys/passes/techmap/hilomap.cc	/^struct HilomapPass : public Pass {$/;"	s	file:
HilomapPass	yosys/passes/techmap/hilomap.cc	/^} HilomapPass;$/;"	v	typeref:struct:HilomapPass
HistoryPass	yosys/kernel/yosys.cc	/^	HistoryPass() : Pass("history", "show last interactive commands") { }$/;"	f	struct:HistoryPass	file:
HistoryPass	yosys/kernel/yosys.cc	/^struct HistoryPass : public Pass {$/;"	s	file:
HistoryPass	yosys/kernel/yosys.cc	/^} HistoryPass;$/;"	v	typeref:struct:HistoryPass
I	yosys/frontends/aiger/aigerparse.h	/^    unsigned M, I, L, O, A;$/;"	m	struct:AigerReader	typeref:typename:unsigned
ID	yosys/kernel/rtlil.h	/^	namespace ID {$/;"	n	namespace:RTLIL
ID	yosys/kernel/yosys.h	/^#define ID(/;"	d
IFExpander	yosys/passes/hierarchy/hierarchy.cc	/^	IFExpander (RTLIL::Design &design, RTLIL::Module &m)$/;"	f	struct:IFExpander	file:
IFExpander	yosys/passes/hierarchy/hierarchy.cc	/^struct IFExpander$/;"	s	file:
IFF	yosys/libs/ezsat/ezsat.h	/^	int IFF(_V a, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {$/;"	f	class:ezSAT	typeref:typename:int
IN	yosys/frontends/verific/verific.cc	/^	#define IN /;"	d	file:
IN1	yosys/frontends/verific/verific.cc	/^	#define IN1 /;"	d	file:
IN2	yosys/frontends/verific/verific.cc	/^	#define IN2 /;"	d	file:
INIT_0	yosys/passes/techmap/dfflegalize.cc	/^	INIT_0 = 0x2,$/;"	e	enum:FfInit	file:
INIT_0_R0	yosys/passes/techmap/dfflegalize.cc	/^	INIT_0_R0 = 0x20,$/;"	e	enum:FfInit	file:
INIT_0_R1	yosys/passes/techmap/dfflegalize.cc	/^	INIT_0_R1 = 0x200,$/;"	e	enum:FfInit	file:
INIT_1	yosys/passes/techmap/dfflegalize.cc	/^	INIT_1 = 0x4,$/;"	e	enum:FfInit	file:
INIT_1_R0	yosys/passes/techmap/dfflegalize.cc	/^	INIT_1_R0 = 0x40,$/;"	e	enum:FfInit	file:
INIT_1_R1	yosys/passes/techmap/dfflegalize.cc	/^	INIT_1_R1 = 0x400,$/;"	e	enum:FfInit	file:
INIT_MODULE	yosys/kernel/yosys.cc	/^#   define INIT_MODULE /;"	d	file:
INIT_W	yosys/libs/ezsat/demo_cmp.cc	/^#define INIT_W /;"	d	file:
INIT_W	yosys/libs/ezsat/demo_vec.cc	/^#define INIT_W /;"	d	file:
INIT_X	yosys/libs/ezsat/demo_cmp.cc	/^#define INIT_X /;"	d	file:
INIT_X	yosys/libs/ezsat/demo_vec.cc	/^#define INIT_X /;"	d	file:
INIT_X	yosys/passes/techmap/dfflegalize.cc	/^	INIT_X = 0x1,$/;"	e	enum:FfInit	file:
INIT_X_R0	yosys/passes/techmap/dfflegalize.cc	/^	INIT_X_R0 = 0x10,$/;"	e	enum:FfInit	file:
INIT_X_R1	yosys/passes/techmap/dfflegalize.cc	/^	INIT_X_R1 = 0x100,$/;"	e	enum:FfInit	file:
INIT_Y	yosys/libs/ezsat/demo_cmp.cc	/^#define INIT_Y /;"	d	file:
INIT_Y	yosys/libs/ezsat/demo_vec.cc	/^#define INIT_Y /;"	d	file:
INIT_Z	yosys/libs/ezsat/demo_cmp.cc	/^#define INIT_Z /;"	d	file:
INIT_Z	yosys/libs/ezsat/demo_vec.cc	/^#define INIT_Z /;"	d	file:
INLINE	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		INLINE,$/;"	e	enum:WireType::Type	file:
INOUT	yosys/backends/cxxrtl/cxxrtl.h	/^		INOUT  = CXXRTL_INOUT,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40403
INPUT	yosys/backends/cxxrtl/cxxrtl.h	/^		INPUT  = CXXRTL_INPUT,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40403
INSTALL_SUDO	yosys/Makefile	/^INSTALL_SUDO :=$/;"	m
ITE	yosys/libs/ezsat/ezsat.h	/^	int ITE(_V a, _V b, _V c) {$/;"	f	class:ezSAT	typeref:typename:int
Ice40BRAMInitPass	yosys/techlibs/ice40/ice40_braminit.cc	/^	Ice40BRAMInitPass() : Pass("ice40_braminit", "iCE40: perform SB_RAM40_4K initialization from fi/;"	f	struct:Ice40BRAMInitPass	file:
Ice40BRAMInitPass	yosys/techlibs/ice40/ice40_braminit.cc	/^struct Ice40BRAMInitPass : public Pass {$/;"	s	file:
Ice40BRAMInitPass	yosys/techlibs/ice40/ice40_braminit.cc	/^} Ice40BRAMInitPass;$/;"	v	typeref:struct:Ice40BRAMInitPass
Ice40DspPass	yosys/passes/pmgen/ice40_dsp.cc	/^	Ice40DspPass() : Pass("ice40_dsp", "iCE40: map multipliers") { }$/;"	f	struct:Ice40DspPass	file:
Ice40DspPass	yosys/passes/pmgen/ice40_dsp.cc	/^struct Ice40DspPass : public Pass {$/;"	s	file:
Ice40DspPass	yosys/passes/pmgen/ice40_dsp.cc	/^} Ice40DspPass;$/;"	v	typeref:struct:Ice40DspPass
Ice40OptPass	yosys/techlibs/ice40/ice40_opt.cc	/^	Ice40OptPass() : Pass("ice40_opt", "iCE40: perform simple optimizations") { }$/;"	f	struct:Ice40OptPass	file:
Ice40OptPass	yosys/techlibs/ice40/ice40_opt.cc	/^struct Ice40OptPass : public Pass {$/;"	s	file:
Ice40OptPass	yosys/techlibs/ice40/ice40_opt.cc	/^} Ice40OptPass;$/;"	v	typeref:struct:Ice40OptPass
Ice40WrapCarryPass	yosys/passes/pmgen/ice40_wrapcarry.cc	/^	Ice40WrapCarryPass() : Pass("ice40_wrapcarry", "iCE40: wrap carries") { }$/;"	f	struct:Ice40WrapCarryPass	file:
Ice40WrapCarryPass	yosys/passes/pmgen/ice40_wrapcarry.cc	/^struct Ice40WrapCarryPass : public Pass {$/;"	s	file:
Ice40WrapCarryPass	yosys/passes/pmgen/ice40_wrapcarry.cc	/^} Ice40WrapCarryPass;$/;"	v	typeref:struct:Ice40WrapCarryPass
IdString	yosys/kernel/rtlil.h	/^		inline IdString() : index_(0) { }$/;"	f	struct:RTLIL::IdString
IdString	yosys/kernel/rtlil.h	/^		inline IdString(IdString &&str) : index_(str.index_) { str.index_ = 0; }$/;"	f	struct:RTLIL::IdString
IdString	yosys/kernel/rtlil.h	/^		inline IdString(const IdString &str) : index_(get_reference(str.index_)) { }$/;"	f	struct:RTLIL::IdString
IdString	yosys/kernel/rtlil.h	/^		inline IdString(const char *str) : index_(get_reference(str)) { }$/;"	f	struct:RTLIL::IdString
IdString	yosys/kernel/rtlil.h	/^		inline IdString(const std::string &str) : index_(get_reference(str.c_str())) { }$/;"	f	struct:RTLIL::IdString
IdString	yosys/kernel/rtlil.h	/^	struct IdString$/;"	s	namespace:RTLIL
IdentUsage	yosys/frontends/ast/simplify.cc	/^enum class IdentUsage {$/;"	g	file:
IlangBackend	yosys/backends/rtlil/rtlil_backend.cc	/^	IlangBackend() : Backend("ilang", "(deprecated) alias of write_rtlil") { }$/;"	f	struct:IlangBackend	file:
IlangBackend	yosys/backends/rtlil/rtlil_backend.cc	/^struct IlangBackend : public Backend {$/;"	s	file:
IlangBackend	yosys/backends/rtlil/rtlil_backend.cc	/^} IlangBackend;$/;"	v	typeref:struct:IlangBackend
IlangFrontend	yosys/frontends/rtlil/rtlil_frontend.cc	/^	IlangFrontend() : Frontend("ilang", "(deprecated) alias of read_rtlil") { }$/;"	f	struct:IlangFrontend	file:
IlangFrontend	yosys/frontends/rtlil/rtlil_frontend.cc	/^struct IlangFrontend : public Frontend {$/;"	s	file:
IlangFrontend	yosys/frontends/rtlil/rtlil_frontend.cc	/^} IlangFrontend;$/;"	v	typeref:struct:IlangFrontend
Index	yosys/libs/bigint/BigInteger.hh	/^	typedef BigUnsigned::Index Index;$/;"	t	class:BigInteger	typeref:typename:BigUnsigned::Index
Index	yosys/libs/bigint/BigUnsigned.hh	/^	typedef NumberlikeArray<Blk>::Index Index;$/;"	t	class:BigUnsigned	typeref:typename:NumberlikeArray<Blk>::Index
Index	yosys/libs/bigint/NumberlikeArray.hh	/^	typedef unsigned int Index;$/;"	t	class:NumberlikeArray	typeref:typename:unsigned int
Initstate	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec RTLIL::Module::Initstate(RTLIL::IdString name, const std::string &src)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::SigSpec
InsbufPass	yosys/passes/techmap/insbuf.cc	/^	InsbufPass() : Pass("insbuf", "insert buffer cells for connected wires") { }$/;"	f	struct:InsbufPass	file:
InsbufPass	yosys/passes/techmap/insbuf.cc	/^struct InsbufPass : public Pass {$/;"	s	file:
InsbufPass	yosys/passes/techmap/insbuf.cc	/^} InsbufPass;$/;"	v	typeref:struct:InsbufPass
Int64Option	yosys/libs/minisat/Options.h	/^    Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range/;"	f	class:Minisat::Int64Option
Int64Option	yosys/libs/minisat/Options.h	/^class Int64Option : public Option$/;"	c	namespace:Minisat
Int64Range	yosys/libs/minisat/Options.h	/^    Int64Range(int64_t b, int64_t e) : begin(b), end(e) {}$/;"	f	struct:Minisat::Int64Range
Int64Range	yosys/libs/minisat/Options.h	/^struct Int64Range {$/;"	s	namespace:Minisat
IntMap	yosys/libs/minisat/IntMap.h	/^        explicit IntMap(MkIndex _index = MkIndex()) : index(_index){}$/;"	f	class:Minisat::IntMap
IntMap	yosys/libs/minisat/IntMap.h	/^    class IntMap {$/;"	c	namespace:Minisat
IntOption	yosys/libs/minisat/Options.h	/^    IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r =/;"	f	class:Minisat::IntOption
IntOption	yosys/libs/minisat/Options.h	/^class IntOption : public Option$/;"	c	namespace:Minisat
IntRange	yosys/libs/minisat/Options.h	/^    IntRange(int b, int e) : begin(b), end(e) {}$/;"	f	struct:Minisat::IntRange
IntRange	yosys/libs/minisat/Options.h	/^struct IntRange {$/;"	s	namespace:Minisat
IntSet	yosys/libs/minisat/IntMap.h	/^    class IntSet$/;"	c	namespace:Minisat
InternalCellChecker	yosys/kernel/rtlil.cc	/^		InternalCellChecker(RTLIL::Module *module, RTLIL::Cell *cell) : module(module), cell(cell) { }$/;"	f	struct:__anon3311ba060111::InternalCellChecker	file:
InternalCellChecker	yosys/kernel/rtlil.cc	/^	struct InternalCellChecker$/;"	s	namespace:__anon3311ba060111	file:
IntersynthBackend	yosys/backends/intersynth/intersynth.cc	/^	IntersynthBackend() : Backend("intersynth", "write design to InterSynth netlist file") { }$/;"	f	struct:IntersynthBackend	file:
IntersynthBackend	yosys/backends/intersynth/intersynth.cc	/^struct IntersynthBackend : public Backend {$/;"	s	file:
IntersynthBackend	yosys/backends/intersynth/intersynth.cc	/^} IntersynthBackend;$/;"	v	typeref:struct:IntersynthBackend
IopadmapPass	yosys/passes/techmap/iopadmap.cc	/^	IopadmapPass() : Pass("iopadmap", "technology mapping of i\/o pads (or buffers)") { }$/;"	f	struct:IopadmapPass	file:
IopadmapPass	yosys/passes/techmap/iopadmap.cc	/^struct IopadmapPass : public Pass {$/;"	s	file:
IopadmapPass	yosys/passes/techmap/iopadmap.cc	/^} IopadmapPass;$/;"	v	typeref:struct:IopadmapPass
IsRightType	yosys/passes/techmap/extract_reduce.cc	/^	inline bool IsRightType(Cell* cell, GateType gt)$/;"	f	struct:ExtractReducePass	typeref:typename:bool	file:
J	yosys/frontends/aiger/aigerparse.h	/^    unsigned B, C, J, F; \/\/ Optional in AIGER 1.9$/;"	m	struct:AigerReader	typeref:typename:unsigned
JenkinsFree	yosys/libs/fst/fstapi.cc	/^void JenkinsFree(void *base_i, uint32_t hashmask)$/;"	f	typeref:typename:void
JenkinsIns	yosys/libs/fst/fstapi.cc	/^void **JenkinsIns(void *base_i, const unsigned char *mem, uint32_t length, uint32_t hashmask)$/;"	f	typeref:typename:void **
JnyBackend	yosys/backends/jny/jny.cc	/^    JnyBackend() : Backend("jny", "generate design metadata") { }$/;"	f	struct:JnyBackend	file:
JnyBackend	yosys/backends/jny/jny.cc	/^struct JnyBackend : public Backend {$/;"	s	file:
JnyBackend	yosys/backends/jny/jny.cc	/^} JnyBackend;$/;"	v	typeref:struct:JnyBackend
JnyPass	yosys/backends/jny/jny.cc	/^    JnyPass() : Pass("jny", "write design and metadata") { }$/;"	f	struct:JnyPass	file:
JnyPass	yosys/backends/jny/jny.cc	/^struct JnyPass : public Pass {$/;"	s	file:
JnyPass	yosys/backends/jny/jny.cc	/^} JnyPass;$/;"	v	typeref:struct:JnyPass
JnyWriter	yosys/backends/jny/jny.cc	/^    JnyWriter(std::ostream &f, bool use_selection, bool connections, bool attributes, bool prope/;"	f	struct:JnyWriter	file:
JnyWriter	yosys/backends/jny/jny.cc	/^struct JnyWriter$/;"	s	file:
Json	yosys/libs/json11/json11.cpp	/^Json::Json() noexcept                  : m_ptr(statics().null) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(Json::array &&values)       : m_ptr(make_shared<JsonArray>(move(values))) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(Json::object &&values)      : m_ptr(make_shared<JsonObject>(move(values))) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(bool value)                 : m_ptr(value ? statics().t : statics().f) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(const Json::array &values)  : m_ptr(make_shared<JsonArray>(values)) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(const Json::object &values) : m_ptr(make_shared<JsonObject>(values)) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(const char * value)         : m_ptr(make_shared<JsonString>(value)) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(const string &value)        : m_ptr(make_shared<JsonString>(value)) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(double value)               : m_ptr(make_shared<JsonDouble>(value)) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(int value)                  : m_ptr(make_shared<JsonInt>(value)) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(std::nullptr_t) noexcept    : m_ptr(statics().null) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.cpp	/^Json::Json(string &&value)             : m_ptr(make_shared<JsonString>(move(value))) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.hpp	/^    Json(const M & m) : Json(object(m.begin(), m.end())) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.hpp	/^    Json(const T & t) : Json(t.to_json()) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.hpp	/^    Json(const V & v) : Json(array(v.begin(), v.end())) {}$/;"	f	class:json11::Json
Json	yosys/libs/json11/json11.hpp	/^class Json final {$/;"	c	namespace:json11
JsonArray	yosys/libs/json11/json11.cpp	/^    explicit JsonArray(Json::array &&value)      : Value(move(value)) {}$/;"	f	class:json11::JsonArray	file:
JsonArray	yosys/libs/json11/json11.cpp	/^    explicit JsonArray(const Json::array &value) : Value(value) {}$/;"	f	class:json11::JsonArray	file:
JsonArray	yosys/libs/json11/json11.cpp	/^class JsonArray final : public Value<Json::ARRAY, Json::array> {$/;"	c	namespace:json11	file:
JsonBackend	yosys/backends/json/json.cc	/^	JsonBackend() : Backend("json", "write design to a JSON file") { }$/;"	f	struct:JsonBackend	file:
JsonBackend	yosys/backends/json/json.cc	/^struct JsonBackend : public Backend {$/;"	s	file:
JsonBackend	yosys/backends/json/json.cc	/^} JsonBackend;$/;"	v	typeref:struct:JsonBackend
JsonBoolean	yosys/libs/json11/json11.cpp	/^    explicit JsonBoolean(bool value) : Value(value) {}$/;"	f	class:json11::JsonBoolean	file:
JsonBoolean	yosys/libs/json11/json11.cpp	/^class JsonBoolean final : public Value<Json::BOOL, bool> {$/;"	c	namespace:json11	file:
JsonDouble	yosys/libs/json11/json11.cpp	/^    explicit JsonDouble(double value) : Value(value) {}$/;"	f	class:json11::JsonDouble	file:
JsonDouble	yosys/libs/json11/json11.cpp	/^class JsonDouble final : public Value<Json::NUMBER, double> {$/;"	c	namespace:json11	file:
JsonFrontend	yosys/frontends/json/jsonparse.cc	/^	JsonFrontend() : Frontend("json", "read JSON file") { }$/;"	f	struct:JsonFrontend	file:
JsonFrontend	yosys/frontends/json/jsonparse.cc	/^struct JsonFrontend : public Frontend {$/;"	s	file:
JsonFrontend	yosys/frontends/json/jsonparse.cc	/^} JsonFrontend;$/;"	v	typeref:struct:JsonFrontend
JsonInt	yosys/libs/json11/json11.cpp	/^    explicit JsonInt(int value) : Value(value) {}$/;"	f	class:json11::JsonInt	file:
JsonInt	yosys/libs/json11/json11.cpp	/^class JsonInt final : public Value<Json::NUMBER, int> {$/;"	c	namespace:json11	file:
JsonNode	yosys/frontends/json/jsonparse.cc	/^	JsonNode(std::istream &f)$/;"	f	struct:JsonNode	file:
JsonNode	yosys/frontends/json/jsonparse.cc	/^struct JsonNode$/;"	s	file:
JsonNull	yosys/libs/json11/json11.cpp	/^    JsonNull() : Value({}) {}$/;"	f	class:json11::JsonNull	file:
JsonNull	yosys/libs/json11/json11.cpp	/^class JsonNull final : public Value<Json::NUL, NullStruct> {$/;"	c	namespace:json11	file:
JsonObject	yosys/libs/json11/json11.cpp	/^    explicit JsonObject(Json::object &&value)      : Value(move(value)) {}$/;"	f	class:json11::JsonObject	file:
JsonObject	yosys/libs/json11/json11.cpp	/^    explicit JsonObject(const Json::object &value) : Value(value) {}$/;"	f	class:json11::JsonObject	file:
JsonObject	yosys/libs/json11/json11.cpp	/^class JsonObject final : public Value<Json::OBJECT, Json::object> {$/;"	c	namespace:json11	file:
JsonParse	yosys/libs/json11/json11.hpp	/^enum JsonParse {$/;"	g	namespace:json11
JsonParser	yosys/libs/json11/json11.cpp	/^struct JsonParser final {$/;"	s	namespace:json11::__anon5ec0faac0111	file:
JsonPass	yosys/backends/json/json.cc	/^	JsonPass() : Pass("json", "write design in JSON format") { }$/;"	f	struct:JsonPass	file:
JsonPass	yosys/backends/json/json.cc	/^struct JsonPass : public Pass {$/;"	s	file:
JsonPass	yosys/backends/json/json.cc	/^} JsonPass;$/;"	v	typeref:struct:JsonPass
JsonString	yosys/libs/json11/json11.cpp	/^    explicit JsonString(const string &value) : Value(value) {}$/;"	f	class:json11::JsonString	file:
JsonString	yosys/libs/json11/json11.cpp	/^    explicit JsonString(string &&value)      : Value(move(value)) {}$/;"	f	class:json11::JsonString	file:
JsonString	yosys/libs/json11/json11.cpp	/^class JsonString final : public Value<Json::STRING, string> {$/;"	c	namespace:json11	file:
JsonValue	yosys/libs/json11/json11.hpp	/^class JsonValue {$/;"	c	namespace:json11
JsonWriter	yosys/backends/json/json.cc	/^	JsonWriter(std::ostream &f, bool use_selection, bool aig_mode, bool compat_int_mode) :$/;"	f	struct:JsonWriter	file:
JsonWriter	yosys/backends/json/json.cc	/^struct JsonWriter$/;"	s	file:
JudyHSFreeArray	yosys/libs/fst/fstapi.cc	/^#define JudyHSFreeArray(/;"	d	file:
JudyHSIns	yosys/libs/fst/fstapi.cc	/^#define JudyHSIns(/;"	d	file:
KB	yosys/libs/fst/lz4.cc	/^#define KB /;"	d	file:
Key	yosys/libs/minisat/Queue.h	/^    typedef T Key;$/;"	t	class:Minisat::Queue	typeref:typename:T
L	yosys/frontends/aiger/aigerparse.h	/^    unsigned M, I, L, O, A;$/;"	m	struct:AigerReader	typeref:typename:unsigned
LASTLITERALS	yosys/libs/fst/lz4.cc	/^#define LASTLITERALS /;"	d	file:
LD	yosys/Makefile	/^LD = $(CXX)$/;"	m
LD	yosys/Makefile	/^LD = $(WASI_SDK)\/bin\/clang++$/;"	m
LD	yosys/Makefile	/^LD = AFL_QUIET=1 AFL_HARDEN=1 afl-gcc$/;"	m
LD	yosys/Makefile	/^LD = clang++$/;"	m
LD	yosys/Makefile	/^LD = emcc$/;"	m
LD	yosys/Makefile	/^LD = gcc$/;"	m
LD	yosys/Makefile	/^LD = gcc-4.8$/;"	m
LDFLAGS	yosys/Makefile	/^LDFLAGS := $(WASIFLAGS) -Wl,-z,stack-size=1048576 $(filter-out -rdynamic,$(LDFLAGS))$/;"	m
LDFLAGS	yosys/Makefile	/^LDFLAGS := $(filter-out -rdynamic,$(LDFLAGS)) -s$/;"	m
LDFLAGS	yosys/Makefile	/^LDFLAGS := $(filter-out -rdynamic,$(LDFLAGS)) -static$/;"	m
LDLIBS	yosys/Makefile	/^LDLIBS := $(LDLIBS) -lstdc++ -lm$/;"	m
LDLIBS	yosys/Makefile	/^LDLIBS := $(filter-out -lrt,$(LDLIBS))$/;"	m
LDLIBS	yosys/Makefile	/^LDLIBS =$/;"	m
LDLIBS	yosys/libs/ezsat/Makefile	/^LDLIBS = ..\/minisat\/Options.cc ..\/minisat\/SimpSolver.cc ..\/minisat\/Solver.cc ..\/minisat\//;"	m
LDLIBS	yosys/libs/subcircuit/Makefile	/^LDLIBS = -lstdc++$/;"	m
LDLIBS_NOVERIFIC	yosys/Makefile	/^LDLIBS_NOVERIFIC = $(LDLIBS)$/;"	m
LDLIBS_NOVERIFIC	yosys/Makefile	/^LDLIBS_NOVERIFIC = $(foreach v,$(LDLIBS),$(if $(findstring $(VERIFIC_DIR),$(v)),,$(v)))$/;"	m
LIBDIR	yosys/Makefile	/^LIBDIR := $(PREFIX)\/lib\/$(PROGRAM_PREFIX)yosys$/;"	m
LIBPARSE_H	yosys/passes/techmap/libparse.h	/^#define LIBPARSE_H$/;"	d
LINK_ABC	yosys/Makefile	/^LINK_ABC := 0$/;"	m
LINK_ABC	yosys/Makefile	/^LINK_ABC := 1$/;"	m
LINK_CURSES	yosys/Makefile	/^LINK_CURSES := 0$/;"	m
LINK_TERMCAP	yosys/Makefile	/^LINK_TERMCAP := 0$/;"	m
LMap	yosys/libs/minisat/SolverTypes.h	/^template<class T> class LMap : public IntMap<Lit, T, MkIndexLit>{};$/;"	c	namespace:Minisat
LOCAL	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		LOCAL,$/;"	e	enum:WireType::Type	file:
LOGICAL_OPS	yosys/passes/opt/opt_share.cc	/^#define LOGICAL_OPS /;"	d	file:
LOG_H	yosys/kernel/log.h	/^#define LOG_H$/;"	d
LOG_OBJECT	yosys/passes/cmds/select.cc	/^		#define LOG_OBJECT(/;"	d	file:
LSet	yosys/libs/minisat/SolverTypes.h	/^class LSet : public IntSet<Lit, MkIndexLit>{};$/;"	c	namespace:Minisat
LZ4_64Klimit	yosys/libs/fst/lz4.cc	/^static const int LZ4_64Klimit = ((64 KB) + (MFLIMIT - 1));$/;"	v	typeref:typename:const int	file:
LZ4_64bits	yosys/libs/fst/lz4.cc	/^static unsigned LZ4_64bits(void) { return sizeof(void *) == 8; }$/;"	f	typeref:typename:unsigned	file:
LZ4_COMPRESSBOUND	yosys/libs/fst/lz4.h	/^#define LZ4_COMPRESSBOUND(/;"	d
LZ4_DEPRECATED	yosys/libs/fst/lz4.h	/^#define LZ4_DEPRECATED(/;"	d
LZ4_DEPRECATE_WARNING_DEFBLOCK	yosys/libs/fst/lz4.h	/^#define LZ4_DEPRECATE_WARNING_DEFBLOCK$/;"	d
LZ4_FORCE_SW_BITCOUNT	yosys/libs/fst/lz4.cc	/^#define LZ4_FORCE_SW_BITCOUNT$/;"	d	file:
LZ4_GCC_VERSION	yosys/libs/fst/lz4.h	/^#define LZ4_GCC_VERSION /;"	d
LZ4_HASHLOG	yosys/libs/fst/lz4.cc	/^#define LZ4_HASHLOG /;"	d	file:
LZ4_MAX_INPUT_SIZE	yosys/libs/fst/lz4.h	/^#define LZ4_MAX_INPUT_SIZE /;"	d
LZ4_MEMORY_USAGE	yosys/libs/fst/lz4.h	/^#define LZ4_MEMORY_USAGE /;"	d
LZ4_NbCommonBytes	yosys/libs/fst/lz4.cc	/^static unsigned LZ4_NbCommonBytes(size_t val)$/;"	f	typeref:typename:unsigned	file:
LZ4_STATIC_ASSERT	yosys/libs/fst/lz4.cc	/^#define LZ4_STATIC_ASSERT(/;"	d	file:
LZ4_STREAMDECODESIZE	yosys/libs/fst/lz4.h	/^#define LZ4_STREAMDECODESIZE /;"	d
LZ4_STREAMDECODESIZE_U64	yosys/libs/fst/lz4.h	/^#define LZ4_STREAMDECODESIZE_U64 /;"	d
LZ4_STREAMSIZE	yosys/libs/fst/lz4.h	/^#define LZ4_STREAMSIZE /;"	d
LZ4_STREAMSIZE_U64	yosys/libs/fst/lz4.h	/^#define LZ4_STREAMSIZE_U64 /;"	d
LZ4_VERSION_MAJOR	yosys/libs/fst/lz4.h	/^#define LZ4_VERSION_MAJOR /;"	d
LZ4_VERSION_MINOR	yosys/libs/fst/lz4.h	/^#define LZ4_VERSION_MINOR /;"	d
LZ4_VERSION_NUMBER	yosys/libs/fst/lz4.h	/^#define LZ4_VERSION_NUMBER /;"	d
LZ4_VERSION_RELEASE	yosys/libs/fst/lz4.h	/^#define LZ4_VERSION_RELEASE /;"	d
LZ4_compress	yosys/libs/fst/lz4.cc	/^int LZ4_compress(const char *source, char *dest, int inputSize)$/;"	f	typeref:typename:int
LZ4_compressBound	yosys/libs/fst/lz4.cc	/^int LZ4_compressBound(int isize) { return LZ4_COMPRESSBOUND(isize); }$/;"	f	typeref:typename:int
LZ4_compress_continue	yosys/libs/fst/lz4.cc	/^int LZ4_compress_continue(LZ4_stream_t *LZ4_stream, const char *source, char *dest, int inputSiz/;"	f	typeref:typename:int
LZ4_compress_default	yosys/libs/fst/lz4.cc	/^int LZ4_compress_default(const char *source, char *dest, int inputSize, int maxOutputSize)$/;"	f	typeref:typename:int
LZ4_compress_destSize	yosys/libs/fst/lz4.cc	/^int LZ4_compress_destSize(const char *src, char *dst, int *srcSizePtr, int targetDstSize)$/;"	f	typeref:typename:int
LZ4_compress_destSize_extState	yosys/libs/fst/lz4.cc	/^static int LZ4_compress_destSize_extState(void *state, const char *src, char *dst, int *srcSizeP/;"	f	typeref:typename:int	file:
LZ4_compress_destSize_generic	yosys/libs/fst/lz4.cc	/^static int LZ4_compress_destSize_generic(void *const ctx, const char *const src, char *const dst/;"	f	typeref:typename:int	file:
LZ4_compress_fast	yosys/libs/fst/lz4.cc	/^int LZ4_compress_fast(const char *source, char *dest, int inputSize, int maxOutputSize, int acce/;"	f	typeref:typename:int
LZ4_compress_fast_continue	yosys/libs/fst/lz4.cc	/^int LZ4_compress_fast_continue(LZ4_stream_t *LZ4_stream, const char *source, char *dest, int inp/;"	f	typeref:typename:int
LZ4_compress_fast_extState	yosys/libs/fst/lz4.cc	/^int LZ4_compress_fast_extState(void *state, const char *source, char *dest, int inputSize, int m/;"	f	typeref:typename:int
LZ4_compress_fast_force	yosys/libs/fst/lz4.cc	/^int LZ4_compress_fast_force(const char *source, char *dest, int inputSize, int maxOutputSize, in/;"	f	typeref:typename:int
LZ4_compress_forceExtDict	yosys/libs/fst/lz4.cc	/^int LZ4_compress_forceExtDict(LZ4_stream_t *LZ4_dict, const char *source, char *dest, int inputS/;"	f	typeref:typename:int
LZ4_compress_generic	yosys/libs/fst/lz4.cc	/^FORCE_INLINE int LZ4_compress_generic(void *const ctx, const char *const source, char *const des/;"	f	typeref:typename:FORCE_INLINE int
LZ4_compress_limitedOutput	yosys/libs/fst/lz4.cc	/^int LZ4_compress_limitedOutput(const char *source, char *dest, int inputSize, int maxOutputSize)$/;"	f	typeref:typename:int
LZ4_compress_limitedOutput_continue	yosys/libs/fst/lz4.cc	/^int LZ4_compress_limitedOutput_continue(LZ4_stream_t *LZ4_stream, const char *src, char *dst, in/;"	f	typeref:typename:int
LZ4_compress_limitedOutput_withState	yosys/libs/fst/lz4.cc	/^int LZ4_compress_limitedOutput_withState(void *state, const char *src, char *dst, int srcSize, i/;"	f	typeref:typename:int
LZ4_compress_withState	yosys/libs/fst/lz4.cc	/^int LZ4_compress_withState(void *state, const char *src, char *dst, int srcSize)$/;"	f	typeref:typename:int
LZ4_copy4	yosys/libs/fst/lz4.cc	/^static void LZ4_copy4(void *dstPtr, const void *srcPtr) { memcpy(dstPtr, srcPtr, 4); }$/;"	f	typeref:typename:void	file:
LZ4_copy8	yosys/libs/fst/lz4.cc	/^static void LZ4_copy8(void *dstPtr, const void *srcPtr) { memcpy(dstPtr, srcPtr, 8); }$/;"	f	typeref:typename:void	file:
LZ4_count	yosys/libs/fst/lz4.cc	/^static unsigned LZ4_count(const BYTE *pIn, const BYTE *pMatch, const BYTE *pInLimit)$/;"	f	typeref:typename:unsigned	file:
LZ4_create	yosys/libs/fst/lz4.cc	/^void *LZ4_create(char *inputBuffer)$/;"	f	typeref:typename:void *
LZ4_createStream	yosys/libs/fst/lz4.cc	/^LZ4_stream_t *LZ4_createStream(void)$/;"	f	typeref:typename:LZ4_stream_t *
LZ4_createStreamDecode	yosys/libs/fst/lz4.cc	/^LZ4_streamDecode_t *LZ4_createStreamDecode(void)$/;"	f	typeref:typename:LZ4_streamDecode_t *
LZ4_decompress_fast	yosys/libs/fst/lz4.cc	/^int LZ4_decompress_fast(const char *source, char *dest, int originalSize)$/;"	f	typeref:typename:int
LZ4_decompress_fast_continue	yosys/libs/fst/lz4.cc	/^int LZ4_decompress_fast_continue(LZ4_streamDecode_t *LZ4_streamDecode, const char *source, char /;"	f	typeref:typename:int
LZ4_decompress_fast_usingDict	yosys/libs/fst/lz4.cc	/^int LZ4_decompress_fast_usingDict(const char *source, char *dest, int originalSize, const char */;"	f	typeref:typename:int
LZ4_decompress_fast_withPrefix64k	yosys/libs/fst/lz4.cc	/^int LZ4_decompress_fast_withPrefix64k(const char *source, char *dest, int originalSize)$/;"	f	typeref:typename:int
LZ4_decompress_generic	yosys/libs/fst/lz4.cc	/^LZ4_decompress_generic(const char *const source, char *const dest, int inputSize,$/;"	f	typeref:typename:FORCE_INLINE int
LZ4_decompress_safe	yosys/libs/fst/lz4.cc	/^int LZ4_decompress_safe(const char *source, char *dest, int compressedSize, int maxDecompressedS/;"	f	typeref:typename:int
LZ4_decompress_safe_continue	yosys/libs/fst/lz4.cc	/^int LZ4_decompress_safe_continue(LZ4_streamDecode_t *LZ4_streamDecode, const char *source, char /;"	f	typeref:typename:int
LZ4_decompress_safe_forceExtDict	yosys/libs/fst/lz4.cc	/^int LZ4_decompress_safe_forceExtDict(const char *source, char *dest, int compressedSize, int max/;"	f	typeref:typename:int
LZ4_decompress_safe_partial	yosys/libs/fst/lz4.cc	/^int LZ4_decompress_safe_partial(const char *source, char *dest, int compressedSize, int targetOu/;"	f	typeref:typename:int
LZ4_decompress_safe_usingDict	yosys/libs/fst/lz4.cc	/^int LZ4_decompress_safe_usingDict(const char *source, char *dest, int compressedSize, int maxOut/;"	f	typeref:typename:int
LZ4_decompress_safe_withPrefix64k	yosys/libs/fst/lz4.cc	/^int LZ4_decompress_safe_withPrefix64k(const char *source, char *dest, int compressedSize, int ma/;"	f	typeref:typename:int
LZ4_decompress_usingDict_generic	yosys/libs/fst/lz4.cc	/^FORCE_INLINE int LZ4_decompress_usingDict_generic(const char *source, char *dest, int compressed/;"	f	typeref:typename:FORCE_INLINE int
LZ4_freeStream	yosys/libs/fst/lz4.cc	/^int LZ4_freeStream(LZ4_stream_t *LZ4_stream)$/;"	f	typeref:typename:int
LZ4_freeStreamDecode	yosys/libs/fst/lz4.cc	/^int LZ4_freeStreamDecode(LZ4_streamDecode_t *LZ4_stream)$/;"	f	typeref:typename:int
LZ4_getPosition	yosys/libs/fst/lz4.cc	/^static const BYTE *LZ4_getPosition(const BYTE *p, void *tableBase, tableType_t tableType, const /;"	f	typeref:typename:const BYTE *	file:
LZ4_getPositionOnHash	yosys/libs/fst/lz4.cc	/^static const BYTE *LZ4_getPositionOnHash(U32 h, void *tableBase, tableType_t tableType, const BY/;"	f	typeref:typename:const BYTE *	file:
LZ4_hashPosition	yosys/libs/fst/lz4.cc	/^static U32 LZ4_hashPosition(const void *p, tableType_t tableType)$/;"	f	typeref:typename:U32	file:
LZ4_hashSequence	yosys/libs/fst/lz4.cc	/^static U32 LZ4_hashSequence(U32 sequence, tableType_t const tableType)$/;"	f	typeref:typename:U32	file:
LZ4_hashSequence64	yosys/libs/fst/lz4.cc	/^static U32 LZ4_hashSequence64(size_t sequence, tableType_t const tableType)$/;"	f	typeref:typename:U32	file:
LZ4_hashSequenceT	yosys/libs/fst/lz4.cc	/^static U32 LZ4_hashSequenceT(size_t sequence, tableType_t const tableType)$/;"	f	typeref:typename:U32	file:
LZ4_init	yosys/libs/fst/lz4.cc	/^static void LZ4_init(LZ4_stream_t_internal *lz4ds, BYTE *base)$/;"	f	typeref:typename:void	file:
LZ4_isLittleEndian	yosys/libs/fst/lz4.cc	/^static unsigned LZ4_isLittleEndian(void)$/;"	f	typeref:typename:unsigned	file:
LZ4_loadDict	yosys/libs/fst/lz4.cc	/^int LZ4_loadDict(LZ4_stream_t *LZ4_dict, const char *dictionary, int dictSize)$/;"	f	typeref:typename:int
LZ4_minLength	yosys/libs/fst/lz4.cc	/^static const int LZ4_minLength = (MFLIMIT + 1);$/;"	v	typeref:typename:const int	file:
LZ4_putPosition	yosys/libs/fst/lz4.cc	/^static void LZ4_putPosition(const BYTE *p, void *tableBase, tableType_t tableType, const BYTE *s/;"	f	typeref:typename:void	file:
LZ4_putPositionOnHash	yosys/libs/fst/lz4.cc	/^static void LZ4_putPositionOnHash(const BYTE *p, U32 h, void *tableBase, tableType_t const table/;"	f	typeref:typename:void	file:
LZ4_read16	yosys/libs/fst/lz4.cc	/^static U16 LZ4_read16(const void *memPtr)$/;"	f	typeref:typename:U16	file:
LZ4_read32	yosys/libs/fst/lz4.cc	/^static U32 LZ4_read32(const void *memPtr)$/;"	f	typeref:typename:U32	file:
LZ4_read64	yosys/libs/fst/lz4.cc	/^static U64 LZ4_read64(const void *memPtr)$/;"	f	typeref:typename:U64	file:
LZ4_readLE16	yosys/libs/fst/lz4.cc	/^static U16 LZ4_readLE16(const void *memPtr)$/;"	f	typeref:typename:U16	file:
LZ4_read_ARCH	yosys/libs/fst/lz4.cc	/^static size_t LZ4_read_ARCH(const void *p)$/;"	f	typeref:typename:size_t	file:
LZ4_renormDictT	yosys/libs/fst/lz4.cc	/^static void LZ4_renormDictT(LZ4_stream_t_internal *LZ4_dict, const BYTE *src)$/;"	f	typeref:typename:void	file:
LZ4_resetStream	yosys/libs/fst/lz4.cc	/^void LZ4_resetStream(LZ4_stream_t *LZ4_stream) { MEM_INIT(LZ4_stream, 0, sizeof(LZ4_stream_t)); /;"	f	typeref:typename:void
LZ4_resetStreamState	yosys/libs/fst/lz4.cc	/^int LZ4_resetStreamState(void *state, char *inputBuffer)$/;"	f	typeref:typename:int
LZ4_saveDict	yosys/libs/fst/lz4.cc	/^int LZ4_saveDict(LZ4_stream_t *LZ4_dict, char *safeBuffer, int dictSize)$/;"	f	typeref:typename:int
LZ4_setStreamDecode	yosys/libs/fst/lz4.cc	/^int LZ4_setStreamDecode(LZ4_streamDecode_t *LZ4_streamDecode, const char *dictionary, int dictSi/;"	f	typeref:typename:int
LZ4_sizeofState	yosys/libs/fst/lz4.cc	/^int LZ4_sizeofState() { return LZ4_STREAMSIZE; }$/;"	f	typeref:typename:int
LZ4_sizeofStreamState	yosys/libs/fst/lz4.cc	/^int LZ4_sizeofStreamState() { return LZ4_STREAMSIZE; }$/;"	f	typeref:typename:int
LZ4_skipTrigger	yosys/libs/fst/lz4.cc	/^static const U32 LZ4_skipTrigger = 6; \/* Increase this value ==> compression run slower on inco/;"	v	typeref:typename:const U32	file:
LZ4_slideInputBuffer	yosys/libs/fst/lz4.cc	/^char *LZ4_slideInputBuffer(void *LZ4_Data)$/;"	f	typeref:typename:char *
LZ4_streamDecode_t	yosys/libs/fst/lz4.h	/^} LZ4_streamDecode_t;$/;"	t	typeref:struct:__anon78d5d8400208
LZ4_streamDecode_t_internal	yosys/libs/fst/lz4.cc	/^} LZ4_streamDecode_t_internal;$/;"	t	typeref:struct:__anon9390dffe0908	file:
LZ4_stream_t	yosys/libs/fst/lz4.h	/^} LZ4_stream_t;$/;"	t	typeref:struct:__anon78d5d8400108
LZ4_stream_t_internal	yosys/libs/fst/lz4.cc	/^} LZ4_stream_t_internal;$/;"	t	typeref:struct:__anon9390dffe0208	file:
LZ4_uncompress	yosys/libs/fst/lz4.cc	/^int LZ4_uncompress(const char *source, char *dest, int outputSize)$/;"	f	typeref:typename:int
LZ4_uncompress_unknownOutputSize	yosys/libs/fst/lz4.cc	/^int LZ4_uncompress_unknownOutputSize(const char *source, char *dest, int isize, int maxOutputSiz/;"	f	typeref:typename:int
LZ4_versionNumber	yosys/libs/fst/lz4.cc	/^int LZ4_versionNumber(void) { return LZ4_VERSION_NUMBER; }$/;"	f	typeref:typename:int
LZ4_wildCopy	yosys/libs/fst/lz4.cc	/^static void LZ4_wildCopy(void *dstPtr, const void *srcPtr, void *dstEnd)$/;"	f	typeref:typename:void	file:
LZ4_writeLE16	yosys/libs/fst/lz4.cc	/^static void LZ4_writeLE16(void *memPtr, U16 value)$/;"	f	typeref:typename:void	file:
Label	yosys/passes/techmap/flowmap.cc	/^		Label,$/;"	e	enum:FlowmapWorker::GraphMode	file:
LessThan_default	yosys/libs/minisat/Sort.h	/^struct LessThan_default {$/;"	s	namespace:Minisat
LibertyAst	yosys/passes/techmap/libparse.h	/^	struct LibertyAst$/;"	s	namespace:Yosys
LibertyFrontend	yosys/frontends/liberty/liberty.cc	/^	LibertyFrontend() : Frontend("liberty", "read cells from liberty file") { }$/;"	f	struct:LibertyFrontend	file:
LibertyFrontend	yosys/frontends/liberty/liberty.cc	/^struct LibertyFrontend : public Frontend {$/;"	s	file:
LibertyFrontend	yosys/frontends/liberty/liberty.cc	/^} LibertyFrontend;$/;"	v	typeref:struct:LibertyFrontend
LibertyParser	yosys/passes/techmap/libparse.h	/^		LibertyParser(std::istream &f) : f(f), line(1), ast(parse()) {}$/;"	f	struct:Yosys::LibertyParser
LibertyParser	yosys/passes/techmap/libparse.h	/^	struct LibertyParser$/;"	s	namespace:Yosys
Lit	yosys/libs/minisat/SolverTypes.h	/^struct Lit {$/;"	s	namespace:Minisat
LogExpectedItem	yosys/kernel/log.h	/^	LogExpectedItem() : expected_count(0), current_count(0) {}$/;"	f	struct:LogExpectedItem
LogExpectedItem	yosys/kernel/log.h	/^	LogExpectedItem(const YS_REGEX_TYPE &pat, int expected) :$/;"	f	struct:LogExpectedItem
LogExpectedItem	yosys/kernel/log.h	/^struct LogExpectedItem$/;"	s
LogMakeDebugHdl	yosys/kernel/log.h	/^	LogMakeDebugHdl(bool start_on = false) {$/;"	f	struct:LogMakeDebugHdl
LogMakeDebugHdl	yosys/kernel/log.h	/^struct LogMakeDebugHdl {$/;"	s
LogPass	yosys/passes/cmds/logcmd.cc	/^	LogPass() : Pass("log", "print text and log files") { }$/;"	f	struct:LogPass	file:
LogPass	yosys/passes/cmds/logcmd.cc	/^struct LogPass : public Pass {$/;"	s	file:
LogPass	yosys/passes/cmds/logcmd.cc	/^} LogPass;$/;"	v	typeref:struct:LogPass
LoggerPass	yosys/passes/cmds/logger.cc	/^	LoggerPass() : Pass("logger", "set logger properties") { }$/;"	f	struct:LoggerPass	file:
LoggerPass	yosys/passes/cmds/logger.cc	/^struct LoggerPass : public Pass {$/;"	s	file:
LoggerPass	yosys/passes/cmds/logger.cc	/^} LoggerPass;$/;"	v	typeref:struct:LoggerPass
LookaheadRewriter	yosys/frontends/ast/genrtlil.cc	/^	LookaheadRewriter(AstNode *top)$/;"	f	struct:AST_INTERNAL::LookaheadRewriter	file:
LookaheadRewriter	yosys/frontends/ast/genrtlil.cc	/^struct AST_INTERNAL::LookaheadRewriter$/;"	s	class:AST_INTERNAL	file:
LsPass	yosys/passes/cmds/select.cc	/^	LsPass() : Pass("ls", "list modules or objects in modules") { }$/;"	f	struct:LsPass	file:
LsPass	yosys/passes/cmds/select.cc	/^struct LsPass : public Pass {$/;"	s	file:
LsPass	yosys/passes/cmds/select.cc	/^} LsPass;$/;"	v	typeref:struct:LsPass
LtpPass	yosys/passes/cmds/ltp.cc	/^	LtpPass() : Pass("ltp", "print longest topological path") { }$/;"	f	struct:LtpPass	file:
LtpPass	yosys/passes/cmds/ltp.cc	/^struct LtpPass : public Pass {$/;"	s	file:
LtpPass	yosys/passes/cmds/ltp.cc	/^} LtpPass;$/;"	v	typeref:struct:LtpPass
LtpWorker	yosys/passes/cmds/ltp.cc	/^	LtpWorker(RTLIL::Module *module, bool noff) : design(module->design), module(module), sigmap(mo/;"	f	struct:LtpWorker	file:
LtpWorker	yosys/passes/cmds/ltp.cc	/^struct LtpWorker$/;"	s	file:
Lut2muxPass	yosys/passes/techmap/lut2mux.cc	/^	Lut2muxPass() : Pass("lut2mux", "convert $lut to $_MUX_") { }$/;"	f	struct:Lut2muxPass	file:
Lut2muxPass	yosys/passes/techmap/lut2mux.cc	/^struct Lut2muxPass : public Pass {$/;"	s	file:
Lut2muxPass	yosys/passes/techmap/lut2mux.cc	/^} Lut2muxPass;$/;"	v	typeref:struct:Lut2muxPass
LutData	yosys/techlibs/xilinx/xilinx_dffopt.cc	/^typedef std::pair<Const, std::vector<SigBit>> LutData;$/;"	t	typeref:typename:std::pair<Const,std::vector<SigBit>>	file:
M	yosys/frontends/aiger/aigerparse.h	/^    unsigned M, I, L, O, A;$/;"	m	struct:AigerReader	typeref:typename:unsigned
MACC_H	yosys/kernel/macc.h	/^#define MACC_H$/;"	d
MAXD_LOG	yosys/libs/fst/lz4.cc	/^#define MAXD_LOG /;"	d	file:
MAX_COPY	yosys/libs/fst/fastlz.cc	/^#define MAX_COPY /;"	d	file:
MAX_DISTANCE	yosys/libs/fst/fastlz.cc	/^#define MAX_DISTANCE /;"	d	file:
MAX_DISTANCE	yosys/libs/fst/lz4.cc	/^#define MAX_DISTANCE /;"	d	file:
MAX_FARDISTANCE	yosys/libs/fst/fastlz.cc	/^#define MAX_FARDISTANCE /;"	d	file:
MAX_LEN	yosys/libs/fst/fastlz.cc	/^#define MAX_LEN /;"	d	file:
MAX_NODE_FLOW	yosys/passes/techmap/flowmap.cc	/^	const int MAX_NODE_FLOW = 1;$/;"	m	struct:FlowGraph	typeref:typename:const int	file:
MAX_REG_COUNT	yosys/kernel/register.cc	/^#define MAX_REG_COUNT /;"	d	file:
MB	yosys/libs/fst/lz4.cc	/^#define MB /;"	d	file:
MEM2REG_FL_ALL	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_ALL       = 0x00000001,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_ASYNC	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_ASYNC     = 0x00000002,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_CMPLX_LHS	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_CMPLX_LHS = 0x00002000,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_CONST_LHS	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_CONST_LHS = 0x00004000,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_EQ1	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_EQ1       = 0x01000000,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_EQ2	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_EQ2       = 0x00001000,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_FORCED	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_FORCED    = 0x00000100,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_INIT	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_INIT      = 0x00000004,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_SET_ASYNC	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_SET_ASYNC = 0x00000800,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_SET_ELSE	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_SET_ELSE  = 0x00000400,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_SET_INIT	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_SET_INIT  = 0x00000200,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEM2REG_FL_VAR_LHS	yosys/frontends/ast/ast.h	/^			MEM2REG_FL_VAR_LHS   = 0x00008000,$/;"	e	enum:AST::AstNode::mem2reg_flags
MEMBER	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		MEMBER,$/;"	e	enum:WireType::Type	file:
MEMORY	yosys/backends/cxxrtl/cxxrtl.h	/^		MEMORY  = CXXRTL_MEMORY,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40303
MEM_H	yosys/kernel/mem.h	/^#define MEM_H$/;"	d
MEM_INIT	yosys/libs/fst/lz4.cc	/^#define MEM_INIT /;"	d	file:
MEM_RDPORT	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^			MEM_RDPORT,$/;"	e	enum:FlowGraph::Node::Type	file:
MEM_WRPORTS	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^			MEM_WRPORTS,$/;"	e	enum:FlowGraph::Node::Type	file:
MFLIMIT	yosys/libs/fst/lz4.cc	/^#define MFLIMIT /;"	d	file:
MINMATCH	yosys/libs/fst/lz4.cc	/^#define MINMATCH /;"	d	file:
MISSING	yosys/backends/cxxrtl/cxxrtl.h	/^		MISSING = 0,$/;"	e	enum:cxxrtl::metadata::__anon481ec9d40203
ML_BITS	yosys/libs/fst/lz4.cc	/^#define ML_BITS /;"	d	file:
ML_MASK	yosys/libs/fst/lz4.cc	/^#define ML_MASK /;"	d	file:
MODE_ANYCONST	yosys/passes/cmds/setundef.cc	/^#define MODE_ANYCONST /;"	d	file:
MODE_ANYSEQ	yosys/passes/cmds/setundef.cc	/^#define MODE_ANYSEQ /;"	d	file:
MODE_ONE	yosys/passes/cmds/setundef.cc	/^#define MODE_ONE /;"	d	file:
MODE_RANDOM	yosys/passes/cmds/setundef.cc	/^#define MODE_RANDOM /;"	d	file:
MODE_UNDEF	yosys/passes/cmds/setundef.cc	/^#define MODE_UNDEF /;"	d	file:
MODE_ZERO	yosys/passes/cmds/setundef.cc	/^#define MODE_ZERO /;"	d	file:
MODTOOLS_H	yosys/kernel/modtools.h	/^#define MODTOOLS_H$/;"	d
MONITOR_VARS	yosys/libs/ezsat/demo_cmp.cc	/^#define MONITOR_VARS /;"	d	file:
Macc	yosys/kernel/macc.h	/^	Macc(RTLIL::Cell *cell = nullptr)$/;"	f	struct:Macc
Macc	yosys/kernel/macc.h	/^struct Macc$/;"	s
MaccmapPass	yosys/passes/techmap/maccmap.cc	/^	MaccmapPass() : Pass("maccmap", "mapping macc cells") { }$/;"	f	struct:MaccmapPass	file:
MaccmapPass	yosys/passes/techmap/maccmap.cc	/^struct MaccmapPass : public Pass {$/;"	s	file:
MaccmapPass	yosys/passes/techmap/maccmap.cc	/^} MaccmapPass;$/;"	v	typeref:struct:MaccmapPass
MaccmapWorker	yosys/passes/techmap/maccmap.cc	/^	MaccmapWorker(RTLIL::Module *module, int width) : module(module), width(width)$/;"	f	struct:MaccmapWorker	file:
MaccmapWorker	yosys/passes/techmap/maccmap.cc	/^struct MaccmapWorker$/;"	s	file:
Map	yosys/libs/minisat/Map.h	/^    Map () : table(NULL), cap(0), size(0) {}$/;"	f	class:Minisat::Map
Map	yosys/libs/minisat/Map.h	/^    Map (const H& h, const E& e) : hash(h), equals(e), table(NULL), cap(0), size(0){}$/;"	f	class:Minisat::Map
Map	yosys/libs/minisat/Map.h	/^class Map {$/;"	c	namespace:Minisat
Mem	yosys/kernel/mem.h	/^	Mem(Module *module, IdString memid, int width, int start_offset, int size) : module(module), me/;"	f	struct:Mem
Mem	yosys/kernel/mem.h	/^struct Mem : RTLIL::AttrObject {$/;"	s
MemIndex	yosys/kernel/mem.cc	/^		MemIndex (Module *module) {$/;"	f	struct:__anon62474a9e0111::MemIndex	file:
MemIndex	yosys/kernel/mem.cc	/^	struct MemIndex {$/;"	s	namespace:__anon62474a9e0111	file:
MemInit	yosys/kernel/mem.h	/^	MemInit() : removed(false), cell(nullptr) {}$/;"	f	struct:MemInit
MemInit	yosys/kernel/mem.h	/^struct MemInit : RTLIL::AttrObject {$/;"	s
MemQueryCache	yosys/passes/memory/memory_dff.cc	/^	MemQueryCache(QuickConeSat &qcsat, Mem &mem, MemRd &port, FfData &ff) : qcsat(qcsat), mem(mem),/;"	f	struct:MemQueryCache	file:
MemQueryCache	yosys/passes/memory/memory_dff.cc	/^struct MemQueryCache$/;"	s	file:
MemRd	yosys/kernel/mem.h	/^	MemRd() : removed(false), cell(nullptr) {}$/;"	f	struct:MemRd
MemRd	yosys/kernel/mem.h	/^struct MemRd : RTLIL::AttrObject {$/;"	s
MemWr	yosys/kernel/mem.h	/^	MemWr() : removed(false), cell(nullptr) {}$/;"	f	struct:MemWr
MemWr	yosys/kernel/mem.h	/^struct MemWr : RTLIL::AttrObject {$/;"	s
MemWriteAction	yosys/kernel/rtlil.h	/^struct RTLIL::MemWriteAction : RTLIL::AttrObject$/;"	s	class:RTLIL
Memory	yosys/kernel/rtlil.cc	/^RTLIL::Memory::Memory()$/;"	f	class:RTLIL::Memory
Memory	yosys/kernel/rtlil.h	/^struct RTLIL::Memory : public RTLIL::AttrObject$/;"	s	class:RTLIL
MemoryBramPass	yosys/passes/memory/memory_bram.cc	/^	MemoryBramPass() : Pass("memory_bram", "map memories to block rams") { }$/;"	f	struct:MemoryBramPass	file:
MemoryBramPass	yosys/passes/memory/memory_bram.cc	/^struct MemoryBramPass : public Pass {$/;"	s	file:
MemoryBramPass	yosys/passes/memory/memory_bram.cc	/^} MemoryBramPass;$/;"	v	typeref:struct:MemoryBramPass
MemoryCollectPass	yosys/passes/memory/memory_collect.cc	/^	MemoryCollectPass() : Pass("memory_collect", "creating multi-port memory cells") { }$/;"	f	struct:MemoryCollectPass	file:
MemoryCollectPass	yosys/passes/memory/memory_collect.cc	/^struct MemoryCollectPass : public Pass {$/;"	s	file:
MemoryCollectPass	yosys/passes/memory/memory_collect.cc	/^} MemoryCollectPass;$/;"	v	typeref:struct:MemoryCollectPass
MemoryDffPass	yosys/passes/memory/memory_dff.cc	/^	MemoryDffPass() : Pass("memory_dff", "merge input\/output DFFs into memory read ports") { }$/;"	f	struct:MemoryDffPass	file:
MemoryDffPass	yosys/passes/memory/memory_dff.cc	/^struct MemoryDffPass : public Pass {$/;"	s	file:
MemoryDffPass	yosys/passes/memory/memory_dff.cc	/^} MemoryDffPass;$/;"	v	typeref:struct:MemoryDffPass
MemoryDffWorker	yosys/passes/memory/memory_dff.cc	/^	MemoryDffWorker(Module *module) : module(module), modwalker(module->design)$/;"	f	struct:MemoryDffWorker	file:
MemoryDffWorker	yosys/passes/memory/memory_dff.cc	/^struct MemoryDffWorker$/;"	s	file:
MemoryMapPass	yosys/passes/memory/memory_map.cc	/^	MemoryMapPass() : Pass("memory_map", "translate multiport memories to basic cells") { }$/;"	f	struct:MemoryMapPass	file:
MemoryMapPass	yosys/passes/memory/memory_map.cc	/^struct MemoryMapPass : public Pass {$/;"	s	file:
MemoryMapPass	yosys/passes/memory/memory_map.cc	/^} MemoryMapPass;$/;"	v	typeref:struct:MemoryMapPass
MemoryMapWorker	yosys/passes/memory/memory_map.cc	/^	MemoryMapWorker(RTLIL::Design *design, RTLIL::Module *module) : design(design), module(module),/;"	f	struct:MemoryMapWorker	file:
MemoryMapWorker	yosys/passes/memory/memory_map.cc	/^struct MemoryMapWorker$/;"	s	file:
MemoryMemxPass	yosys/passes/memory/memory_memx.cc	/^	MemoryMemxPass() : Pass("memory_memx", "emulate vlog sim behavior for mem ports") { }$/;"	f	struct:MemoryMemxPass	file:
MemoryMemxPass	yosys/passes/memory/memory_memx.cc	/^struct MemoryMemxPass : public Pass {$/;"	s	file:
MemoryMemxPass	yosys/passes/memory/memory_memx.cc	/^} MemoryMemxPass;$/;"	v	typeref:struct:MemoryMemxPass
MemoryNarrowPass	yosys/passes/memory/memory_narrow.cc	/^	MemoryNarrowPass() : Pass("memory_narrow", "split up wide memory ports") { }$/;"	f	struct:MemoryNarrowPass	file:
MemoryNarrowPass	yosys/passes/memory/memory_narrow.cc	/^struct MemoryNarrowPass : public Pass {$/;"	s	file:
MemoryNarrowPass	yosys/passes/memory/memory_narrow.cc	/^} MemoryNarrowPass;$/;"	v	typeref:struct:MemoryNarrowPass
MemoryNordffPass	yosys/passes/memory/memory_nordff.cc	/^	MemoryNordffPass() : Pass("memory_nordff", "extract read port FFs from memories") { }$/;"	f	struct:MemoryNordffPass	file:
MemoryNordffPass	yosys/passes/memory/memory_nordff.cc	/^struct MemoryNordffPass : public Pass {$/;"	s	file:
MemoryNordffPass	yosys/passes/memory/memory_nordff.cc	/^} MemoryNordffPass;$/;"	v	typeref:struct:MemoryNordffPass
MemoryPass	yosys/passes/memory/memory.cc	/^	MemoryPass() : Pass("memory", "translate memories to basic cells") { }$/;"	f	struct:MemoryPass	file:
MemoryPass	yosys/passes/memory/memory.cc	/^struct MemoryPass : public Pass {$/;"	s	file:
MemoryPass	yosys/passes/memory/memory.cc	/^} MemoryPass;$/;"	v	typeref:struct:MemoryPass
MemorySharePass	yosys/passes/memory/memory_share.cc	/^	MemorySharePass() : Pass("memory_share", "consolidate memory ports") { }$/;"	f	struct:MemorySharePass	file:
MemorySharePass	yosys/passes/memory/memory_share.cc	/^struct MemorySharePass : public Pass {$/;"	s	file:
MemorySharePass	yosys/passes/memory/memory_share.cc	/^} MemorySharePass;$/;"	v	typeref:struct:MemorySharePass
MemoryShareWorker	yosys/passes/memory/memory_share.cc	/^	MemoryShareWorker(RTLIL::Design *design, bool flag_widen, bool flag_sat) : design(design), modw/;"	f	struct:MemoryShareWorker	file:
MemoryShareWorker	yosys/passes/memory/memory_share.cc	/^struct MemoryShareWorker$/;"	s	file:
MemoryUnpackPass	yosys/passes/memory/memory_unpack.cc	/^	MemoryUnpackPass() : Pass("memory_unpack", "unpack multi-port memory cells") { }$/;"	f	struct:MemoryUnpackPass	file:
MemoryUnpackPass	yosys/passes/memory/memory_unpack.cc	/^struct MemoryUnpackPass : public Pass {$/;"	s	file:
MemoryUnpackPass	yosys/passes/memory/memory_unpack.cc	/^} MemoryUnpackPass;$/;"	v	typeref:struct:MemoryUnpackPass
MineResult	yosys/libs/subcircuit/subcircuit.h	/^		struct MineResult {$/;"	s	class:SubCircuit::Solver
MineResultNode	yosys/libs/subcircuit/subcircuit.h	/^		struct MineResultNode {$/;"	s	class:SubCircuit::Solver
Minisat	yosys/libs/ezsat/ezminisat.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Alg.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Alloc.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Dimacs.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Heap.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/IntMap.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Map.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Options.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/ParseUtils.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Queue.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Rnd.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/SimpSolver.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Solver.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/SolverTypes.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Sort.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/System.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/Vec.h	/^namespace Minisat {$/;"	n
Minisat	yosys/libs/minisat/XAlloc.h	/^namespace Minisat {$/;"	n
MinisatSatSolver	yosys/kernel/register.cc	/^	MinisatSatSolver() : SatSolver("minisat") {$/;"	f	struct:MinisatSatSolver	file:
MinisatSatSolver	yosys/kernel/register.cc	/^struct MinisatSatSolver : public SatSolver {$/;"	s	file:
MinisatSatSolver	yosys/kernel/register.cc	/^} MinisatSatSolver;$/;"	v	typeref:struct:MinisatSatSolver
Minisat_Alg_h	yosys/libs/minisat/Alg.h	/^#define Minisat_Alg_h$/;"	d
Minisat_Alloc_h	yosys/libs/minisat/Alloc.h	/^#define Minisat_Alloc_h$/;"	d
Minisat_Dimacs_h	yosys/libs/minisat/Dimacs.h	/^#define Minisat_Dimacs_h$/;"	d
Minisat_Heap_h	yosys/libs/minisat/Heap.h	/^#define Minisat_Heap_h$/;"	d
Minisat_IntMap_h	yosys/libs/minisat/IntMap.h	/^#define Minisat_IntMap_h$/;"	d
Minisat_IntTypes_h	yosys/libs/minisat/IntTypes.h	/^#define Minisat_IntTypes_h$/;"	d
Minisat_Map_h	yosys/libs/minisat/Map.h	/^#define Minisat_Map_h$/;"	d
Minisat_Options_h	yosys/libs/minisat/Options.h	/^#define Minisat_Options_h$/;"	d
Minisat_ParseUtils_h	yosys/libs/minisat/ParseUtils.h	/^#define Minisat_ParseUtils_h$/;"	d
Minisat_Queue_h	yosys/libs/minisat/Queue.h	/^#define Minisat_Queue_h$/;"	d
Minisat_Rnd_h	yosys/libs/minisat/Rnd.h	/^#define Minisat_Rnd_h$/;"	d
Minisat_SimpSolver_h	yosys/libs/minisat/SimpSolver.h	/^#define Minisat_SimpSolver_h$/;"	d
Minisat_SolverTypes_h	yosys/libs/minisat/SolverTypes.h	/^#define Minisat_SolverTypes_h$/;"	d
Minisat_Solver_h	yosys/libs/minisat/Solver.h	/^#define Minisat_Solver_h$/;"	d
Minisat_Sort_h	yosys/libs/minisat/Sort.h	/^#define Minisat_Sort_h$/;"	d
Minisat_System_h	yosys/libs/minisat/System.h	/^#define Minisat_System_h$/;"	d
Minisat_Vec_h	yosys/libs/minisat/Vec.h	/^#define Minisat_Vec_h$/;"	d
Minisat_XAlloc_h	yosys/libs/minisat/XAlloc.h	/^#define Minisat_XAlloc_h$/;"	d
MiterPass	yosys/passes/sat/miter.cc	/^	MiterPass() : Pass("miter", "automatically create a miter circuit") { }$/;"	f	struct:MiterPass	file:
MiterPass	yosys/passes/sat/miter.cc	/^struct MiterPass : public Pass {$/;"	s	file:
MiterPass	yosys/passes/sat/miter.cc	/^} MiterPass;$/;"	v	typeref:struct:MiterPass
MkIndexDefault	yosys/libs/minisat/IntMap.h	/^    template<class T> struct MkIndexDefault {$/;"	s	namespace:Minisat
MkIndexLit	yosys/libs/minisat/SolverTypes.h	/^struct MkIndexLit { vec<Lit>::Size operator()(Lit l) const { return vec<Lit>::Size(l.x); } };$/;"	s	namespace:Minisat
ModIndex	yosys/kernel/modtools.h	/^	ModIndex(RTLIL::Module *_m) : sigmap(_m), module(_m)$/;"	f	struct:ModIndex
ModIndex	yosys/kernel/modtools.h	/^struct ModIndex : public RTLIL::Monitor$/;"	s
ModWalker	yosys/kernel/modtools.h	/^	ModWalker(RTLIL::Design *design, RTLIL::Module *module = nullptr) : design(design), module(NULL/;"	f	struct:ModWalker
ModWalker	yosys/kernel/modtools.h	/^struct ModWalker$/;"	s
ModelBlockInfo	yosys/passes/sat/sat.cc	/^	struct ModelBlockInfo {$/;"	s	struct:SatHelper	file:
Module	yosys/kernel/rtlil.cc	/^RTLIL::Module::Module()$/;"	f	class:RTLIL::Module
Module	yosys/kernel/rtlil.h	/^struct RTLIL::Module : public RTLIL::AttrObject$/;"	s	class:RTLIL
ModuleTiming	yosys/kernel/timinginfo.h	/^	struct ModuleTiming$/;"	s	struct:TimingInfo
Monitor	yosys/kernel/rtlil.h	/^	Monitor() {$/;"	f	struct:RTLIL::Monitor
Monitor	yosys/kernel/rtlil.h	/^struct RTLIL::Monitor$/;"	s	class:RTLIL
MutatePass	yosys/passes/sat/mutate.cc	/^	MutatePass() : Pass("mutate", "generate or apply design mutations") { }$/;"	f	struct:MutatePass	file:
MutatePass	yosys/passes/sat/mutate.cc	/^struct MutatePass : public Pass {$/;"	s	file:
MutatePass	yosys/passes/sat/mutate.cc	/^} MutatePass;$/;"	v	typeref:struct:MutatePass
MuxData	yosys/passes/memory/memory_dff.cc	/^struct MuxData {$/;"	s	file:
MuxcoverPass	yosys/passes/techmap/muxcover.cc	/^	MuxcoverPass() : Pass("muxcover", "cover trees of MUX cells with wider MUXes") { }$/;"	f	struct:MuxcoverPass	file:
MuxcoverPass	yosys/passes/techmap/muxcover.cc	/^struct MuxcoverPass : public Pass {$/;"	s	file:
MuxcoverPass	yosys/passes/techmap/muxcover.cc	/^} MuxcoverPass;$/;"	v	typeref:struct:MuxcoverPass
MuxcoverWorker	yosys/passes/techmap/muxcover.cc	/^	MuxcoverWorker(Module *module) : module(module), sigmap(module)$/;"	f	struct:MuxcoverWorker	file:
MuxcoverWorker	yosys/passes/techmap/muxcover.cc	/^struct MuxcoverWorker$/;"	s	file:
MuxpackPass	yosys/passes/opt/muxpack.cc	/^	MuxpackPass() : Pass("muxpack", "$mux\/$pmux cascades to $pmux") { }$/;"	f	struct:MuxpackPass	file:
MuxpackPass	yosys/passes/opt/muxpack.cc	/^struct MuxpackPass : public Pass {$/;"	s	file:
MuxpackPass	yosys/passes/opt/muxpack.cc	/^} MuxpackPass;$/;"	v	typeref:struct:MuxpackPass
MuxpackWorker	yosys/passes/opt/muxpack.cc	/^	MuxpackWorker(Module *module) :$/;"	f	struct:MuxpackWorker	file:
MuxpackWorker	yosys/passes/opt/muxpack.cc	/^struct MuxpackWorker$/;"	s	file:
MyPass	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^    MyPass() : Pass("my_cmd", "just a simple test") { }$/;"	f	struct:MyPass	file:
MyPass	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^struct MyPass : public Pass {$/;"	s	file:
MyPass	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^} MyPass;$/;"	v	typeref:struct:MyPass
N	yosys/libs/bigint/NumberlikeArray.hh	/^	static const unsigned int N;$/;"	m	class:NumberlikeArray	typeref:typename:const unsigned int
N	yosys/libs/bigint/NumberlikeArray.hh	/^const unsigned int NumberlikeArray<Blk>::N = 8 * sizeof(Blk);$/;"	m	class:NumberlikeArray<Blk>	typeref:typename:const unsigned int
NEG_C	yosys/passes/techmap/dfflegalize.cc	/^	NEG_C = 0x10,$/;"	e	enum:FfNeg	file:
NEG_CE	yosys/passes/techmap/dfflegalize.cc	/^	NEG_CE = 0x1,$/;"	e	enum:FfNeg	file:
NEG_L	yosys/passes/techmap/dfflegalize.cc	/^	NEG_L = 0x8,$/;"	e	enum:FfNeg	file:
NEG_R	yosys/passes/techmap/dfflegalize.cc	/^	NEG_R = 0x2,$/;"	e	enum:FfNeg	file:
NEG_S	yosys/passes/techmap/dfflegalize.cc	/^	NEG_S = 0x4,$/;"	e	enum:FfNeg	file:
NEW_ID	yosys/kernel/yosys.h	/^#define NEW_ID /;"	d
NEW_ID_SUFFIX	yosys/kernel/yosys.h	/^#define NEW_ID_SUFFIX(/;"	d
NOMINMAX	yosys/kernel/yosys.h	/^#  define NOMINMAX /;"	d
NOT	yosys/libs/ezsat/ezsat.h	/^	int NOT(_V a) {$/;"	f	class:ezSAT	typeref:typename:int
NUL	yosys/libs/json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::Json::Type
NULL	yosys/libs/bigint/NumberlikeArray.hh	/^#define NULL /;"	d
NUMBER	yosys/libs/json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::Json::Type
NUMBERLIKEARRAY_H	yosys/libs/bigint/NumberlikeArray.hh	/^#define NUMBERLIKEARRAY_H$/;"	d
NUM_124	yosys/libs/ezsat/puzzle3d.cc	/^#define NUM_124 /;"	d	file:
NUM_223	yosys/libs/ezsat/puzzle3d.cc	/^#define NUM_223 /;"	d	file:
NUM_FFTYPES	yosys/passes/techmap/dfflegalize.cc	/^	NUM_FFTYPES,$/;"	e	enum:FfType	file:
NUM_NEG	yosys/passes/techmap/dfflegalize.cc	/^	NUM_NEG = 0x20,$/;"	e	enum:FfNeg	file:
NameBit	yosys/kernel/timinginfo.h	/^		NameBit() : offset(0) {}$/;"	f	struct:TimingInfo::NameBit
NameBit	yosys/kernel/timinginfo.h	/^		NameBit(const RTLIL::IdString name, int offset) : name(name), offset(offset) {}$/;"	f	struct:TimingInfo::NameBit
NameBit	yosys/kernel/timinginfo.h	/^		explicit NameBit(const RTLIL::SigBit &b) : name(b.wire->name), offset(b.offset) {}$/;"	f	struct:TimingInfo::NameBit
NameBit	yosys/kernel/timinginfo.h	/^	struct NameBit$/;"	s	struct:TimingInfo
NlutmapConfig	yosys/passes/techmap/nlutmap.cc	/^struct NlutmapConfig$/;"	s	file:
NlutmapPass	yosys/passes/techmap/nlutmap.cc	/^	NlutmapPass() : Pass("nlutmap", "map to LUTs of different sizes") { }$/;"	f	struct:NlutmapPass	file:
NlutmapPass	yosys/passes/techmap/nlutmap.cc	/^struct NlutmapPass : public Pass {$/;"	s	file:
NlutmapPass	yosys/passes/techmap/nlutmap.cc	/^} NlutmapPass;$/;"	v	typeref:struct:NlutmapPass
NlutmapWorker	yosys/passes/techmap/nlutmap.cc	/^	NlutmapWorker(const NlutmapConfig &config, Module *module) :$/;"	f	struct:NlutmapWorker	file:
NlutmapWorker	yosys/passes/techmap/nlutmap.cc	/^struct NlutmapWorker$/;"	s	file:
Node	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	struct Node {$/;"	s	struct:FlowGraph	file:
Node	yosys/libs/subcircuit/subcircuit.h	/^			Node() : userData(NULL), shared(false) { };$/;"	f	struct:SubCircuit::Graph::Node
Node	yosys/libs/subcircuit/subcircuit.h	/^		struct Node {$/;"	s	class:SubCircuit::Graph
Node	yosys/passes/cmds/qwp.cc	/^		Node() {$/;"	f	struct:QwpWorker::Node	file:
Node	yosys/passes/cmds/qwp.cc	/^	struct Node {$/;"	s	struct:QwpWorker	file:
NodePrime	yosys/passes/techmap/flowmap.cc	/^		NodePrime(RTLIL::SigBit node, bool is_bottom) :$/;"	f	struct:FlowGraph::NodePrime	file:
NodePrime	yosys/passes/techmap/flowmap.cc	/^	struct NodePrime$/;"	s	struct:FlowGraph	file:
NodeSet	yosys/libs/subcircuit/subcircuit.cc	/^		NodeSet(std::string graphId, const std::vector<int> &nodes) {$/;"	f	struct:SubCircuit::SolverWorker::NodeSet	file:
NodeSet	yosys/libs/subcircuit/subcircuit.cc	/^		NodeSet(std::string graphId, int node1, int node2) {$/;"	f	struct:SubCircuit::SolverWorker::NodeSet	file:
NodeSet	yosys/libs/subcircuit/subcircuit.cc	/^	struct NodeSet {$/;"	s	class:SubCircuit::SolverWorker	file:
NotReferenced	yosys/frontends/ast/simplify.cc	/^	NotReferenced, \/\/ target variable is neither read or written in the block$/;"	e	enum:IdentUsage	file:
NullStruct	yosys/libs/json11/json11.cpp	/^struct NullStruct {$/;"	s	namespace:json11	file:
NumberlikeArray	yosys/libs/bigint/NumberlikeArray.hh	/^	NumberlikeArray() : cap(0), len(0) {$/;"	f	class:NumberlikeArray
NumberlikeArray	yosys/libs/bigint/NumberlikeArray.hh	/^	NumberlikeArray(Index c) : cap(c), len(0) { $/;"	f	class:NumberlikeArray
NumberlikeArray	yosys/libs/bigint/NumberlikeArray.hh	/^NumberlikeArray<Blk>::NumberlikeArray(const Blk *b, Index blen)$/;"	f	class:NumberlikeArray
NumberlikeArray	yosys/libs/bigint/NumberlikeArray.hh	/^NumberlikeArray<Blk>::NumberlikeArray(const NumberlikeArray<Blk> &x)$/;"	f	class:NumberlikeArray
NumberlikeArray	yosys/libs/bigint/NumberlikeArray.hh	/^class NumberlikeArray {$/;"	c
O	yosys/frontends/aiger/aigerparse.h	/^    unsigned M, I, L, O, A;$/;"	m	struct:AigerReader	typeref:typename:unsigned
O0	yosys/passes/sat/qbfsat.h	/^	enum OptimizationLevel{O0, O1, O2} oflag = O0;$/;"	e	enum:QbfSolveOptions::OptimizationLevel
O1	yosys/passes/sat/qbfsat.h	/^	enum OptimizationLevel{O0, O1, O2} oflag = O0;$/;"	e	enum:QbfSolveOptions::OptimizationLevel
O2	yosys/passes/sat/qbfsat.h	/^	enum OptimizationLevel{O0, O1, O2} oflag = O0;$/;"	e	enum:QbfSolveOptions::OptimizationLevel
OBJECT	yosys/libs/json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::Json::Type
OBJS	yosys/Makefile	/^OBJS = kernel\/version_$(GIT_REV).o$/;"	m
OBJS	yosys/Makefile	/^OBJS =$/;"	m
OBJTEST	yosys/tests/unit/Makefile	/^OBJTEST := objtest$/;"	m
OR	yosys/libs/ezsat/ezsat.h	/^	int OR(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {$/;"	f	class:ezSAT	typeref:typename:int
OS	yosys/Makefile	/^OS := $(shell uname -s)$/;"	m
OUT	yosys/frontends/verific/verific.cc	/^	#define OUT /;"	d	file:
OUTLINE	yosys/backends/cxxrtl/cxxrtl.h	/^		OUTLINE = CXXRTL_OUTLINE,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40303
OUTLINE	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		OUTLINE,$/;"	e	enum:WireType::Type	file:
OUTPUT	yosys/backends/cxxrtl/cxxrtl.h	/^		OUTPUT = CXXRTL_OUTPUT,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40403
ObjIterator	yosys/kernel/rtlil.h	/^		ObjIterator() : list_p(nullptr), refcount_p(nullptr) {$/;"	f	struct:RTLIL::ObjIterator
ObjIterator	yosys/kernel/rtlil.h	/^		ObjIterator(const RTLIL::ObjIterator<T> &other) {$/;"	f	struct:RTLIL::ObjIterator
ObjIterator	yosys/kernel/rtlil.h	/^		ObjIterator(decltype(list_p) list_p, int *refcount_p) : list_p(list_p), refcount_p(refcount_p)/;"	f	struct:RTLIL::ObjIterator
ObjIterator	yosys/kernel/rtlil.h	/^	struct ObjIterator {$/;"	s	namespace:RTLIL
ObjRange	yosys/kernel/rtlil.h	/^		ObjRange(decltype(list_p) list_p, int *refcount_p) : list_p(list_p), refcount_p(refcount_p) { /;"	f	struct:RTLIL::ObjRange
ObjRange	yosys/kernel/rtlil.h	/^	struct ObjRange$/;"	s	namespace:RTLIL
OccLists	yosys/libs/minisat/SolverTypes.h	/^    OccLists(const Deleted& d, MkIndex _index = MkIndex()) :$/;"	f	class:Minisat::OccLists
OccLists	yosys/libs/minisat/SolverTypes.h	/^class OccLists$/;"	c	namespace:Minisat
OnehotDatabase	yosys/passes/opt/pmux2shiftx.cc	/^	OnehotDatabase(Module *module, const SigMap &sigmap) : module(module), sigmap(sigmap)$/;"	f	struct:OnehotDatabase	file:
OnehotDatabase	yosys/passes/opt/pmux2shiftx.cc	/^struct OnehotDatabase$/;"	s	file:
OnehotPass	yosys/passes/opt/pmux2shiftx.cc	/^	OnehotPass() : Pass("onehot", "optimize $eq cells for onehot signals") { }$/;"	f	struct:OnehotPass	file:
OnehotPass	yosys/passes/opt/pmux2shiftx.cc	/^struct OnehotPass : public Pass {$/;"	s	file:
OnehotPass	yosys/passes/opt/pmux2shiftx.cc	/^} OnehotPass;$/;"	v	typeref:struct:OnehotPass
OpAnd	yosys/libs/ezsat/ezsat.h	/^		OpNot, OpAnd, OpOr, OpXor, OpIFF, OpITE$/;"	e	enum:ezSAT::OpId
OpIFF	yosys/libs/ezsat/ezsat.h	/^		OpNot, OpAnd, OpOr, OpXor, OpIFF, OpITE$/;"	e	enum:ezSAT::OpId
OpITE	yosys/libs/ezsat/ezsat.h	/^		OpNot, OpAnd, OpOr, OpXor, OpIFF, OpITE$/;"	e	enum:ezSAT::OpId
OpId	yosys/libs/ezsat/ezsat.h	/^	enum OpId {$/;"	g	class:ezSAT
OpMuxConn	yosys/passes/opt/opt_share.cc	/^struct OpMuxConn {$/;"	s	file:
OpNot	yosys/libs/ezsat/ezsat.h	/^		OpNot, OpAnd, OpOr, OpXor, OpIFF, OpITE$/;"	e	enum:ezSAT::OpId
OpOr	yosys/libs/ezsat/ezsat.h	/^		OpNot, OpAnd, OpOr, OpXor, OpIFF, OpITE$/;"	e	enum:ezSAT::OpId
OpXor	yosys/libs/ezsat/ezsat.h	/^		OpNot, OpAnd, OpOr, OpXor, OpIFF, OpITE$/;"	e	enum:ezSAT::OpId
OptCleanPass	yosys/passes/opt/opt_clean.cc	/^	OptCleanPass() : Pass("opt_clean", "remove unused cells and wires") { }$/;"	f	struct:OptCleanPass	file:
OptCleanPass	yosys/passes/opt/opt_clean.cc	/^struct OptCleanPass : public Pass {$/;"	s	file:
OptCleanPass	yosys/passes/opt/opt_clean.cc	/^} OptCleanPass;$/;"	v	typeref:struct:OptCleanPass
OptDemorganPass	yosys/passes/opt/opt_demorgan.cc	/^	OptDemorganPass() : Pass("opt_demorgan", "Optimize reductions with DeMorgan equivalents") { }$/;"	f	struct:OptDemorganPass	file:
OptDemorganPass	yosys/passes/opt/opt_demorgan.cc	/^struct OptDemorganPass : public Pass {$/;"	s	file:
OptDemorganPass	yosys/passes/opt/opt_demorgan.cc	/^} OptDemorganPass;$/;"	v	typeref:struct:OptDemorganPass
OptDffOptions	yosys/passes/opt/opt_dff.cc	/^struct OptDffOptions$/;"	s	file:
OptDffPass	yosys/passes/opt/opt_dff.cc	/^	OptDffPass() : Pass("opt_dff", "perform DFF optimizations") { }$/;"	f	struct:OptDffPass	file:
OptDffPass	yosys/passes/opt/opt_dff.cc	/^struct OptDffPass : public Pass {$/;"	s	file:
OptDffPass	yosys/passes/opt/opt_dff.cc	/^} OptDffPass;$/;"	v	typeref:struct:OptDffPass
OptDffWorker	yosys/passes/opt/opt_dff.cc	/^	OptDffWorker(const OptDffOptions &opt, Module *mod) : opt(opt), module(mod), sigmap(mod), initv/;"	f	struct:OptDffWorker	file:
OptDffWorker	yosys/passes/opt/opt_dff.cc	/^struct OptDffWorker$/;"	s	file:
OptExprPass	yosys/passes/opt/opt_expr.cc	/^	OptExprPass() : Pass("opt_expr", "perform const folding and simple expression rewriting") { }$/;"	f	struct:OptExprPass	file:
OptExprPass	yosys/passes/opt/opt_expr.cc	/^struct OptExprPass : public Pass {$/;"	s	file:
OptExprPass	yosys/passes/opt/opt_expr.cc	/^} OptExprPass;$/;"	v	typeref:struct:OptExprPass
OptLutInsPass	yosys/passes/opt/opt_lut_ins.cc	/^	OptLutInsPass() : Pass("opt_lut_ins", "discard unused LUT inputs") { }$/;"	f	struct:OptLutInsPass	file:
OptLutInsPass	yosys/passes/opt/opt_lut_ins.cc	/^struct OptLutInsPass : public Pass {$/;"	s	file:
OptLutPass	yosys/passes/opt/opt_lut.cc	/^	OptLutPass() : Pass("opt_lut", "optimize LUT cells") { }$/;"	f	struct:OptLutPass	file:
OptLutPass	yosys/passes/opt/opt_lut.cc	/^struct OptLutPass : public Pass {$/;"	s	file:
OptLutPass	yosys/passes/opt/opt_lut.cc	/^} OptLutPass;$/;"	v	typeref:struct:OptLutPass
OptLutWorker	yosys/passes/opt/opt_lut.cc	/^	OptLutWorker(const std::vector<dlogic_t> &dlogic, RTLIL::Module *module, int limit) :$/;"	f	struct:OptLutWorker	file:
OptLutWorker	yosys/passes/opt/opt_lut.cc	/^struct OptLutWorker$/;"	s	file:
OptMemFeedbackPass	yosys/passes/opt/opt_mem_feedback.cc	/^	OptMemFeedbackPass() : Pass("opt_mem_feedback", "convert memory read-to-write port feedback pat/;"	f	struct:OptMemFeedbackPass	file:
OptMemFeedbackPass	yosys/passes/opt/opt_mem_feedback.cc	/^struct OptMemFeedbackPass : public Pass {$/;"	s	file:
OptMemFeedbackPass	yosys/passes/opt/opt_mem_feedback.cc	/^} OptMemFeedbackPass;$/;"	v	typeref:struct:OptMemFeedbackPass
OptMemFeedbackWorker	yosys/passes/opt/opt_mem_feedback.cc	/^	OptMemFeedbackWorker(RTLIL::Design *design) : design(design) {}$/;"	f	struct:OptMemFeedbackWorker	file:
OptMemFeedbackWorker	yosys/passes/opt/opt_mem_feedback.cc	/^struct OptMemFeedbackWorker$/;"	s	file:
OptMemPass	yosys/passes/opt/opt_mem.cc	/^	OptMemPass() : Pass("opt_mem", "optimize memories") { }$/;"	f	struct:OptMemPass	file:
OptMemPass	yosys/passes/opt/opt_mem.cc	/^struct OptMemPass : public Pass {$/;"	s	file:
OptMemPass	yosys/passes/opt/opt_mem.cc	/^} OptMemPass;$/;"	v	typeref:struct:OptMemPass
OptMemPriorityPass	yosys/passes/opt/opt_mem_priority.cc	/^	OptMemPriorityPass() : Pass("opt_mem_priority", "remove priority relations between write ports /;"	f	struct:OptMemPriorityPass	file:
OptMemPriorityPass	yosys/passes/opt/opt_mem_priority.cc	/^struct OptMemPriorityPass : public Pass {$/;"	s	file:
OptMemPriorityPass	yosys/passes/opt/opt_mem_priority.cc	/^} OptMemPriorityPass;$/;"	v	typeref:struct:OptMemPriorityPass
OptMemWidenPass	yosys/passes/opt/opt_mem_widen.cc	/^	OptMemWidenPass() : Pass("opt_mem_widen", "optimize memories where all ports are wide") { }$/;"	f	struct:OptMemWidenPass	file:
OptMemWidenPass	yosys/passes/opt/opt_mem_widen.cc	/^struct OptMemWidenPass : public Pass {$/;"	s	file:
OptMemWidenPass	yosys/passes/opt/opt_mem_widen.cc	/^} OptMemWidenPass;$/;"	v	typeref:struct:OptMemWidenPass
OptMergePass	yosys/passes/opt/opt_merge.cc	/^	OptMergePass() : Pass("opt_merge", "consolidate identical cells") { }$/;"	f	struct:OptMergePass	file:
OptMergePass	yosys/passes/opt/opt_merge.cc	/^struct OptMergePass : public Pass {$/;"	s	file:
OptMergePass	yosys/passes/opt/opt_merge.cc	/^} OptMergePass;$/;"	v	typeref:struct:OptMergePass
OptMergeWorker	yosys/passes/opt/opt_merge.cc	/^	OptMergeWorker(RTLIL::Design *design, RTLIL::Module *module, bool mode_nomux, bool mode_share_a/;"	f	struct:OptMergeWorker	file:
OptMergeWorker	yosys/passes/opt/opt_merge.cc	/^struct OptMergeWorker$/;"	s	file:
OptMuxtreePass	yosys/passes/opt/opt_muxtree.cc	/^	OptMuxtreePass() : Pass("opt_muxtree", "eliminate dead trees in multiplexer trees") { }$/;"	f	struct:OptMuxtreePass	file:
OptMuxtreePass	yosys/passes/opt/opt_muxtree.cc	/^struct OptMuxtreePass : public Pass {$/;"	s	file:
OptMuxtreePass	yosys/passes/opt/opt_muxtree.cc	/^} OptMuxtreePass;$/;"	v	typeref:struct:OptMuxtreePass
OptMuxtreeWorker	yosys/passes/opt/opt_muxtree.cc	/^	OptMuxtreeWorker(RTLIL::Design *design, RTLIL::Module *module) :$/;"	f	struct:OptMuxtreeWorker	file:
OptMuxtreeWorker	yosys/passes/opt/opt_muxtree.cc	/^struct OptMuxtreeWorker$/;"	s	file:
OptPass	yosys/passes/opt/opt.cc	/^	OptPass() : Pass("opt", "perform simple optimizations") { }$/;"	f	struct:OptPass	file:
OptPass	yosys/passes/opt/opt.cc	/^struct OptPass : public Pass {$/;"	s	file:
OptPass	yosys/passes/opt/opt.cc	/^} OptPass;$/;"	v	typeref:struct:OptPass
OptReducePass	yosys/passes/opt/opt_reduce.cc	/^	OptReducePass() : Pass("opt_reduce", "simplify large MUXes and AND\/OR gates") { }$/;"	f	struct:OptReducePass	file:
OptReducePass	yosys/passes/opt/opt_reduce.cc	/^struct OptReducePass : public Pass {$/;"	s	file:
OptReducePass	yosys/passes/opt/opt_reduce.cc	/^} OptReducePass;$/;"	v	typeref:struct:OptReducePass
OptReduceWorker	yosys/passes/opt/opt_reduce.cc	/^	OptReduceWorker(RTLIL::Design *design, RTLIL::Module *module, bool do_fine) :$/;"	f	struct:OptReduceWorker	file:
OptReduceWorker	yosys/passes/opt/opt_reduce.cc	/^struct OptReduceWorker$/;"	s	file:
OptSharePass	yosys/passes/opt/opt_share.cc	/^	OptSharePass() : Pass("opt_share", "merge mutually exclusive cells of the same type that share /;"	f	struct:OptSharePass	file:
OptSharePass	yosys/passes/opt/opt_share.cc	/^struct OptSharePass : public Pass {$/;"	s	file:
OptSharePass	yosys/passes/opt/opt_share.cc	/^} OptSharePass;$/;"	v	typeref:struct:OptSharePass
OptimizationLevel	yosys/passes/sat/qbfsat.h	/^	enum OptimizationLevel{O0, O1, O2} oflag = O0;$/;"	g	struct:QbfSolveOptions
Option	yosys/libs/minisat/Options.h	/^    Option(const char* name_, $/;"	f	class:Minisat::Option
Option	yosys/libs/minisat/Options.h	/^class Option$/;"	c	namespace:Minisat
OptionLt	yosys/libs/minisat/Options.h	/^    struct OptionLt {$/;"	s	class:Minisat::Option
Or	yosys/passes/techmap/extract_reduce.cc	/^		Or,$/;"	e	enum:ExtractReducePass::GateType	file:
OutOfMemoryException	yosys/libs/minisat/XAlloc.h	/^class OutOfMemoryException{};$/;"	c	namespace:Minisat
OutputWriter	yosys/passes/sat/sim.cc	/^	OutputWriter(SimWorker *w) { worker = w;};$/;"	f	struct:OutputWriter	file:
OutputWriter	yosys/passes/sat/sim.cc	/^struct OutputWriter$/;"	s	file:
P	yosys/Makefile	/^P = @echo "$(if $(findstring $@,$(TARGETS) $(EXTRA_TARGETS)),$(eval P_OFFSET = 10))$(call P_UPDA/;"	m
P	yosys/Makefile	/^P =$/;"	m
PATH	yosys/Makefile	/^export PATH := $(BREW_PREFIX)\/bison\/bin:$(BREW_PREFIX)\/gettext\/bin:$(BREW_PREFIX)\/flex\/bin/;"	m
PATH	yosys/Makefile	/^export PATH := $(PORT_PREFIX)\/bin:$(PATH)$/;"	m
PATH_MAX	yosys/kernel/yosys.h	/^#    define PATH_MAX /;"	d
PATH_MAX	yosys/kernel/yosys.h	/^#  define PATH_MAX /;"	d
PATH_MAX	yosys/libs/fst/fstapi.cc	/^#define PATH_MAX /;"	d	file:
PKG_CONFIG	yosys/Makefile	/^PKG_CONFIG = \/usr\/local\/src\/mxe\/usr\/bin\/i686-w64-mingw32.static-pkg-config$/;"	m
PKG_CONFIG	yosys/Makefile	/^PKG_CONFIG ?= pkg-config$/;"	m
PKG_CONFIG_PATH	yosys/Makefile	/^PKG_CONFIG_PATH := $(BREW_PREFIX)\/libffi\/lib\/pkgconfig:$(PKG_CONFIG_PATH)$/;"	m
PKG_CONFIG_PATH	yosys/Makefile	/^PKG_CONFIG_PATH := $(BREW_PREFIX)\/tcl-tk\/lib\/pkgconfig:$(PKG_CONFIG_PATH)$/;"	m
PKG_CONFIG_PATH	yosys/Makefile	/^PKG_CONFIG_PATH := $(PORT_PREFIX)\/lib\/pkgconfig:$(PKG_CONFIG_PATH)$/;"	m
PMGEN_GENERATE	yosys/passes/pmgen/generate.h	/^#define PMGEN_GENERATE$/;"	d
PORT_PREFIX	yosys/Makefile	/^PORT_PREFIX := $(patsubst %\/bin\/port,%,$(shell :; command -v port))$/;"	m
PPvoid_t	yosys/libs/fst/fstapi.cc	/^typedef void **PPvoid_t;$/;"	t	typeref:typename:void **	file:
PREFIX	yosys/Makefile	/^PREFIX ?= \/usr\/local$/;"	m
PRETTY	yosys/Makefile	/^PRETTY = 1$/;"	m
PRIVATE_NAMESPACE_BEGIN	yosys/kernel/yosys.h	/^#define PRIVATE_NAMESPACE_BEGIN /;"	d
PRIVATE_NAMESPACE_END	yosys/kernel/yosys.h	/^#define PRIVATE_NAMESPACE_END /;"	d
PROCESS_CASE	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^			PROCESS_CASE,$/;"	e	enum:FlowGraph::Node::Type	file:
PROCESS_SYNC	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^			PROCESS_SYNC,$/;"	e	enum:FlowGraph::Node::Type	file:
PROGRAM_PREFIX	yosys/Makefile	/^PROGRAM_PREFIX :=$/;"	m
PYTHON_CONFIG	yosys/Makefile	/^PYTHON_CONFIG := $(PYTHON_EXECUTABLE)-config --embed$/;"	m
PYTHON_CONFIG	yosys/Makefile	/^PYTHON_CONFIG := $(PYTHON_EXECUTABLE)-config$/;"	m
PYTHON_DESTDIR	yosys/Makefile	/^PYTHON_DESTDIR := $(shell $(PYTHON_EXECUTABLE) -c "import site; print(site.getsitepackages()[-1]/;"	m
PYTHON_EXECUTABLE	yosys/Makefile	/^PYTHON_EXECUTABLE := $(shell if python3 -c ""; then echo "python3"; else echo "python"; fi)$/;"	m
PYTHON_MAJOR_VERSION	yosys/Makefile	/^PYTHON_MAJOR_VERSION := $(shell echo $(PYTHON_VERSION) | cut -f1 -d.)$/;"	m
PYTHON_VERSION	yosys/Makefile	/^PYTHON_VERSION := $(shell $(PYTHON_EXECUTABLE) -c ""$(PYTHON_VERSION_TESTCODE)"")$/;"	m
PYTHON_VERSION_TESTCODE	yosys/Makefile	/^PYTHON_VERSION_TESTCODE := "import sys;t='{v[0]}.{v[1]}'.format(v=list(sys.version_info[:2]));pr/;"	m
PY_GEN_SCRIPT	yosys/Makefile	/^PY_GEN_SCRIPT= py_wrap_generator$/;"	m
PY_WRAPPER_FILE	yosys/Makefile	/^PY_WRAPPER_FILE = kernel\/python_wrappers$/;"	m
PY_WRAP_INCLUDES	yosys/Makefile	/^PY_WRAP_INCLUDES := $(shell python$(PYTHON_VERSION) -c "from misc import $(PY_GEN_SCRIPT); $(PY_/;"	m
P_OFFSET	yosys/Makefile	/^P_OFFSET = 0$/;"	m
P_SHOW	yosys/Makefile	/^P_SHOW = ->$/;"	m
P_SHOW	yosys/Makefile	/^P_SHOW = [$(shell $(AWK) "BEGIN { N=$(words $(OBJS) $(PROGRAM_PREFIX)yosys$(EXE)); printf \\"%3d/;"	m
P_STATUS	yosys/Makefile	/^P_STATUS = 0$/;"	m
P_UPDATE	yosys/Makefile	/^P_UPDATE = $(eval P_STATUS=$(shell echo $(OBJS) $(PROGRAM_PREFIX)yosys$(EXE) | $(AWK) 'BEGIN { R/;"	m
Pair	yosys/libs/minisat/Map.h	/^    struct Pair { K key; D data; };$/;"	s	class:Minisat::Map
ParamapPass	yosys/passes/techmap/attrmap.cc	/^	ParamapPass() : Pass("paramap", "renaming cell parameters") { }$/;"	f	struct:ParamapPass	file:
ParamapPass	yosys/passes/techmap/attrmap.cc	/^struct ParamapPass : public Pass {$/;"	s	file:
ParamapPass	yosys/passes/techmap/attrmap.cc	/^} ParamapPass;$/;"	v	typeref:struct:ParamapPass
ParserErrorException	yosys/frontends/verific/verificsva.cc	/^	struct ParserErrorException {$/;"	s	struct:VerificSvaImporter	file:
Pass	yosys/kernel/register.cc	/^Pass::Pass(std::string name, std::string short_help) : pass_name(name), short_help(short_help)$/;"	f	class:Pass
Pass	yosys/kernel/register.h	/^struct Pass$/;"	s
Pcvoid_t	yosys/libs/fst/fstapi.cc	/^typedef const void *Pcvoid_t;$/;"	t	typeref:typename:const void *	file:
PeepoptPass	yosys/passes/pmgen/peepopt.cc	/^	PeepoptPass() : Pass("peepopt", "collection of peephole optimizers") { }$/;"	f	struct:PeepoptPass	file:
PeepoptPass	yosys/passes/pmgen/peepopt.cc	/^struct PeepoptPass : public Pass {$/;"	s	file:
PeepoptPass	yosys/passes/pmgen/peepopt.cc	/^} PeepoptPass;$/;"	v	typeref:struct:PeepoptPass
PerformReduction	yosys/passes/sat/freduce.cc	/^	PerformReduction(SigMap &sigmap, drivers_t &drivers, std::set<std::pair<RTLIL::SigBit, RTLIL::S/;"	f	struct:PerformReduction	file:
PerformReduction	yosys/passes/sat/freduce.cc	/^struct PerformReduction$/;"	s	file:
PerformanceTimer	yosys/kernel/log.h	/^	PerformanceTimer() {$/;"	f	struct:PerformanceTimer
PerformanceTimer	yosys/kernel/log.h	/^struct PerformanceTimer$/;"	s
PluginPass	yosys/passes/cmds/plugin.cc	/^	PluginPass() : Pass("plugin", "load and list loaded plugins") { }$/;"	f	struct:PluginPass	file:
PluginPass	yosys/passes/cmds/plugin.cc	/^struct PluginPass : public Pass {$/;"	s	file:
PluginPass	yosys/passes/cmds/plugin.cc	/^} PluginPass;$/;"	v	typeref:struct:PluginPass
Pmux2ShiftxPass	yosys/passes/opt/pmux2shiftx.cc	/^	Pmux2ShiftxPass() : Pass("pmux2shiftx", "transform $pmux cells to $shiftx cells") { }$/;"	f	struct:Pmux2ShiftxPass	file:
Pmux2ShiftxPass	yosys/passes/opt/pmux2shiftx.cc	/^struct Pmux2ShiftxPass : public Pass {$/;"	s	file:
Pmux2ShiftxPass	yosys/passes/opt/pmux2shiftx.cc	/^} Pmux2ShiftxPass;$/;"	v	typeref:struct:Pmux2ShiftxPass
PmuxtreePass	yosys/passes/techmap/pmuxtree.cc	/^	PmuxtreePass() : Pass("pmuxtree", "transform $pmux cells to trees of $mux cells") { }$/;"	f	struct:PmuxtreePass	file:
PmuxtreePass	yosys/passes/techmap/pmuxtree.cc	/^struct PmuxtreePass : public Pass {$/;"	s	file:
PmuxtreePass	yosys/passes/techmap/pmuxtree.cc	/^} PmuxtreePass;$/;"	v	typeref:struct:PmuxtreePass
Port	yosys/libs/subcircuit/subcircuit.h	/^			Port() : minWidth(-1) { };$/;"	f	struct:SubCircuit::Graph::Port
Port	yosys/libs/subcircuit/subcircuit.h	/^		struct Port {$/;"	s	class:SubCircuit::Graph
PortBit	yosys/kernel/modtools.h	/^	struct PortBit$/;"	s	struct:ModWalker
PortBit	yosys/libs/subcircuit/subcircuit.h	/^			PortBit() : edgeIdx(-1) { };$/;"	f	struct:SubCircuit::Graph::PortBit
PortBit	yosys/libs/subcircuit/subcircuit.h	/^		struct PortBit {$/;"	s	class:SubCircuit::Graph
PortData	yosys/passes/memory/memory_dff.cc	/^struct PortData {$/;"	s	file:
PortInfo	yosys/kernel/modtools.h	/^		PortInfo() : cell(), port(), offset() { }$/;"	f	struct:ModIndex::PortInfo
PortInfo	yosys/kernel/modtools.h	/^		PortInfo(RTLIL::Cell* _c, RTLIL::IdString _p, int _o) : cell(_c), port(_p), offset(_o) { }$/;"	f	struct:ModIndex::PortInfo
PortInfo	yosys/kernel/modtools.h	/^	struct PortInfo {$/;"	s	struct:ModIndex
PortlistPass	yosys/passes/cmds/portlist.cc	/^	PortlistPass() : Pass("portlist", "list (top-level) ports") { }$/;"	f	struct:PortlistPass	file:
PortlistPass	yosys/passes/cmds/portlist.cc	/^struct PortlistPass : public Pass {$/;"	s	file:
PortlistPass	yosys/passes/cmds/portlist.cc	/^} PortlistPass;$/;"	v	typeref:struct:PortlistPass
PrepPass	yosys/techlibs/common/prep.cc	/^	PrepPass() : ScriptPass("prep", "generic synthesis script") { }$/;"	f	struct:PrepPass	file:
PrepPass	yosys/techlibs/common/prep.cc	/^struct PrepPass : public ScriptPass$/;"	s	file:
PrepPass	yosys/techlibs/common/prep.cc	/^} PrepPass;$/;"	v	typeref:struct:PrepPass
PrintAttrsPass	yosys/passes/cmds/printattrs.cc	/^	PrintAttrsPass() : Pass("printattrs", "print attributes of selected objects") { }$/;"	f	struct:PrintAttrsPass	file:
PrintAttrsPass	yosys/passes/cmds/printattrs.cc	/^struct PrintAttrsPass : public Pass {$/;"	s	file:
PrintAttrsPass	yosys/passes/cmds/printattrs.cc	/^} PrintAttrsPass;$/;"	v	typeref:struct:PrintAttrsPass
ProcArstPass	yosys/passes/proc/proc_arst.cc	/^	ProcArstPass() : Pass("proc_arst", "detect asynchronous resets") { }$/;"	f	struct:ProcArstPass	file:
ProcArstPass	yosys/passes/proc/proc_arst.cc	/^struct ProcArstPass : public Pass {$/;"	s	file:
ProcArstPass	yosys/passes/proc/proc_arst.cc	/^} ProcArstPass;$/;"	v	typeref:struct:ProcArstPass
ProcCleanPass	yosys/passes/proc/proc_clean.cc	/^	ProcCleanPass() : Pass("proc_clean", "remove empty parts of processes") { }$/;"	f	struct:ProcCleanPass	file:
ProcCleanPass	yosys/passes/proc/proc_clean.cc	/^struct ProcCleanPass : public Pass {$/;"	s	file:
ProcCleanPass	yosys/passes/proc/proc_clean.cc	/^} ProcCleanPass;$/;"	v	typeref:struct:ProcCleanPass
ProcDffPass	yosys/passes/proc/proc_dff.cc	/^	ProcDffPass() : Pass("proc_dff", "extract flip-flops from processes") { }$/;"	f	struct:ProcDffPass	file:
ProcDffPass	yosys/passes/proc/proc_dff.cc	/^struct ProcDffPass : public Pass {$/;"	s	file:
ProcDffPass	yosys/passes/proc/proc_dff.cc	/^} ProcDffPass;$/;"	v	typeref:struct:ProcDffPass
ProcDlatchPass	yosys/passes/proc/proc_dlatch.cc	/^	ProcDlatchPass() : Pass("proc_dlatch", "extract latches from processes") { }$/;"	f	struct:ProcDlatchPass	file:
ProcDlatchPass	yosys/passes/proc/proc_dlatch.cc	/^struct ProcDlatchPass : public Pass {$/;"	s	file:
ProcDlatchPass	yosys/passes/proc/proc_dlatch.cc	/^} ProcDlatchPass;$/;"	v	typeref:struct:ProcDlatchPass
ProcInitPass	yosys/passes/proc/proc_init.cc	/^	ProcInitPass() : Pass("proc_init", "convert initial block to init attributes") { }$/;"	f	struct:ProcInitPass	file:
ProcInitPass	yosys/passes/proc/proc_init.cc	/^struct ProcInitPass : public Pass {$/;"	s	file:
ProcInitPass	yosys/passes/proc/proc_init.cc	/^} ProcInitPass;$/;"	v	typeref:struct:ProcInitPass
ProcMemWrPass	yosys/passes/proc/proc_memwr.cc	/^	ProcMemWrPass() : Pass("proc_memwr", "extract memory writes from processes") { }$/;"	f	struct:ProcMemWrPass	file:
ProcMemWrPass	yosys/passes/proc/proc_memwr.cc	/^struct ProcMemWrPass : public Pass {$/;"	s	file:
ProcMemWrPass	yosys/passes/proc/proc_memwr.cc	/^} ProcMemWrPass;$/;"	v	typeref:struct:ProcMemWrPass
ProcMuxPass	yosys/passes/proc/proc_mux.cc	/^	ProcMuxPass() : Pass("proc_mux", "convert decision trees to multiplexers") { }$/;"	f	struct:ProcMuxPass	file:
ProcMuxPass	yosys/passes/proc/proc_mux.cc	/^struct ProcMuxPass : public Pass {$/;"	s	file:
ProcMuxPass	yosys/passes/proc/proc_mux.cc	/^} ProcMuxPass;$/;"	v	typeref:struct:ProcMuxPass
ProcPass	yosys/passes/proc/proc.cc	/^	ProcPass() : Pass("proc", "translate processes to netlists") { }$/;"	f	struct:ProcPass	file:
ProcPass	yosys/passes/proc/proc.cc	/^struct ProcPass : public Pass {$/;"	s	file:
ProcPass	yosys/passes/proc/proc.cc	/^} ProcPass;$/;"	v	typeref:struct:ProcPass
ProcPrunePass	yosys/passes/proc/proc_prune.cc	/^	ProcPrunePass() : Pass("proc_prune", "remove redundant assignments") { }$/;"	f	struct:ProcPrunePass	file:
ProcPrunePass	yosys/passes/proc/proc_prune.cc	/^struct ProcPrunePass : public Pass {$/;"	s	file:
ProcPrunePass	yosys/passes/proc/proc_prune.cc	/^} ProcPrunePass;$/;"	v	typeref:struct:ProcPrunePass
ProcRmdeadPass	yosys/passes/proc/proc_rmdead.cc	/^	ProcRmdeadPass() : Pass("proc_rmdead", "eliminate dead trees in decision trees") { }$/;"	f	struct:ProcRmdeadPass	file:
ProcRmdeadPass	yosys/passes/proc/proc_rmdead.cc	/^struct ProcRmdeadPass : public Pass {$/;"	s	file:
ProcRmdeadPass	yosys/passes/proc/proc_rmdead.cc	/^} ProcRmdeadPass;$/;"	v	typeref:struct:ProcRmdeadPass
Process	yosys/kernel/rtlil.cc	/^RTLIL::Process::Process() : module(nullptr)$/;"	f	class:RTLIL::Process
Process	yosys/kernel/rtlil.h	/^struct RTLIL::Process : public RTLIL::AttrObject$/;"	s	class:RTLIL
ProcessGenerator	yosys/frontends/ast/genrtlil.cc	/^	ProcessGenerator(AstNode *always, RTLIL::SigSpec initSyncSignalsArg = RTLIL::SigSpec()) : alway/;"	f	struct:AST_INTERNAL::ProcessGenerator	file:
ProcessGenerator	yosys/frontends/ast/genrtlil.cc	/^struct AST_INTERNAL::ProcessGenerator$/;"	s	class:AST_INTERNAL	file:
ProtobufBackend	yosys/backends/protobuf/protobuf.cc	/^	ProtobufBackend(): Backend("protobuf", "write design to a Protocol Buffer file") { }$/;"	f	struct:ProtobufBackend	file:
ProtobufBackend	yosys/backends/protobuf/protobuf.cc	/^struct ProtobufBackend : public Backend {$/;"	s	file:
ProtobufBackend	yosys/backends/protobuf/protobuf.cc	/^} ProtobufBackend;$/;"	v	typeref:struct:ProtobufBackend
ProtobufDesignSerializer	yosys/backends/protobuf/protobuf.cc	/^	ProtobufDesignSerializer(bool use_selection, bool aig_mode) :$/;"	f	struct:ProtobufDesignSerializer	file:
ProtobufDesignSerializer	yosys/backends/protobuf/protobuf.cc	/^struct ProtobufDesignSerializer$/;"	s	file:
ProtobufPass	yosys/backends/protobuf/protobuf.cc	/^	ProtobufPass() : Pass("protobuf", "write design in Protobuf format") { }$/;"	f	struct:ProtobufPass	file:
ProtobufPass	yosys/backends/protobuf/protobuf.cc	/^struct ProtobufPass : public Pass {$/;"	s	file:
ProtobufPass	yosys/backends/protobuf/protobuf.cc	/^} ProtobufPass;$/;"	v	typeref:struct:ProtobufPass
PruneWorker	yosys/passes/proc/proc_prune.cc	/^	PruneWorker(RTLIL::Module *mod) : module(mod), sigmap(mod) {}$/;"	f	struct:PruneWorker	file:
PruneWorker	yosys/passes/proc/proc_prune.cc	/^struct PruneWorker$/;"	s	file:
Pvoid_t	yosys/libs/fst/fstapi.cc	/^typedef void *Pvoid_t;$/;"	t	typeref:typename:void *	file:
Q	yosys/Makefile	/^Q = @$/;"	m
Q	yosys/Makefile	/^Q =$/;"	m
QBFSAT_H	yosys/passes/sat/qbfsat.h	/^#define QBFSAT_H$/;"	d
QCSAT_H	yosys/kernel/qcsat.h	/^#define QCSAT_H$/;"	d
QbfSatPass	yosys/passes/sat/qbfsat.cc	/^	QbfSatPass() : Pass("qbfsat", "solve a 2QBF-SAT problem in the circuit") { }$/;"	f	struct:QbfSatPass	file:
QbfSatPass	yosys/passes/sat/qbfsat.cc	/^struct QbfSatPass : public Pass {$/;"	s	file:
QbfSatPass	yosys/passes/sat/qbfsat.cc	/^} QbfSatPass;$/;"	v	typeref:struct:QbfSatPass
QbfSolutionType	yosys/passes/sat/qbfsat.h	/^struct QbfSolutionType {$/;"	s
QbfSolveOptions	yosys/passes/sat/qbfsat.h	/^struct QbfSolveOptions {$/;"	s
Queue	yosys/libs/minisat/Queue.h	/^    Queue() : buf(1), first(0), end(0) {}$/;"	f	class:Minisat::Queue
Queue	yosys/libs/minisat/Queue.h	/^class Queue {$/;"	c	namespace:Minisat
QuickConeSat	yosys/kernel/qcsat.h	/^	QuickConeSat(ModWalker &modwalker) : modwalker(modwalker), ez(), satgen(ez.get(), &modwalker.si/;"	f	struct:QuickConeSat
QuickConeSat	yosys/kernel/qcsat.h	/^struct QuickConeSat {$/;"	s
QwpConfig	yosys/passes/cmds/qwp.cc	/^	QwpConfig() {$/;"	f	struct:QwpConfig	file:
QwpConfig	yosys/passes/cmds/qwp.cc	/^struct QwpConfig$/;"	s	file:
QwpPass	yosys/passes/cmds/qwp.cc	/^	QwpPass() : Pass("qwp", "quadratic wirelength placer") { }$/;"	f	struct:QwpPass	file:
QwpPass	yosys/passes/cmds/qwp.cc	/^struct QwpPass : public Pass {$/;"	s	file:
QwpPass	yosys/passes/cmds/qwp.cc	/^} QwpPass;$/;"	v	typeref:struct:QwpPass
QwpWorker	yosys/passes/cmds/qwp.cc	/^	QwpWorker(QwpConfig &config, Module *module, char direction = 'x') : config(config), module(mod/;"	f	struct:QwpWorker	file:
QwpWorker	yosys/passes/cmds/qwp.cc	/^struct QwpWorker$/;"	s	file:
RANLIB	yosys/Makefile	/^RANLIB = $(WASI_SDK)\/bin\/ranlib$/;"	m
RANLIB	yosys/Makefile	/^RANLIB = llvm-ranlib$/;"	m
REDUCTION_OPS	yosys/passes/opt/opt_share.cc	/^#define REDUCTION_OPS /;"	d	file:
REGISTER_H	yosys/kernel/register.h	/^#define REGISTER_H$/;"	d
RELATIONAL_OPS	yosys/passes/opt/opt_share.cc	/^#define RELATIONAL_OPS /;"	d	file:
RLIMIT_AS	yosys/libs/minisat/System.cc	/^#define RLIMIT_AS /;"	d	file:
RPATH	yosys/tests/unit/Makefile	/^RPATH := -Wl,-rpath$/;"	m
RTLIL	yosys/kernel/rtlil.h	/^namespace RTLIL$/;"	n
RTLIL	yosys/kernel/yosys.h	/^namespace RTLIL {$/;"	n
RTLILBackend	yosys/backends/rtlil/rtlil_backend.cc	/^	RTLILBackend() : Backend("rtlil", "write design to RTLIL file") { }$/;"	f	struct:RTLILBackend	file:
RTLILBackend	yosys/backends/rtlil/rtlil_backend.cc	/^struct RTLILBackend : public Backend {$/;"	s	file:
RTLILBackend	yosys/backends/rtlil/rtlil_backend.cc	/^} RTLILBackend;$/;"	v	typeref:struct:RTLILBackend
RTLILFrontend	yosys/frontends/rtlil/rtlil_frontend.cc	/^	RTLILFrontend() : Frontend("rtlil", "read modules from RTLIL file") { }$/;"	f	struct:RTLILFrontend	file:
RTLILFrontend	yosys/frontends/rtlil/rtlil_frontend.cc	/^struct RTLILFrontend : public Frontend {$/;"	s	file:
RTLILFrontend	yosys/frontends/rtlil/rtlil_frontend.cc	/^} RTLILFrontend;$/;"	v	typeref:struct:RTLILFrontend
RTLIL_BACKEND	yosys/backends/rtlil/rtlil_backend.h	/^namespace RTLIL_BACKEND {$/;"	n
RTLIL_BACKEND_H	yosys/backends/rtlil/rtlil_backend.h	/^#define RTLIL_BACKEND_H$/;"	d
RTLIL_FRONTEND	yosys/frontends/rtlil/rtlil_frontend.h	/^namespace RTLIL_FRONTEND {$/;"	n
RTLIL_FRONTEND_H	yosys/frontends/rtlil/rtlil_frontend.h	/^#define RTLIL_FRONTEND_H$/;"	d
RTLIL_H	yosys/kernel/rtlil.h	/^#define RTLIL_H$/;"	d
RUN_BITS	yosys/libs/fst/lz4.cc	/^#define RUN_BITS /;"	d	file:
RUN_MASK	yosys/libs/fst/lz4.cc	/^#define RUN_MASK /;"	d	file:
ReadPass	yosys/frontends/verific/verific.cc	/^	ReadPass() : Pass("read", "load HDL designs") { }$/;"	f	struct:ReadPass	file:
ReadPass	yosys/frontends/verific/verific.cc	/^struct ReadPass : public Pass {$/;"	s	file:
ReadPass	yosys/frontends/verific/verific.cc	/^} ReadPass;$/;"	v	typeref:struct:ReadPass
Ref	yosys/libs/minisat/Alloc.h	/^    typedef uint32_t Ref;$/;"	t	class:Minisat::RegionAllocator	typeref:typename:uint32_t
Ref_Undef	yosys/libs/minisat/Alloc.h	/^    enum { Ref_Undef = UINT32_MAX };$/;"	e	enum:Minisat::RegionAllocator::__anon5d4f57590103
RegionAllocator	yosys/libs/minisat/Alloc.h	/^    explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wast/;"	f	class:Minisat::RegionAllocator
RegionAllocator	yosys/libs/minisat/Alloc.h	/^class RegionAllocator$/;"	c	namespace:Minisat
RenamePass	yosys/passes/cmds/rename.cc	/^	RenamePass() : Pass("rename", "rename object in the design") { }$/;"	f	struct:RenamePass	file:
RenamePass	yosys/passes/cmds/rename.cc	/^struct RenamePass : public Pass {$/;"	s	file:
RenamePass	yosys/passes/cmds/rename.cc	/^} RenamePass;$/;"	v	typeref:struct:RenamePass
Result	yosys/libs/subcircuit/subcircuit.h	/^		struct Result {$/;"	s	class:SubCircuit::Solver
ResultNodeMapping	yosys/libs/subcircuit/subcircuit.h	/^		struct ResultNodeMapping {$/;"	s	class:SubCircuit::Solver
RevCellEdgesDatabase	yosys/kernel/celledges.h	/^	RevCellEdgesDatabase(SigMap &sigmap) : sigmap(sigmap) { }$/;"	f	struct:RevCellEdgesDatabase
RevCellEdgesDatabase	yosys/kernel/celledges.h	/^struct RevCellEdgesDatabase : AbstractCellEdgesDatabase$/;"	s
RewriteSigSpecWorker	yosys/kernel/rtlil.cc	/^	struct RewriteSigSpecWorker$/;"	s	function:RTLIL::Module::cloneInto	file:
RewriteSigSpecWorker	yosys/passes/equiv/equiv_miter.cc	/^		struct RewriteSigSpecWorker {$/;"	s	function:EquivMiterWorker::copy_to_miter	file:
RmportsPassPass	yosys/passes/opt/rmports.cc	/^	RmportsPassPass() : Pass("rmports", "remove module ports with no connections") { }$/;"	f	struct:RmportsPassPass	file:
RmportsPassPass	yosys/passes/opt/rmports.cc	/^struct RmportsPassPass : public Pass {$/;"	s	file:
RmportsPassPass	yosys/passes/opt/rmports.cc	/^} RmportsPassPass;$/;"	v	typeref:struct:RmportsPassPass
RpcFrontend	yosys/frontends/rpc/rpc_frontend.cc	/^	RpcFrontend() : Pass("connect_rpc", "connect to RPC frontend") { }$/;"	f	struct:RpcFrontend	file:
RpcFrontend	yosys/frontends/rpc/rpc_frontend.cc	/^struct RpcFrontend : public Pass {$/;"	s	file:
RpcFrontend	yosys/frontends/rpc/rpc_frontend.cc	/^} RpcFrontend;$/;"	v	typeref:struct:RpcFrontend
RpcModule	yosys/frontends/rpc/rpc_frontend.cc	/^struct RpcModule : RTLIL::Module {$/;"	s	file:
RpcServer	yosys/frontends/rpc/rpc_frontend.cc	/^	RpcServer(const std::string &name) : name(name) { }$/;"	f	struct:RpcServer	file:
RpcServer	yosys/frontends/rpc/rpc_frontend.cc	/^struct RpcServer {$/;"	s	file:
S	yosys/Makefile	/^S = -s$/;"	m
S	yosys/Makefile	/^S =$/;"	m
S0	yosys/kernel/rtlil.h	/^		S0 = 0,$/;"	e	enum:RTLIL::State
S1	yosys/kernel/rtlil.h	/^		S1 = 1,$/;"	e	enum:RTLIL::State
S32	yosys/libs/fst/lz4.cc	/^typedef int32_t S32;$/;"	t	typeref:typename:int32_t	file:
S32	yosys/libs/fst/lz4.cc	/^typedef signed int S32;$/;"	t	typeref:typename:signed int	file:
SANITIZER	yosys/Makefile	/^SANITIZER =$/;"	m
SATGEN_H	yosys/kernel/satgen.h	/^#define SATGEN_H$/;"	d
SED	yosys/Makefile	/^SED ?= sed$/;"	m
SEEDOPT	yosys/Makefile	/^SEEDOPT=""$/;"	m
SEEDOPT	yosys/Makefile	/^SEEDOPT="-S $(SEED)"$/;"	m
SEEDOPT	yosys/tests/tools/autotest.mk	/^SEEDOPT=-S$(SEED)$/;"	m
SET	yosys/libs/ezsat/ezsat.h	/^	void SET(_V a, _V b) {$/;"	f	class:ezSAT	typeref:typename:void
SHA1	yosys/libs/sha1/sha1.cpp	/^SHA1::SHA1()$/;"	f	class:SHA1
SHA1	yosys/libs/sha1/sha1.h	/^class SHA1$/;"	c
SHA1_BLK	yosys/libs/sha1/sha1.cpp	/^#define SHA1_BLK(/;"	d	file:
SHA1_HPP	yosys/libs/sha1/sha1.h	/^#define SHA1_HPP$/;"	d
SHA1_R0	yosys/libs/sha1/sha1.cpp	/^#define SHA1_R0(/;"	d	file:
SHA1_R1	yosys/libs/sha1/sha1.cpp	/^#define SHA1_R1(/;"	d	file:
SHA1_R2	yosys/libs/sha1/sha1.cpp	/^#define SHA1_R2(/;"	d	file:
SHA1_R3	yosys/libs/sha1/sha1.cpp	/^#define SHA1_R3(/;"	d	file:
SHA1_R4	yosys/libs/sha1/sha1.cpp	/^#define SHA1_R4(/;"	d	file:
SHA1_ROL	yosys/libs/sha1/sha1.cpp	/^#define SHA1_ROL(/;"	d	file:
SHIFT_OPS	yosys/passes/opt/opt_share.cc	/^#define SHIFT_OPS /;"	d	file:
SIGNED	yosys/frontends/verific/verific.cc	/^	#define SIGNED /;"	d	file:
SIGTOOLS_H	yosys/kernel/sigtools.h	/^#define SIGTOOLS_H$/;"	d
SIMPLEMAP_H	yosys/passes/techmap/simplemap.h	/^#define SIMPLEMAP_H$/;"	d
SINT	yosys/backends/cxxrtl/cxxrtl.h	/^		SINT   	= 2,$/;"	e	enum:cxxrtl::metadata::__anon481ec9d40203
SMALL	yosys/Makefile	/^SMALL = 0$/;"	m
SSIZE_MAX	yosys/libs/fst/fstapi.h	/^#define SSIZE_MAX /;"	d
ST0	yosys/kernel/rtlil.h	/^		ST0 = 0, \/\/ level sensitive: 0$/;"	e	enum:RTLIL::SyncType
ST1	yosys/kernel/rtlil.h	/^		ST1 = 1, \/\/ level sensitive: 1$/;"	e	enum:RTLIL::SyncType
STANDARD	yosys/libs/json11/json11.hpp	/^    STANDARD, COMMENTS$/;"	e	enum:json11::JsonParse
STAT_INT_MEMBERS	yosys/passes/cmds/stat.cc	/^	#define STAT_INT_MEMBERS /;"	d	file:
STAT_NUMERIC_MEMBERS	yosys/passes/cmds/stat.cc	/^	#define STAT_NUMERIC_MEMBERS /;"	d	file:
STEPSIZE	yosys/libs/fst/lz4.cc	/^#define STEPSIZE /;"	d	file:
STRING	yosys/backends/cxxrtl/cxxrtl.h	/^		STRING 	= 3,$/;"	e	enum:cxxrtl::metadata::__anon481ec9d40203
STRING	yosys/libs/json11/json11.hpp	/^        NUL, NUMBER, BOOL, STRING, ARRAY, OBJECT$/;"	e	enum:json11::Json::Type
STRIP	yosys/Makefile	/^STRIP ?= strip$/;"	m
STa	yosys/kernel/rtlil.h	/^		STa = 5, \/\/ always active$/;"	e	enum:RTLIL::SyncType
STe	yosys/kernel/rtlil.h	/^		STe = 4, \/\/ edge sensitive: both edges$/;"	e	enum:RTLIL::SyncType
STg	yosys/kernel/rtlil.h	/^		STg = 6, \/\/ global clock$/;"	e	enum:RTLIL::SyncType
STi	yosys/kernel/rtlil.h	/^		STi = 7  \/\/ init$/;"	e	enum:RTLIL::SyncType
STn	yosys/kernel/rtlil.h	/^		STn = 3, \/\/ edge sensitive: negedge$/;"	e	enum:RTLIL::SyncType
STp	yosys/kernel/rtlil.h	/^		STp = 2, \/\/ edge sensitive: posedge$/;"	e	enum:RTLIL::SyncType
SUBCIRCUIT_H	yosys/libs/subcircuit/subcircuit.h	/^#define SUBCIRCUIT_H$/;"	d
SYNC	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	SYNC = 2,$/;"	e	enum:CxxrtlPortType	file:
S__LINE__	yosys/kernel/log.h	/^#define S__LINE__ /;"	d
S__LINE__sub1	yosys/kernel/log.h	/^#define S__LINE__sub1(/;"	d
S__LINE__sub2	yosys/kernel/log.h	/^#define S__LINE__sub2(/;"	d
Sa	yosys/kernel/rtlil.h	/^		Sa = 4, \/\/ don't care (used only in cases)$/;"	e	enum:RTLIL::State
SatGen	yosys/kernel/satgen.h	/^	SatGen(ezSAT *ez, SigMap *sigmap, std::string prefix = std::string()) :$/;"	f	struct:SatGen
SatGen	yosys/kernel/satgen.h	/^struct SatGen$/;"	s
SatHelper	yosys/passes/sat/sat.cc	/^	SatHelper(RTLIL::Design *design, RTLIL::Module *module, bool enable_undef) :$/;"	f	struct:SatHelper	file:
SatHelper	yosys/passes/sat/sat.cc	/^struct SatHelper$/;"	s	file:
SatPass	yosys/passes/sat/sat.cc	/^	SatPass() : Pass("sat", "solve a SAT problem in the circuit") { }$/;"	f	struct:SatPass	file:
SatPass	yosys/passes/sat/sat.cc	/^struct SatPass : public Pass {$/;"	s	file:
SatPass	yosys/passes/sat/sat.cc	/^} SatPass;$/;"	v	typeref:struct:SatPass
SatSolver	yosys/kernel/satgen.h	/^	SatSolver(string name) : name(name) {$/;"	f	struct:SatSolver
SatSolver	yosys/kernel/satgen.h	/^struct SatSolver$/;"	s
ScanModule	yosys/passes/opt/rmports.cc	/^	void ScanModule(Module* module, dict<IdString, pool<IdString>> &removed_ports)$/;"	f	struct:RmportsPassPass	typeref:typename:void	file:
ScatterPass	yosys/passes/cmds/scatter.cc	/^	ScatterPass() : Pass("scatter", "add additional intermediate nets") { }$/;"	f	struct:ScatterPass	file:
ScatterPass	yosys/passes/cmds/scatter.cc	/^struct ScatterPass : public Pass {$/;"	s	file:
ScatterPass	yosys/passes/cmds/scatter.cc	/^} ScatterPass;$/;"	v	typeref:struct:ScatterPass
SccPass	yosys/passes/cmds/scc.cc	/^	SccPass() : Pass("scc", "detect strongly connected components (logic loops)") { }$/;"	f	struct:SccPass	file:
SccPass	yosys/passes/cmds/scc.cc	/^struct SccPass : public Pass {$/;"	s	file:
SccPass	yosys/passes/cmds/scc.cc	/^} SccPass;$/;"	v	typeref:struct:SccPass
SccWorker	yosys/passes/cmds/scc.cc	/^	SccWorker(RTLIL::Design *design, RTLIL::Module *module, bool nofeedbackMode, bool allCellTypes,/;"	f	struct:SccWorker	file:
SccWorker	yosys/passes/cmds/scc.cc	/^struct SccWorker$/;"	s	file:
Scheduler	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^struct Scheduler {$/;"	s	file:
ScratchpadPass	yosys/passes/cmds/scratchpad.cc	/^	ScratchpadPass() : Pass("scratchpad", "get\/set values in the scratchpad") { }$/;"	f	struct:ScratchpadPass	file:
ScratchpadPass	yosys/passes/cmds/scratchpad.cc	/^struct ScratchpadPass : public Pass {$/;"	s	file:
ScratchpadPass	yosys/passes/cmds/scratchpad.cc	/^} ScratchpadPass;$/;"	v	typeref:struct:ScratchpadPass
ScriptCmdPass	yosys/kernel/yosys.cc	/^	ScriptCmdPass() : Pass("script", "execute commands from file or wire") { }$/;"	f	struct:ScriptCmdPass	file:
ScriptCmdPass	yosys/kernel/yosys.cc	/^struct ScriptCmdPass : public Pass {$/;"	s	file:
ScriptCmdPass	yosys/kernel/yosys.cc	/^} ScriptCmdPass;$/;"	v	typeref:struct:ScriptCmdPass
ScriptPass	yosys/kernel/register.h	/^	ScriptPass(std::string name, std::string short_help = "** document me **") : Pass(name, short_h/;"	f	struct:ScriptPass
ScriptPass	yosys/kernel/register.h	/^struct ScriptPass : Pass$/;"	s
SelectPass	yosys/passes/cmds/select.cc	/^	SelectPass() : Pass("select", "modify and view the list of selected objects") { }$/;"	f	struct:SelectPass	file:
SelectPass	yosys/passes/cmds/select.cc	/^struct SelectPass : public Pass {$/;"	s	file:
SelectPass	yosys/passes/cmds/select.cc	/^} SelectPass;$/;"	v	typeref:struct:SelectPass
Selection	yosys/kernel/rtlil.h	/^	Selection(bool full = true) : full_selection(full) { }$/;"	f	struct:RTLIL::Selection
Selection	yosys/kernel/rtlil.h	/^struct RTLIL::Selection$/;"	s	class:RTLIL
SetattrPass	yosys/passes/cmds/setattr.cc	/^	SetattrPass() : Pass("setattr", "set\/unset attributes on objects") { }$/;"	f	struct:SetattrPass	file:
SetattrPass	yosys/passes/cmds/setattr.cc	/^struct SetattrPass : public Pass {$/;"	s	file:
SetattrPass	yosys/passes/cmds/setattr.cc	/^} SetattrPass;$/;"	v	typeref:struct:SetattrPass
SetparamPass	yosys/passes/cmds/setattr.cc	/^	SetparamPass() : Pass("setparam", "set\/unset parameters on objects") { }$/;"	f	struct:SetparamPass	file:
SetparamPass	yosys/passes/cmds/setattr.cc	/^struct SetparamPass : public Pass {$/;"	s	file:
SetparamPass	yosys/passes/cmds/setattr.cc	/^} SetparamPass;$/;"	v	typeref:struct:SetparamPass
SetundefPass	yosys/passes/cmds/setundef.cc	/^	SetundefPass() : Pass("setundef", "replace undef values with defined constants") { }$/;"	f	struct:SetundefPass	file:
SetundefPass	yosys/passes/cmds/setundef.cc	/^struct SetundefPass : public Pass {$/;"	s	file:
SetundefPass	yosys/passes/cmds/setundef.cc	/^} SetundefPass;$/;"	v	typeref:struct:SetundefPass
SetundefWorker	yosys/passes/cmds/setundef.cc	/^struct SetundefWorker$/;"	s	file:
SharePass	yosys/passes/opt/share.cc	/^	SharePass() : Pass("share", "perform sat-based resource sharing") { }$/;"	f	struct:SharePass	file:
SharePass	yosys/passes/opt/share.cc	/^struct SharePass : public Pass {$/;"	s	file:
SharePass	yosys/passes/opt/share.cc	/^} SharePass;$/;"	v	typeref:struct:SharePass
ShareWorker	yosys/passes/opt/share.cc	/^	ShareWorker(ShareWorkerConfig config, RTLIL::Design* design) :$/;"	f	struct:ShareWorker	file:
ShareWorker	yosys/passes/opt/share.cc	/^struct ShareWorker$/;"	s	file:
ShareWorkerConfig	yosys/passes/opt/share.cc	/^struct ShareWorkerConfig$/;"	s	file:
ShellPass	yosys/kernel/yosys.cc	/^	ShellPass() : Pass("shell", "enter interactive command mode") { }$/;"	f	struct:ShellPass	file:
ShellPass	yosys/kernel/yosys.cc	/^struct ShellPass : public Pass {$/;"	s	file:
ShellPass	yosys/kernel/yosys.cc	/^} ShellPass;$/;"	v	typeref:struct:ShellPass
ShowPass	yosys/passes/cmds/show.cc	/^	ShowPass() : Pass("show", "generate schematics using graphviz") { }$/;"	f	struct:ShowPass	file:
ShowPass	yosys/passes/cmds/show.cc	/^struct ShowPass : public Pass {$/;"	s	file:
ShowPass	yosys/passes/cmds/show.cc	/^} ShowPass;$/;"	v	typeref:struct:ShowPass
ShowWorker	yosys/passes/cmds/show.cc	/^	ShowWorker(FILE *f, RTLIL::Design *design, std::vector<RTLIL::Design*> &libs, uint32_t colorSee/;"	f	struct:ShowWorker	file:
ShowWorker	yosys/passes/cmds/show.cc	/^struct ShowWorker$/;"	s	file:
ShregmapOptions	yosys/passes/techmap/shregmap.cc	/^	ShregmapOptions()$/;"	f	struct:ShregmapOptions	file:
ShregmapOptions	yosys/passes/techmap/shregmap.cc	/^struct ShregmapOptions$/;"	s	file:
ShregmapPass	yosys/passes/techmap/shregmap.cc	/^	ShregmapPass() : Pass("shregmap", "map shift registers") { }$/;"	f	struct:ShregmapPass	file:
ShregmapPass	yosys/passes/techmap/shregmap.cc	/^struct ShregmapPass : public Pass {$/;"	s	file:
ShregmapPass	yosys/passes/techmap/shregmap.cc	/^} ShregmapPass;$/;"	v	typeref:struct:ShregmapPass
ShregmapTech	yosys/passes/techmap/shregmap.cc	/^struct ShregmapTech$/;"	s	file:
ShregmapTechGreenpak4	yosys/passes/techmap/shregmap.cc	/^struct ShregmapTechGreenpak4 : ShregmapTech$/;"	s	file:
ShregmapWorker	yosys/passes/techmap/shregmap.cc	/^	ShregmapWorker(Module *module, const ShregmapOptions &opts) :$/;"	f	struct:ShregmapWorker	file:
ShregmapWorker	yosys/passes/techmap/shregmap.cc	/^struct ShregmapWorker$/;"	s	file:
ShrinkStackElem	yosys/libs/minisat/Solver.h	/^        ShrinkStackElem(uint32_t _i, Lit _l) : i(_i), l(_l){}$/;"	f	struct:Minisat::Solver::ShrinkStackElem
ShrinkStackElem	yosys/libs/minisat/Solver.h	/^    struct ShrinkStackElem {$/;"	s	class:Minisat::Solver
SigBit	yosys/kernel/rtlil.h	/^inline RTLIL::SigBit::SigBit() : wire(NULL), data(RTLIL::State::S0) { }$/;"	f	class:RTLIL::SigBit
SigBit	yosys/kernel/rtlil.h	/^inline RTLIL::SigBit::SigBit(RTLIL::State bit) : wire(NULL), data(bit) { }$/;"	f	class:RTLIL::SigBit
SigBit	yosys/kernel/rtlil.h	/^inline RTLIL::SigBit::SigBit(RTLIL::Wire *wire) : wire(wire), offset(0) { log_assert(wire && wir/;"	f	class:RTLIL::SigBit
SigBit	yosys/kernel/rtlil.h	/^inline RTLIL::SigBit::SigBit(RTLIL::Wire *wire, int offset) : wire(wire), offset(offset) { log_a/;"	f	class:RTLIL::SigBit
SigBit	yosys/kernel/rtlil.h	/^inline RTLIL::SigBit::SigBit(bool bit) : wire(NULL), data(bit ? State::S1 : State::S0) { }$/;"	f	class:RTLIL::SigBit
SigBit	yosys/kernel/rtlil.h	/^inline RTLIL::SigBit::SigBit(const RTLIL::SigChunk &chunk) : wire(chunk.wire) { log_assert(chunk/;"	f	class:RTLIL::SigBit
SigBit	yosys/kernel/rtlil.h	/^inline RTLIL::SigBit::SigBit(const RTLIL::SigChunk &chunk, int index) : wire(chunk.wire) { if (w/;"	f	class:RTLIL::SigBit
SigBit	yosys/kernel/rtlil.h	/^inline RTLIL::SigBit::SigBit(const RTLIL::SigSpec &sig) {$/;"	f	class:RTLIL::SigBit
SigBit	yosys/kernel/rtlil.h	/^struct RTLIL::SigBit$/;"	s	class:RTLIL
SigBitInfo	yosys/kernel/modtools.h	/^		SigBitInfo() : is_input(false), is_output(false) { }$/;"	f	struct:ModIndex::SigBitInfo
SigBitInfo	yosys/kernel/modtools.h	/^	struct SigBitInfo$/;"	s	struct:ModIndex
SigChunk	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk::SigChunk()$/;"	f	class:RTLIL::SigChunk
SigChunk	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk::SigChunk(RTLIL::State bit, int width)$/;"	f	class:RTLIL::SigChunk
SigChunk	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk::SigChunk(RTLIL::Wire *wire)$/;"	f	class:RTLIL::SigChunk
SigChunk	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk::SigChunk(RTLIL::Wire *wire, int offset, int width)$/;"	f	class:RTLIL::SigChunk
SigChunk	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk::SigChunk(const RTLIL::Const &value)$/;"	f	class:RTLIL::SigChunk
SigChunk	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk::SigChunk(const RTLIL::SigBit &bit)$/;"	f	class:RTLIL::SigChunk
SigChunk	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk::SigChunk(const RTLIL::SigChunk &sigchunk)$/;"	f	class:RTLIL::SigChunk
SigChunk	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk::SigChunk(const std::string &str)$/;"	f	class:RTLIL::SigChunk
SigChunk	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk::SigChunk(int val, int width)$/;"	f	class:RTLIL::SigChunk
SigChunk	yosys/kernel/rtlil.h	/^struct RTLIL::SigChunk$/;"	s	class:RTLIL
SigMap	yosys/kernel/sigtools.h	/^	SigMap(RTLIL::Module *module = NULL)$/;"	f	struct:SigMap
SigMap	yosys/kernel/sigtools.h	/^struct SigMap$/;"	s
SigPool	yosys/kernel/sigtools.h	/^struct SigPool$/;"	s
SigSet	yosys/kernel/sigtools.h	/^class SigSet<T, sort_by_name_id_guard<T>> : public SigSet<T, RTLIL::sort_by_name_id<typename std/;"	c
SigSet	yosys/kernel/sigtools.h	/^class SigSet<T, typename std::enable_if<!std::is_pointer<T>::value>::type> : public SigSet<T, st/;"	c
SigSet	yosys/kernel/sigtools.h	/^struct SigSet$/;"	s
SigSig	yosys/kernel/rtlil.h	/^	typedef std::pair<SigSpec, SigSpec> SigSig;$/;"	t	namespace:RTLIL	typeref:typename:std::pair<SigSpec,SigSpec>
SigSnippets	yosys/passes/proc/proc_mux.cc	/^struct SigSnippets$/;"	s	file:
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec()$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(RTLIL::State bit, int width)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(RTLIL::Wire *wire)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(RTLIL::Wire *wire, int offset, int width)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(bool bit)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(const RTLIL::Const &value)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(const RTLIL::SigBit &bit, int width)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(const RTLIL::SigChunk &chunk)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(const RTLIL::SigSpec &other)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(const pool<RTLIL::SigBit> &bits)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(const std::set<RTLIL::SigBit> &bits)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(const std::string &str)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(const std::vector<RTLIL::SigBit> &bits)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(const std::vector<RTLIL::SigChunk> &chunks)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(int val, int width)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec::SigSpec(std::initializer_list<RTLIL::SigSpec> parts)$/;"	f	class:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.h	/^	SigSpec(RTLIL::SigSpec &&other) {$/;"	f	struct:RTLIL::SigSpec
SigSpec	yosys/kernel/rtlil.h	/^struct RTLIL::SigSpec$/;"	s	class:RTLIL
SigSpecConstIterator	yosys/kernel/rtlil.h	/^struct RTLIL::SigSpecConstIterator : public std::iterator<std::input_iterator_tag, RTLIL::SigSpe/;"	s	class:RTLIL
SigSpecIterator	yosys/kernel/rtlil.h	/^struct RTLIL::SigSpecIterator : public std::iterator<std::input_iterator_tag, RTLIL::SigSpec>$/;"	s	class:RTLIL
Sign	yosys/libs/bigint/BigInteger.hh	/^	enum Sign { negative = -1, zero = 0, positive = 1 };$/;"	g	class:BigInteger
SimInstance	yosys/passes/sat/sim.cc	/^	SimInstance(SimShared *shared, std::string scope, Module *module, Cell *instance = nullptr, Sim/;"	f	struct:SimInstance	file:
SimInstance	yosys/passes/sat/sim.cc	/^struct SimInstance$/;"	s	file:
SimPass	yosys/passes/sat/sim.cc	/^	SimPass() : Pass("sim", "simulate the circuit") { }$/;"	f	struct:SimPass	file:
SimPass	yosys/passes/sat/sim.cc	/^struct SimPass : public Pass {$/;"	s	file:
SimPass	yosys/passes/sat/sim.cc	/^} SimPass;$/;"	v	typeref:struct:SimPass
SimShared	yosys/passes/sat/sim.cc	/^struct SimShared$/;"	s	file:
SimWorker	yosys/passes/sat/sim.cc	/^struct SimWorker : SimShared$/;"	s	file:
SimpSolver	yosys/libs/minisat/SimpSolver.cc	/^SimpSolver::SimpSolver() :$/;"	f	class:SimpSolver
SimpSolver	yosys/libs/minisat/SimpSolver.h	/^class SimpSolver : public Solver {$/;"	c	namespace:Minisat
SimplecBackend	yosys/backends/simplec/simplec.cc	/^	SimplecBackend() : Backend("simplec", "convert design to simple C code") { }$/;"	f	struct:SimplecBackend	file:
SimplecBackend	yosys/backends/simplec/simplec.cc	/^struct SimplecBackend : public Backend {$/;"	s	file:
SimplecBackend	yosys/backends/simplec/simplec.cc	/^} SimplecBackend;$/;"	v	typeref:struct:SimplecBackend
SimplecWorker	yosys/backends/simplec/simplec.cc	/^	SimplecWorker(Design *design) : design(design)$/;"	f	struct:SimplecWorker	file:
SimplecWorker	yosys/backends/simplec/simplec.cc	/^struct SimplecWorker$/;"	s	file:
SimplemapPass	yosys/passes/techmap/simplemap.cc	/^	SimplemapPass() : Pass("simplemap", "mapping simple coarse-grain cells") { }$/;"	f	struct:SimplemapPass	file:
SimplemapPass	yosys/passes/techmap/simplemap.cc	/^struct SimplemapPass : public Pass {$/;"	s	file:
SimplemapPass	yosys/passes/techmap/simplemap.cc	/^} SimplemapPass;$/;"	v	typeref:struct:SimplemapPass
SimulationMode	yosys/passes/sat/sim.cc	/^enum class SimulationMode {$/;"	g	file:
Size	yosys/libs/minisat/Vec.h	/^    typedef _Size Size;$/;"	t	class:Minisat::vec	typeref:typename:_Size
Slack	yosys/passes/techmap/flowmap.cc	/^		Slack,$/;"	e	enum:FlowmapWorker::GraphMode	file:
Sm	yosys/kernel/rtlil.h	/^		Sm = 5  \/\/ marker (used internally by some passes)$/;"	e	enum:RTLIL::State
Smt2Backend	yosys/backends/smt2/smt2.cc	/^	Smt2Backend() : Backend("smt2", "write design to SMT-LIBv2 file") { }$/;"	f	struct:Smt2Backend	file:
Smt2Backend	yosys/backends/smt2/smt2.cc	/^struct Smt2Backend : public Backend {$/;"	s	file:
Smt2Backend	yosys/backends/smt2/smt2.cc	/^} Smt2Backend;$/;"	v	typeref:struct:Smt2Backend
Smt2Worker	yosys/backends/smt2/smt2.cc	/^	Smt2Worker(RTLIL::Module *module, bool bvmode, bool memmode, bool wiresmode, bool verbose, bool/;"	f	struct:Smt2Worker	file:
Smt2Worker	yosys/backends/smt2/smt2.cc	/^struct Smt2Worker$/;"	s	file:
SmvBackend	yosys/backends/smv/smv.cc	/^	SmvBackend() : Backend("smv", "write design to SMV file") { }$/;"	f	struct:SmvBackend	file:
SmvBackend	yosys/backends/smv/smv.cc	/^struct SmvBackend : public Backend {$/;"	s	file:
SmvBackend	yosys/backends/smv/smv.cc	/^} SmvBackend;$/;"	v	typeref:struct:SmvBackend
SmvWorker	yosys/backends/smv/smv.cc	/^	SmvWorker(RTLIL::Module *module, bool verbose, std::ostream &f) :$/;"	f	struct:SmvWorker	file:
SmvWorker	yosys/backends/smv/smv.cc	/^struct SmvWorker$/;"	s	file:
SnippetSwCache	yosys/passes/proc/proc_mux.cc	/^struct SnippetSwCache$/;"	s	file:
Solver	yosys/libs/ezsat/ezminisat.h	/^	typedef Minisat::SimpSolver Solver;$/;"	t	class:ezMiniSAT	typeref:typename:Minisat::SimpSolver
Solver	yosys/libs/minisat/Solver.cc	/^Solver::Solver() :$/;"	f	class:Solver
Solver	yosys/libs/minisat/Solver.h	/^class Solver {$/;"	c	namespace:Minisat
Solver	yosys/libs/subcircuit/subcircuit.cc	/^SubCircuit::Solver::Solver()$/;"	f	class:SubCircuit::Solver
Solver	yosys/libs/subcircuit/subcircuit.h	/^	class Solver$/;"	c	namespace:SubCircuit
Solver	yosys/passes/sat/qbfsat.h	/^	enum Solver{Z3, Yices, CVC4} solver = Yices;$/;"	g	struct:QbfSolveOptions
SolverWorker	yosys/libs/subcircuit/subcircuit.cc	/^	SolverWorker(Solver *userSolver) : userSolver(userSolver), verbose(false)$/;"	f	class:SubCircuit::SolverWorker	file:
SolverWorker	yosys/libs/subcircuit/subcircuit.cc	/^class SubCircuit::SolverWorker$/;"	c	class:SubCircuit	file:
SpiceBackend	yosys/backends/spice/spice.cc	/^	SpiceBackend() : Backend("spice", "write design to SPICE netlist file") { }$/;"	f	struct:SpiceBackend	file:
SpiceBackend	yosys/backends/spice/spice.cc	/^struct SpiceBackend : public Backend {$/;"	s	file:
SpiceBackend	yosys/backends/spice/spice.cc	/^} SpiceBackend;$/;"	v	typeref:struct:SpiceBackend
SplicePass	yosys/passes/cmds/splice.cc	/^	SplicePass() : Pass("splice", "create explicit splicing cells") { }$/;"	f	struct:SplicePass	file:
SplicePass	yosys/passes/cmds/splice.cc	/^struct SplicePass : public Pass {$/;"	s	file:
SplicePass	yosys/passes/cmds/splice.cc	/^} SplicePass;$/;"	v	typeref:struct:SplicePass
SpliceWorker	yosys/passes/cmds/splice.cc	/^	SpliceWorker(RTLIL::Design *design, RTLIL::Module *module) : design(design), module(module), ct/;"	f	struct:SpliceWorker	file:
SpliceWorker	yosys/passes/cmds/splice.cc	/^struct SpliceWorker$/;"	s	file:
SplitnetsPass	yosys/passes/cmds/splitnets.cc	/^	SplitnetsPass() : Pass("splitnets", "split up multi-bit nets") { }$/;"	f	struct:SplitnetsPass	file:
SplitnetsPass	yosys/passes/cmds/splitnets.cc	/^struct SplitnetsPass : public Pass {$/;"	s	file:
SplitnetsPass	yosys/passes/cmds/splitnets.cc	/^} SplitnetsPass;$/;"	v	typeref:struct:SplitnetsPass
SplitnetsWorker	yosys/passes/cmds/splitnets.cc	/^struct SplitnetsWorker$/;"	s	file:
StaPass	yosys/passes/cmds/sta.cc	/^	StaPass() : Pass("sta", "perform static timing analysis") { }$/;"	f	struct:StaPass	file:
StaPass	yosys/passes/cmds/sta.cc	/^struct StaPass : public Pass {$/;"	s	file:
StaPass	yosys/passes/cmds/sta.cc	/^} StaPass;$/;"	v	typeref:struct:StaPass
StaWorker	yosys/passes/cmds/sta.cc	/^	StaWorker(RTLIL::Module *module) : design(module->design), module(module), sigmap(module), maxa/;"	f	struct:StaWorker	file:
StaWorker	yosys/passes/cmds/sta.cc	/^struct StaWorker$/;"	s	file:
StatPass	yosys/passes/cmds/stat.cc	/^	StatPass() : Pass("stat", "print some statistics") { }$/;"	f	struct:StatPass	file:
StatPass	yosys/passes/cmds/stat.cc	/^struct StatPass : public Pass {$/;"	s	file:
StatPass	yosys/passes/cmds/stat.cc	/^} StatPass;$/;"	v	typeref:struct:StatPass
State	yosys/kernel/rtlil.h	/^	enum State : unsigned char {$/;"	g	namespace:RTLIL	typeref:typename:unsigned char
Statics	yosys/libs/json11/json11.cpp	/^    Statics() {}$/;"	f	struct:json11::Statics	file:
Statics	yosys/libs/json11/json11.cpp	/^struct Statics {$/;"	s	namespace:json11	file:
StreamBuffer	yosys/libs/minisat/ParseUtils.h	/^class StreamBuffer {$/;"	c	namespace:Minisat
StringOption	yosys/libs/minisat/Options.h	/^    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) $/;"	f	class:Minisat::StringOption
StringOption	yosys/libs/minisat/Options.h	/^class StringOption : public Option$/;"	c	namespace:Minisat
StubnetsPass	yosys/manual/CHAPTER_Prog/stubnets.cc	/^	StubnetsPass() : Pass("stubnets") { }$/;"	f	struct:StubnetsPass	file:
StubnetsPass	yosys/manual/CHAPTER_Prog/stubnets.cc	/^struct StubnetsPass : public Pass {$/;"	s	file:
StubnetsPass	yosys/manual/CHAPTER_Prog/stubnets.cc	/^} StubnetsPass;$/;"	v	typeref:struct:StubnetsPass
SubCircuit	yosys/libs/subcircuit/subcircuit.h	/^namespace SubCircuit$/;"	n
SubCircuitSolver	yosys/passes/techmap/extract.cc	/^	SubCircuitSolver() : ignore_parameters(false)$/;"	f	class:SubCircuitSolver	file:
SubCircuitSolver	yosys/passes/techmap/extract.cc	/^class SubCircuitSolver : public SubCircuit::Solver$/;"	c	file:
SubModule	yosys/passes/hierarchy/submod.cc	/^	struct SubModule$/;"	s	struct:SubmodWorker	file:
SubmodPass	yosys/passes/hierarchy/submod.cc	/^	SubmodPass() : Pass("submod", "moving part of a module to a new submodule") { }$/;"	f	struct:SubmodPass	file:
SubmodPass	yosys/passes/hierarchy/submod.cc	/^struct SubmodPass : public Pass {$/;"	s	file:
SubmodPass	yosys/passes/hierarchy/submod.cc	/^} SubmodPass;$/;"	v	typeref:struct:SubmodPass
SubmodWorker	yosys/passes/hierarchy/submod.cc	/^	SubmodWorker(RTLIL::Design *design, RTLIL::Module *module, bool copy_mode = false, bool hidden_/;"	f	struct:SubmodWorker	file:
SubmodWorker	yosys/passes/hierarchy/submod.cc	/^struct SubmodWorker$/;"	s	file:
SupercoverPass	yosys/passes/sat/supercover.cc	/^	SupercoverPass() : Pass("supercover", "add hi\/lo cover cells for each wire bit") { }$/;"	f	struct:SupercoverPass	file:
SupercoverPass	yosys/passes/sat/supercover.cc	/^struct SupercoverPass : public Pass {$/;"	s	file:
SupercoverPass	yosys/passes/sat/supercover.cc	/^} SupercoverPass;$/;"	v	typeref:struct:SupercoverPass
SvaDFsmNode	yosys/frontends/verific/verificsva.cc	/^struct SvaDFsmNode$/;"	s	file:
SvaFsm	yosys/frontends/verific/verificsva.cc	/^	SvaFsm(const VerificClocking &clking, SigBit trig = State::S1)$/;"	f	struct:SvaFsm	file:
SvaFsm	yosys/frontends/verific/verificsva.cc	/^struct SvaFsm$/;"	s	file:
SvaNFsmNode	yosys/frontends/verific/verificsva.cc	/^struct SvaNFsmNode$/;"	s	file:
SvaUFsmNode	yosys/frontends/verific/verificsva.cc	/^struct SvaUFsmNode$/;"	s	file:
SwitchRule	yosys/kernel/rtlil.h	/^struct RTLIL::SwitchRule : public RTLIL::AttrObject$/;"	s	class:RTLIL
Sx	yosys/kernel/rtlil.h	/^		Sx = 2, \/\/ undefined value or conflict$/;"	e	enum:RTLIL::State
SyncRequired	yosys/frontends/ast/simplify.cc	/^	SyncRequired, \/\/ target variable may be used before it has been assigned$/;"	e	enum:IdentUsage	file:
SyncRule	yosys/kernel/rtlil.h	/^struct RTLIL::SyncRule$/;"	s	class:RTLIL
SyncType	yosys/kernel/rtlil.h	/^	enum SyncType : unsigned char {$/;"	g	namespace:RTLIL	typeref:typename:unsigned char
SynthAchronixPass	yosys/techlibs/achronix/synth_achronix.cc	/^  SynthAchronixPass() : ScriptPass("synth_achronix", "synthesis for Acrhonix Speedster22i FPGAs./;"	f	struct:SynthAchronixPass	file:
SynthAchronixPass	yosys/techlibs/achronix/synth_achronix.cc	/^struct SynthAchronixPass : public ScriptPass {$/;"	s	file:
SynthAchronixPass	yosys/techlibs/achronix/synth_achronix.cc	/^} SynthAchronixPass;$/;"	v	typeref:struct:SynthAchronixPass
SynthAnlogicPass	yosys/techlibs/anlogic/synth_anlogic.cc	/^	SynthAnlogicPass() : ScriptPass("synth_anlogic", "synthesis for Anlogic FPGAs") { }$/;"	f	struct:SynthAnlogicPass	file:
SynthAnlogicPass	yosys/techlibs/anlogic/synth_anlogic.cc	/^struct SynthAnlogicPass : public ScriptPass$/;"	s	file:
SynthAnlogicPass	yosys/techlibs/anlogic/synth_anlogic.cc	/^} SynthAnlogicPass;$/;"	v	typeref:struct:SynthAnlogicPass
SynthCoolrunner2Pass	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^	SynthCoolrunner2Pass() : ScriptPass("synth_coolrunner2", "synthesis for Xilinx Coolrunner-II CP/;"	f	struct:SynthCoolrunner2Pass	file:
SynthCoolrunner2Pass	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^struct SynthCoolrunner2Pass : public ScriptPass$/;"	s	file:
SynthCoolrunner2Pass	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^} SynthCoolrunner2Pass;$/;"	v	typeref:struct:SynthCoolrunner2Pass
SynthEasicPass	yosys/techlibs/easic/synth_easic.cc	/^	SynthEasicPass() : ScriptPass("synth_easic", "synthesis for eASIC platform") { }$/;"	f	struct:SynthEasicPass	file:
SynthEasicPass	yosys/techlibs/easic/synth_easic.cc	/^struct SynthEasicPass : public ScriptPass$/;"	s	file:
SynthEasicPass	yosys/techlibs/easic/synth_easic.cc	/^} SynthEasicPass;$/;"	v	typeref:struct:SynthEasicPass
SynthEcp5Pass	yosys/techlibs/ecp5/synth_ecp5.cc	/^	SynthEcp5Pass() : ScriptPass("synth_ecp5", "synthesis for ECP5 FPGAs") { }$/;"	f	struct:SynthEcp5Pass	file:
SynthEcp5Pass	yosys/techlibs/ecp5/synth_ecp5.cc	/^struct SynthEcp5Pass : public ScriptPass$/;"	s	file:
SynthEcp5Pass	yosys/techlibs/ecp5/synth_ecp5.cc	/^} SynthEcp5Pass;$/;"	v	typeref:struct:SynthEcp5Pass
SynthEfinixPass	yosys/techlibs/efinix/synth_efinix.cc	/^	SynthEfinixPass() : ScriptPass("synth_efinix", "synthesis for Efinix FPGAs") { }$/;"	f	struct:SynthEfinixPass	file:
SynthEfinixPass	yosys/techlibs/efinix/synth_efinix.cc	/^struct SynthEfinixPass : public ScriptPass$/;"	s	file:
SynthEfinixPass	yosys/techlibs/efinix/synth_efinix.cc	/^} SynthEfinixPass;$/;"	v	typeref:struct:SynthEfinixPass
SynthGateMatePass	yosys/techlibs/gatemate/synth_gatemate.cc	/^	SynthGateMatePass() : ScriptPass("synth_gatemate", "synthesis for Cologne Chip GateMate FPGAs")/;"	f	struct:SynthGateMatePass	file:
SynthGateMatePass	yosys/techlibs/gatemate/synth_gatemate.cc	/^struct SynthGateMatePass : public ScriptPass$/;"	s	file:
SynthGateMatePass	yosys/techlibs/gatemate/synth_gatemate.cc	/^} SynthGateMatePass;$/;"	v	typeref:struct:SynthGateMatePass
SynthGowinPass	yosys/techlibs/gowin/synth_gowin.cc	/^	SynthGowinPass() : ScriptPass("synth_gowin", "synthesis for Gowin FPGAs") { }$/;"	f	struct:SynthGowinPass	file:
SynthGowinPass	yosys/techlibs/gowin/synth_gowin.cc	/^struct SynthGowinPass : public ScriptPass$/;"	s	file:
SynthGowinPass	yosys/techlibs/gowin/synth_gowin.cc	/^} SynthGowinPass;$/;"	v	typeref:struct:SynthGowinPass
SynthGreenPAK4Pass	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^	SynthGreenPAK4Pass() : ScriptPass("synth_greenpak4", "synthesis for GreenPAK4 FPGAs") { }$/;"	f	struct:SynthGreenPAK4Pass	file:
SynthGreenPAK4Pass	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^struct SynthGreenPAK4Pass : public ScriptPass$/;"	s	file:
SynthGreenPAK4Pass	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^} SynthGreenPAK4Pass;$/;"	v	typeref:struct:SynthGreenPAK4Pass
SynthIce40Pass	yosys/techlibs/ice40/synth_ice40.cc	/^	SynthIce40Pass() : ScriptPass("synth_ice40", "synthesis for iCE40 FPGAs") { }$/;"	f	struct:SynthIce40Pass	file:
SynthIce40Pass	yosys/techlibs/ice40/synth_ice40.cc	/^struct SynthIce40Pass : public ScriptPass$/;"	s	file:
SynthIce40Pass	yosys/techlibs/ice40/synth_ice40.cc	/^} SynthIce40Pass;$/;"	v	typeref:struct:SynthIce40Pass
SynthIntelALMPass	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	SynthIntelALMPass() : ScriptPass("synth_intel_alm", "synthesis for ALM-based Intel (Altera) FPG/;"	f	struct:SynthIntelALMPass	file:
SynthIntelALMPass	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^struct SynthIntelALMPass : public ScriptPass {$/;"	s	file:
SynthIntelALMPass	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^} SynthIntelALMPass;$/;"	v	typeref:struct:SynthIntelALMPass
SynthIntelPass	yosys/techlibs/intel/synth_intel.cc	/^	SynthIntelPass() : ScriptPass("synth_intel", "synthesis for Intel (Altera) FPGAs.") { experimen/;"	f	struct:SynthIntelPass	file:
SynthIntelPass	yosys/techlibs/intel/synth_intel.cc	/^struct SynthIntelPass : public ScriptPass {$/;"	s	file:
SynthIntelPass	yosys/techlibs/intel/synth_intel.cc	/^} SynthIntelPass;$/;"	v	typeref:struct:SynthIntelPass
SynthMachXO2Pass	yosys/techlibs/machxo2/synth_machxo2.cc	/^	SynthMachXO2Pass() : ScriptPass("synth_machxo2", "synthesis for MachXO2 FPGAs. This work is exp/;"	f	struct:SynthMachXO2Pass	file:
SynthMachXO2Pass	yosys/techlibs/machxo2/synth_machxo2.cc	/^struct SynthMachXO2Pass : public ScriptPass$/;"	s	file:
SynthMachXO2Pass	yosys/techlibs/machxo2/synth_machxo2.cc	/^} SynthMachXO2Pass;$/;"	v	typeref:struct:SynthMachXO2Pass
SynthNexusPass	yosys/techlibs/nexus/synth_nexus.cc	/^	SynthNexusPass() : ScriptPass("synth_nexus", "synthesis for Lattice Nexus FPGAs") { }$/;"	f	struct:SynthNexusPass	file:
SynthNexusPass	yosys/techlibs/nexus/synth_nexus.cc	/^struct SynthNexusPass : public ScriptPass$/;"	s	file:
SynthNexusPass	yosys/techlibs/nexus/synth_nexus.cc	/^} SynthNexusPass;$/;"	v	typeref:struct:SynthNexusPass
SynthPass	yosys/techlibs/common/synth.cc	/^	SynthPass() : ScriptPass("synth", "generic synthesis script") { }$/;"	f	struct:SynthPass	file:
SynthPass	yosys/techlibs/common/synth.cc	/^struct SynthPass : public ScriptPass$/;"	s	file:
SynthPass	yosys/techlibs/common/synth.cc	/^} SynthPass;$/;"	v	typeref:struct:SynthPass
SynthQuickLogicPass	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	SynthQuickLogicPass() : ScriptPass("synth_quicklogic", "Synthesis for QuickLogic FPGAs") {}$/;"	f	struct:SynthQuickLogicPass	file:
SynthQuickLogicPass	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^struct SynthQuickLogicPass : public ScriptPass {$/;"	s	file:
SynthQuicklogicPass	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^} SynthQuicklogicPass;$/;"	v	typeref:struct:SynthQuickLogicPass
SynthSf2Pass	yosys/techlibs/sf2/synth_sf2.cc	/^	SynthSf2Pass() : ScriptPass("synth_sf2", "synthesis for SmartFusion2 and IGLOO2 FPGAs") { }$/;"	f	struct:SynthSf2Pass	file:
SynthSf2Pass	yosys/techlibs/sf2/synth_sf2.cc	/^struct SynthSf2Pass : public ScriptPass$/;"	s	file:
SynthSf2Pass	yosys/techlibs/sf2/synth_sf2.cc	/^} SynthSf2Pass;$/;"	v	typeref:struct:SynthSf2Pass
SynthXilinxPass	yosys/techlibs/xilinx/synth_xilinx.cc	/^	SynthXilinxPass() : ScriptPass("synth_xilinx", "synthesis for Xilinx FPGAs") { }$/;"	f	struct:SynthXilinxPass	file:
SynthXilinxPass	yosys/techlibs/xilinx/synth_xilinx.cc	/^struct SynthXilinxPass : public ScriptPass$/;"	s	file:
SynthXilinxPass	yosys/techlibs/xilinx/synth_xilinx.cc	/^} SynthXilinxPass;$/;"	v	typeref:struct:SynthXilinxPass
Sz	yosys/kernel/rtlil.h	/^		Sz = 3, \/\/ high-impedance \/ not-connected$/;"	e	enum:RTLIL::State
TARGETS	yosys/Makefile	/^TARGETS := $(filter-out $(PROGRAM_PREFIX)yosys-config,$(TARGETS))$/;"	m
TARGETS	yosys/Makefile	/^TARGETS = $(PROGRAM_PREFIX)yosys$(EXE) $(PROGRAM_PREFIX)yosys-config$/;"	m
TCL_INCLUDE	yosys/Makefile	/^TCL_INCLUDE ?= \/usr\/include\/$(TCL_VERSION)$/;"	m
TCL_INCLUDE	yosys/Makefile	/^TCL_INCLUDE ?= \/usr\/local\/include\/$(TCL_VERSION)$/;"	m
TCL_VERSION	yosys/Makefile	/^TCL_VERSION ?= tcl$(shell bash -c "tclsh <(echo 'puts [info tclversion]')")$/;"	m
TEST	yosys/libs/bigint/testsuite.cc	/^#define TEST(/;"	d	file:
TEST	yosys/tests/unit/kernel/logTest.cc	/^TEST(KernelLogTest, logvValidValues)$/;"	f	typeref:typename:YOSYS_NAMESPACE_BEGIN
TEST	yosys/tests/unit/kernel/rtlilTest.cc	/^TEST(KernelRtlilTest, getReferenceValid)$/;"	f	typeref:typename:YOSYS_NAMESPACE_BEGIN
TESTDIRS	yosys/tests/unit/Makefile	/^TESTDIRS := $(sort $(dir $(ALLTESTFILE)))$/;"	m
TESTS	yosys/tests/sva/Makefile	/^TESTS = $(sort $(basename $(wildcard *.sv)) $(basename $(wildcard *.vhd)))$/;"	m
TESTS	yosys/tests/unit/Makefile	/^TESTS := $(addprefix $(BINTEST)\/, $(basename $(ALLTESTFILE:%Test.cc=%Test.o)))$/;"	m
TIMINGINFO_H	yosys/kernel/timinginfo.h	/^#define TIMINGINFO_H$/;"	d
TableBackend	yosys/backends/table/table.cc	/^	TableBackend() : Backend("table", "write design as connectivity table") { }$/;"	f	struct:TableBackend	file:
TableBackend	yosys/backends/table/table.cc	/^struct TableBackend : public Backend {$/;"	s	file:
TableBackend	yosys/backends/table/table.cc	/^} TableBackend;$/;"	v	typeref:struct:TableBackend
TclPass	yosys/kernel/yosys.cc	/^	TclPass() : Pass("tcl", "execute a TCL script file") { }$/;"	f	struct:TclPass	file:
TclPass	yosys/kernel/yosys.cc	/^struct TclPass : public Pass {$/;"	s	file:
TclPass	yosys/kernel/yosys.cc	/^} TclPass;$/;"	v	typeref:struct:TclPass
TechmapPass	yosys/passes/techmap/techmap.cc	/^	TechmapPass() : Pass("techmap", "generic technology mapper") { }$/;"	f	struct:TechmapPass	file:
TechmapPass	yosys/passes/techmap/techmap.cc	/^struct TechmapPass : public Pass {$/;"	s	file:
TechmapPass	yosys/passes/techmap/techmap.cc	/^} TechmapPass;$/;"	v	typeref:struct:TechmapPass
TechmapWireData	yosys/passes/techmap/techmap.cc	/^	struct TechmapWireData {$/;"	s	struct:TechmapWorker	file:
TechmapWires	yosys/passes/techmap/techmap.cc	/^	typedef dict<IdString, std::vector<TechmapWireData>> TechmapWires;$/;"	t	struct:TechmapWorker	typeref:typename:dict<IdString,std::vector<TechmapWireData>>	file:
TechmapWorker	yosys/passes/techmap/techmap.cc	/^struct TechmapWorker$/;"	s	file:
TeePass	yosys/passes/cmds/tee.cc	/^	TeePass() : Pass("tee", "redirect command output to file") { }$/;"	f	struct:TeePass	file:
TeePass	yosys/passes/cmds/tee.cc	/^struct TeePass : public Pass {$/;"	s	file:
TeePass	yosys/passes/cmds/tee.cc	/^} TeePass;$/;"	v	typeref:struct:TeePass
Test1Pass	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^    Test1Pass() : Pass("test1", "creating the absval module") { }$/;"	f	struct:Test1Pass	file:
Test1Pass	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^struct Test1Pass : public Pass {$/;"	s	file:
Test1Pass	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^} Test1Pass;$/;"	v	typeref:struct:Test1Pass
Test2Pass	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^    Test2Pass() : Pass("test2", "demonstrating sigmap on test module") { }$/;"	f	struct:Test2Pass	file:
Test2Pass	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^struct Test2Pass : public Pass {$/;"	s	file:
Test2Pass	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^} Test2Pass;$/;"	v	typeref:struct:Test2Pass
TestAbcloopPass	yosys/passes/tests/test_abcloop.cc	/^	TestAbcloopPass() : Pass("test_abcloop", "automatically test handling of loops in abc command")/;"	f	struct:TestAbcloopPass	file:
TestAbcloopPass	yosys/passes/tests/test_abcloop.cc	/^struct TestAbcloopPass : public Pass {$/;"	s	file:
TestAbcloopPass	yosys/passes/tests/test_abcloop.cc	/^} TestAbcloopPass;$/;"	v	typeref:struct:TestAbcloopPass
TestAutotbBackend	yosys/passes/tests/test_autotb.cc	/^	TestAutotbBackend() : Backend("=test_autotb", "generate simple test benches") { }$/;"	f	struct:TestAutotbBackend	file:
TestAutotbBackend	yosys/passes/tests/test_autotb.cc	/^struct TestAutotbBackend : public Backend {$/;"	s	file:
TestAutotbBackend	yosys/passes/tests/test_autotb.cc	/^} TestAutotbBackend;$/;"	v	typeref:struct:TestAutotbBackend
TestCellPass	yosys/passes/tests/test_cell.cc	/^	TestCellPass() : Pass("test_cell", "automatically test the implementation of a cell type") { }$/;"	f	struct:TestCellPass	file:
TestCellPass	yosys/passes/tests/test_cell.cc	/^struct TestCellPass : public Pass {$/;"	s	file:
TestCellPass	yosys/passes/tests/test_cell.cc	/^} TestCellPass;$/;"	v	typeref:struct:TestCellPass
TestPass	yosys/tests/various/plugin.cc	/^	TestPass() : Pass("test", "test") { }$/;"	f	struct:TestPass	file:
TestPass	yosys/tests/various/plugin.cc	/^struct TestPass : public Pass {$/;"	s	file:
TestPass	yosys/tests/various/plugin.cc	/^} TestPass;$/;"	v	typeref:struct:TestPass
TestPmgenPass	yosys/passes/pmgen/test_pmgen.cc	/^	TestPmgenPass() : Pass("test_pmgen", "test pass for pmgen") { }$/;"	f	struct:TestPmgenPass	file:
TestPmgenPass	yosys/passes/pmgen/test_pmgen.cc	/^struct TestPmgenPass : public Pass {$/;"	s	file:
TestPmgenPass	yosys/passes/pmgen/test_pmgen.cc	/^} TestPmgenPass;$/;"	v	typeref:struct:TestPmgenPass
TimingInfo	yosys/kernel/timinginfo.h	/^	TimingInfo()$/;"	f	struct:TimingInfo
TimingInfo	yosys/kernel/timinginfo.h	/^	TimingInfo(RTLIL::Design *design)$/;"	f	struct:TimingInfo
TimingInfo	yosys/kernel/timinginfo.h	/^struct TimingInfo$/;"	s
TopoSort	yosys/kernel/utils.h	/^	TopoSort()$/;"	f	struct:TopoSort
TopoSort	yosys/kernel/utils.h	/^struct TopoSort$/;"	s
TorderPass	yosys/passes/cmds/torder.cc	/^	TorderPass() : Pass("torder", "print cells in topological order") { }$/;"	f	struct:TorderPass	file:
TorderPass	yosys/passes/cmds/torder.cc	/^struct TorderPass : public Pass {$/;"	s	file:
TorderPass	yosys/passes/cmds/torder.cc	/^} TorderPass;$/;"	v	typeref:struct:TorderPass
TraceMonitor	yosys/passes/cmds/trace.cc	/^struct TraceMonitor : public RTLIL::Monitor$/;"	s	file:
TracePass	yosys/passes/cmds/trace.cc	/^	TracePass() : Pass("trace", "redirect command output to file") { }$/;"	f	struct:TracePass	file:
TracePass	yosys/passes/cmds/trace.cc	/^struct TracePass : public Pass {$/;"	s	file:
TracePass	yosys/passes/cmds/trace.cc	/^} TracePass;$/;"	v	typeref:struct:TracePass
TrailIterator	yosys/libs/minisat/SolverTypes.h	/^    TrailIterator(const Lit* _lits) : lits(_lits){}$/;"	f	class:Minisat::TrailIterator
TrailIterator	yosys/libs/minisat/SolverTypes.h	/^class TrailIterator {$/;"	c	namespace:Minisat
TribufConfig	yosys/passes/techmap/tribuf.cc	/^	TribufConfig() {$/;"	f	struct:TribufConfig	file:
TribufConfig	yosys/passes/techmap/tribuf.cc	/^struct TribufConfig {$/;"	s	file:
TribufPass	yosys/passes/techmap/tribuf.cc	/^	TribufPass() : Pass("tribuf", "infer tri-state buffers") { }$/;"	f	struct:TribufPass	file:
TribufPass	yosys/passes/techmap/tribuf.cc	/^struct TribufPass : public Pass {$/;"	s	file:
TribufPass	yosys/passes/techmap/tribuf.cc	/^} TribufPass;$/;"	v	typeref:struct:TribufPass
TribufWorker	yosys/passes/techmap/tribuf.cc	/^	TribufWorker(Module *module, const TribufConfig &config) : module(module), sigmap(module), conf/;"	f	struct:TribufWorker	file:
TribufWorker	yosys/passes/techmap/tribuf.cc	/^struct TribufWorker {$/;"	s	file:
Type	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		enum class Type {$/;"	g	struct:FlowGraph::Node	file:
Type	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	enum Type {$/;"	g	struct:WireType	file:
Type	yosys/libs/json11/json11.hpp	/^    enum Type {$/;"	g	class:json11::Json
U16	yosys/libs/fst/lz4.cc	/^typedef uint16_t U16;$/;"	t	typeref:typename:uint16_t	file:
U16	yosys/libs/fst/lz4.cc	/^typedef unsigned short U16;$/;"	t	typeref:typename:unsigned short	file:
U32	yosys/libs/fst/lz4.cc	/^typedef uint32_t U32;$/;"	t	typeref:typename:uint32_t	file:
U32	yosys/libs/fst/lz4.cc	/^typedef unsigned int U32;$/;"	t	typeref:typename:unsigned int	file:
U64	yosys/libs/fst/lz4.cc	/^typedef uint64_t U64;$/;"	t	typeref:typename:uint64_t	file:
U64	yosys/libs/fst/lz4.cc	/^typedef unsigned long long U64;$/;"	t	typeref:typename:unsigned long long	file:
UINT	yosys/backends/cxxrtl/cxxrtl.h	/^		UINT   	= 1,$/;"	e	enum:cxxrtl::metadata::__anon481ec9d40203
UNDRIVEN	yosys/backends/cxxrtl/cxxrtl.h	/^		UNDRIVEN    = CXXRTL_UNDRIVEN,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40403
UNITESTPATH	yosys/Makefile	/^UNITESTPATH := tests\/unit$/;"	m
UNKNOWN	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	UNKNOWN = 0, \/\/ or mixed comb\/sync$/;"	e	enum:CxxrtlPortType	file:
UNUSED	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		UNUSED,$/;"	e	enum:WireType::Type	file:
USING_YOSYS_NAMESPACE	yosys/kernel/yosys.h	/^#define USING_YOSYS_NAMESPACE /;"	d
UTILS_H	yosys/kernel/utils.h	/^#define UTILS_H$/;"	d
UniquifyPass	yosys/passes/hierarchy/uniquify.cc	/^	UniquifyPass() : Pass("uniquify", "create unique copies of modules") { }$/;"	f	struct:UniquifyPass	file:
UniquifyPass	yosys/passes/hierarchy/uniquify.cc	/^struct UniquifyPass : public Pass {$/;"	s	file:
UniquifyPass	yosys/passes/hierarchy/uniquify.cc	/^} UniquifyPass;$/;"	v	typeref:struct:UniquifyPass
Unit_Size	yosys/libs/minisat/Alloc.h	/^    enum { Unit_Size = sizeof(T) };$/;"	e	enum:Minisat::RegionAllocator::__anon5d4f57590203
Unit_Size	yosys/libs/minisat/SolverTypes.h	/^    enum { Unit_Size = RegionAllocator<uint32_t>::Unit_Size };$/;"	e	enum:Minisat::ClauseAllocator::__anonb7535e3e0303
UserTypeMap	yosys/frontends/verilog/verilog_frontend.h	/^	typedef std::map<std::string, AST::AstNode*> UserTypeMap;$/;"	t	namespace:VERILOG_FRONTEND	typeref:typename:std::map<std::string,AST::AstNode * >
VALGRIND	yosys/Makefile	/^VALGRIND ?= valgrind --error-exitcode=1 --leak-check=full --show-reachable=yes --errors-for-leak/;"	m
VALUE	yosys/backends/cxxrtl/cxxrtl.h	/^		VALUE   = CXXRTL_VALUE,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40303
VAR	yosys/libs/ezsat/ezsat.h	/^	int VAR(_V a) {$/;"	f	class:ezSAT	typeref:typename:int
VCDWriter	yosys/passes/sat/sim.cc	/^	VCDWriter(SimWorker *worker, std::string filename) : OutputWriter(worker) {$/;"	f	struct:VCDWriter	file:
VCDWriter	yosys/passes/sat/sim.cc	/^struct VCDWriter : public OutputWriter$/;"	s	file:
VERBOSE	yosys/libs/subcircuit/demo.cc	/^#define VERBOSE$/;"	d	file:
VERIFIC_COMPONENTS	yosys/Makefile	/^VERIFIC_COMPONENTS ?= verilog database util containers hier_tree$/;"	m
VERIFIC_DIR	yosys/Makefile	/^VERIFIC_DIR ?= \/usr\/local\/src\/verific_lib$/;"	m
VERILOG_FRONTEND	yosys/frontends/verilog/verilog_frontend.h	/^namespace VERILOG_FRONTEND$/;"	n
VERILOG_FRONTEND_H	yosys/frontends/verilog/verilog_frontend.h	/^#define VERILOG_FRONTEND_H$/;"	d
VERILOG_PREPROC_H	yosys/frontends/verilog/preproc.h	/^#define VERILOG_PREPROC_H$/;"	d
VMap	yosys/libs/minisat/SolverTypes.h	/^template<class T> class VMap : public IntMap<Var, T>{};$/;"	c	namespace:Minisat
VPATH	yosys/Makefile	/^VPATH := $(YOSYS_SRC)$/;"	m
Value	yosys/libs/json11/json11.cpp	/^    explicit Value(T &&value)      : m_value(move(value)) {}$/;"	f	class:json11::Value	file:
Value	yosys/libs/json11/json11.cpp	/^    explicit Value(const T &value) : m_value(value) {}$/;"	f	class:json11::Value	file:
Value	yosys/libs/json11/json11.cpp	/^class Value : public JsonValue {$/;"	c	namespace:json11	file:
Var	yosys/libs/minisat/SolverTypes.h	/^typedef int Var;$/;"	t	namespace:Minisat	typeref:typename:int
VarData	yosys/libs/minisat/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	s	class:Minisat::Solver
VarOrderLt	yosys/libs/minisat/Solver.h	/^        VarOrderLt(const IntMap<Var, double>&  act) : activity(act) { }$/;"	f	struct:Minisat::Solver::VarOrderLt
VarOrderLt	yosys/libs/minisat/Solver.h	/^    struct VarOrderLt {$/;"	s	class:Minisat::Solver
VerificClocking	yosys/frontends/verific/verific.cc	/^VerificClocking::VerificClocking(VerificImporter *importer, Net *net, bool sva_at_only)$/;"	f	class:VerificClocking
VerificClocking	yosys/frontends/verific/verific.h	/^	VerificClocking() { }$/;"	f	struct:VerificClocking
VerificClocking	yosys/frontends/verific/verific.h	/^struct VerificClocking {$/;"	s
VerificExtNets	yosys/frontends/verific/verific.cc	/^struct VerificExtNets$/;"	s	file:
VerificImporter	yosys/frontends/verific/verific.cc	/^VerificImporter::VerificImporter(bool mode_gates, bool mode_keep, bool mode_nosva, bool mode_nam/;"	f	class:VerificImporter
VerificImporter	yosys/frontends/verific/verific.h	/^struct VerificImporter$/;"	s
VerificPass	yosys/frontends/verific/verific.cc	/^	VerificPass() : Pass("verific", "load Verilog and VHDL designs using Verific") { }$/;"	f	struct:VerificPass	file:
VerificPass	yosys/frontends/verific/verific.cc	/^struct VerificPass : public Pass {$/;"	s	file:
VerificPass	yosys/frontends/verific/verific.cc	/^} VerificPass;$/;"	v	typeref:struct:VerificPass
VerificSvaImporter	yosys/frontends/verific/verificsva.cc	/^struct VerificSvaImporter$/;"	s	file:
VerilogBackend	yosys/backends/verilog/verilog_backend.cc	/^	VerilogBackend() : Backend("verilog", "write design to Verilog file") { }$/;"	f	struct:VerilogBackend	file:
VerilogBackend	yosys/backends/verilog/verilog_backend.cc	/^struct VerilogBackend : public Backend {$/;"	s	file:
VerilogBackend	yosys/backends/verilog/verilog_backend.cc	/^} VerilogBackend;$/;"	v	typeref:struct:VerilogBackend
VerilogDefaults	yosys/frontends/verilog/verilog_frontend.cc	/^	VerilogDefaults() : Pass("verilog_defaults", "set default options for read_verilog") { }$/;"	f	struct:VerilogDefaults	file:
VerilogDefaults	yosys/frontends/verilog/verilog_frontend.cc	/^struct VerilogDefaults : public Pass {$/;"	s	file:
VerilogDefaults	yosys/frontends/verilog/verilog_frontend.cc	/^} VerilogDefaults;$/;"	v	typeref:struct:VerilogDefaults
VerilogDefines	yosys/frontends/verilog/verilog_frontend.cc	/^	VerilogDefines() : Pass("verilog_defines", "define and undefine verilog defines") { }$/;"	f	struct:VerilogDefines	file:
VerilogDefines	yosys/frontends/verilog/verilog_frontend.cc	/^struct VerilogDefines : public Pass {$/;"	s	file:
VerilogDefines	yosys/frontends/verilog/verilog_frontend.cc	/^} VerilogDefines;$/;"	v	typeref:struct:VerilogDefines
VerilogFrontend	yosys/frontends/verilog/verilog_frontend.cc	/^	VerilogFrontend() : Frontend("verilog", "read modules from Verilog file") { }$/;"	f	struct:VerilogFrontend	file:
VerilogFrontend	yosys/frontends/verilog/verilog_frontend.cc	/^struct VerilogFrontend : public Frontend {$/;"	s	file:
VerilogFrontend	yosys/frontends/verilog/verilog_frontend.cc	/^} VerilogFrontend;$/;"	v	typeref:struct:VerilogFrontend
Vertex	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		Vertex() : data(NULL), prev(this), next(this) {}$/;"	f	struct:Scheduler::Vertex	file:
Vertex	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		Vertex(T *data) : data(data), prev(NULL), next(NULL) {}$/;"	f	struct:Scheduler::Vertex	file:
Vertex	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	struct Vertex {$/;"	s	struct:Scheduler	file:
VlogHammerReporter	yosys/passes/sat/eval.cc	/^	VlogHammerReporter(RTLIL::Design *design, std::string module_prefix, std::string module_list, s/;"	f	struct:VlogHammerReporter	file:
VlogHammerReporter	yosys/passes/sat/eval.cc	/^struct VlogHammerReporter$/;"	s	file:
WASIFLAGS	yosys/Makefile	/^WASIFLAGS := --sysroot $(WASI_SDK)\/share\/wasi-sysroot $(WASIFLAGS)$/;"	m
WASIFLAGS	yosys/Makefile	/^WASIFLAGS := -target wasm32-wasi --sysroot $(WASI_SYSROOT) $(WASIFLAGS)$/;"	m
WEXITSTATUS	yosys/passes/cmds/exec.cc	/^#  define WEXITSTATUS(/;"	d	file:
WIFEXITED	yosys/passes/cmds/exec.cc	/^#  define WIFEXITED(/;"	d	file:
WIFSIGNALED	yosys/passes/cmds/exec.cc	/^#  define WIFSIGNALED(/;"	d	file:
WIFSTOPPED	yosys/passes/cmds/exec.cc	/^#  define WIFSTOPPED(/;"	d	file:
WIRE	yosys/backends/cxxrtl/cxxrtl.h	/^		WIRE    = CXXRTL_WIRE,$/;"	e	enum:cxxrtl::debug_item::__anon481ec9d40303
WSTOPSIG	yosys/passes/cmds/exec.cc	/^#  define WSTOPSIG(/;"	d	file:
WTERMSIG	yosys/passes/cmds/exec.cc	/^#  define WTERMSIG(/;"	d	file:
Watcher	yosys/libs/minisat/Solver.h	/^        Watcher(CRef cr, Lit p) : cref(cr), blocker(p) {}$/;"	f	struct:Minisat::Solver::Watcher
Watcher	yosys/libs/minisat/Solver.h	/^    struct Watcher {$/;"	s	class:Minisat::Solver
WatcherDeleted	yosys/libs/minisat/Solver.h	/^        WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Minisat::Solver::WatcherDeleted
WatcherDeleted	yosys/libs/minisat/Solver.h	/^    struct WatcherDeleted$/;"	s	class:Minisat::Solver
WbflipPass	yosys/passes/cmds/setattr.cc	/^	WbflipPass() : Pass("wbflip", "flip the whitebox attribute") { }$/;"	f	struct:WbflipPass	file:
WbflipPass	yosys/passes/cmds/setattr.cc	/^struct WbflipPass : public Pass {$/;"	s	file:
WbflipPass	yosys/passes/cmds/setattr.cc	/^} WbflipPass;$/;"	v	typeref:struct:WbflipPass
WinMain	yosys/misc/launcher.c	/^int WINAPI WinMain(HINSTANCE hI, HINSTANCE hP, LPSTR lpCmd, int nShow) {$/;"	f	typeref:typename:int WINAPI
Wire	yosys/kernel/rtlil.cc	/^RTLIL::Wire::Wire()$/;"	f	class:RTLIL::Wire
Wire	yosys/kernel/rtlil.h	/^struct RTLIL::Wire : public RTLIL::AttrObject$/;"	s	class:RTLIL
WireType	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	WireType(Type type) : type(type) {$/;"	f	struct:WireType	file:
WireType	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	WireType(Type type, RTLIL::SigSpec sig) : type(type), sig_subst(sig) {$/;"	f	struct:WireType	file:
WireType	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	WireType(Type type, const RTLIL::Cell *cell) : type(type), cell_subst(cell) {$/;"	f	struct:WireType	file:
WireType	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^struct WireType {$/;"	s	file:
WreduceConfig	yosys/passes/opt/wreduce.cc	/^	WreduceConfig()$/;"	f	struct:WreduceConfig	file:
WreduceConfig	yosys/passes/opt/wreduce.cc	/^struct WreduceConfig$/;"	s	file:
WreducePass	yosys/passes/opt/wreduce.cc	/^	WreducePass() : Pass("wreduce", "reduce the word size of operations if possible") { }$/;"	f	struct:WreducePass	file:
WreducePass	yosys/passes/opt/wreduce.cc	/^struct WreducePass : public Pass {$/;"	s	file:
WreducePass	yosys/passes/opt/wreduce.cc	/^} WreducePass;$/;"	v	typeref:struct:WreducePass
WreduceWorker	yosys/passes/opt/wreduce.cc	/^	WreduceWorker(WreduceConfig *config, Module *module) :$/;"	f	struct:WreduceWorker	file:
WreduceWorker	yosys/passes/opt/wreduce.cc	/^struct WreduceWorker$/;"	s	file:
WriteFileFrontend	yosys/passes/cmds/write_file.cc	/^	WriteFileFrontend() : Frontend("=write_file", "write a text to a file") { }$/;"	f	struct:WriteFileFrontend	file:
WriteFileFrontend	yosys/passes/cmds/write_file.cc	/^struct WriteFileFrontend : public Frontend {$/;"	s	file:
WriteFileFrontend	yosys/passes/cmds/write_file.cc	/^} WriteFileFrontend;$/;"	v	typeref:struct:WriteFileFrontend
X	yosys/frontends/ast/ast.cc	/^#define X(/;"	d	file:
X	yosys/kernel/rtlil.cc	/^#define X(/;"	d	file:
X	yosys/kernel/rtlil.h	/^#define X(/;"	d
X	yosys/kernel/yosys.cc	/^#define X(/;"	d	file:
X	yosys/libs/ezsat/demo_cmp.cc	/^#define X(/;"	d	file:
X	yosys/libs/ezsat/ezsat.cc	/^#define X(/;"	d	file:
X	yosys/passes/cmds/stat.cc	/^	#define X(/;"	d	file:
X	yosys/passes/sat/mutate.cc	/^#define X(/;"	d	file:
XAigerBackend	yosys/backends/aiger/xaiger.cc	/^	XAigerBackend() : Backend("xaiger", "write design to XAIGER file") { }$/;"	f	struct:XAigerBackend	file:
XAigerBackend	yosys/backends/aiger/xaiger.cc	/^struct XAigerBackend : public Backend {$/;"	s	file:
XAigerBackend	yosys/backends/aiger/xaiger.cc	/^} XAigerBackend;$/;"	v	typeref:struct:XAigerBackend
XAigerWriter	yosys/backends/aiger/xaiger.cc	/^	XAigerWriter(Module *module, bool dff_mode) : design(module->design), module(module), sigmap(mo/;"	f	struct:XAigerWriter	file:
XAigerWriter	yosys/backends/aiger/xaiger.cc	/^struct XAigerWriter$/;"	s	file:
XOR	yosys/libs/ezsat/ezsat.h	/^	int XOR(_V a = 0, _V b = 0, _V c = 0, _V d = 0, _V e = 0, _V f = 0) {$/;"	f	class:ezSAT	typeref:typename:int
XilinxDffOptPass	yosys/passes/opt/opt_lut_ins.cc	/^} XilinxDffOptPass;$/;"	v	typeref:struct:OptLutInsPass
XilinxDffOptPass	yosys/techlibs/xilinx/xilinx_dffopt.cc	/^	XilinxDffOptPass() : Pass("xilinx_dffopt", "Xilinx: optimize FF control signal usage") { }$/;"	f	struct:XilinxDffOptPass	file:
XilinxDffOptPass	yosys/techlibs/xilinx/xilinx_dffopt.cc	/^struct XilinxDffOptPass : public Pass {$/;"	s	file:
XilinxDffOptPass	yosys/techlibs/xilinx/xilinx_dffopt.cc	/^} XilinxDffOptPass;$/;"	v	typeref:struct:XilinxDffOptPass
XilinxDspPass	yosys/passes/pmgen/xilinx_dsp.cc	/^	XilinxDspPass() : Pass("xilinx_dsp", "Xilinx: pack resources into DSPs") { }$/;"	f	struct:XilinxDspPass	file:
XilinxDspPass	yosys/passes/pmgen/xilinx_dsp.cc	/^struct XilinxDspPass : public Pass {$/;"	s	file:
XilinxDspPass	yosys/passes/pmgen/xilinx_dsp.cc	/^} XilinxDspPass;$/;"	v	typeref:struct:XilinxDspPass
XilinxSrlPass	yosys/passes/pmgen/xilinx_srl.cc	/^	XilinxSrlPass() : Pass("xilinx_srl", "Xilinx shift register extraction") { }$/;"	f	struct:XilinxSrlPass	file:
XilinxSrlPass	yosys/passes/pmgen/xilinx_srl.cc	/^struct XilinxSrlPass : public Pass {$/;"	s	file:
XilinxSrlPass	yosys/passes/pmgen/xilinx_srl.cc	/^} XilinxSrlPass;$/;"	v	typeref:struct:XilinxSrlPass
Xor	yosys/passes/techmap/extract_reduce.cc	/^		Xor$/;"	e	enum:ExtractReducePass::GateType	file:
YOSYS_H	yosys/kernel/yosys.h	/^#define YOSYS_H$/;"	d
YOSYS_NAMESPACE	yosys/kernel/yosys.h	/^#define YOSYS_NAMESPACE /;"	d
YOSYS_NAMESPACE_BEGIN	yosys/kernel/yosys.h	/^#define YOSYS_NAMESPACE_BEGIN /;"	d
YOSYS_NAMESPACE_END	yosys/kernel/yosys.h	/^#define YOSYS_NAMESPACE_END /;"	d
YOSYS_NAMESPACE_PREFIX	yosys/kernel/yosys.h	/^#define YOSYS_NAMESPACE_PREFIX /;"	d
YOSYS_SRC	yosys/Makefile	/^YOSYS_SRC := $(dir $(firstword $(MAKEFILE_LIST)))$/;"	m
YOSYS_VER	yosys/Makefile	/^YOSYS_VER := 0.16+31$/;"	m
YOSYS_VER_STR	yosys/Makefile	/^YOSYS_VER_STR := Yosys $(YOSYS_VER) (git sha1 $(GIT_REV), $(notdir $(CXX)) $(shell \\$/;"	m
YS_ATTRIBUTE	yosys/kernel/log.h	/^} YS_ATTRIBUTE(packed);$/;"	v	typeref:struct:CoverData
YS_ATTRIBUTE	yosys/kernel/yosys.h	/^#  define YS_ATTRIBUTE(/;"	d
YS_DEBUGTRAP	yosys/kernel/log.h	/^# define YS_DEBUGTRAP /;"	d
YS_DEBUGTRAP_IF_DEBUGGING	yosys/kernel/log.h	/^# define YS_DEBUGTRAP_IF_DEBUGGING /;"	d
YS_FALLTHROUGH	yosys/kernel/yosys.h	/^#  define YS_FALLTHROUGH /;"	d
YS_FALLTHROUGH	yosys/kernel/yosys.h	/^#  define YS_FALLTHROUGH$/;"	d
YS_HAS_BAD_STD_REGEX	yosys/kernel/log.h	/^#    define YS_HAS_BAD_STD_REGEX$/;"	d
YS_MAYBE_UNUSED	yosys/kernel/yosys.h	/^#  define YS_MAYBE_UNUSED /;"	d
YS_MAYBE_UNUSED	yosys/kernel/yosys.h	/^#  define YS_MAYBE_UNUSED$/;"	d
YS_REGEX_COMPILE	yosys/kernel/log.h	/^	#define YS_REGEX_COMPILE(/;"	d
YS_REGEX_COMPILE_WITH_SUBS	yosys/kernel/log.h	/^	#define YS_REGEX_COMPILE_WITH_SUBS(/;"	d
YS_REGEX_MATCH_TYPE	yosys/kernel/log.h	/^	#define YS_REGEX_MATCH_TYPE /;"	d
YS_REGEX_NS	yosys/kernel/log.h	/^	#define YS_REGEX_NS /;"	d
YS_REGEX_TYPE	yosys/kernel/log.h	/^	#define YS_REGEX_TYPE /;"	d
YY_NO_UNISTD_H	yosys/kernel/yosys.h	/^#  define YY_NO_UNISTD_H /;"	d
Yices	yosys/passes/sat/qbfsat.h	/^	enum Solver{Z3, Yices, CVC4} solver = Yices;$/;"	e	enum:QbfSolveOptions::Solver
Yosys	yosys/passes/techmap/libparse.h	/^namespace Yosys$/;"	n
Z3	yosys/passes/sat/qbfsat.h	/^	enum Solver{Z3, Yices, CVC4} solver = Yices;$/;"	e	enum:QbfSolveOptions::Solver
ZinitPass	yosys/passes/techmap/zinit.cc	/^	ZinitPass() : Pass("zinit", "add inverters so all FF are zero-initialized") { }$/;"	f	struct:ZinitPass	file:
ZinitPass	yosys/passes/techmap/zinit.cc	/^struct ZinitPass : public Pass {$/;"	s	file:
ZinitPass	yosys/passes/techmap/zinit.cc	/^} ZinitPass;$/;"	v	typeref:struct:ZinitPass
_V	yosys/libs/ezsat/ezsat.h	/^		_V(const char *name) : id(0), name(name) { }$/;"	f	struct:ezSAT::_V
_V	yosys/libs/ezsat/ezsat.h	/^		_V(const std::string &name) : id(0), name(name) { }$/;"	f	struct:ezSAT::_V
_V	yosys/libs/ezsat/ezsat.h	/^		_V(int id) : id(id) { }$/;"	f	struct:ezSAT::_V
_V	yosys/libs/ezsat/ezsat.h	/^	struct _V {$/;"	s	class:ezSAT
__PRETTY_FUNCTION__	yosys/kernel/log.h	/^#  define __PRETTY_FUNCTION__ /;"	d
__STDC_FORMAT_MACROS	yosys/frontends/aiger/aigerparse.cc	/^#define __STDC_FORMAT_MACROS$/;"	d	file:
__STDC_FORMAT_MACROS	yosys/libs/ezsat/ezminisat.cc	/^#define __STDC_FORMAT_MACROS$/;"	d	file:
__STDC_FORMAT_MACROS	yosys/libs/fst/config.h	/^#  define __STDC_FORMAT_MACROS /;"	d
__STDC_FORMAT_MACROS	yosys/libs/minisat/Options.cc	/^#define __STDC_FORMAT_MACROS$/;"	d	file:
__STDC_FORMAT_MACROS	yosys/libs/minisat/SimpSolver.cc	/^#define __STDC_FORMAT_MACROS$/;"	d	file:
__STDC_FORMAT_MACROS	yosys/libs/minisat/Solver.cc	/^#define __STDC_FORMAT_MACROS$/;"	d	file:
__STDC_FORMAT_MACROS	yosys/libs/minisat/System.cc	/^#define __STDC_FORMAT_MACROS$/;"	d	file:
__STDC_LIMIT_MACROS	yosys/libs/ezsat/ezminisat.cc	/^#define __STDC_LIMIT_MACROS$/;"	d	file:
__STDC_LIMIT_MACROS	yosys/libs/minisat/Options.cc	/^#define __STDC_LIMIT_MACROS$/;"	d	file:
__STDC_LIMIT_MACROS	yosys/libs/minisat/SimpSolver.cc	/^#define __STDC_LIMIT_MACROS$/;"	d	file:
__STDC_LIMIT_MACROS	yosys/libs/minisat/Solver.cc	/^#define __STDC_LIMIT_MACROS$/;"	d	file:
__STDC_LIMIT_MACROS	yosys/libs/minisat/System.cc	/^#define __STDC_LIMIT_MACROS$/;"	d	file:
__anon0d3289950102	yosys/frontends/blif/blifparse.cc	/^	{$/;"	f	function:parse_blif	typeref:typename:Wire *	file:
__anon11a1cacc0102	yosys/passes/techmap/flatten.cc	/^			auto rewriter = [&](RTLIL::SigSpec &sig) { map_sigspec(wire_map, sig); };$/;"	f	function:FlattenWorker::flatten_cell	file:
__anon11a1cacc0202	yosys/passes/techmap/flatten.cc	/^			auto rewriter = [&](RTLIL::SigSpec &sig) { map_sigspec(wire_map, sig); };$/;"	f	function:FlattenWorker::flatten_cell	file:
__anon19c995b50102	yosys/passes/pmgen/xilinx_dsp.cc	/^	auto f12 = [module](SigSpec &AB, SigSpec &C, SigSpec &P, SigSpec &CARRYOUT, Cell *lane) {$/;"	f	function:xilinx_simd_pack	file:
__anon19c995b50202	yosys/passes/pmgen/xilinx_dsp.cc	/^	auto g12 = [&f12,module](std::deque<Cell*> &simd12) {$/;"	f	function:xilinx_simd_pack	file:
__anon19c995b50302	yosys/passes/pmgen/xilinx_dsp.cc	/^	auto f24 = [module](SigSpec &AB, SigSpec &C, SigSpec &P, SigSpec &CARRYOUT, Cell *lane) {$/;"	f	function:xilinx_simd_pack	file:
__anon19c995b50402	yosys/passes/pmgen/xilinx_dsp.cc	/^	auto g24 = [&f24,module](std::deque<Cell*> &simd24) {$/;"	f	function:xilinx_simd_pack	file:
__anon19c995b50502	yosys/passes/pmgen/xilinx_dsp.cc	/^		auto f = [&pm,cell](SigSpec &A, Cell* ff, IdString ceport, IdString rstport) {$/;"	f	function:xilinx_dsp_pack	file:
__anon19c995b50602	yosys/passes/pmgen/xilinx_dsp.cc	/^		auto f = [&pm,cell](SigSpec &A, Cell* ff, IdString ceport, IdString rstport) {$/;"	f	function:xilinx_dsp48a_pack	file:
__anon19c995b50702	yosys/passes/pmgen/xilinx_dsp.cc	/^		auto f = [&pm,cell](SigSpec &A, Cell* ff, IdString ceport, IdString rstport) {$/;"	f	function:xilinx_dsp_packC	file:
__anon19e891840102	yosys/passes/cmds/portlist.cc	/^		auto handle_module = [&](RTLIL::Module *module) {$/;"	f	function:PortlistPass::execute	file:
__anon240a0d430111	yosys/passes/cmds/select.cc	/^namespace {$/;"	n	file:
__anon240a0d430202	yosys/passes/cmds/select.cc	/^	auto isprefixed = [](const string &s) {$/;"	f	function:select_stmt	file:
__anon259aef150102	yosys/frontends/ast/simplify.cc	/^	auto reprocess_after = [this] (const std::string &modname) {$/;"	f	function:AstNode::lookup_cell_module	file:
__anon259aef150202	yosys/frontends/ast/simplify.cc	/^			auto attempt_resolve = [&new_prefix](const std::string &ident) -> std::string {$/;"	f	function:AstNode::expand_genblock	typeref:typename:std::string	file:
__anon259aef150302	yosys/frontends/ast/simplify.cc	/^	auto prefix_node = [&prefix](AstNode* child) {$/;"	f	function:AstNode::expand_genblock	file:
__anon259aef150402	yosys/frontends/ast/simplify.cc	/^	std::function<bool(const AstNode *node)> visit = [&](const AstNode *node) {$/;"	f	function:AstNode::is_recursive_function	file:
__anon3311ba060111	yosys/kernel/rtlil.cc	/^namespace {$/;"	n	file:
__anon438a1a400103	yosys/passes/opt/opt_expr.cc	/^	enum { GRP_DYN, GRP_CONST_A, GRP_CONST_B, GRP_CONST_AB, GRP_N };$/;"	g	function:group_cell_inputs	file:
__anon481ec9d40102	yosys/backends/cxxrtl/cxxrtl.h	/^				[](const int a, const write& b) { return a < b.priority; }),$/;"	f	function:cxxrtl::memory::update	file:
__anon481ec9d40203	yosys/backends/cxxrtl/cxxrtl.h	/^	const enum {$/;"	g	struct:cxxrtl::metadata
__anon481ec9d40303	yosys/backends/cxxrtl/cxxrtl.h	/^	enum : uint32_t {$/;"	g	struct:cxxrtl::debug_item	typeref:typename:uint32_t
__anon481ec9d40403	yosys/backends/cxxrtl/cxxrtl.h	/^	enum : uint32_t {$/;"	g	struct:cxxrtl::debug_item	typeref:typename:uint32_t
__anon481ec9d40502	yosys/backends/cxxrtl/cxxrtl.h	/^			[](const debug_item &a, const debug_item &b) {$/;"	f	function:cxxrtl::debug_items::add	file:
__anon4f1f9148010a	yosys/kernel/rtlil.h	/^	union {$/;"	u	struct:RTLIL::SigBit
__anon5d4f57590103	yosys/libs/minisat/Alloc.h	/^    enum { Ref_Undef = UINT32_MAX };$/;"	g	class:Minisat::RegionAllocator
__anon5d4f57590203	yosys/libs/minisat/Alloc.h	/^    enum { Unit_Size = sizeof(T) };$/;"	g	class:Minisat::RegionAllocator
__anon5ec0faac0111	yosys/libs/json11/json11.cpp	/^namespace {$/;"	n	namespace:json11	file:
__anon62474a9e0111	yosys/kernel/mem.cc	/^namespace {$/;"	n	file:
__anon62474a9e0202	yosys/kernel/mem.cc	/^			std::sort(ports.begin(), ports.end(), [](const std::pair<int, MemWr> &a, const std::pair<int,/;"	f	function:__anon62474a9e0111::mem_from_memory	file:
__anon62474a9e0302	yosys/kernel/mem.cc	/^			std::sort(inits.begin(), inits.end(), [](const std::pair<int, MemInit> &a, const std::pair<in/;"	f	function:__anon62474a9e0111::mem_from_memory	file:
__anon72b4bc8d0102	yosys/passes/sat/sim.cc	/^			fst->reconstructAllAtTimes(fst_clock, startCount, stopCount, [&](uint64_t time) {$/;"	f	function:SimWorker::run_cosim_fst	file:
__anon72b4bc8d0202	yosys/passes/sat/sim.cc	/^			fst->reconstructAllAtTimes(fst_clock, startCount, stopCount, [&](uint64_t time) {$/;"	f	function:SimWorker::generate_tb	file:
__anon72b4bc8d0302	yosys/passes/sat/sim.cc	/^			[this](IdString name) { vcdfile << stringf("$scope module %s $end\\n", log_id(name)); },$/;"	f	function:VCDWriter::write	file:
__anon72b4bc8d0402	yosys/passes/sat/sim.cc	/^			[this]() { vcdfile << stringf("$upscope $end\\n");},$/;"	f	function:VCDWriter::write	file:
__anon72b4bc8d0502	yosys/passes/sat/sim.cc	/^			[this,use_signal](Wire *wire, int id, bool is_reg) { if (use_signal.at(id)) vcdfile << string/;"	f	function:VCDWriter::write	file:
__anon72b4bc8d0602	yosys/passes/sat/sim.cc	/^			[this](IdString name) { fstWriterSetScope(fstfile, FST_ST_VCD_MODULE, stringf("%s",log_id(nam/;"	f	function:FSTWriter::write	file:
__anon72b4bc8d0702	yosys/passes/sat/sim.cc	/^			[this]() { fstWriterSetUpscope(fstfile); },$/;"	f	function:FSTWriter::write	file:
__anon72b4bc8d0802	yosys/passes/sat/sim.cc	/^			[this,use_signal](Wire *wire, int id, bool is_reg) {$/;"	f	function:FSTWriter::write	file:
__anon72b4bc8d0902	yosys/passes/sat/sim.cc	/^			[](IdString) {},$/;"	f	function:AIWWriter::write	file:
__anon72b4bc8d0a02	yosys/passes/sat/sim.cc	/^			[]() {},$/;"	f	function:AIWWriter::write	file:
__anon72b4bc8d0b02	yosys/passes/sat/sim.cc	/^			[this](Wire *wire, int id, bool) { mapping[wire] = id; }$/;"	f	function:AIWWriter::write	file:
__anon74d515a50102	yosys/passes/sat/qbfsat.cc	/^	auto process_line = [&ret, &smtbmc_warning, &opt, &quiet](const std::string &line) {$/;"	f	function:call_qbf_solver	file:
__anon76f5ae300102	yosys/frontends/ast/ast.cc	/^		[&rename, &idents, pkg](AstNode *node) {$/;"	f	function:rename_in_package_stmts	file:
__anon78d5d8400108	yosys/libs/fst/lz4.h	/^{$/;"	s
__anon78d5d8400208	yosys/libs/fst/lz4.h	/^{$/;"	s
__anon799d24500102	yosys/backends/aiger/xaiger.cc	/^		auto write_buffer = [](std::stringstream &buffer, int i32) {$/;"	f	function:XAigerWriter::write_aiger	file:
__anon799d24500202	yosys/backends/aiger/xaiger.cc	/^		auto write_buffer_float = [](std::stringstream &buffer, float f32) {$/;"	f	function:XAigerWriter::write_aiger	file:
__anon7e9a4a8b0111	yosys/kernel/ff.cc	/^namespace {$/;"	n	file:
__anon8adab8ba0103	yosys/libs/minisat/ParseUtils.h	/^    enum { buffer_size = 64*1024 };$/;"	g	class:Minisat::StreamBuffer
__anon9118cec90102	yosys/frontends/ast/genrtlil.cc	/^		auto visit_case_expr = [&width_hint, &sign_hint] (AstNode *node) {$/;"	f	function:AstNode::detectSignWidthWorker	file:
__anon9118cec90202	yosys/frontends/ast/genrtlil.cc	/^	auto already_exists = [&](const RTLIL::AttrObject *existing, const char *existing_kind) {$/;"	f	function:check_unique_id	file:
__anon9390dffe010a	yosys/libs/fst/lz4.cc	/^    {$/;"	u	function:LZ4_isLittleEndian	file:
__anon9390dffe0208	yosys/libs/fst/lz4.cc	/^{$/;"	s	file:
__anon9390dffe0303	yosys/libs/fst/lz4.cc	/^{$/;"	g	file:
__anon9390dffe0403	yosys/libs/fst/lz4.cc	/^{$/;"	g	file:
__anon9390dffe0503	yosys/libs/fst/lz4.cc	/^{$/;"	g	file:
__anon9390dffe0603	yosys/libs/fst/lz4.cc	/^{$/;"	g	file:
__anon9390dffe0703	yosys/libs/fst/lz4.cc	/^{$/;"	g	file:
__anon9390dffe0803	yosys/libs/fst/lz4.cc	/^{$/;"	g	file:
__anon9390dffe0908	yosys/libs/fst/lz4.cc	/^{$/;"	s	file:
__anon944949140111	yosys/libs/bigint/BigInteger.cc	/^namespace {$/;"	n	file:
__anon982c945c0102	yosys/kernel/hashlib.h	/^		std::sort(entries.begin(), entries.end(), [comp](const entry_t &a, const entry_t &b){ return c/;"	f	function:hashlib::dict::sort	file:
__anon982c945c0202	yosys/kernel/hashlib.h	/^		std::sort(entries.begin(), entries.end(), [comp](const entry_t &a, const entry_t &b){ return c/;"	f	function:hashlib::pool::sort	file:
__anona73446400102	yosys/passes/pmgen/generate.h	/^				run(matcher, [&](){ found_match = true; });$/;"	f	function:generate_pattern	file:
__anona73446400202	yosys/passes/pmgen/generate.h	/^			run(matcher, [](){});$/;"	f	function:generate_pattern	file:
__anonaa21f10b010a	yosys/libs/fst/fstapi.cc	/^                        {$/;"	u	function:fstReaderInit	file:
__anonad5aa9e1010a	yosys/frontends/ast/dpicall.cc	/^	union { double f64; float f32; int32_t i32; void *ptr; } value_store [args.size() + 1];$/;"	u	function:AST::dpi_call	file:
__anonade320d40102	yosys/passes/opt/opt_share.cc	/^	if (std::any_of(muxed_operands.begin(), muxed_operands.end(), [&](ExtSigSpec &op) { return op.s/;"	f	function:merge_operators	file:
__anonade320d40208	yosys/passes/opt/opt_share.cc	/^typedef struct {$/;"	s	file:
__anonade320d40302	yosys/passes/opt/opt_share.cc	/^			ports.erase(std::remove_if(ports.begin(), ports.end(), [&](const OpMuxConn *p) { return !ops_/;"	f	function:find_shared_operand	file:
__anonafd27bad010a	yosys/libs/fst/fstapi.h	/^    {$/;"	u	struct:fstHier
__anonb0a93cd80102	yosys/backends/edif/edif.cc	/^		auto add_prop = [&](IdString name, Const val) {$/;"	f	function:EdifBackend::execute	file:
__anonb0a93cd80202	yosys/backends/edif/edif.cc	/^						auto count_nontrivial_attr = [](Wire *w) {$/;"	f	function:EdifBackend::execute	file:
__anonb4c8d9f00102	yosys/frontends/verific/verific.cc	/^	auto set_init_attribute = [&](SigSpec &s) {$/;"	f	function:VerificClocking::addDff	file:
__anonb4c8d9f00202	yosys/frontends/verific/verific.cc	/^			application->setLogger([](std::string msg) { log("%s",msg.c_str()); } );$/;"	f	function:VerificPass::execute	file:
__anonb4c8d9f00302	yosys/frontends/verific/verific.cc	/^			generator->setLogger([](std::string msg) { log("%s",msg.c_str()); } );$/;"	f	function:VerificPass::execute	file:
__anonb7535e3e0108	yosys/libs/minisat/SolverTypes.h	/^    struct {$/;"	s	class:Minisat::Clause
__anonb7535e3e020a	yosys/libs/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	u	class:Minisat::Clause
__anonb7535e3e0303	yosys/libs/minisat/SolverTypes.h	/^    enum { Unit_Size = RegionAllocator<uint32_t>::Unit_Size };$/;"	g	class:Minisat::ClauseAllocator
__anonbf84816e0102	yosys/passes/techmap/abc9_ops.cc	/^				{$/;"	f	function:prep_bypass	file:
__anond38ebfb40102	yosys/passes/techmap/flowmap.cc	/^                                   [](RTLIL::SigBit) { return GraphStyle{}; },$/;"	f	file:
__anond38ebfb40202	yosys/passes/techmap/flowmap.cc	/^                                   [](RTLIL::SigBit, RTLIL::SigBit) { return GraphStyle{}; },$/;"	f	file:
__anond38ebfb40302	yosys/passes/techmap/flowmap.cc	/^		auto node_style = [&](RTLIL::SigBit node) {$/;"	f	function:FlowGraph::dump_dot_graph	file:
__anond38ebfb40402	yosys/passes/techmap/flowmap.cc	/^		auto edge_style = [&](RTLIL::SigBit source, RTLIL::SigBit sink) {$/;"	f	function:FlowGraph::dump_dot_graph	file:
__anond38ebfb40502	yosys/passes/techmap/flowmap.cc	/^		auto node_style = [&](RTLIL::SigBit node) {$/;"	f	function:FlowmapWorker::dump_dot_graph	file:
__anond38ebfb40602	yosys/passes/techmap/flowmap.cc	/^		auto edge_style = [&](RTLIL::SigBit, RTLIL::SigBit) {$/;"	f	function:FlowmapWorker::dump_dot_graph	file:
__anond4d589b60111	yosys/libs/bigint/BigUnsignedInABase.cc	/^namespace {$/;"	n	file:
__anond6aa304a0102	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^		[=](const std::string &name, const cxxrtl::debug_item &item) {$/;"	f	function:cxxrtl_vcd_add_from_if	file:
__anonded9aaf00102	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^		this->add(items, [](const std::string &, const debug_item &) {$/;"	f	function:cxxrtl::vcd_writer::add	file:
__anonded9aaf00202	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^		this->add(items, [](const std::string &, const debug_item &item) {$/;"	f	function:cxxrtl::vcd_writer::add_without_memories	file:
__anone41566e10102	yosys/passes/cmds/setundef.cc	/^				{$/;"	f	function:SetundefPass::execute	file:
__anone41566e10202	yosys/passes/cmds/setundef.cc	/^					initwires.sort([&](Wire *a, Wire *b) { return wire_weights.at(a) > wire_weights.at(b); });$/;"	f	function:SetundefPass::execute::__anone41566e10102	file:
__anonf40675070102	yosys/passes/sat/qbfsat.h	/^			std::string src_as_str = std::accumulate(x.first.begin(), x.first.end(), std::string(), [](co/;"	f	function:QbfSolutionType::write_solution	file:
__anonf4a4afe70103	yosys/libs/minisat/Solver.cc	/^    enum { seen_undef = 0, seen_source = 1, seen_removable = 2, seen_failed = 3 };$/;"	g	function:Solver::litRedundant	file:
__anonfa5010410102	yosys/passes/opt/pmux2shiftx.cc	/^					auto print_choices = [&]() {$/;"	f	function:Pmux2ShiftxPass::execute	file:
__anonfddb21b90102	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^			auto assign_from_outputs = [&](bool cell_converged) {$/;"	f	function:CxxrtlWorker::dump_cell_eval	file:
__anonfddb21b90202	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^			auto show_wire_type = [&](const RTLIL::Wire* wire, const WireType &wire_type) {$/;"	f	function:CxxrtlWorker::analyze_design	file:
__builtin_bswap32	yosys/frontends/aiger/aigerparse.cc	/^#define __builtin_bswap32 /;"	d	file:
__has_attribute	yosys/backends/cxxrtl/cxxrtl.h	/^#	define __has_attribute(/;"	d
_cat	yosys/libs/minisat/SimpSolver.cc	/^static const char* _cat = "SIMP";$/;"	v	typeref:typename:const char *	file:
_cat	yosys/libs/minisat/Solver.cc	/^static const char* _cat = "CORE";$/;"	v	typeref:typename:const char *	file:
_cells	yosys/backends/jny/jny.cc	/^        std::unordered_map<std::string, std::vector<Cell*>> _cells{};$/;"	m	struct:JnyWriter	typeref:typename:std::unordered_map<std::string,std::vector<Cell * >>	file:
_cxxrtl_handle	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^struct _cxxrtl_handle {$/;"	s	file:
_cxxrtl_outline	yosys/backends/cxxrtl/cxxrtl.h	/^typedef struct _cxxrtl_outline {$/;"	s
_cxxrtl_toplevel	yosys/backends/cxxrtl/cxxrtl.h	/^typedef struct _cxxrtl_toplevel {$/;"	s
_cxxrtl_vcd	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^struct _cxxrtl_vcd {$/;"	s	file:
_include_attributes	yosys/backends/jny/jny.cc	/^        bool _include_attributes;$/;"	m	struct:JnyWriter	typeref:typename:bool	file:
_include_connections	yosys/backends/jny/jny.cc	/^        bool _include_connections;$/;"	m	struct:JnyWriter	typeref:typename:bool	file:
_include_properties	yosys/backends/jny/jny.cc	/^        bool _include_properties;$/;"	m	struct:JnyWriter	typeref:typename:bool	file:
_insert	yosys/libs/minisat/Map.h	/^    void   _insert (const K& k, const D& d) { $/;"	f	class:Minisat::Map	typeref:typename:void
_use_selection	yosys/backends/jny/jny.cc	/^        bool _use_selection;$/;"	m	struct:JnyWriter	typeref:typename:bool	file:
a	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec a, b, c, y;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
a_maxwidth	yosys/techlibs/nexus/synth_nexus.cc	/^		int a_maxwidth;$/;"	m	struct:SynthNexusPass::DSPRule	typeref:typename:int	file:
a_minwidth	yosys/techlibs/nexus/synth_nexus.cc	/^		int a_minwidth;$/;"	m	struct:SynthNexusPass::DSPRule	typeref:typename:int	file:
abbreviateIds	yosys/passes/cmds/show.cc	/^	bool abbreviateIds;$/;"	m	struct:ShowWorker	typeref:typename:bool	file:
abc	yosys/techlibs/common/synth.cc	/^	string top_module, fsm_opts, memory_opts, abc;$/;"	m	struct:SynthPass	typeref:typename:string	file:
abc/abc-$(ABCREV)$(EXE)	yosys/Makefile	/^abc\/abc-$(ABCREV)$(EXE) abc\/libabc-$(ABCREV).a:$/;"	t
abc/libabc-$(ABCREV).a	yosys/Makefile	/^abc\/abc-$(ABCREV)$(EXE) abc\/libabc-$(ABCREV).a:$/;"	t
abc2	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
abc2	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
abc9	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
abc9	yosys/techlibs/gowin/synth_gowin.cc	/^	bool retime, nobram, nolutram, flatten, nodffe, nowidelut, abc9, noiopads, noalu;$/;"	m	struct:SynthGowinPass	typeref:typename:bool	file:
abc9	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
abc9	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
abc9	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	bool abc9;$/;"	m	struct:SynthQuickLogicPass	typeref:typename:bool	file:
abc9	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool abc9, dff;$/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
abc9_module	yosys/passes/techmap/abc9_exe.cc	/^void abc9_module(RTLIL::Design *design, std::string script_file, std::string exe_file,$/;"	f	typeref:typename:void
abc9_output_filter	yosys/passes/techmap/abc9_exe.cc	/^	abc9_output_filter(std::string tempdir_name, bool show_tempdir) : tempdir_name(tempdir_name), s/;"	f	struct:abc9_output_filter	file:
abc9_output_filter	yosys/passes/techmap/abc9_exe.cc	/^struct abc9_output_filter$/;"	s	file:
abc_module	yosys/passes/techmap/abc.cc	/^void abc_module(RTLIL::Design *design, RTLIL::Module *current_module, std::string script_file, s/;"	f	typeref:typename:void
abc_output_filter	yosys/passes/techmap/abc.cc	/^	abc_output_filter(std::string tempdir_name, bool show_tempdir) : tempdir_name(tempdir_name), sh/;"	f	struct:abc_output_filter	file:
abc_output_filter	yosys/passes/techmap/abc.cc	/^struct abc_output_filter$/;"	s	file:
abits	yosys/passes/memory/memory_bram.cc	/^		int groups, abits, dbits, init;$/;"	m	struct:rules_t::bram_t	typeref:typename:int	file:
abs	yosys/libs/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anonb7535e3e020a	typeref:typename:uint32_t
abstractLevel	yosys/libs/minisat/Solver.h	/^inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }$/;"	f	class:Minisat::Solver	typeref:typename:uint32_t
abstraction	yosys/libs/minisat/SolverTypes.h	/^    uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size/;"	f	class:Minisat::Clause	typeref:typename:uint32_t
accept	yosys/frontends/verific/verificsva.cc	/^	vector<Const> accept, reject;$/;"	m	struct:SvaDFsmNode	typeref:typename:vector<Const>	file:
accept	yosys/frontends/verific/verificsva.cc	/^	vector<SigSpec> accept, cond;$/;"	m	struct:SvaUFsmNode	typeref:typename:vector<SigSpec>	file:
acceptNode	yosys/frontends/verific/verificsva.cc	/^	int startNode, acceptNode, condNode;$/;"	m	struct:SvaFsm	typeref:typename:int	file:
act	yosys/libs/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anonb7535e3e020a	typeref:typename:float
actions	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::SigSig> actions;$/;"	m	struct:RTLIL::CaseRule	typeref:typename:std::vector<RTLIL::SigSig>
actions	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::SigSig> actions;$/;"	m	struct:RTLIL::SyncRule	typeref:typename:std::vector<RTLIL::SigSig>
activated_cells	yosys/backends/simplec/simplec.cc	/^	pool<string> activated_cells;$/;"	m	struct:SimplecWorker	typeref:typename:pool<string>	file:
activation_patterns_cache	yosys/passes/opt/share.cc	/^	std::map<RTLIL::Cell*, pool<ssc_pair_t>, cell_ptr_cmp> activation_patterns_cache;$/;"	m	struct:ShareWorker	typeref:typename:std::map<RTLIL::Cell *,pool<ssc_pair_t>,cell_ptr_cmp>	file:
active	yosys/libs/fst/fstapi.cc	/^    unsigned active : 1;$/;"	m	struct:fstBlackoutChain	typeref:typename:unsigned:1	file:
active_design	yosys/kernel/register.h	/^	RTLIL::Design *active_design;$/;"	m	struct:ScriptPass	typeref:typename:RTLIL::Design *
active_initdata	yosys/backends/verilog/verilog_backend.cc	/^dict<RTLIL::SigBit, RTLIL::State> active_initdata;$/;"	v	typeref:typename:dict<RTLIL::SigBit,RTLIL::State>
active_module	yosys/backends/verilog/verilog_backend.cc	/^RTLIL::Module *active_module;$/;"	v	typeref:typename:RTLIL::Module *
active_run_from	yosys/kernel/register.h	/^	std::string active_run_from, active_run_to;$/;"	m	struct:ScriptPass	typeref:typename:std::string
active_run_to	yosys/kernel/register.h	/^	std::string active_run_from, active_run_to;$/;"	m	struct:ScriptPass	typeref:typename:std::string
active_sigmap	yosys/backends/verilog/verilog_backend.cc	/^SigMap active_sigmap;$/;"	v	typeref:typename:SigMap
activity	yosys/libs/minisat/Solver.h	/^        const IntMap<Var, double>&  activity;$/;"	m	struct:Minisat::Solver::VarOrderLt	typeref:typename:const IntMap<Var,double> &
activity	yosys/libs/minisat/Solver.h	/^    VMap<double>        activity;         \/\/ A heuristic measurement of the activity of a vari/;"	m	class:Minisat::Solver	typeref:typename:VMap<double>
activity	yosys/libs/minisat/SolverTypes.h	/^    float&       activity    ()              { assert(header.has_extra); return data[header.size/;"	f	class:Minisat::Clause	typeref:typename:float &
add	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> add(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
add	yosys/backends/cxxrtl/cxxrtl.h	/^	void add(const std::string &name, debug_item &&item) {$/;"	f	struct:cxxrtl::debug_items	typeref:typename:void
add	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	Vertex *add(T *data)$/;"	f	struct:Scheduler	typeref:typename:Vertex *	file:
add	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void add(const debug_items &items) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
add	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void add(const debug_items &items, const Filter &filter) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
add	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void add(const std::string &hier_name, const debug_item &item, bool multipart = false) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
add	yosys/frontends/verilog/preproc.cc	/^define_map_t::add(const std::string &name, const std::string &txt, const arg_map_t *args)$/;"	f	class:define_map_t	typeref:typename:void
add	yosys/frontends/verilog/preproc.cc	/^void define_map_t::add(const std::string &name, const define_body_t &body)$/;"	f	class:define_map_t	typeref:typename:void
add	yosys/kernel/rtlil.cc	/^void RTLIL::Design::add(RTLIL::Binding *binding)$/;"	f	class:RTLIL::Design	typeref:typename:void
add	yosys/kernel/rtlil.cc	/^void RTLIL::Design::add(RTLIL::Module *module)$/;"	f	class:RTLIL::Design	typeref:typename:void
add	yosys/kernel/rtlil.cc	/^void RTLIL::Module::add(RTLIL::Binding *binding)$/;"	f	class:RTLIL::Module	typeref:typename:void
add	yosys/kernel/rtlil.cc	/^void RTLIL::Module::add(RTLIL::Cell *cell)$/;"	f	class:RTLIL::Module	typeref:typename:void
add	yosys/kernel/rtlil.cc	/^void RTLIL::Module::add(RTLIL::Process *process)$/;"	f	class:RTLIL::Module	typeref:typename:void
add	yosys/kernel/rtlil.cc	/^void RTLIL::Module::add(RTLIL::Wire *wire)$/;"	f	class:RTLIL::Module	typeref:typename:void
add	yosys/kernel/sigtools.h	/^	inline void add(Wire *wire) { return add(RTLIL::SigSpec(wire)); }$/;"	f	struct:SigMap	typeref:typename:void
add	yosys/kernel/sigtools.h	/^	void add(const RTLIL::SigBit &bit)$/;"	f	struct:SigMap	typeref:typename:void
add	yosys/kernel/sigtools.h	/^	void add(const RTLIL::SigSpec &sig)$/;"	f	struct:SigMap	typeref:typename:void
add	yosys/kernel/sigtools.h	/^	void add(const RTLIL::SigSpec &sig)$/;"	f	struct:SigPool	typeref:typename:void
add	yosys/kernel/sigtools.h	/^	void add(const RTLIL::SigSpec& from, const RTLIL::SigSpec& to)$/;"	f	struct:SigMap	typeref:typename:void
add	yosys/kernel/sigtools.h	/^	void add(const SigPool &other)$/;"	f	struct:SigPool	typeref:typename:void
add	yosys/libs/bigint/BigInteger.cc	/^void BigInteger::add(const BigInteger &a, const BigInteger &b) {$/;"	f	class:BigInteger	typeref:typename:void
add	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::add(const BigUnsigned &a, const BigUnsigned &b) {$/;"	f	class:BigUnsigned	typeref:typename:void
add	yosys/libs/subcircuit/subcircuit.cc	/^		void add(const Graph &graph, adjMatrix_t &adjMatrix, const std::string &graphId, Solver *userS/;"	f	struct:SubCircuit::SolverWorker::DiCache	typeref:typename:void	file:
add	yosys/passes/sat/mutate.cc	/^	void add(mutate_t *m) {$/;"	f	struct:mutate_queue_t	typeref:typename:void	file:
add	yosys/passes/sat/mutate.cc	/^	void add(mutate_t *m, K key, Args... args) {$/;"	f	struct:mutate_chain_queue_t	typeref:typename:void	file:
add	yosys/passes/sat/mutate.cc	/^	void add(mutate_t *m, K key, Args... args) {$/;"	f	struct:mutate_once_queue_t	typeref:typename:void	file:
add	yosys/passes/techmap/maccmap.cc	/^	void add(RTLIL::SigBit bit, int position)$/;"	f	struct:MaccmapWorker	typeref:typename:void	file:
add	yosys/passes/techmap/maccmap.cc	/^	void add(RTLIL::SigSpec a, RTLIL::SigSpec b, bool is_signed, bool do_subtract)$/;"	f	struct:MaccmapWorker	typeref:typename:void	file:
add	yosys/passes/techmap/maccmap.cc	/^	void add(RTLIL::SigSpec a, bool is_signed, bool do_subtract)$/;"	f	struct:MaccmapWorker	typeref:typename:void	file:
addAdff	yosys/frontends/verific/verific.cc	/^Cell *VerificClocking::addAdff(IdString name, RTLIL::SigSpec sig_arst, SigSpec sig_d, SigSpec si/;"	f	class:VerificClocking	typeref:typename:Cell *
addAdff	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAdff(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const R/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAdffGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAdffGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, con/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAdffe	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAdffe(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const /;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAdffeGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAdffeGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, co/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAdlatch	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAdlatch(RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAdlatchGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAdlatchGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_en, c/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAldff	yosys/frontends/verific/verific.cc	/^Cell *VerificClocking::addAldff(IdString name, RTLIL::SigSpec sig_aload, RTLIL::SigSpec sig_adat/;"	f	class:VerificClocking	typeref:typename:Cell *
addAldff	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAldff(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const /;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAldffGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAldffGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, co/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAldffe	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAldffe(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAldffeGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAldffeGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, c/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAssert	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAssert(RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const R/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addAssume	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addAssume(RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const R/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addCell	yosys/kernel/rtlil.cc	/^RTLIL::Cell *RTLIL::Module::addCell(RTLIL::IdString name, RTLIL::IdString type)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addCell	yosys/kernel/rtlil.cc	/^RTLIL::Cell *RTLIL::Module::addCell(RTLIL::IdString name, const RTLIL::Cell *other)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addChunkActions	yosys/frontends/ast/genrtlil.cc	/^	void addChunkActions(std::vector<RTLIL::SigSig> &actions, RTLIL::SigSpec lvalue, RTLIL::SigSpec/;"	f	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:void	file:
addClause	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p)                 { add_tmp.clear(); add_tmp.push(p);/;"	f	class:Minisat::SimpSolver	typeref:typename:bool
addClause	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p);/;"	f	class:Minisat::SimpSolver	typeref:typename:bool
addClause	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p);/;"	f	class:Minisat::SimpSolver	typeref:typename:bool
addClause	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::addClause    (Lit p, Lit q, Lit r, Lit s){ add_tmp.clear(); add_tmp.push/;"	f	class:Minisat::SimpSolver	typeref:typename:bool
addClause	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::addClause    (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addCla/;"	f	class:Minisat::SimpSolver	typeref:typename:bool
addClause	yosys/libs/minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(/;"	f	class:Minisat::Solver	typeref:typename:bool
addClause	yosys/libs/minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(/;"	f	class:Minisat::Solver	typeref:typename:bool
addClause	yosys/libs/minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(/;"	f	class:Minisat::Solver	typeref:typename:bool
addClause	yosys/libs/minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r, Lit s){ add_tmp.clear(); add_tmp.p/;"	f	class:Minisat::Solver	typeref:typename:bool
addClause	yosys/libs/minisat/Solver.h	/^inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return add/;"	f	class:Minisat::Solver	typeref:typename:bool
addClause_	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::addClause_(vec<Lit>& ps)$/;"	f	class:SimpSolver	typeref:typename:bool
addClause_	yosys/libs/minisat/Solver.cc	/^bool Solver::addClause_(vec<Lit>& ps)$/;"	f	class:Solver	typeref:typename:bool
addCompatibleConstants	yosys/libs/subcircuit/subcircuit.cc	/^	void addCompatibleConstants(int needleConstant, int haystackConstant)$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
addCompatibleConstants	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::addCompatibleConstants(int needleConstant, int haystackConstant)$/;"	f	class:SubCircuit::Solver	typeref:typename:void
addCompatibleTypes	yosys/libs/subcircuit/subcircuit.cc	/^	void addCompatibleTypes(std::string needleTypeId, std::string haystackTypeId)$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
addCompatibleTypes	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::addCompatibleTypes(std::string needleTypeId, std::string haystackTypeId/;"	f	class:SubCircuit::Solver	typeref:typename:void
addConcat	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addConcat(RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const R/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addCover	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addCover(RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RT/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDff	yosys/frontends/verific/verific.cc	/^Cell *VerificClocking::addDff(IdString name, SigSpec sig_d, SigSpec sig_q, Const init_value)$/;"	f	class:VerificClocking	typeref:typename:Cell *
addDff	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDff(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const RT/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDffGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDffGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, cons/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDffe	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDffe(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const R/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDffeGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDffeGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, con/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDffsr	yosys/frontends/verific/verific.cc	/^Cell *VerificClocking::addDffsr(IdString name, RTLIL::SigSpec sig_set, RTLIL::SigSpec sig_clr, S/;"	f	class:VerificClocking	typeref:typename:Cell *
addDffsr	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDffsr(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const /;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDffsrGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDffsrGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, co/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDffsre	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDffsre(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDffsreGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDffsreGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, c/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDlatch	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDlatch(RTLIL::IdString name, const RTLIL::SigSpec &sig_en, const /;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDlatchGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDlatchGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_en, co/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDlatchsr	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDlatchsr(RTLIL::IdString name, const RTLIL::SigSpec &sig_en, cons/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDlatchsrGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addDlatchsrGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_en, /;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addDsp	yosys/passes/pmgen/xilinx_dsp.cc	/^static Cell* addDsp(Module *module) {$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN Cell *	file:
addEmptyClause	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::addEmptyClause()                     { add_tmp.clear(); return addClause/;"	f	class:Minisat::SimpSolver	typeref:typename:bool
addEmptyClause	yosys/libs/minisat/Solver.h	/^inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addCla/;"	f	class:Minisat::Solver	typeref:typename:bool
addEquiv	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addEquiv(RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RT/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addFair	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addFair(RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTL/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addFf	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addFf(RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const RTLIL/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addFfGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addFfGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_d, const R/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addGraph	yosys/libs/subcircuit/subcircuit.cc	/^	void addGraph(std::string graphId, const Graph &graph)$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
addGraph	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::addGraph(std::string graphId, const Graph &graph)$/;"	f	class:SubCircuit::Solver	typeref:typename:void
addLive	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addLive(RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTL/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addLut	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addLut(RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RTLI/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addMemory	yosys/kernel/rtlil.cc	/^RTLIL::Memory *RTLIL::Module::addMemory(RTLIL::IdString name, const RTLIL::Memory *other)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Memory *
addModule	yosys/kernel/rtlil.cc	/^RTLIL::Module *RTLIL::Design::addModule(RTLIL::IdString name)$/;"	f	class:RTLIL::Design	typeref:typename:RTLIL::Module *
addProcess	yosys/kernel/rtlil.cc	/^RTLIL::Process *RTLIL::Module::addProcess(RTLIL::IdString name)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Process *
addProcess	yosys/kernel/rtlil.cc	/^RTLIL::Process *RTLIL::Module::addProcess(RTLIL::IdString name, const RTLIL::Process *other)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Process *
addSdff	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addSdff(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const R/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addSdffGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addSdffGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, con/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addSdffce	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addSdffce(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addSdffceGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addSdffceGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, c/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addSdffe	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addSdffe(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, const /;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addSdffeGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addSdffeGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_clk, co/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addSlice	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addSlice(RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const RT/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addSr	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addSr(RTLIL::IdString name, const RTLIL::SigSpec &sig_set, const RTL/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addSrGate	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addSrGate(RTLIL::IdString name, const RTLIL::SigSpec &sig_set, const/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addSwappablePorts	yosys/libs/subcircuit/subcircuit.cc	/^	void addSwappablePorts(std::string needleTypeId, const std::set<std::string> &ports)$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
addSwappablePorts	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::addSwappablePorts(std::string needleTypeId, std::set<std::string> ports/;"	f	class:SubCircuit::Solver	typeref:typename:void
addSwappablePorts	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::addSwappablePorts(std::string needleTypeId, std::string portId1, std::s/;"	f	class:SubCircuit::Solver	typeref:typename:void
addSwappablePortsPermutation	yosys/libs/subcircuit/subcircuit.cc	/^	void addSwappablePortsPermutation(std::string needleTypeId, const std::map<std::string, std::st/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
addSwappablePortsPermutation	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::addSwappablePortsPermutation(std::string needleTypeId, std::map<std::st/;"	f	class:SubCircuit::Solver	typeref:typename:void
addTribuf	yosys/kernel/rtlil.cc	/^RTLIL::Cell* RTLIL::Module::addTribuf(RTLIL::IdString name, const RTLIL::SigSpec &sig_a, const R/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Cell *
addWire	yosys/kernel/rtlil.cc	/^RTLIL::Wire *RTLIL::Module::addWire(RTLIL::IdString name, const RTLIL::Wire *other)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Wire *
addWire	yosys/kernel/rtlil.cc	/^RTLIL::Wire *RTLIL::Module::addWire(RTLIL::IdString name, int width)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Wire *
add_arg	yosys/frontends/verilog/preproc.cc	/^	void add_arg(const std::string &name, const char *default_value)$/;"	f	struct:arg_map_t	typeref:typename:void	file:
add_block	yosys/libs/ezsat/puzzle3d.cc	/^int add_block(int pos_x, int pos_y, int pos_z, int size_x, int size_y, int size_z, int blockidx)$/;"	f	typeref:typename:int
add_block_positions_124	yosys/libs/ezsat/puzzle3d.cc	/^void add_block_positions_124(std::vector<int> &block_positions_124)$/;"	f	typeref:typename:void
add_block_positions_223	yosys/libs/ezsat/puzzle3d.cc	/^void add_block_positions_223(std::vector<int> &block_positions_223)$/;"	f	typeref:typename:void
add_case_rule_defs_uses	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void add_case_rule_defs_uses(Node *node, const RTLIL::CaseRule *case_)$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_cell	yosys/kernel/modtools.h	/^	void add_cell(RTLIL::Cell *cell)$/;"	f	struct:ModWalker	typeref:typename:void
add_cell_eval_defs_uses	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void add_cell_eval_defs_uses(Node *node, const RTLIL::Cell *cell)$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_cell_port	yosys/kernel/modtools.h	/^	void add_cell_port(RTLIL::Cell *cell, RTLIL::IdString port, std::vector<RTLIL::SigBit> bits, bo/;"	f	struct:ModWalker	typeref:typename:void
add_cell_sync_defs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void add_cell_sync_defs(Node *node, const RTLIL::Cell *cell)$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_clause	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::add_clause(const std::vector<int> &args)$/;"	f	class:ezSAT	typeref:typename:void
add_clause	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::add_clause(const std::vector<int> &args, bool argsPolarity, int a, int b, int c)$/;"	f	class:ezSAT	typeref:typename:void
add_clause	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::add_clause(int a, int b, int c)$/;"	f	class:ezSAT	typeref:typename:void
add_connect_defs_uses	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void add_connect_defs_uses(Node *node, const RTLIL::SigSig &conn)$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_defs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void add_defs(Node *node, const RTLIL::SigSpec &sig, bool is_ff, bool inlinable)$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_dummy_aload	yosys/kernel/ff.cc	/^void FfData::add_dummy_aload() {$/;"	f	class:FfData	typeref:typename:void
add_dummy_arst	yosys/kernel/ff.cc	/^void FfData::add_dummy_arst() {$/;"	f	class:FfData	typeref:typename:void
add_dummy_ce	yosys/kernel/ff.cc	/^void FfData::add_dummy_ce() {$/;"	f	class:FfData	typeref:typename:void
add_dummy_clk	yosys/kernel/ff.cc	/^void FfData::add_dummy_clk() {$/;"	f	class:FfData	typeref:typename:void
add_dummy_sr	yosys/kernel/ff.cc	/^void FfData::add_dummy_sr() {$/;"	f	class:FfData	typeref:typename:void
add_dummy_srst	yosys/kernel/ff.cc	/^void FfData::add_dummy_srst() {$/;"	f	class:FfData	typeref:typename:void
add_echos_to_abc9_cmd	yosys/passes/techmap/abc9_exe.cc	/^std::string add_echos_to_abc9_cmd(std::string str)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN std::string
add_echos_to_abc_cmd	yosys/passes/techmap/abc.cc	/^std::string add_echos_to_abc_cmd(std::string str)$/;"	f	typeref:typename:std::string
add_edge	yosys/kernel/celledges.h	/^	void add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_po/;"	f	struct:FwdCellEdgesDatabase	typeref:typename:void
add_edge	yosys/kernel/celledges.h	/^	void add_edge(RTLIL::Cell *cell, RTLIL::IdString from_port, int from_bit, RTLIL::IdString to_po/;"	f	struct:RevCellEdgesDatabase	typeref:typename:void
add_edges_from_cell	yosys/kernel/celledges.cc	/^bool YOSYS_NAMESPACE_PREFIX AbstractCellEdgesDatabase::add_edges_from_cell(RTLIL::Cell *cell)$/;"	f	class:AbstractCellEdgesDatabase	typeref:typename:PRIVATE_NAMESPACE_END bool YOSYS_NAMESPACE_PREFIX
add_extra_objs	yosys/Makefile	/^define add_extra_objs$/;"	m
add_formal	yosys/passes/cmds/add.cc	/^static void add_formal(RTLIL::Module *module, const std::string &celltype, const std::string &na/;"	f	typeref:typename:void	file:
add_gen_share_file	yosys/Makefile	/^define add_gen_share_file$/;"	m
add_imprecise_GLIFT_logic_1	yosys/passes/cmds/glift.cc	/^	void add_imprecise_GLIFT_logic_1(const RTLIL::Cell *cell, RTLIL::SigSpec &port_a, RTLIL::SigSpe/;"	f	struct:GliftWorker	typeref:typename:void	file:
add_imprecise_GLIFT_logic_2	yosys/passes/cmds/glift.cc	/^	void add_imprecise_GLIFT_logic_2(const RTLIL::Cell *cell, RTLIL::SigSpec &port_a, RTLIL::SigSpe/;"	f	struct:GliftWorker	typeref:typename:void	file:
add_imprecise_GLIFT_logic_3	yosys/passes/cmds/glift.cc	/^	void add_imprecise_GLIFT_logic_3(const RTLIL::Cell *cell, RTLIL::SigSpec &port_a_taint, RTLIL::/;"	f	struct:GliftWorker	typeref:typename:void	file:
add_imprecise_GLIFT_logic_4	yosys/passes/cmds/glift.cc	/^	void add_imprecise_GLIFT_logic_4(RTLIL::SigSpec &port_a_taint, RTLIL::SigSpec &port_y_taint) {$/;"	f	struct:GliftWorker	typeref:typename:void	file:
add_imprecise_GLIFT_logic_5	yosys/passes/cmds/glift.cc	/^	void add_imprecise_GLIFT_logic_5(RTLIL::SigSpec &port_b_taint, RTLIL::SigSpec &port_y_taint) {$/;"	f	struct:GliftWorker	typeref:typename:void	file:
add_imprecise_GLIFT_logic_6	yosys/passes/cmds/glift.cc	/^	void add_imprecise_GLIFT_logic_6(RTLIL::SigSpec &port_y_taint) {$/;"	f	struct:GliftWorker	typeref:typename:void	file:
add_imprecise_GLIFT_logic_7	yosys/passes/cmds/glift.cc	/^	void add_imprecise_GLIFT_logic_7(RTLIL::SigSpec &port_y_taint) {$/;"	f	struct:GliftWorker	typeref:typename:void	file:
add_include_file	yosys/Makefile	/^define add_include_file$/;"	m
add_lut_edge	yosys/passes/techmap/flowmap.cc	/^	void add_lut_edge(RTLIL::SigBit pred, RTLIL::SigBit succ, pool<RTLIL::SigBit> *changed = nullpt/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
add_members_to_scope	yosys/frontends/ast/simplify.cc	/^static void add_members_to_scope(AstNode *snode, std::string name)$/;"	f	typeref:typename:void	file:
add_new_wire	yosys/passes/sat/expose.cc	/^RTLIL::Wire *add_new_wire(RTLIL::Module *module, RTLIL::IdString name, int width = 1)$/;"	f	typeref:typename:RTLIL::Wire *
add_nid_sig	yosys/backends/btor/btor.cc	/^	void add_nid_sig(int nid, const SigSpec &sig)$/;"	f	struct:BtorWorker	typeref:typename:void	file:
add_node	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	Node *add_node(const RTLIL::Cell *cell)$/;"	f	struct:FlowGraph	typeref:typename:Node *	file:
add_node	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	Node *add_node(const RTLIL::Process *process)$/;"	f	struct:FlowGraph	typeref:typename:Node *	file:
add_node	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	Node *add_node(const RTLIL::SigSig &conn)$/;"	f	struct:FlowGraph	typeref:typename:Node *	file:
add_node	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void add_node(const Mem *mem) {$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_package_types	yosys/frontends/verilog/verilog_frontend.cc	/^static void add_package_types(dict<std::string, AST::AstNode *> &user_types, std::vector<AST::As/;"	f	typeref:typename:void	file:
add_port	yosys/passes/cmds/connwrappers.cc	/^	void add_port(std::string celltype, std::string portname, std::string widthparam, bool is_signe/;"	f	struct:ConnwrappersWorker	typeref:typename:void	file:
add_port	yosys/passes/cmds/connwrappers.cc	/^	void add_port(std::string celltype, std::string portname, std::string widthparam, std::string s/;"	f	struct:ConnwrappersWorker	typeref:typename:void	file:
add_precise_GLIFT_logic	yosys/passes/cmds/glift.cc	/^	void add_precise_GLIFT_logic(const RTLIL::Cell *cell, RTLIL::SigSpec &port_a, RTLIL::SigSpec &p/;"	f	struct:GliftWorker	typeref:typename:void	file:
add_precise_GLIFT_mux	yosys/passes/cmds/glift.cc	/^	void add_precise_GLIFT_mux(const RTLIL::Cell *cell, RTLIL::SigSpec &port_a, RTLIL::SigSpec &por/;"	f	struct:GliftWorker	typeref:typename:void	file:
add_share_file	yosys/Makefile	/^define add_share_file$/;"	m
add_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> add_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
add_strpool_attribute	yosys/kernel/rtlil.cc	/^void RTLIL::AttrObject::add_strpool_attribute(RTLIL::IdString id, const pool<string> &data)$/;"	f	class:RTLIL::AttrObject	typeref:typename:void
add_sync_rules_defs_uses	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void add_sync_rules_defs_uses(Node *node, const RTLIL::Process *process)$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_tmp	yosys/libs/minisat/Solver.h	/^    vec<Lit>            add_tmp;$/;"	m	class:Minisat::Solver	typeref:typename:vec<Lit>
add_uses	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void add_uses(Node *node, const RTLIL::SigSpec &sig)$/;"	f	struct:FlowGraph	typeref:typename:void	file:
add_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> add_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
add_wire	yosys/kernel/modtools.h	/^	void add_wire(RTLIL::Wire *wire)$/;"	f	struct:ModWalker	typeref:typename:void
add_wire	yosys/passes/cmds/add.cc	/^static void add_wire(RTLIL::Design *design, RTLIL::Module *module, std::string name, int width, /;"	f	typeref:typename:void	file:
add_wire	yosys/passes/cmds/setundef.cc	/^static RTLIL::Wire * add_wire(RTLIL::Module *module, std::string name, int width, bool flag_inpu/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN RTLIL::Wire *	file:
add_wire_for_ref	yosys/frontends/ast/simplify.cc	/^void add_wire_for_ref(const RTLIL::Wire *ref, const std::string &str)$/;"	f	typeref:typename:void
add_without_memories	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void add_without_memories(const debug_items &items) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
adder	yosys/kernel/cellaigs.cc	/^	vector<int> adder(const vector<int> &A, const vector<int> &B, int carry, vector<int> *X = nullp/;"	f	struct:AigMaker	typeref:typename:vector<int>	file:
addhash	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::addhash(unsigned int h)$/;"	f	class:ezSAT	typeref:typename:void
addr	yosys/kernel/mem.h	/^	Const addr;$/;"	m	struct:MemInit	typeref:typename:Const
addr	yosys/kernel/mem.h	/^	SigSpec clk, en, addr, data;$/;"	m	struct:MemWr	typeref:typename:SigSpec
addr	yosys/kernel/mem.h	/^	SigSpec clk, en, arst, srst, addr, data;$/;"	m	struct:MemRd	typeref:typename:SigSpec
addr_decode	yosys/passes/memory/memory_map.cc	/^	RTLIL::Wire *addr_decode(RTLIL::SigSpec addr_sig, RTLIL::SigSpec addr_val)$/;"	f	struct:MemoryMapWorker	typeref:typename:RTLIL::Wire *	file:
addr_eq	yosys/passes/memory/memory_dff.cc	/^	int addr_eq(SigSpec raddr, SigSpec waddr) {$/;"	f	struct:MemQueryCache	typeref:typename:int	file:
address	yosys/kernel/rtlil.h	/^	RTLIL::SigSpec address;$/;"	m	struct:RTLIL::MemWriteAction	typeref:typename:RTLIL::SigSpec
addshift.pdf	yosys/manual/PRESENTATION_ExAdv/Makefile	/^addshift.pdf: addshift_*$/;"	t
adjMatrix	yosys/libs/subcircuit/subcircuit.cc	/^		adjMatrix_t adjMatrix;$/;"	m	struct:SubCircuit::SolverWorker::GraphData	typeref:typename:adjMatrix_t	file:
adjMatrix_t	yosys/libs/subcircuit/subcircuit.cc	/^	typedef std::vector<std::map<int, int>> adjMatrix_t;$/;"	t	class:SubCircuit::SolverWorker	typeref:typename:std::vector<std::map<int,int>>	file:
ael	yosys/libs/minisat/Alloc.h	/^    Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*/;"	f	class:Minisat::RegionAllocator	typeref:typename:Ref
ael	yosys/libs/minisat/SolverTypes.h	/^    CRef          ael       (const Clause* t){ return ra.ael((uint32_t*)t); }$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:CRef
aig	yosys/kernel/cellaigs.cc	/^	Aig *aig;$/;"	m	struct:AigMaker	typeref:typename:Aig *	file:
aig_a	yosys/backends/aiger/aiger.cc	/^	int aig_m = 0, aig_i = 0, aig_l = 0, aig_o = 0, aig_a = 0;$/;"	m	struct:AigerWriter	typeref:typename:int	file:
aig_a	yosys/backends/aiger/xaiger.cc	/^	int aig_m = 0, aig_i = 0, aig_l = 0, aig_o = 0, aig_a = 0;$/;"	m	struct:XAigerWriter	typeref:typename:int	file:
aig_b	yosys/backends/aiger/aiger.cc	/^	int aig_b = 0, aig_c = 0, aig_j = 0, aig_f = 0;$/;"	m	struct:AigerWriter	typeref:typename:int	file:
aig_c	yosys/backends/aiger/aiger.cc	/^	int aig_b = 0, aig_c = 0, aig_j = 0, aig_f = 0;$/;"	m	struct:AigerWriter	typeref:typename:int	file:
aig_f	yosys/backends/aiger/aiger.cc	/^	int aig_b = 0, aig_c = 0, aig_j = 0, aig_f = 0;$/;"	m	struct:AigerWriter	typeref:typename:int	file:
aig_gates	yosys/backends/aiger/aiger.cc	/^	vector<pair<int, int>> aig_gates;$/;"	m	struct:AigerWriter	typeref:typename:vector<pair<int,int>>	file:
aig_gates	yosys/backends/aiger/xaiger.cc	/^	vector<pair<int, int>> aig_gates;$/;"	m	struct:XAigerWriter	typeref:typename:vector<pair<int,int>>	file:
aig_i	yosys/backends/aiger/aiger.cc	/^	int aig_m = 0, aig_i = 0, aig_l = 0, aig_o = 0, aig_a = 0;$/;"	m	struct:AigerWriter	typeref:typename:int	file:
aig_i	yosys/backends/aiger/xaiger.cc	/^	int aig_m = 0, aig_i = 0, aig_l = 0, aig_o = 0, aig_a = 0;$/;"	m	struct:XAigerWriter	typeref:typename:int	file:
aig_indices	yosys/kernel/cellaigs.cc	/^	idict<AigNode> aig_indices;$/;"	m	struct:AigMaker	typeref:typename:idict<AigNode>	file:
aig_j	yosys/backends/aiger/aiger.cc	/^	int aig_b = 0, aig_c = 0, aig_j = 0, aig_f = 0;$/;"	m	struct:AigerWriter	typeref:typename:int	file:
aig_l	yosys/backends/aiger/aiger.cc	/^	int aig_m = 0, aig_i = 0, aig_l = 0, aig_o = 0, aig_a = 0;$/;"	m	struct:AigerWriter	typeref:typename:int	file:
aig_l	yosys/backends/aiger/xaiger.cc	/^	int aig_m = 0, aig_i = 0, aig_l = 0, aig_o = 0, aig_a = 0;$/;"	m	struct:XAigerWriter	typeref:typename:int	file:
aig_latchin	yosys/backends/aiger/aiger.cc	/^	vector<int> aig_latchin, aig_latchinit, aig_outputs;$/;"	m	struct:AigerWriter	typeref:typename:vector<int>	file:
aig_latchinit	yosys/backends/aiger/aiger.cc	/^	vector<int> aig_latchin, aig_latchinit, aig_outputs;$/;"	m	struct:AigerWriter	typeref:typename:vector<int>	file:
aig_m	yosys/backends/aiger/aiger.cc	/^	int aig_m = 0, aig_i = 0, aig_l = 0, aig_o = 0, aig_a = 0;$/;"	m	struct:AigerWriter	typeref:typename:int	file:
aig_m	yosys/backends/aiger/xaiger.cc	/^	int aig_m = 0, aig_i = 0, aig_l = 0, aig_o = 0, aig_a = 0;$/;"	m	struct:XAigerWriter	typeref:typename:int	file:
aig_map	yosys/backends/aiger/aiger.cc	/^	dict<SigBit, int> aig_map;$/;"	m	struct:AigerWriter	typeref:typename:dict<SigBit,int>	file:
aig_map	yosys/backends/aiger/xaiger.cc	/^	dict<SigBit, int> aig_map;$/;"	m	struct:XAigerWriter	typeref:typename:dict<SigBit,int>	file:
aig_mode	yosys/backends/json/json.cc	/^	bool aig_mode;$/;"	m	struct:JsonWriter	typeref:typename:bool	file:
aig_mode_	yosys/backends/protobuf/protobuf.cc	/^	bool aig_mode_;$/;"	m	struct:ProtobufDesignSerializer	typeref:typename:bool	file:
aig_models	yosys/backends/json/json.cc	/^	pool<Aig> aig_models;$/;"	m	struct:JsonWriter	typeref:typename:pool<Aig>	file:
aig_models_	yosys/backends/protobuf/protobuf.cc	/^	pool<Aig> aig_models_;$/;"	m	struct:ProtobufDesignSerializer	typeref:typename:pool<Aig>	file:
aig_o	yosys/backends/aiger/aiger.cc	/^	int aig_m = 0, aig_i = 0, aig_l = 0, aig_o = 0, aig_a = 0;$/;"	m	struct:AigerWriter	typeref:typename:int	file:
aig_o	yosys/backends/aiger/xaiger.cc	/^	int aig_m = 0, aig_i = 0, aig_l = 0, aig_o = 0, aig_a = 0;$/;"	m	struct:XAigerWriter	typeref:typename:int	file:
aig_outputs	yosys/backends/aiger/aiger.cc	/^	vector<int> aig_latchin, aig_latchinit, aig_outputs;$/;"	m	struct:AigerWriter	typeref:typename:vector<int>	file:
aig_outputs	yosys/backends/aiger/xaiger.cc	/^	vector<int> aig_outputs;$/;"	m	struct:XAigerWriter	typeref:typename:vector<int>	file:
aiger_autoidx	yosys/frontends/aiger/aigerparse.h	/^    const int aiger_autoidx;$/;"	m	struct:AigerReader	typeref:typename:const int
aiger_encode	yosys/backends/aiger/aiger.cc	/^void aiger_encode(std::ostream &f, int x)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
aiger_encode	yosys/backends/aiger/xaiger.cc	/^void aiger_encode(std::ostream &f, int x)$/;"	f	typeref:typename:void
aiw_inits	yosys/passes/sat/sim.cc	/^	dict<int, SigBit> aiw_inputs, aiw_inits;$/;"	m	struct:AIWWriter	typeref:typename:dict<int,SigBit>	file:
aiw_inputs	yosys/passes/sat/sim.cc	/^	dict<int, SigBit> aiw_inputs, aiw_inits;$/;"	m	struct:AIWWriter	typeref:typename:dict<int,SigBit>	file:
aiw_latches	yosys/passes/sat/sim.cc	/^	dict<int, std::pair<SigBit, bool>> aiw_latches;$/;"	m	struct:AIWWriter	typeref:typename:dict<int,std::pair<SigBit,bool>>	file:
aiwfile	yosys/passes/sat/sim.cc	/^	std::ofstream aiwfile;$/;"	m	struct:AIWWriter	typeref:typename:std::ofstream	file:
alarmHandler	yosys/libs/ezsat/ezminisat.cc	/^void ezMiniSAT::alarmHandler(int)$/;"	f	class:ezMiniSAT	typeref:typename:void
alarmHandlerThis	yosys/libs/ezsat/ezminisat.cc	/^ezMiniSAT *ezMiniSAT::alarmHandlerThis = NULL;$/;"	m	class:ezMiniSAT	typeref:typename:ezMiniSAT *
alarmHandlerThis	yosys/libs/ezsat/ezminisat.h	/^	static ezMiniSAT *alarmHandlerThis;$/;"	m	class:ezMiniSAT	typeref:typename:ezMiniSAT *
alarmHandlerTimeout	yosys/libs/ezsat/ezminisat.cc	/^clock_t ezMiniSAT::alarmHandlerTimeout = 0;$/;"	m	class:ezMiniSAT	typeref:typename:clock_t
alarmHandlerTimeout	yosys/libs/ezsat/ezminisat.h	/^	static clock_t alarmHandlerTimeout;$/;"	m	class:ezMiniSAT	typeref:typename:clock_t
alias_map	yosys/backends/aiger/aiger.cc	/^	dict<SigBit, SigBit> not_map, ff_map, alias_map;$/;"	m	struct:AigerWriter	typeref:typename:dict<SigBit,SigBit>	file:
alias_map	yosys/backends/aiger/xaiger.cc	/^	dict<SigBit, SigBit> not_map, alias_map;$/;"	m	struct:XAigerWriter	typeref:typename:dict<SigBit,SigBit>	file:
aliases	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	std::map<chunk_t*, size_t> aliases;$/;"	m	class:cxxrtl::vcd_writer	typeref:typename:std::map<chunk_t *,size_t>
all	yosys/Makefile	/^all: top-all$/;"	t
all	yosys/examples/smtbmc/Makefile	/^all: demo1 demo2 demo3 demo4 demo5 demo6 demo7 demo8 demo9 glift_mux$/;"	t
all	yosys/libs/bigint/Makefile	/^all : library $(program)$/;"	t
all	yosys/libs/bigint/Makefile	/^all:$/;"	t
all	yosys/libs/ezsat/Makefile	/^all: demo_vec demo_bit demo_cmp testbench puzzle3d$/;"	t
all	yosys/libs/subcircuit/Makefile	/^all: demo scshell$/;"	t
all	yosys/manual/PRESENTATION_ExAdv/Makefile	/^all: select.pdf red_or3x1.pdf sym_mul.pdf mymul.pdf mulshift.pdf addshift.pdf \\$/;"	t
all	yosys/manual/PRESENTATION_ExOth/Makefile	/^all: scrambler_p01.pdf scrambler_p02.pdf equiv.log axis_test.log$/;"	t
all	yosys/manual/PRESENTATION_ExSyn/Makefile	/^all: $(addsuffix .pdf,$(TARGETS))$/;"	t
all	yosys/manual/PRESENTATION_Intro/Makefile	/^all: counter_00.pdf counter_01.pdf counter_02.pdf counter_03.pdf$/;"	t
all	yosys/manual/PRESENTATION_Prog/Makefile	/^all: test0.log test1.log test2.log$/;"	t
all	yosys/tests/sva/Makefile	/^all: $(addsuffix .ok,$(TESTS))$/;"	t
all	yosys/tests/unit/Makefile	/^all: prepare $(TESTS) run-tests$/;"	t
allExtern	yosys/libs/subcircuit/subcircuit.h	/^		bool allExtern;$/;"	m	class:SubCircuit::Graph	typeref:typename:bool
all_cells	yosys/kernel/rtlil.cc	/^static std::map<unsigned int, RTLIL::Cell*> all_cells;$/;"	v	typeref:typename:std::map<unsigned int,RTLIL::Cell * >	file:
all_designs	yosys/kernel/rtlil.cc	/^static std::map<unsigned int, RTLIL::Design*> all_designs;$/;"	v	typeref:typename:std::map<unsigned int,RTLIL::Design * >	file:
all_memorys	yosys/kernel/rtlil.cc	/^static std::map<unsigned int, RTLIL::Memory*> all_memorys;$/;"	v	typeref:typename:std::map<unsigned int,RTLIL::Memory * >	file:
all_modules	yosys/kernel/rtlil.cc	/^static std::map<unsigned int, RTLIL::Module*> all_modules;$/;"	v	typeref:typename:std::map<unsigned int,RTLIL::Module * >	file:
all_samples	yosys/kernel/fstdata.h	/^	bool all_samples;$/;"	m	class:FstData	typeref:typename:bool
all_white	yosys/frontends/verilog/preproc.cc	/^static bool all_white(const std::string &str)$/;"	f	typeref:typename:bool	file:
all_wires	yosys/kernel/rtlil.cc	/^static std::map<unsigned int, RTLIL::Wire*> all_wires;$/;"	v	typeref:typename:std::map<unsigned int,RTLIL::Wire * >	file:
allbits	yosys/kernel/sigtools.h	/^	RTLIL::SigSpec allbits() const$/;"	f	struct:SigMap	typeref:typename:RTLIL::SigSpec
allconstify_inputs	yosys/passes/sat/qbfsat.cc	/^void allconstify_inputs(RTLIL::Module *module, const pool<std::string> &input_wires) {$/;"	f	typeref:typename:void
alloc	yosys/libs/minisat/Alloc.h	/^RegionAllocator<T>::alloc(int size)$/;"	f	class:Minisat::RegionAllocator	typeref:typename:RegionAllocator<T>::Ref
alloc	yosys/libs/minisat/SolverTypes.h	/^    CRef alloc(const Clause& from)$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:CRef
alloc	yosys/libs/minisat/SolverTypes.h	/^    CRef alloc(const vec<Lit>& ps, bool learnt = false)$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:CRef
alloca	yosys/libs/fst/fstapi.cc	/^#define alloca /;"	d	file:
allocate	yosys/libs/bigint/NumberlikeArray.hh	/^void NumberlikeArray<Blk>::allocate(Index c) {$/;"	f	class:NumberlikeArray	typeref:typename:void
allocateAndCopy	yosys/libs/bigint/NumberlikeArray.hh	/^void NumberlikeArray<Blk>::allocateAndCopy(Index c) {$/;"	f	class:NumberlikeArray	typeref:typename:void
allocateDefaultEnumValues	yosys/frontends/ast/simplify.cc	/^void AstNode::allocateDefaultEnumValues()$/;"	f	class:AstNode	typeref:typename:void
allow_arst	yosys/passes/techmap/extract_counter.cc	/^	bool allow_arst;$/;"	m	struct:CounterExtractionSettings	typeref:typename:bool	file:
allowed_dirs	yosys/passes/techmap/extract_counter.cc	/^	int allowed_dirs;	\/\/0 = down, 1 = up, 2 = both$/;"	m	struct:CounterExtractionSettings	typeref:typename:int	file:
aload_to_sr	yosys/kernel/ff.cc	/^void FfData::aload_to_sr() {$/;"	f	class:FfData	typeref:typename:void
alpha	yosys/passes/cmds/qwp.cc	/^	bool alpha;$/;"	m	struct:QwpConfig	typeref:typename:bool	file:
already_in_close	yosys/libs/fst/fstapi.cc	/^    unsigned char already_in_close; \/* in case control-c handlers interrupt *\/$/;"	m	struct:fstWriterContext	typeref:typename:unsigned char	file:
already_in_flush	yosys/libs/fst/fstapi.cc	/^    unsigned char already_in_flush; \/* in case control-c handlers interrupt *\/$/;"	m	struct:fstWriterContext	typeref:typename:unsigned char	file:
already_optimized	yosys/passes/fsm/fsm_expand.cc	/^	bool already_optimized;$/;"	m	struct:FsmExpand	typeref:typename:bool	file:
already_setup	yosys/kernel/yosys.cc	/^bool already_setup = false;$/;"	v	typeref:typename:bool
already_shutdown	yosys/kernel/yosys.cc	/^bool already_shutdown = false;$/;"	v	typeref:typename:bool
alt_midpos	yosys/passes/cmds/qwp.cc	/^	double alt_midpos;$/;"	m	struct:QwpWorker	typeref:typename:double	file:
alt_pos	yosys/passes/cmds/qwp.cc	/^		double pos, alt_pos;$/;"	m	struct:QwpWorker::Node	typeref:typename:double	file:
alt_radius	yosys/passes/cmds/qwp.cc	/^	double alt_radius;$/;"	m	struct:QwpWorker	typeref:typename:double	file:
alt_tie	yosys/passes/cmds/qwp.cc	/^		void alt_tie(double v) {$/;"	f	struct:QwpWorker::Node	typeref:typename:void	file:
alt_tied	yosys/passes/cmds/qwp.cc	/^		bool tied, alt_tied;$/;"	m	struct:QwpWorker::Node	typeref:typename:bool	file:
alu	yosys/backends/cxxrtl/cxxrtl.h	/^	std::pair<value<Bits>, bool \/*CarryOut*\/> alu(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:std::pair<value<Bits>,bool>
alu_cell	yosys/passes/techmap/alumacc.cc	/^		RTLIL::Cell *alu_cell;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::Cell *	file:
alu_counter	yosys/passes/techmap/alumacc.cc	/^	int macc_counter, alu_counter;$/;"	m	struct:AlumaccWorker	typeref:typename:int	file:
alunode_t	yosys/passes/techmap/alumacc.cc	/^	struct alunode_t$/;"	s	struct:AlumaccWorker	file:
always	yosys/frontends/ast/genrtlil.cc	/^	AstNode *always;$/;"	m	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:AstNode *	file:
always_asgn_before_use	yosys/frontends/ast/simplify.cc	/^static IdentUsage always_asgn_before_use(const AstNode *node, const std::string &target)$/;"	f	typeref:typename:IdentUsage	file:
analyze	yosys/libs/minisat/Solver.cc	/^void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:Solver	typeref:typename:void
analyze	yosys/passes/sat/freduce.cc	/^	void analyze(std::vector<RTLIL::SigBit> &reduced_inputs, RTLIL::SigBit output, int prec)$/;"	f	struct:FindReducedInputs	typeref:typename:void	file:
analyze	yosys/passes/sat/freduce.cc	/^	void analyze(std::vector<std::set<int>> &results, std::map<int, int> &results_map, std::vector</;"	f	struct:PerformReduction	typeref:typename:void	file:
analyze	yosys/passes/sat/freduce.cc	/^	void analyze(std::vector<std::vector<equiv_bit_t>> &results, int perc)$/;"	f	struct:PerformReduction	typeref:typename:void	file:
analyze	yosys/passes/techmap/shregmap.cc	/^	bool analyze(vector<int> &taps)$/;"	f	struct:ShregmapTechGreenpak4	typeref:typename:bool	file:
analyzeFinal	yosys/libs/minisat/Solver.cc	/^void Solver::analyzeFinal(Lit p, LSet& out_conflict)$/;"	f	class:Solver	typeref:typename:void
analyze_const	yosys/passes/sat/freduce.cc	/^	void analyze_const(std::vector<std::vector<equiv_bit_t>> &results, int idx)$/;"	f	struct:PerformReduction	typeref:typename:void	file:
analyze_design	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void analyze_design(RTLIL::Design *design)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
analyze_loops	yosys/kernel/utils.h	/^	bool analyze_loops, found_loops;$/;"	m	struct:TopoSort	typeref:typename:bool
analyze_stack	yosys/libs/minisat/Solver.h	/^    vec<ShrinkStackElem>analyze_stack;$/;"	m	class:Minisat::Solver	typeref:typename:vec<ShrinkStackElem>
analyze_toclear	yosys/libs/minisat/Solver.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:Minisat::Solver	typeref:typename:vec<Lit>
and_gate	yosys/kernel/cellaigs.cc	/^	int and_gate(int A, int B, bool inverter = false)$/;"	f	struct:AigMaker	typeref:typename:int	file:
and_map	yosys/backends/aiger/aiger.cc	/^	dict<SigBit, pair<SigBit, SigBit>> and_map;$/;"	m	struct:AigerWriter	typeref:typename:dict<SigBit,pair<SigBit,SigBit>>	file:
and_map	yosys/backends/aiger/xaiger.cc	/^	dict<SigBit, pair<SigBit, SigBit>> and_map;$/;"	m	struct:XAigerWriter	typeref:typename:dict<SigBit,pair<SigBit,SigBit>>	file:
and_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> and_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
and_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> and_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
andnot_gate	yosys/kernel/cellaigs.cc	/^	int andnot_gate(int A, int B)$/;"	f	struct:AigMaker	typeref:typename:int	file:
annotateTypedEnums	yosys/frontends/ast/simplify.cc	/^void AstNode::annotateTypedEnums(AstNode *template_node)$/;"	f	class:AstNode	typeref:typename:void
any_all_nets	yosys/frontends/verific/verific.h	/^	pool<Verific::Net*, hash_ptr_ops> any_all_nets;$/;"	m	struct:VerificImporter	typeref:typename:pool<Verific::Net *,hash_ptr_ops>
anyeq	yosys/passes/sat/fmcombine.cc	/^	bool anyeq = false;$/;"	m	struct:opts_t	typeref:typename:bool	file:
append	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::append(const RTLIL::SigBit &bit)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
append	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::append(const RTLIL::SigSpec &signal)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
append	yosys/kernel/rtlil.h	/^	inline void append(RTLIL::State state) { append(RTLIL::SigBit(state)); }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:void
append	yosys/kernel/rtlil.h	/^	inline void append(Wire *wire) { append(RTLIL::SigSpec(wire)); }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:void
append	yosys/kernel/rtlil.h	/^	inline void append(bool bool_) { append(RTLIL::SigBit(bool_)); }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:void
append	yosys/kernel/rtlil.h	/^	inline void append(const RTLIL::Const &const_) { append(RTLIL::SigSpec(const_)); }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:void
append	yosys/kernel/rtlil.h	/^	inline void append(const RTLIL::SigChunk &chunk) { append(RTLIL::SigSpec(chunk)); }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:void
append	yosys/libs/minisat/Alg.h	/^static inline void append(const vec<T>& from, vec<T>& to){ copy(from, to, true); }$/;"	f	namespace:Minisat	typeref:typename:void
append_pmux	yosys/passes/proc/proc_mux.cc	/^void append_pmux(RTLIL::Module *mod, const RTLIL::SigSpec &signal, const std::vector<RTLIL::SigS/;"	f	typeref:typename:void
append_wire	yosys/passes/cmds/splitnets.cc	/^	void append_wire(RTLIL::Module *module, RTLIL::Wire *wire, int offset, int width, std::string f/;"	f	struct:SplitnetsWorker	typeref:typename:void	file:
apply	yosys/kernel/sigtools.h	/^	void apply(RTLIL::SigBit &bit) const$/;"	f	struct:SigMap	typeref:typename:void
apply	yosys/kernel/sigtools.h	/^	void apply(RTLIL::SigSpec &sig) const$/;"	f	struct:SigMap	typeref:typename:void
apply	yosys/passes/techmap/attrmap.cc	/^	bool apply(IdString &id, Const &val) override {$/;"	f	struct:AttrmapMap	typeref:typename:bool	file:
apply	yosys/passes/techmap/attrmap.cc	/^	bool apply(IdString &id, Const &val) override {$/;"	f	struct:AttrmapRemove	typeref:typename:bool	file:
apply	yosys/passes/techmap/attrmap.cc	/^	bool apply(IdString &id, Const&) override {$/;"	f	struct:AttrmapRename	typeref:typename:bool	file:
apply	yosys/passes/techmap/attrmap.cc	/^	bool apply(IdString &id, Const&) override {$/;"	f	struct:AttrmapTocase	typeref:typename:bool	file:
applyPermutation	yosys/libs/subcircuit/subcircuit.cc	/^	static void applyPermutation(std::map<std::string, std::string> &map, const std::map<std::strin/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
apply_attrs	yosys/passes/proc/proc_mux.cc	/^void apply_attrs(RTLIL::Cell *cell, const RTLIL::SwitchRule *sw, const RTLIL::CaseRule *cs)$/;"	f	typeref:typename:void
apply_const	yosys/passes/proc/proc_arst.cc	/^void apply_const(RTLIL::Module *mod, const RTLIL::SigSpec rspec, RTLIL::SigSpec &rval, RTLIL::Ca/;"	f	typeref:typename:void
apply_prefix	yosys/passes/techmap/techmap.cc	/^void apply_prefix(IdString prefix, IdString &id)$/;"	f	typeref:typename:YOSYS_NAMESPACE_END USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
apply_prefix	yosys/passes/techmap/techmap.cc	/^void apply_prefix(IdString prefix, RTLIL::SigSpec &sig, RTLIL::Module *module)$/;"	f	typeref:typename:void
apply_reset	yosys/passes/proc/proc_arst.cc	/^RTLIL::SigSpec apply_reset(RTLIL::Module *mod, RTLIL::Process *proc, RTLIL::SyncRule *sync, SigM/;"	f	typeref:typename:RTLIL::SigSpec
area	yosys/passes/cmds/stat.cc	/^	double area;$/;"	m	struct:statdata_t	typeref:typename:STAT_INT_MEMBERS double	file:
area	yosys/passes/techmap/abc9_ops.cc	/^		int area;$/;"	m	struct:prep_lut::t_lut	typeref:typename:int	file:
arg	yosys/frontends/ast/ast.h	/^			AstNode *arg = nullptr;$/;"	m	struct:AST::AstNode::varinfo_t	typeref:typename:AstNode *
arg	yosys/libs/fst/fstapi.h	/^            uint64_t arg; \/* number of array elements, struct members, or some other payload (p/;"	m	struct:fstHier::__anonafd27bad010a::fstHierAttr	typeref:typename:uint64_t
arg_from_name	yosys/libs/fst/fstapi.h	/^            uint64_t arg_from_name; \/* for when name is overloaded as a variable-length integer/;"	m	struct:fstHier::__anonafd27bad010a::fstHierAttr	typeref:typename:uint64_t
arg_map_t	yosys/frontends/verilog/preproc.cc	/^	arg_map_t()$/;"	f	struct:arg_map_t	file:
arg_map_t	yosys/frontends/verilog/preproc.cc	/^struct arg_map_t$/;"	s	file:
argidx	yosys/passes/sat/qbfsat.h	/^	size_t argidx = 0;$/;"	m	struct:QbfSolveOptions	typeref:typename:size_t
args	yosys/frontends/verilog/preproc.cc	/^	arg_map_t   args;$/;"	m	struct:define_body_t	typeref:typename:arg_map_t	file:
args	yosys/frontends/verilog/preproc.cc	/^	std::vector<macro_arg_t>   args;$/;"	m	struct:arg_map_t	typeref:typename:std::vector<macro_arg_t>	file:
args	yosys/passes/techmap/libparse.h	/^		std::vector<std::string> args;$/;"	m	struct:Yosys::LibertyAst	typeref:typename:std::vector<std::string>
arith_binary_op	yosys/kernel/celledges.cc	/^void arith_binary_op(AbstractCellEdgesDatabase *db, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
arith_neg_op	yosys/kernel/celledges.cc	/^void arith_neg_op(AbstractCellEdgesDatabase *db, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
array	yosys/libs/json11/json11.hpp	/^    typedef std::vector<Json> array;$/;"	t	class:json11::Json	typeref:typename:std::vector<Json>
array_items	yosys/libs/json11/json11.cpp	/^    const Json::array &array_items() const override { return m_value; }$/;"	f	class:json11::JsonArray	typeref:typename:const Json::array &	file:
array_items	yosys/libs/json11/json11.cpp	/^const vector<Json> &      JsonValue::array_items()               const { return statics().empty_/;"	f	class:json11::JsonValue	typeref:typename:const vector<Json> &
array_items	yosys/libs/json11/json11.cpp	/^const vector<Json> & Json::array_items()          const { return m_ptr->array_items();  }$/;"	f	class:json11::Json	typeref:typename:const vector<Json> &
arraytypes	yosys/libs/fst/fstapi.cc	/^static const char *arraytypes[] = {"none", "unpacked", "packed", "sparse"};$/;"	v	typeref:typename:const char * []	file:
arrival	yosys/kernel/timinginfo.h	/^		dict<NameBit, std::pair<int,NameBit>> arrival, required;$/;"	m	struct:TimingInfo::ModuleTiming	typeref:typename:dict<NameBit,std::pair<int,NameBit>>
arrival_times	yosys/backends/aiger/xaiger.cc	/^	dict<SigBit, float> arrival_times;$/;"	m	struct:XAigerWriter	typeref:typename:dict<SigBit,float>	file:
arst	yosys/kernel/mem.h	/^	SigSpec clk, en, arst, srst, addr, data;$/;"	m	struct:MemRd	typeref:typename:SigSpec
arst_polarity	yosys/passes/sat/expose.cc	/^	bool clk_polarity, arst_polarity;$/;"	m	struct:dff_map_bit_info_t	typeref:typename:bool	file:
arst_polarity	yosys/passes/sat/expose.cc	/^	bool clk_polarity, arst_polarity;$/;"	m	struct:dff_map_info_t	typeref:typename:bool	file:
arst_polarity	yosys/passes/techmap/abc.cc	/^bool clk_polarity, en_polarity, arst_polarity, srst_polarity;$/;"	v	typeref:typename:bool
arst_sig	yosys/passes/techmap/abc.cc	/^RTLIL::SigSpec clk_sig, en_sig, arst_sig, srst_sig;$/;"	v	typeref:typename:RTLIL::SigSpec
arst_to_aload	yosys/kernel/ff.cc	/^void FfData::arst_to_aload() {$/;"	f	class:FfData	typeref:typename:void
arst_to_sr	yosys/kernel/ff.cc	/^void FfData::arst_to_sr() {$/;"	f	class:FfData	typeref:typename:void
arst_value	yosys/kernel/mem.h	/^	Const arst_value, srst_value, init_value;$/;"	m	struct:MemRd	typeref:typename:Const
arst_value	yosys/passes/sat/expose.cc	/^	RTLIL::Const arst_value;$/;"	m	struct:dff_map_info_t	typeref:typename:RTLIL::Const	file:
arst_value	yosys/passes/sat/expose.cc	/^	RTLIL::State arst_value;$/;"	m	struct:dff_map_bit_info_t	typeref:typename:RTLIL::State	file:
asAttrConst	yosys/frontends/ast/ast.cc	/^RTLIL::Const AstNode::asAttrConst() const$/;"	f	class:AstNode	typeref:typename:RTLIL::Const
asBool	yosys/frontends/ast/ast.cc	/^bool AstNode::asBool() const$/;"	f	class:AstNode	typeref:typename:bool
asInt	yosys/frontends/ast/ast.cc	/^uint64_t AstNode::asInt(bool is_signed)$/;"	f	class:AstNode	typeref:typename:uint64_t
asParaConst	yosys/frontends/ast/ast.cc	/^RTLIL::Const AstNode::asParaConst() const$/;"	f	class:AstNode	typeref:typename:RTLIL::Const
asReal	yosys/frontends/ast/ast.cc	/^double AstNode::asReal(bool is_signed)$/;"	f	class:AstNode	typeref:typename:double
as_bit	yosys/kernel/rtlil.cc	/^RTLIL::SigBit RTLIL::SigSpec::as_bit() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:RTLIL::SigBit
as_bool	yosys/kernel/rtlil.cc	/^bool RTLIL::Const::as_bool() const$/;"	f	class:RTLIL::Const	typeref:typename:bool
as_bool	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::as_bool() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
as_bottom	yosys/passes/techmap/flowmap.cc	/^		NodePrime as_bottom() const$/;"	f	struct:FlowGraph::NodePrime	typeref:typename:NodePrime	file:
as_chunk	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk RTLIL::SigSpec::as_chunk() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:RTLIL::SigChunk
as_const	yosys/kernel/rtlil.cc	/^RTLIL::Const RTLIL::SigSpec::as_const() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:RTLIL::Const
as_double	yosys/backends/cxxrtl/cxxrtl.h	/^	double as_double() const {$/;"	f	struct:cxxrtl::metadata	typeref:typename:double
as_int	yosys/kernel/rtlil.cc	/^int RTLIL::Const::as_int(bool is_signed) const$/;"	f	class:RTLIL::Const	typeref:typename:int
as_int	yosys/kernel/rtlil.cc	/^int RTLIL::SigSpec::as_int(bool is_signed) const$/;"	f	class:RTLIL::SigSpec	typeref:typename:int
as_sint	yosys/backends/cxxrtl/cxxrtl.h	/^	signed as_sint() const {$/;"	f	struct:cxxrtl::metadata	typeref:typename:signed
as_string	yosys/backends/cxxrtl/cxxrtl.h	/^	const std::string &as_string() const {$/;"	f	struct:cxxrtl::metadata	typeref:typename:const std::string &
as_string	yosys/kernel/rtlil.cc	/^std::string RTLIL::Const::as_string() const$/;"	f	class:RTLIL::Const	typeref:typename:std::string
as_string	yosys/kernel/rtlil.cc	/^std::string RTLIL::SigSpec::as_string() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:std::string
as_top	yosys/passes/techmap/flowmap.cc	/^		NodePrime as_top() const$/;"	f	struct:FlowGraph::NodePrime	typeref:typename:NodePrime	file:
as_uint	yosys/backends/cxxrtl/cxxrtl.h	/^	unsigned as_uint() const {$/;"	f	struct:cxxrtl::metadata	typeref:typename:unsigned
as_wire	yosys/kernel/rtlil.cc	/^RTLIL::Wire *RTLIL::SigSpec::as_wire() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:RTLIL::Wire *
assert	yosys/passes/equiv/equiv_opt.cc	/^	bool assert, undef, multiclock, async2sync;$/;"	m	struct:EquivOptPass	typeref:typename:bool	file:
assert_mode	yosys/passes/techmap/nlutmap.cc	/^	bool assert_mode = false;$/;"	m	struct:NlutmapConfig	typeref:typename:bool	file:
assert_mode	yosys/passes/techmap/techmap.cc	/^	bool assert_mode = false;$/;"	m	struct:TechmapWorker	typeref:typename:bool	file:
asserts	yosys/backends/aiger/aiger.cc	/^	vector<pair<SigBit, SigBit>> asserts, assumes;$/;"	m	struct:AigerWriter	typeref:typename:vector<pair<SigBit,SigBit>>	file:
asserts_a	yosys/kernel/satgen.h	/^	std::map<std::string, RTLIL::SigSpec> asserts_a, asserts_en;$/;"	m	struct:SatGen	typeref:typename:std::map<std::string,RTLIL::SigSpec>
asserts_en	yosys/kernel/satgen.h	/^	std::map<std::string, RTLIL::SigSpec> asserts_a, asserts_en;$/;"	m	struct:SatGen	typeref:typename:std::map<std::string,RTLIL::SigSpec>
assign_map	yosys/kernel/consteval.h	/^	SigMap assign_map;$/;"	m	struct:ConstEval	typeref:typename:SigMap
assign_map	yosys/passes/equiv/equiv_make.cc	/^	SigMap assign_map;$/;"	m	struct:EquivMakeWorker	typeref:typename:SigMap	file:
assign_map	yosys/passes/fsm/fsm_detect.cc	/^static SigMap assign_map;$/;"	v	typeref:typename:SigMap	file:
assign_map	yosys/passes/fsm/fsm_expand.cc	/^	SigMap assign_map;$/;"	m	struct:FsmExpand	typeref:typename:SigMap	file:
assign_map	yosys/passes/fsm/fsm_extract.cc	/^static SigMap assign_map;$/;"	v	typeref:typename:SigMap	file:
assign_map	yosys/passes/opt/opt_merge.cc	/^	SigMap assign_map;$/;"	m	struct:OptMergeWorker	typeref:typename:SigMap	file:
assign_map	yosys/passes/opt/opt_muxtree.cc	/^	SigMap assign_map;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:SigMap	file:
assign_map	yosys/passes/opt/opt_reduce.cc	/^	SigMap assign_map;$/;"	m	struct:OptReduceWorker	typeref:typename:SigMap	file:
assign_map	yosys/passes/techmap/abc.cc	/^SigMap assign_map;$/;"	v	typeref:typename:SigMap
assign_new_driver	yosys/passes/techmap/extract_fa.cc	/^	void assign_new_driver(SigBit bit, SigBit new_driver)$/;"	f	struct:ExtractFaWorker	typeref:typename:void	file:
assignments	yosys/backends/smv/smv.cc	/^	vector<string> inputvars, vars, definitions, assignments, invarspecs;$/;"	m	struct:SmvWorker	typeref:typename:vector<string>	file:
assigns	yosys/libs/minisat/Solver.h	/^    VMap<lbool>         assigns;          \/\/ The current assignments.$/;"	m	class:Minisat::Solver	typeref:typename:VMap<lbool>
assume	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::assume(int id)$/;"	f	class:ezSAT	typeref:typename:void
assume	yosys/libs/ezsat/ezsat.h	/^	void assume(int id, int context_id) { assume(OR(id, NOT(context_id))); }$/;"	f	class:ezSAT	typeref:typename:void
assume_miter_outputs	yosys/passes/sat/qbfsat.cc	/^void assume_miter_outputs(RTLIL::Module *module, bool assume_neg) {$/;"	f	typeref:typename:void
assume_neg	yosys/passes/sat/qbfsat.h	/^	bool dump_final_smt2 = false, assume_outputs = false, assume_neg = false, nooptimize = false;$/;"	m	struct:QbfSolveOptions	typeref:typename:bool
assume_outputs	yosys/passes/sat/qbfsat.h	/^	bool dump_final_smt2 = false, assume_outputs = false, assume_neg = false, nooptimize = false;$/;"	m	struct:QbfSolveOptions	typeref:typename:bool
assumes	yosys/backends/aiger/aiger.cc	/^	vector<pair<SigBit, SigBit>> asserts, assumes;$/;"	m	struct:AigerWriter	typeref:typename:vector<pair<SigBit,SigBit>>	file:
assumes_a	yosys/kernel/satgen.h	/^	std::map<std::string, RTLIL::SigSpec> assumes_a, assumes_en;$/;"	m	struct:SatGen	typeref:typename:std::map<std::string,RTLIL::SigSpec>
assumes_en	yosys/kernel/satgen.h	/^	std::map<std::string, RTLIL::SigSpec> assumes_a, assumes_en;$/;"	m	struct:SatGen	typeref:typename:std::map<std::string,RTLIL::SigSpec>
assumptions	yosys/libs/minisat/Solver.h	/^    vec<Lit>            assumptions;      \/\/ Current set of assumptions provided to solve by t/;"	m	class:Minisat::Solver	typeref:typename:vec<Lit>
ast	yosys/frontends/ast/ast.h	/^		AstNode *ast;$/;"	m	struct:AST::AstModule	typeref:typename:AstNode *
ast	yosys/passes/techmap/libparse.h	/^		LibertyAst *ast;$/;"	m	struct:Yosys::LibertyParser	typeref:typename:LibertyAst *
ast_node	yosys/frontends/ast/ast_binding.h	/^		std::unique_ptr<AstNode> ast_node;$/;"	m	class:AST::Binding	typeref:typename:std::unique_ptr<AstNode>
asymm	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::asymm(Var v, CRef cr)$/;"	f	class:SimpSolver	typeref:typename:bool
asymmVar	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::asymmVar(Var v)$/;"	f	class:SimpSolver	typeref:typename:bool
asymm_lits	yosys/libs/minisat/SimpSolver.h	/^    int     asymm_lits;$/;"	m	class:Minisat::SimpSolver	typeref:typename:int
async2sync	yosys/passes/equiv/equiv_opt.cc	/^	bool assert, undef, multiclock, async2sync;$/;"	m	struct:EquivOptPass	typeref:typename:bool	file:
asynch_interrupt	yosys/libs/minisat/Solver.h	/^    bool                asynch_interrupt;$/;"	m	class:Minisat::Solver	typeref:typename:bool
asyncprld	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
at	yosys/backends/cxxrtl/cxxrtl.h	/^	const debug_item &at(const std::string &name) const {$/;"	f	struct:cxxrtl::debug_items	typeref:typename:const debug_item &
at	yosys/kernel/hashlib.h	/^	T& at(const K &key)$/;"	f	class:hashlib::dict	typeref:typename:T &
at	yosys/kernel/hashlib.h	/^	const T& at(const K &key) const$/;"	f	class:hashlib::dict	typeref:typename:const T &
at	yosys/kernel/hashlib.h	/^	const T& at(const K &key, const T &defval) const$/;"	f	class:hashlib::dict	typeref:typename:const T &
at	yosys/kernel/hashlib.h	/^	int at(const K &key) const$/;"	f	class:hashlib::idict	typeref:typename:int
at	yosys/kernel/hashlib.h	/^	int at(const K &key, int defval) const$/;"	f	class:hashlib::idict	typeref:typename:int
at	yosys/kernel/rtlil.h	/^	const RTLIL::SigBit &at(int offset, const RTLIL::SigBit &defval) { return offset < width_ ? (*t/;"	f	struct:RTLIL::SigSpec	typeref:typename:const RTLIL::SigBit &
at	yosys/kernel/timinginfo.h	/^	const ModuleTiming& at(RTLIL::IdString module_name) const { return data.at(module_name); }$/;"	f	struct:TimingInfo	typeref:typename:const ModuleTiming &
attachClause	yosys/libs/minisat/Solver.cc	/^void Solver::attachClause(CRef cr){$/;"	f	class:Solver	typeref:typename:void
attr	yosys/libs/fst/fstapi.h	/^        } attr;$/;"	m	union:fstHier::__anonafd27bad010a	typeref:struct:fstHier::__anonafd27bad010a::fstHierAttr
attr2comment	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
attr_icase	yosys/passes/memory/memory_bram.cc	/^	bool attr_icase;$/;"	m	struct:rules_t	typeref:typename:bool	file:
attr_icase	yosys/passes/memory/memory_map.cc	/^	bool attr_icase = false;$/;"	m	struct:MemoryMapWorker	typeref:typename:bool	file:
attr_mode	yosys/backends/blif/blif.cc	/^	bool attr_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
attr_name	yosys/kernel/binding.h	/^	RTLIL::IdString attr_name;$/;"	m	struct:RTLIL::Binding	typeref:typename:RTLIL::IdString
attributes	yosys/frontends/ast/ast.h	/^		std::map<RTLIL::IdString, AstNode*> attributes;$/;"	m	struct:AST::AstNode	typeref:typename:std::map<RTLIL::IdString,AstNode * >
attributes	yosys/kernel/ff.h	/^	dict<IdString, Const> attributes;$/;"	m	struct:FfData	typeref:typename:dict<IdString,Const>
attributes	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, RTLIL::Const> attributes;$/;"	m	struct:RTLIL::AttrObject	typeref:typename:dict<RTLIL::IdString,RTLIL::Const>
attributes	yosys/passes/memory/memory_bram.cc	/^		vector<vector<std::tuple<bool,IdString,Const>>> attributes;$/;"	m	struct:rules_t::match_t	typeref:typename:vector<vector<std::tuple<bool,IdString,Const>>>	file:
attributes	yosys/passes/memory/memory_map.cc	/^	dict<RTLIL::IdString, std::vector<RTLIL::Const>> attributes;$/;"	m	struct:MemoryMapWorker	typeref:typename:dict<RTLIL::IdString,std::vector<RTLIL::Const>>	file:
attrmap_apply	yosys/passes/techmap/attrmap.cc	/^void attrmap_apply(string objname, vector<std::unique_ptr<AttrmapAction>> &actions, dict<RTLIL::/;"	f	typeref:typename:void
attrtypes	yosys/libs/fst/fstapi.cc	/^static const char *attrtypes[] = {"misc", "array", "enum", "class"};$/;"	v	typeref:typename:const char * []	file:
auto_name_counter	yosys/backends/verilog/verilog_backend.cc	/^int auto_name_counter, auto_name_offset, auto_name_digits, extmem_counter;$/;"	v	typeref:typename:int
auto_name_digits	yosys/backends/verilog/verilog_backend.cc	/^int auto_name_counter, auto_name_offset, auto_name_digits, extmem_counter;$/;"	v	typeref:typename:int
auto_name_map	yosys/backends/verilog/verilog_backend.cc	/^std::map<RTLIL::IdString, int> auto_name_map;$/;"	v	typeref:typename:std::map<RTLIL::IdString,int>
auto_name_offset	yosys/backends/verilog/verilog_backend.cc	/^int auto_name_counter, auto_name_offset, auto_name_digits, extmem_counter;$/;"	v	typeref:typename:int
auto_nosync_prefix	yosys/frontends/ast/simplify.cc	/^static const std::string auto_nosync_prefix = "\\\\AutoNosync";$/;"	v	typeref:typename:const std::string	file:
auto_prefix	yosys/backends/verilog/verilog_backend.cc	/^std::string auto_prefix, extmem_prefix;$/;"	v	typeref:typename:std::string
auto_reload_counter	yosys/kernel/modtools.h	/^	int auto_reload_counter;$/;"	m	struct:ModIndex	typeref:typename:int
auto_reload_module	yosys/kernel/modtools.h	/^	bool auto_reload_module;$/;"	m	struct:ModIndex	typeref:typename:bool
autoid_counter	yosys/backends/firrtl/firrtl.cc	/^int autoid_counter;$/;"	v	typeref:typename:int
autoidx	yosys/kernel/yosys.cc	/^int autoidx = 1;$/;"	v	typeref:typename:YOSYS_NAMESPACE_BEGIN int
autoname_worker	yosys/passes/cmds/autoname.cc	/^int autoname_worker(Module *module, const dict<Wire*, int>& wire_score)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN int
autonames	yosys/passes/cmds/show.cc	/^	std::map<RTLIL::IdString, int> autonames;$/;"	m	struct:ShowWorker	typeref:typename:std::map<RTLIL::IdString,int>	file:
autoproc_mode	yosys/passes/techmap/techmap.cc	/^	bool autoproc_mode = false;$/;"	m	struct:TechmapWorker	typeref:typename:bool	file:
autotest	yosys/passes/tests/test_autotb.cc	/^static void autotest(std::ostream &f, RTLIL::Design *design, int num_iter, int seed)$/;"	f	typeref:typename:void	file:
autotop	yosys/techlibs/common/prep.cc	/^	bool autotop, flatten, ifxmode, memxmode, nomemmode, nokeepdc, rdff;$/;"	m	struct:PrepPass	typeref:typename:bool	file:
autotop	yosys/techlibs/common/synth.cc	/^	bool autotop, flatten, noalumacc, nofsm, noabc, noshare, flowmap;$/;"	m	struct:SynthPass	typeref:typename:bool	file:
autowire	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
avail_parameters	yosys/kernel/rtlil.h	/^	idict<RTLIL::IdString> avail_parameters;$/;"	m	struct:RTLIL::Module	typeref:typename:idict<RTLIL::IdString>
axis_test.log	yosys/manual/PRESENTATION_ExOth/Makefile	/^axis_test.log: axis_test.ys axis_master.v axis_test.v$/;"	t
b	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec a, b, c, y;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
b_maxwidth	yosys/techlibs/nexus/synth_nexus.cc	/^		int b_maxwidth;$/;"	m	struct:SynthNexusPass::DSPRule	typeref:typename:int	file:
b_minwidth	yosys/techlibs/nexus/synth_nexus.cc	/^		int b_minwidth;$/;"	m	struct:SynthNexusPass::DSPRule	typeref:typename:int	file:
backend_call	yosys/kernel/register.cc	/^void Backend::backend_call(RTLIL::Design *design, std::ostream *f, std::string filename, std::st/;"	f	class:Backend	typeref:typename:void
backend_call	yosys/kernel/register.cc	/^void Backend::backend_call(RTLIL::Design *design, std::ostream *f, std::string filename, std::ve/;"	f	class:Backend	typeref:typename:void
backend_name	yosys/kernel/register.h	/^	std::string backend_name;$/;"	m	struct:Backend	typeref:typename:std::string
backend_register	yosys/kernel/register.cc	/^std::map<std::string, Backend*> backend_register;$/;"	v	typeref:typename:std::map<std::string,Backend * >
backtrack	yosys/passes/cmds/sta.cc	/^		SigBit backtrack;$/;"	m	struct:StaWorker::t_data	typeref:typename:SigBit	file:
backup_state	yosys/kernel/utils.h	/^	std::vector<dict<Key, T*, OPS>> backup_state;$/;"	m	struct:stackmap	typeref:typename:std::vector<dict<Key,T *,OPS>>
backwardSubsumptionCheck	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::backwardSubsumptionCheck(bool verbose)$/;"	f	class:SimpSolver	typeref:typename:bool
bad_properties	yosys/backends/btor/btor.cc	/^	vector<int> bad_properties;$/;"	m	struct:BtorWorker	typeref:typename:vector<int>	file:
bad_properties	yosys/frontends/aiger/aigerparse.h	/^    std::vector<RTLIL::Wire*> bad_properties;$/;"	m	struct:AigerReader	typeref:typename:std::vector<RTLIL::Wire * >
base	yosys/libs/bigint/BigUnsignedInABase.hh	/^	Base base;$/;"	m	class:BigUnsignedInABase	typeref:typename:Base
base_idx	yosys/passes/memory/memory_dff.cc	/^	int base_idx;$/;"	m	struct:MuxData	typeref:typename:int	file:
basic_cell_type	yosys/passes/hierarchy/hierarchy.cc	/^std::string basic_cell_type(const std::string celltype, int pos[3] = nullptr) {$/;"	f	typeref:typename:std::string
basic_prep	yosys/frontends/ast/ast.h	/^		bool basic_prep;$/;"	m	struct:AST::AstNode	typeref:typename:bool
begin	yosys/kernel/hashlib.h	/^	const_iterator begin() const { return const_iterator(*this, offset); }$/;"	f	class:hashlib::idict	typeref:typename:const_iterator
begin	yosys/kernel/hashlib.h	/^	const_iterator begin() const { return const_iterator(this, int(entries.size())-1); }$/;"	f	class:hashlib::dict	typeref:typename:const_iterator
begin	yosys/kernel/hashlib.h	/^	const_iterator begin() const { return const_iterator(this, int(entries.size())-1); }$/;"	f	class:hashlib::pool	typeref:typename:const_iterator
begin	yosys/kernel/hashlib.h	/^	const_iterator begin() const { return database.begin(); }$/;"	f	class:hashlib::mfp	typeref:typename:const_iterator
begin	yosys/kernel/hashlib.h	/^	iterator begin() { return iterator(this, int(entries.size())-1); }$/;"	f	class:hashlib::dict	typeref:typename:iterator
begin	yosys/kernel/hashlib.h	/^	iterator begin() { return iterator(this, int(entries.size())-1); }$/;"	f	class:hashlib::pool	typeref:typename:iterator
begin	yosys/kernel/log.h	/^	void begin() {$/;"	f	struct:PerformanceTimer	typeref:typename:void
begin	yosys/kernel/rtlil.h	/^		RTLIL::ObjIterator<T> begin() { return RTLIL::ObjIterator<T>(list_p, refcount_p); }$/;"	f	struct:RTLIL::ObjRange	typeref:typename:RTLIL::ObjIterator<T>
begin	yosys/kernel/rtlil.h	/^	inline RTLIL::SigSpecConstIterator begin() const { RTLIL::SigSpecConstIterator it; it.sig_p = t/;"	f	struct:RTLIL::SigSpec	typeref:typename:RTLIL::SigSpecConstIterator
begin	yosys/kernel/rtlil.h	/^	inline RTLIL::SigSpecIterator begin() { RTLIL::SigSpecIterator it; it.sig_p = this; it.index = /;"	f	struct:RTLIL::SigSpec	typeref:typename:RTLIL::SigSpecIterator
begin	yosys/kernel/rtlil.h	/^	inline decltype(bits)::iterator begin() { return bits.begin(); }$/;"	f	struct:RTLIL::Const	typeref:typename:decltype(bits)::iterator
begin	yosys/libs/minisat/IntMap.h	/^        V*       begin  ()       { return &map[0]; }$/;"	f	class:Minisat::IntMap	typeref:typename:V *
begin	yosys/libs/minisat/IntMap.h	/^        const V* begin  () const { return &map[0]; }$/;"	f	class:Minisat::IntMap	typeref:typename:const V *
begin	yosys/libs/minisat/Options.h	/^    double begin;$/;"	m	struct:Minisat::DoubleRange	typeref:typename:double
begin	yosys/libs/minisat/Options.h	/^    int begin;$/;"	m	struct:Minisat::IntRange	typeref:typename:int
begin	yosys/libs/minisat/Options.h	/^    int64_t begin;$/;"	m	struct:Minisat::Int64Range	typeref:typename:int64_t
begin_inclusive	yosys/libs/minisat/Options.h	/^    bool  begin_inclusive;$/;"	m	struct:Minisat::DoubleRange	typeref:typename:bool
begin_ns	yosys/kernel/register.h	/^		int64_t begin_ns;$/;"	m	struct:Pass::pre_post_exec_state_t	typeref:typename:int64_t
begins_with	yosys/kernel/rtlil.h	/^		bool begins_with(const char* prefix) const {$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
big2const	yosys/kernel/calc.cc	/^static RTLIL::Const big2const(const BigInteger &val, int result_len, int undef_bit_pos)$/;"	f	typeref:typename:RTLIL::Const	file:
bigIntegerToString	yosys/libs/bigint/BigIntegerUtils.cc	/^std::string bigIntegerToString(const BigInteger &x) {$/;"	f	typeref:typename:std::string
bigUnsignedToString	yosys/libs/bigint/BigIntegerUtils.cc	/^std::string bigUnsignedToString(const BigUnsigned &x) {$/;"	f	typeref:typename:std::string
bind	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::bind(int id, bool auto_freeze)$/;"	f	class:ezSAT	typeref:typename:int
bind_cnf_and	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::bind_cnf_and(const std::vector<int> &args)$/;"	f	class:ezSAT	typeref:typename:int
bind_cnf_not	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::bind_cnf_not(const std::vector<int> &args)$/;"	f	class:ezSAT	typeref:typename:int
bind_cnf_or	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::bind_cnf_or(const std::vector<int> &args)$/;"	f	class:ezSAT	typeref:typename:int
bindec	yosys/passes/techmap/extract_fa.cc	/^int bindec(unsigned char v)$/;"	f	typeref:typename:int
bindings_	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::Binding*> bindings_;$/;"	m	struct:RTLIL::Design	typeref:typename:std::vector<RTLIL::Binding * >
bindings_	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::Binding*> bindings_;$/;"	m	struct:RTLIL::Module	typeref:typename:std::vector<RTLIL::Binding * >
binop2rtlil	yosys/frontends/ast/genrtlil.cc	/^static RTLIL::SigSpec binop2rtlil(AstNode *that, IdString type, int result_width, const RTLIL::S/;"	f	typeref:typename:RTLIL::SigSpec	file:
bins	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<int, Vertex*> bins;$/;"	m	struct:Scheduler	typeref:typename:dict<int,Vertex * >	file:
bit	yosys/backends/cxxrtl/cxxrtl.h	/^	bool bit(size_t offset) const {$/;"	f	struct:cxxrtl::value	typeref:typename:bool
bit	yosys/libs/ezsat/ezsat.cc	/^ezSATbit ezSAT::bit(_V a)$/;"	f	class:ezSAT	typeref:typename:ezSATbit
bit	yosys/passes/sat/freduce.cc	/^	RTLIL::SigBit bit;$/;"	m	struct:equiv_bit_t	typeref:typename:RTLIL::SigBit	file:
bit	yosys/passes/techmap/abc.cc	/^	RTLIL::SigBit bit;$/;"	m	struct:gate_t	typeref:typename:RTLIL::SigBit	file:
bit	yosys/passes/techmap/extract.cc	/^	int bit;$/;"	m	struct:bit_ref_t	typeref:typename:int	file:
bit2aig	yosys/backends/aiger/aiger.cc	/^	int bit2aig(SigBit bit)$/;"	f	struct:AigerWriter	typeref:typename:int	file:
bit2aig	yosys/backends/aiger/xaiger.cc	/^	int bit2aig(SigBit bit)$/;"	f	struct:XAigerWriter	typeref:typename:int	file:
bit2bits	yosys/passes/cmds/ltp.cc	/^	dict<SigBit, dict<SigBit, Cell*>> bit2bits;$/;"	m	struct:LtpWorker	typeref:typename:dict<SigBit,dict<SigBit,Cell * >>	file:
bit2cell	yosys/backends/simplec/simplec.cc	/^	dict<Module*, dict<SigBit, pool<tuple<Cell*, IdString, int>>>> bit2cell;$/;"	m	struct:SimplecWorker	typeref:typename:dict<Module *,dict<SigBit,pool<tuple<Cell *,IdString,int>>>>	file:
bit2driven	yosys/passes/equiv/equiv_make.cc	/^	dict<SigBit, pool<Cell*>> bit2driven; \/\/ map: bit <--> and its driven cells$/;"	m	struct:EquivMakeWorker	typeref:typename:dict<SigBit,pool<Cell * >>	file:
bit2driver	yosys/passes/equiv/equiv_simple.cc	/^	dict<SigBit, Cell*> &bit2driver;$/;"	m	struct:EquivSimpleWorker	typeref:typename:dict<SigBit,Cell * > &	file:
bit2ff	yosys/passes/cmds/ltp.cc	/^	dict<SigBit, tuple<SigBit, Cell*>> bit2ff;$/;"	m	struct:LtpWorker	typeref:typename:dict<SigBit,tuple<SigBit,Cell * >>	file:
bit2info	yosys/passes/opt/opt_muxtree.cc	/^	vector<bitinfo_t> bit2info;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:vector<bitinfo_t>	file:
bit2mux	yosys/passes/opt/opt_dff.cc	/^	dict<SigBit, cell_int_t> bit2mux;$/;"	m	struct:OptDffWorker	typeref:typename:dict<SigBit,cell_int_t>	file:
bit2num	yosys/passes/opt/opt_muxtree.cc	/^	idict<SigBit> bit2num;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:idict<SigBit>	file:
bit2output	yosys/backends/simplec/simplec.cc	/^	dict<Module*, dict<SigBit, pool<SigBit>>> bit2output;$/;"	m	struct:SimplecWorker	typeref:typename:dict<Module *,dict<SigBit,pool<SigBit>>>	file:
bit2snippet	yosys/passes/proc/proc_mux.cc	/^	dict<SigBit, int> bit2snippet;$/;"	m	struct:SigSnippets	typeref:typename:dict<SigBit,int>	file:
bitAnd	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::bitAnd(const BigUnsigned &a, const BigUnsigned &b) {$/;"	f	class:BigUnsigned	typeref:typename:void
bitDef_t	yosys/kernel/sigtools.h	/^		bitDef_t() : std::pair<RTLIL::Wire*, int>(NULL, 0) { }$/;"	f	struct:SigPool::bitDef_t
bitDef_t	yosys/kernel/sigtools.h	/^		bitDef_t() : std::pair<RTLIL::Wire*, int>(NULL, 0) { }$/;"	f	struct:SigSet::bitDef_t
bitDef_t	yosys/kernel/sigtools.h	/^		bitDef_t(const RTLIL::SigBit &bit) : std::pair<RTLIL::Wire*, int>(bit.wire, bit.offset) { }$/;"	f	struct:SigPool::bitDef_t
bitDef_t	yosys/kernel/sigtools.h	/^		bitDef_t(const RTLIL::SigBit &bit) : std::pair<RTLIL::Wire*, int>(bit.wire, bit.offset) { }$/;"	f	struct:SigSet::bitDef_t
bitDef_t	yosys/kernel/sigtools.h	/^	struct bitDef_t : public std::pair<RTLIL::Wire*, int> {$/;"	s	struct:SigPool
bitDef_t	yosys/kernel/sigtools.h	/^	struct bitDef_t : public std::pair<RTLIL::Wire*, int> {$/;"	s	struct:SigSet
bitIdx	yosys/libs/subcircuit/subcircuit.h	/^			int nodeIdx, portIdx, bitIdx;$/;"	m	struct:SubCircuit::Graph::BitRef	typeref:typename:int
bitLen	yosys/libs/bigint/BigUnsignedInABase.cc	/^	unsigned int bitLen(unsigned int x) {$/;"	f	namespace:__anond4d589b60111	typeref:typename:unsigned int
bitLength	yosys/libs/bigint/BigUnsigned.cc	/^BigUnsigned::Index BigUnsigned::bitLength() const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned::Index
bitOr	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::bitOr(const BigUnsigned &a, const BigUnsigned &b) {$/;"	f	class:BigUnsigned	typeref:typename:void
bitShiftLeft	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::bitShiftLeft(const BigUnsigned &a, int b) {$/;"	f	class:BigUnsigned	typeref:typename:void
bitShiftRight	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::bitShiftRight(const BigUnsigned &a, int b) {$/;"	f	class:BigUnsigned	typeref:typename:void
bitXor	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::bitXor(const BigUnsigned &a, const BigUnsigned &b) {$/;"	f	class:BigUnsigned	typeref:typename:void
bit_and	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> bit_and(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
bit_arst	yosys/passes/sat/expose.cc	/^	RTLIL::SigBit bit_d, bit_clk, bit_arst;$/;"	m	struct:dff_map_bit_info_t	typeref:typename:RTLIL::SigBit	file:
bit_cell	yosys/backends/btor/btor.cc	/^	dict<SigBit, Cell*> bit_cell;$/;"	m	struct:BtorWorker	typeref:typename:dict<SigBit,Cell * >	file:
bit_clk	yosys/passes/sat/expose.cc	/^	RTLIL::SigBit bit_d, bit_clk, bit_arst;$/;"	m	struct:dff_map_bit_info_t	typeref:typename:RTLIL::SigBit	file:
bit_d	yosys/passes/sat/expose.cc	/^	RTLIL::SigBit bit_d, bit_clk, bit_arst;$/;"	m	struct:dff_map_bit_info_t	typeref:typename:RTLIL::SigBit	file:
bit_driver	yosys/backends/smt2/smt2.cc	/^	std::map<RTLIL::SigBit, RTLIL::Cell*> bit_driver;$/;"	m	struct:Smt2Worker	typeref:typename:std::map<RTLIL::SigBit,RTLIL::Cell * >	file:
bit_has_state	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<RTLIL::SigBit, bool> bit_has_state;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<RTLIL::SigBit,bool>	file:
bit_has_state	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<RTLIL::SigBit, bool> bit_has_state;$/;"	m	struct:FlowGraph	typeref:typename:dict<RTLIL::SigBit,bool>	file:
bit_nid	yosys/backends/btor/btor.cc	/^	dict<SigBit, pair<int, int>> bit_nid;$/;"	m	struct:BtorWorker	typeref:typename:dict<SigBit,pair<int,int>>	file:
bit_not	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> bit_not() const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
bit_or	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> bit_or(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
bit_ports	yosys/kernel/macc.h	/^	RTLIL::SigSpec bit_ports;$/;"	m	struct:Macc	typeref:typename:RTLIL::SigSpec
bit_ref_t	yosys/passes/techmap/extract.cc	/^struct bit_ref_t {$/;"	s	file:
bit_regions	yosys/passes/equiv/equiv_mark.cc	/^	dict<SigBit, int> bit_regions;$/;"	m	struct:EquivMarkWorker	typeref:typename:dict<SigBit,int>	file:
bit_to_driver	yosys/passes/equiv/equiv_miter.cc	/^	dict<SigBit, Cell*> bit_to_driver;$/;"	m	struct:EquivMiterWorker	typeref:typename:dict<SigBit,Cell * >	file:
bit_users	yosys/passes/techmap/alumacc.cc	/^	dict<RTLIL::SigBit, int> bit_users;$/;"	m	struct:AlumaccWorker	typeref:typename:dict<RTLIL::SigBit,int>	file:
bit_xor	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> bit_xor(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
bitdata	yosys/kernel/bitpattern.h	/^		std::vector<RTLIL::State> bitdata;$/;"	m	struct:BitPatternPool::bits_t	typeref:typename:std::vector<RTLIL::State>
bitinfo_t	yosys/passes/opt/opt_muxtree.cc	/^	struct bitinfo_t {$/;"	s	struct:OptMuxtreeWorker	file:
bits	yosys/backends/cxxrtl/cxxrtl.h	/^	static constexpr size_t bits = Bits;$/;"	m	struct:cxxrtl::value	typeref:typename:size_t
bits	yosys/backends/cxxrtl/cxxrtl.h	/^	static constexpr size_t bits = Bits;$/;"	m	struct:cxxrtl::wire	typeref:typename:size_t
bits	yosys/backends/cxxrtl/cxxrtl.h	/^	static constexpr size_t bits = Stop - Start + 1;$/;"	m	struct:cxxrtl::slice_expr	typeref:typename:size_t
bits	yosys/backends/cxxrtl/cxxrtl.h	/^	static constexpr size_t bits = T::bits + U::bits;$/;"	m	struct:cxxrtl::concat_expr	typeref:typename:size_t
bits	yosys/backends/cxxrtl/cxxrtl.h	/^	static constexpr size_t bits = std::numeric_limits<T>::digits;$/;"	m	struct:cxxrtl::chunk_traits	typeref:typename:size_t
bits	yosys/frontends/ast/ast.h	/^		std::vector<RTLIL::State> bits;$/;"	m	struct:AST::AstNode	typeref:typename:std::vector<RTLIL::State>
bits	yosys/kernel/rtlil.h	/^	inline const std::vector<RTLIL::SigBit> &bits() const { inline_unpack(); return bits_; }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:const std::vector<RTLIL::SigBit> &
bits	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::State> bits;$/;"	m	struct:RTLIL::Const	typeref:typename:std::vector<RTLIL::State>
bits	yosys/kernel/sigtools.h	/^	dict<bitDef_t, std::set<T, Compare>> bits;$/;"	m	struct:SigSet	typeref:typename:dict<bitDef_t,std::set<T,Compare>>
bits	yosys/kernel/sigtools.h	/^	pool<bitDef_t> bits;$/;"	m	struct:SigPool	typeref:typename:pool<bitDef_t>
bits	yosys/libs/subcircuit/subcircuit.cc	/^		std::set<DiBit> bits;$/;"	m	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:std::set<DiBit>	file:
bits	yosys/libs/subcircuit/subcircuit.h	/^			std::vector<PortBit> bits;$/;"	m	struct:SubCircuit::Graph::Port	typeref:typename:std::vector<PortBit>
bits	yosys/passes/cmds/ltp.cc	/^	dict<SigBit, tuple<int, SigBit, Cell*>> bits;$/;"	m	struct:LtpWorker	typeref:typename:dict<SigBit,tuple<int,SigBit,Cell * >>	file:
bits	yosys/passes/techmap/maccmap.cc	/^	std::vector<std::set<RTLIL::SigBit>> bits;$/;"	m	struct:MaccmapWorker	typeref:typename:std::vector<std::set<RTLIL::SigBit>>	file:
bitsAsConst	yosys/frontends/ast/ast.cc	/^RTLIL::Const AstNode::bitsAsConst(int width)$/;"	f	class:AstNode	typeref:typename:RTLIL::Const
bitsAsConst	yosys/frontends/ast/ast.cc	/^RTLIL::Const AstNode::bitsAsConst(int width, bool is_signed)$/;"	f	class:AstNode	typeref:typename:RTLIL::Const
bitsAsUnsizedConst	yosys/frontends/ast/ast.cc	/^RTLIL::Const AstNode::bitsAsUnsizedConst(int width)$/;"	f	class:AstNode	typeref:typename:RTLIL::Const
bits_	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::SigBit> bits_; \/\/ LSB at index 0$/;"	m	struct:RTLIL::SigSpec	typeref:typename:std::vector<RTLIL::SigBit>
bits_from_activation_patterns	yosys/passes/opt/share.cc	/^	RTLIL::SigSpec bits_from_activation_patterns(const pool<ssc_pair_t> &activation_patterns)$/;"	f	struct:ShareWorker	typeref:typename:RTLIL::SigSpec	file:
bits_macc	yosys/passes/opt/share.cc	/^	static int bits_macc(RTLIL::Cell *c)$/;"	f	struct:ShareWorker	typeref:typename:int	file:
bits_macc	yosys/passes/opt/share.cc	/^	static int bits_macc(const Macc &m, int width)$/;"	f	struct:ShareWorker	typeref:typename:int	file:
bits_macc_port	yosys/passes/opt/share.cc	/^	static int bits_macc_port(const Macc::port_t &p, int width)$/;"	f	struct:ShareWorker	typeref:typename:int	file:
bits_only_01	yosys/frontends/ast/ast.cc	/^bool AstNode::bits_only_01() const$/;"	f	class:AstNode	typeref:typename:bool
bits_queue	yosys/kernel/qcsat.h	/^	pool<RTLIL::SigBit> bits_queue;$/;"	m	struct:QuickConeSat	typeref:typename:pool<RTLIL::SigBit>
bits_t	yosys/kernel/bitpattern.h	/^		bits_t(int width = 0) : bitdata(width), cached_hash(0) { }$/;"	f	struct:BitPatternPool::bits_t
bits_t	yosys/kernel/bitpattern.h	/^	struct bits_t {$/;"	s	struct:BitPatternPool
bitusers	yosys/passes/opt/opt_dff.cc	/^	dict<SigBit, int> bitusers;$/;"	m	struct:OptDffWorker	typeref:typename:dict<SigBit,int>	file:
bitwise_binary_op	yosys/kernel/celledges.cc	/^void bitwise_binary_op(AbstractCellEdgesDatabase *db, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
bitwise_unary_op	yosys/kernel/celledges.cc	/^void bitwise_unary_op(AbstractCellEdgesDatabase *db, RTLIL::Cell *cell)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
blackbox_mode	yosys/backends/blif/blif.cc	/^	bool blackbox_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
blackbox_specializations	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Module*, pool<std::string>> blackbox_specializations;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<const RTLIL::Module *,pool<std::string>>	file:
blacklist	yosys/passes/techmap/libparse.cc	/^std::set<std::string> LibertyAst::blacklist;$/;"	m	class:LibertyAst	typeref:typename:std::set<std::string>
blacklist	yosys/passes/techmap/libparse.h	/^		static std::set<std::string> blacklist;$/;"	m	struct:Yosys::LibertyAst	typeref:typename:std::set<std::string>
blacklist_names	yosys/passes/equiv/equiv_make.cc	/^	pool<IdString> blacklist_names;$/;"	m	struct:EquivMakeWorker	typeref:typename:pool<IdString>	file:
blacklists	yosys/passes/equiv/equiv_make.cc	/^	vector<string> blacklists;$/;"	m	struct:EquivMakeWorker	typeref:typename:vector<string>	file:
blackout_activity	yosys/libs/fst/fstapi.cc	/^    unsigned char *blackout_activity;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned char *	file:
blackout_curr	yosys/libs/fst/fstapi.cc	/^    struct fstBlackoutChain *blackout_curr;$/;"	m	struct:fstWriterContext	typeref:struct:fstBlackoutChain *	file:
blackout_head	yosys/libs/fst/fstapi.cc	/^    struct fstBlackoutChain *blackout_head;$/;"	m	struct:fstWriterContext	typeref:struct:fstBlackoutChain *	file:
blackout_times	yosys/libs/fst/fstapi.cc	/^    uint64_t *blackout_times;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t *	file:
blif_file	yosys/techlibs/ecp5/synth_ecp5.cc	/^	string top_opt, blif_file, edif_file, json_file;$/;"	m	struct:SynthEcp5Pass	typeref:typename:string	file:
blif_file	yosys/techlibs/ice40/synth_ice40.cc	/^	string top_opt, blif_file, edif_file, json_file, device_opt;$/;"	m	struct:SynthIce40Pass	typeref:typename:string	file:
blif_file	yosys/techlibs/intel/synth_intel.cc	/^	string top_opt, family_opt, vout_file, blif_file;$/;"	m	struct:SynthIntelPass	typeref:typename:string	file:
blif_file	yosys/techlibs/machxo2/synth_machxo2.cc	/^	string top_opt, blif_file, edif_file, json_file;$/;"	m	struct:SynthMachXO2Pass	typeref:typename:string	file:
blif_file	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	string top_opt, blif_file, family, currmodule, verilog_file;$/;"	m	struct:SynthQuickLogicPass	typeref:typename:string	file:
blif_file	yosys/techlibs/xilinx/synth_xilinx.cc	/^	std::string top_opt, edif_file, blif_file, family;$/;"	m	struct:SynthXilinxPass	typeref:typename:std::string	file:
blit	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> blit(const value<Stop - Start + 1> &source) const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE value<Bits>
blk	yosys/libs/bigint/NumberlikeArray.hh	/^	Blk *blk;$/;"	m	class:NumberlikeArray	typeref:typename:Blk *
block_active	yosys/kernel/register.h	/^	bool block_active, help_mode;$/;"	m	struct:ScriptPass	typeref:typename:bool
blocker	yosys/libs/minisat/Solver.h	/^        Lit  blocker;$/;"	m	struct:Minisat::Solver::Watcher	typeref:typename:Lit
blockgeom	yosys/libs/ezsat/puzzle3d.cc	/^std::set<blockgeom_t> blockgeom;$/;"	v	typeref:typename:std::set<blockgeom_t>
blockgeom_t	yosys/libs/ezsat/puzzle3d.cc	/^struct blockgeom_t$/;"	s	file:
blockidx	yosys/libs/ezsat/puzzle3d.cc	/^int blockidx = 0;$/;"	v	typeref:typename:int
blockinfo	yosys/libs/ezsat/puzzle3d.cc	/^std::map<int, std::string> blockinfo;$/;"	v	typeref:typename:std::map<int,std::string>
bmux	yosys/backends/cxxrtl/cxxrtl.h	/^	value<ResultBits> bmux(const value<SelBits> &sel) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<ResultBits>
bmux_op	yosys/kernel/celledges.cc	/^void bmux_op(AbstractCellEdgesDatabase *db, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
body	yosys/frontends/verilog/preproc.cc	/^	std::string body;$/;"	m	struct:define_body_t	typeref:typename:std::string	file:
body_net	yosys/frontends/verific/verific.h	/^	Verific::Net *body_net = nullptr;$/;"	m	struct:VerificClocking	typeref:typename:Verific::Net *
bool_node	yosys/kernel/cellaigs.cc	/^	int bool_node(bool value)$/;"	f	struct:AigMaker	typeref:typename:int	file:
bool_value	yosys/libs/json11/json11.cpp	/^    bool bool_value() const override { return m_value; }$/;"	f	class:json11::JsonBoolean	typeref:typename:bool	file:
bool_value	yosys/libs/json11/json11.cpp	/^bool                      JsonValue::bool_value()                const { return false; }$/;"	f	class:json11::JsonValue	typeref:typename:bool
bool_value	yosys/libs/json11/json11.cpp	/^bool Json::bool_value()                           const { return m_ptr->bool_value();   }$/;"	f	class:json11::Json	typeref:typename:bool
bottom	yosys/passes/techmap/flowmap.cc	/^		static NodePrime bottom(RTLIL::SigBit node)$/;"	f	struct:FlowGraph::NodePrime	typeref:typename:NodePrime	file:
bound	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::bound(int id) const$/;"	f	class:ezSAT	typeref:typename:int
box_file	yosys/passes/techmap/abc9.cc	/^	std::string box_file;$/;"	m	struct:Abc9Pass	typeref:typename:std::string	file:
box_list	yosys/backends/aiger/xaiger.cc	/^	vector<Cell*> box_list;$/;"	m	struct:XAigerWriter	typeref:typename:vector<Cell * >	file:
boxes	yosys/frontends/aiger/aigerparse.h	/^    std::vector<RTLIL::Cell*> boxes;$/;"	m	struct:AigerReader	typeref:typename:std::vector<RTLIL::Cell * >
bram_t	yosys/passes/memory/memory_bram.cc	/^	struct bram_t {$/;"	s	struct:rules_t	file:
bram_type	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	string top_opt, family_opt, bram_type, vout_file;$/;"	m	struct:SynthIntelALMPass	typeref:typename:string	file:
brams	yosys/passes/memory/memory_bram.cc	/^	dict<IdString, vector<bram_t>> brams;$/;"	m	struct:rules_t	typeref:typename:dict<IdString,vector<bram_t>>	file:
break_scc	yosys/passes/techmap/abc9_ops.cc	/^void break_scc(RTLIL::Module *module)$/;"	f	typeref:typename:void
bswap32	yosys/backends/aiger/xaiger.cc	/^#define bswap32 /;"	d	file:
bswap32	yosys/backends/aiger/xaiger.cc	/^inline static uint32_t bswap32(uint32_t x)$/;"	f	typeref:typename:uint32_t	file:
btorf	yosys/backends/btor/btor.cc	/^	void btorf(const char *fmt, ...) YS_ATTRIBUTE(format(printf, 2, 3))$/;"	f	struct:BtorWorker	typeref:typename:void	file:
btorf_pop	yosys/backends/btor/btor.cc	/^	void btorf_pop(const string &id)$/;"	f	struct:BtorWorker	typeref:typename:void	file:
btorf_push	yosys/backends/btor/btor.cc	/^	void btorf_push(const string &id)$/;"	f	struct:BtorWorker	typeref:typename:void	file:
bucket	yosys/libs/minisat/Map.h	/^    const vec<Pair>& bucket(int i) const { return table[i]; }$/;"	f	class:Minisat::Map	typeref:typename:const vec<Pair> &
bucket	yosys/libs/minisat/SolverTypes.h	/^    const vec<typename HashTable::Pair>& bucket(int i) const { return map.bucket(i); }$/;"	f	class:Minisat::CMap	typeref:typename:const vec<typename HashTable::Pair> &
bucket_count	yosys/libs/minisat/Map.h	/^    int  bucket_count() const { return cap; }$/;"	f	class:Minisat::Map	typeref:typename:int
bucket_count	yosys/libs/minisat/SolverTypes.h	/^    int  bucket_count() const { return map.bucket_count(); }$/;"	f	class:Minisat::CMap	typeref:typename:int
budgetOff	yosys/libs/minisat/Solver.h	/^inline void     Solver::budgetOff(){ conflict_budget = propagation_budget = -1; }$/;"	f	class:Minisat::Solver	typeref:typename:void
buf	yosys/libs/minisat/ParseUtils.h	/^    unsigned char* buf;$/;"	m	class:Minisat::StreamBuffer	typeref:typename:unsigned char *
buf	yosys/libs/minisat/Queue.h	/^    vec<T>  buf;$/;"	m	class:Minisat::Queue	typeref:typename:vec<T>
buf_in	yosys/backends/blif/blif.cc	/^	std::string buf_type, buf_in, buf_out;$/;"	m	struct:BlifDumperConfig	typeref:typename:std::string	file:
buf_out	yosys/backends/blif/blif.cc	/^	std::string buf_type, buf_in, buf_out;$/;"	m	struct:BlifDumperConfig	typeref:typename:std::string	file:
buf_type	yosys/backends/blif/blif.cc	/^	std::string buf_type, buf_in, buf_out;$/;"	m	struct:BlifDumperConfig	typeref:typename:std::string	file:
buffer	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	std::string buffer;$/;"	m	class:cxxrtl::vcd_writer	typeref:typename:std::string
buffer	yosys/libs/sha1/sha1.h	/^    std::string buffer;$/;"	m	class:SHA1	typeref:typename:std::string
buffer1	yosys/manual/CHAPTER_StateOfTheArt/cmp_tbdata.c	/^char buffer1[1024];$/;"	v	typeref:typename:char[1024]
buffer1	yosys/tests/tools/cmp_tbdata.c	/^char buffer1[8192];$/;"	v	typeref:typename:char[8192]
buffer2	yosys/manual/CHAPTER_StateOfTheArt/cmp_tbdata.c	/^char buffer2[1024];$/;"	v	typeref:typename:char[1024]
buffer2	yosys/tests/tools/cmp_tbdata.c	/^char buffer2[8192];$/;"	v	typeref:typename:char[8192]
bufferStart	yosys/libs/fst/lz4.cc	/^    BYTE *bufferStart; \/* obsolete, used for slideInputBuffer *\/$/;"	m	struct:__anon9390dffe0208	typeref:typename:BYTE *	file:
buffer_size	yosys/libs/minisat/ParseUtils.h	/^    enum { buffer_size = 64*1024 };$/;"	e	enum:Minisat::StreamBuffer::__anon8adab8ba0103
buffer_to_block	yosys/libs/sha1/sha1.cpp	/^void SHA1::buffer_to_block(const std::string &buffer, uint32_t block[BLOCK_INTS])$/;"	f	class:SHA1	typeref:typename:void
build	yosys/libs/minisat/Heap.h	/^    void build(const vec<K>& ns) {$/;"	f	class:Minisat::Heap	typeref:typename:void
build_flow_graph	yosys/passes/techmap/flowmap.cc	/^	FlowGraph build_flow_graph(RTLIL::SigBit sink, int p)$/;"	f	struct:FlowmapWorker	typeref:typename:FlowGraph	file:
builtin_ff_cell_types	yosys/kernel/rtlil.cc	/^const pool<IdString> &RTLIL::builtin_ff_cell_types() {$/;"	f	class:RTLIL	typeref:typename:const pool<IdString> &
bumpversion	yosys/Makefile	/^bumpversion:$/;"	t
busy	yosys/kernel/consteval.h	/^	std::set<RTLIL::Cell*> busy;$/;"	m	struct:ConstEval	typeref:typename:std::set<RTLIL::Cell * >
busy	yosys/passes/cmds/ltp.cc	/^	pool<SigBit> busy;$/;"	m	struct:LtpWorker	typeref:typename:pool<SigBit>	file:
bvmode	yosys/backends/smt2/smt2.cc	/^	bool bvmode, memmode, wiresmode, verbose, statebv, statedt, forallmode;$/;"	m	struct:Smt2Worker	typeref:typename:bool	file:
bvsizes	yosys/backends/smt2/smt2.cc	/^	std::map<int, int> bvsizes;$/;"	m	struct:Smt2Worker	typeref:typename:std::map<int,int>	file:
bwd	yosys/passes/sat/fmcombine.cc	/^	bool bwd = false;$/;"	m	struct:opts_t	typeref:typename:bool	file:
bwd_merge_cache	yosys/passes/equiv/equiv_struct.cc	/^	pool<merge_key_t> fwd_merge_cache, bwd_merge_cache;$/;"	m	struct:EquivStructWorker	typeref:typename:pool<merge_key_t>	file:
bwdsub_assigns	yosys/libs/minisat/SimpSolver.h	/^    int                 bwdsub_assigns;$/;"	m	class:Minisat::SimpSolver	typeref:typename:int
bwdsub_tmpunit	yosys/libs/minisat/SimpSolver.h	/^    CRef                bwdsub_tmpunit;$/;"	m	class:Minisat::SimpSolver	typeref:typename:CRef
byPtr	yosys/libs/fst/lz4.cc	/^    byPtr,$/;"	e	enum:__anon9390dffe0403	file:
byU16	yosys/libs/fst/lz4.cc	/^    byU16$/;"	e	enum:__anon9390dffe0403	file:
byU32	yosys/libs/fst/lz4.cc	/^    byU32,$/;"	e	enum:__anon9390dffe0403	file:
c	yosys/libs/fst/lz4.cc	/^        BYTE c[4];$/;"	m	union:LZ4_isLittleEndian::__anon9390dffe010a	typeref:typename:BYTE[4]	file:
c	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec a, b, c, y;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
c_str	yosys/kernel/rtlil.h	/^		inline const char *c_str() const {$/;"	f	struct:RTLIL::IdString	typeref:typename:const char *
c_str	yosys/kernel/yosys.h	/^	const char *c_str() const { return content->c_str(); }$/;"	f	struct:shared_str	typeref:typename:const char *
ca	yosys/libs/minisat/SimpSolver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Minisat::SimpSolver::ClauseDeleted	typeref:typename:const ClauseAllocator &
ca	yosys/libs/minisat/Solver.cc	/^    ClauseAllocator& ca;$/;"	m	struct:reduceDB_lt	typeref:typename:ClauseAllocator &	file:
ca	yosys/libs/minisat/Solver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Minisat::Solver::WatcherDeleted	typeref:typename:const ClauseAllocator &
ca	yosys/libs/minisat/Solver.h	/^    ClauseAllocator     ca;$/;"	m	class:Minisat::Solver	typeref:typename:ClauseAllocator
ca	yosys/libs/minisat/SolverTypes.h	/^    const ClauseAllocator& ca;$/;"	m	class:Minisat::ClauseIterator	typeref:typename:const ClauseAllocator &
cache	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	std::vector<chunk_t> cache;$/;"	m	class:cxxrtl::vcd_writer	typeref:typename:std::vector<chunk_t>
cache	yosys/passes/opt/opt_clean.cc	/^	dict<Module*, bool> cache;$/;"	m	struct:keep_cache_t	typeref:typename:dict<Module *,bool>	file:
cache	yosys/passes/proc/proc_mux.cc	/^	dict<RTLIL::SwitchRule*, pool<int>, hash_ptr_ops> cache;$/;"	m	struct:SnippetSwCache	typeref:typename:dict<RTLIL::SwitchRule *,pool<int>,hash_ptr_ops>	file:
cache	yosys/passes/sat/freduce.cc	/^	std::map<RTLIL::SigBit, int> &cache;$/;"	m	struct:CountBitUsage	typeref:typename:std::map<RTLIL::SigBit,int> &	file:
cache_can_collide_rdwr	yosys/passes/memory/memory_dff.cc	/^	dict<std::pair<int, SigBit>, bool> cache_can_collide_rdwr;$/;"	m	struct:MemQueryCache	typeref:typename:dict<std::pair<int,SigBit>,bool>	file:
cache_can_collide_together	yosys/passes/memory/memory_dff.cc	/^	dict<std::tuple<int, int, SigBit, SigBit>, bool> cache_can_collide_together;$/;"	m	struct:MemQueryCache	typeref:typename:dict<std::tuple<int,int,SigBit,SigBit>,bool>	file:
cache_impossible_with_ren	yosys/passes/memory/memory_dff.cc	/^	dict<std::tuple<SigBit, bool>, bool> cache_impossible_with_ren;$/;"	m	struct:MemQueryCache	typeref:typename:dict<std::tuple<SigBit,bool>,bool>	file:
cache_is_w2rbyp	yosys/passes/memory/memory_dff.cc	/^	dict<std::tuple<int, SigBit, SigBit, bool>, bool> cache_is_w2rbyp;$/;"	m	struct:MemQueryCache	typeref:typename:dict<std::tuple<int,SigBit,SigBit,bool>,bool>	file:
cache_offset	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^		size_t cache_offset;$/;"	m	struct:cxxrtl::vcd_writer::variable	typeref:typename:size_t
cached_cf	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec cached_cf, cached_of, cached_sf;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
cached_eq	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec cached_lt, cached_gt, cached_eq, cached_ne;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
cached_gt	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec cached_lt, cached_gt, cached_eq, cached_ne;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
cached_hash	yosys/kernel/bitpattern.h	/^		mutable unsigned int cached_hash;$/;"	m	struct:BitPatternPool::bits_t	typeref:typename:unsigned int
cached_lt	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec cached_lt, cached_gt, cached_eq, cached_ne;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
cached_ne	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec cached_lt, cached_gt, cached_eq, cached_ne;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
cached_of	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec cached_cf, cached_of, cached_sf;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
cached_sf	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec cached_cf, cached_of, cached_sf;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
calcAbstraction	yosys/libs/minisat/SolverTypes.h	/^    void calcAbstraction() {$/;"	f	class:Minisat::Clause	typeref:typename:void
call	yosys/frontends/rpc/rpc_frontend.cc	/^	Json call(const Json &json_request) {$/;"	f	struct:RpcServer	typeref:typename:Json	file:
call	yosys/kernel/register.cc	/^void Pass::call(RTLIL::Design *design, std::string command)$/;"	f	class:Pass	typeref:typename:void
call	yosys/kernel/register.cc	/^void Pass::call(RTLIL::Design *design, std::vector<std::string> args)$/;"	f	class:Pass	typeref:typename:void
call_counter	yosys/kernel/register.h	/^	int call_counter;$/;"	m	struct:Pass	typeref:typename:int
call_on_module	yosys/kernel/register.cc	/^void Pass::call_on_module(RTLIL::Design *design, RTLIL::Module *module, std::string command)$/;"	f	class:Pass	typeref:typename:void
call_on_module	yosys/kernel/register.cc	/^void Pass::call_on_module(RTLIL::Design *design, RTLIL::Module *module, std::vector<std::string>/;"	f	class:Pass	typeref:typename:void
call_on_selection	yosys/kernel/register.cc	/^void Pass::call_on_selection(RTLIL::Design *design, const RTLIL::Selection &selection, std::stri/;"	f	class:Pass	typeref:typename:void
call_on_selection	yosys/kernel/register.cc	/^void Pass::call_on_selection(RTLIL::Design *design, const RTLIL::Selection &selection, std::vect/;"	f	class:Pass	typeref:typename:void
call_qbf_solver	yosys/passes/sat/qbfsat.cc	/^QbfSolutionType call_qbf_solver(RTLIL::Module *mod, const QbfSolveOptions &opt, const std::strin/;"	f	typeref:typename:QbfSolutionType
callback	yosys/kernel/fstdata.h	/^	CallbackFunction callback;$/;"	m	class:FstData	typeref:typename:CallbackFunction
can_collide_rdwr	yosys/passes/memory/memory_dff.cc	/^	bool can_collide_rdwr(int widx, SigBit wen) {$/;"	f	struct:MemQueryCache	typeref:typename:bool	file:
can_collide_together	yosys/passes/memory/memory_dff.cc	/^	bool can_collide_together(int widx1, int widx2, int bitidx) {$/;"	f	struct:MemQueryCache	typeref:typename:bool	file:
can_use_fully_defined_pool	yosys/passes/proc/proc_rmdead.cc	/^static bool can_use_fully_defined_pool(RTLIL::SwitchRule *sw)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool	file:
cancelUntil	yosys/libs/minisat/Solver.cc	/^void Solver::cancelUntil(int level) {$/;"	f	class:Solver	typeref:typename:void
candidate_cells	yosys/passes/opt/muxpack.cc	/^	pool<Cell*> candidate_cells;$/;"	m	struct:MuxpackWorker	typeref:typename:pool<Cell * >	file:
cap	yosys/libs/bigint/NumberlikeArray.hh	/^	Index cap;$/;"	m	class:NumberlikeArray	typeref:typename:Index
cap	yosys/libs/minisat/Alloc.h	/^    uint32_t  cap;$/;"	m	class:Minisat::RegionAllocator	typeref:typename:uint32_t
cap	yosys/libs/minisat/Map.h	/^    int        cap;$/;"	m	class:Minisat::Map	typeref:typename:int
cap	yosys/libs/minisat/Vec.h	/^    Size cap;$/;"	m	class:Minisat::vec	typeref:typename:Size
capacity	yosys/libs/minisat/Alloc.h	/^void RegionAllocator<T>::capacity(uint32_t min_cap)$/;"	f	class:Minisat::RegionAllocator	typeref:typename:void
capacity	yosys/libs/minisat/Vec.h	/^    int      capacity (void) const   { return cap; }$/;"	f	class:Minisat::vec	typeref:typename:int
capacity	yosys/libs/minisat/Vec.h	/^void vec<T,_Size>::capacity(Size min_cap) {$/;"	f	class:Minisat::vec	typeref:typename:void
case_body_find_regs	yosys/backends/verilog/verilog_backend.cc	/^void case_body_find_regs(RTLIL::CaseRule *cs)$/;"	f	typeref:typename:void
cases	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::CaseRule*> cases;$/;"	m	struct:RTLIL::SwitchRule	typeref:typename:std::vector<RTLIL::CaseRule * >
category	yosys/libs/minisat/Options.h	/^    const char* category;$/;"	m	class:Minisat::Option	typeref:typename:const char *
ccmin_mode	yosys/libs/minisat/Solver.h	/^    int       ccmin_mode;         \/\/ Controls conflict clause minimization (0=none, 1=basic, 2/;"	m	class:Minisat::Solver	typeref:typename:int
ce	yosys/passes/techmap/extract_counter.cc	/^	RTLIL::SigSpec ce;				\/\/clock signal$/;"	m	struct:CounterExtraction	typeref:typename:RTLIL::SigSpec	file:
ce	yosys/passes/techmap/extract_fa.cc	/^	ConstEval ce;$/;"	m	struct:ExtractFaWorker	typeref:typename:ConstEval	file:
ce_inverted	yosys/passes/techmap/extract_counter.cc	/^	bool ce_inverted;				\/\/true if clock enable is active low$/;"	m	struct:CounterExtraction	typeref:typename:bool	file:
ce_over_srst	yosys/kernel/ff.h	/^	bool ce_over_srst;$/;"	m	struct:FfData	typeref:typename:bool
ce_over_srst	yosys/kernel/mem.h	/^	bool clk_enable, clk_polarity, ce_over_srst;$/;"	m	struct:MemRd	typeref:typename:bool
ce_used	yosys/passes/techmap/dfflegalize.cc	/^	dict<SigBit, int> ce_used;$/;"	m	struct:DffLegalizePass	typeref:typename:dict<SigBit,int>	file:
ceil_log2	yosys/kernel/yosys.cc	/^int ceil_log2(int x)$/;"	f	typeref:typename:int
ceilingDiv	yosys/libs/bigint/BigUnsignedInABase.cc	/^	unsigned int ceilingDiv(unsigned int a, unsigned int b) {$/;"	f	namespace:__anond4d589b60111	typeref:typename:unsigned int
cell	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		const RTLIL::Cell *cell = nullptr;$/;"	m	struct:FlowGraph::Node	typeref:typename:const RTLIL::Cell *	file:
cell	yosys/kernel/cellaigs.cc	/^	Cell *cell;$/;"	m	struct:AigMaker	typeref:typename:Cell *	file:
cell	yosys/kernel/ff.h	/^	Cell *cell;$/;"	m	struct:FfData	typeref:typename:Cell *
cell	yosys/kernel/mem.h	/^	Cell *cell;$/;"	m	struct:Mem	typeref:typename:Cell *
cell	yosys/kernel/mem.h	/^	Cell *cell;$/;"	m	struct:MemInit	typeref:typename:Cell *
cell	yosys/kernel/mem.h	/^	Cell *cell;$/;"	m	struct:MemRd	typeref:typename:Cell *
cell	yosys/kernel/mem.h	/^	Cell *cell;$/;"	m	struct:MemWr	typeref:typename:Cell *
cell	yosys/kernel/modtools.h	/^		RTLIL::Cell *cell;$/;"	m	struct:ModWalker::PortBit	typeref:typename:RTLIL::Cell *
cell	yosys/kernel/modtools.h	/^		RTLIL::Cell* cell;$/;"	m	struct:ModIndex::PortInfo	typeref:typename:RTLIL::Cell *
cell	yosys/kernel/rtlil.cc	/^		RTLIL::Cell *cell;$/;"	m	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:RTLIL::Cell *	file:
cell	yosys/kernel/rtlil.h	/^	RTLIL::Cell* cell(RTLIL::IdString id) {$/;"	f	struct:RTLIL::Module	typeref:typename:RTLIL::Cell *
cell	yosys/kernel/rtlil.h	/^	const RTLIL::Cell* cell(RTLIL::IdString id) const {$/;"	f	struct:RTLIL::Module	typeref:typename:const RTLIL::Cell *
cell	yosys/passes/cmds/qwp.cc	/^		Cell *cell;$/;"	m	struct:QwpWorker::Node	typeref:typename:Cell *	file:
cell	yosys/passes/fsm/fsm_opt.cc	/^	RTLIL::Cell *cell;$/;"	m	struct:FsmOpt	typeref:typename:RTLIL::Cell *	file:
cell	yosys/passes/opt/opt_muxtree.cc	/^		RTLIL::Cell *cell;$/;"	m	struct:OptMuxtreeWorker::muxinfo_t	typeref:typename:RTLIL::Cell *	file:
cell	yosys/passes/sat/expose.cc	/^	RTLIL::Cell *cell;$/;"	m	struct:dff_map_bit_info_t	typeref:typename:RTLIL::Cell *	file:
cell	yosys/passes/sat/mutate.cc	/^	IdString module, cell, port, wire;$/;"	m	struct:mutate_opts_t	typeref:typename:IdString	file:
cell	yosys/passes/sat/mutate.cc	/^	IdString module, cell;$/;"	m	struct:mutate_t	typeref:typename:IdString	file:
cell	yosys/passes/techmap/alumacc.cc	/^		RTLIL::Cell *cell;$/;"	m	struct:AlumaccWorker::maccnode_t	typeref:typename:RTLIL::Cell *	file:
cell	yosys/passes/techmap/extract.cc	/^	std::string cell, port;$/;"	m	struct:bit_ref_t	typeref:typename:std::string	file:
cell2scc	yosys/passes/cmds/scc.cc	/^	std::map<RTLIL::Cell*, int> cell2scc;$/;"	m	struct:SccWorker	typeref:typename:std::map<RTLIL::Cell *,int>	file:
cellDepth	yosys/passes/cmds/scc.cc	/^	std::map<RTLIL::Cell*, int> cellDepth;$/;"	m	struct:SccWorker	typeref:typename:std::map<RTLIL::Cell *,int>	file:
cellLabels	yosys/passes/cmds/scc.cc	/^	std::map<RTLIL::Cell*, std::pair<int, int>> cellLabels;$/;"	m	struct:SccWorker	typeref:typename:std::map<RTLIL::Cell *,std::pair<int,int>>	file:
cellStack	yosys/passes/cmds/scc.cc	/^	std::vector<RTLIL::Cell*> cellStack;$/;"	m	struct:SccWorker	typeref:typename:std::vector<RTLIL::Cell * >	file:
cellToNextCell	yosys/passes/cmds/scc.cc	/^	std::map<RTLIL::Cell*, std::set<RTLIL::Cell*>> cellToNextCell;$/;"	m	struct:SccWorker	typeref:typename:std::map<RTLIL::Cell *,std::set<RTLIL::Cell * >>	file:
cellToNextSig	yosys/passes/cmds/scc.cc	/^	std::map<RTLIL::Cell*, RTLIL::SigSpec> cellToPrevSig, cellToNextSig;$/;"	m	struct:SccWorker	typeref:typename:std::map<RTLIL::Cell *,RTLIL::SigSpec>	file:
cellToPrevSig	yosys/passes/cmds/scc.cc	/^	std::map<RTLIL::Cell*, RTLIL::SigSpec> cellToPrevSig, cellToNextSig;$/;"	m	struct:SccWorker	typeref:typename:std::map<RTLIL::Cell *,RTLIL::SigSpec>	file:
cell_attr	yosys/passes/techmap/extract.cc	/^	std::set<RTLIL::IdString> cell_attr, wire_attr;$/;"	m	class:SubCircuitSolver	typeref:typename:std::set<RTLIL::IdString>	file:
cell_code	yosys/kernel/register.cc	/^	dict<string, string> cell_help, cell_code;$/;"	m	struct:CellHelpMessages	typeref:typename:dict<string,string>	file:
cell_complexity	yosys/kernel/qcsat.cc	/^int QuickConeSat::cell_complexity(RTLIL::Cell *cell)$/;"	f	class:QuickConeSat	typeref:typename:int
cell_evaluable	yosys/kernel/celltypes.h	/^	bool cell_evaluable(RTLIL::IdString type) const$/;"	f	struct:CellTypes	typeref:typename:bool
cell_help	yosys/kernel/register.cc	/^	dict<string, string> cell_help, cell_code;$/;"	m	struct:CellHelpMessages	typeref:typename:dict<string,string>	file:
cell_help_messages	yosys/kernel/register.cc	/^} cell_help_messages;$/;"	v	typeref:struct:CellHelpMessages
cell_input	yosys/kernel/celltypes.h	/^	bool cell_input(RTLIL::IdString type, RTLIL::IdString port) const$/;"	f	struct:CellTypes	typeref:typename:bool
cell_inputs	yosys/kernel/modtools.h	/^	dict<RTLIL::Cell*, pool<RTLIL::SigBit>> cell_outputs, cell_inputs;$/;"	m	struct:ModWalker	typeref:typename:dict<RTLIL::Cell *,pool<RTLIL::SigBit>>
cell_int_t	yosys/passes/opt/opt_dff.cc	/^	typedef std::pair<RTLIL::Cell*, int> cell_int_t;$/;"	t	struct:OptDffWorker	typeref:typename:std::pair<RTLIL::Cell *,int>	file:
cell_known	yosys/kernel/celltypes.h	/^	bool cell_known(RTLIL::IdString type) const$/;"	f	struct:CellTypes	typeref:typename:bool
cell_mapping	yosys/passes/techmap/dfflibmap.cc	/^struct cell_mapping {$/;"	s	file:
cell_mappings	yosys/passes/techmap/dfflibmap.cc	/^static std::map<RTLIL::IdString, cell_mapping> cell_mappings;$/;"	v	typeref:typename:std::map<RTLIL::IdString,cell_mapping>	file:
cell_name	yosys/passes/sat/sim.cc	/^	std::string cell_name(std::string const & name)$/;"	f	struct:SimWorker	typeref:typename:std::string	file:
cell_name	yosys/passes/techmap/dfflibmap.cc	/^	IdString cell_name;$/;"	m	struct:cell_mapping	typeref:typename:IdString	file:
cell_names	yosys/passes/equiv/equiv_make.cc	/^	pool<IdString> wire_names, cell_names;$/;"	m	struct:EquivMakeWorker	typeref:typename:pool<IdString>	file:
cell_output	yosys/kernel/celltypes.h	/^	bool cell_output(RTLIL::IdString type, RTLIL::IdString port) const$/;"	f	struct:CellTypes	typeref:typename:bool
cell_outputs	yosys/kernel/modtools.h	/^	dict<RTLIL::Cell*, pool<RTLIL::SigBit>> cell_outputs, cell_inputs;$/;"	m	struct:ModWalker	typeref:typename:dict<RTLIL::Cell *,pool<RTLIL::SigBit>>
cell_ptr_cmp	yosys/passes/opt/share.cc	/^typedef RTLIL::IdString::compare_ptr_by_name<RTLIL::Cell> cell_ptr_cmp;$/;"	t	typeref:typename:RTLIL::IdString::compare_ptr_by_name<RTLIL::Cell>	file:
cell_recursion_guard	yosys/backends/btor/btor.cc	/^	pool<Cell*> cell_recursion_guard;$/;"	m	struct:BtorWorker	typeref:typename:pool<Cell * >	file:
cell_regions	yosys/passes/equiv/equiv_mark.cc	/^	dict<IdString, int> cell_regions;$/;"	m	struct:EquivMarkWorker	typeref:typename:dict<IdString,int>	file:
cell_subst	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	const RTLIL::Cell *cell_subst = nullptr; \/\/ for INLINE$/;"	m	struct:WireType	typeref:typename:const RTLIL::Cell *	file:
cell_supported	yosys/passes/opt/opt_share.cc	/^bool cell_supported(RTLIL::Cell *cell)$/;"	f	typeref:typename:bool
cell_to_node	yosys/passes/cmds/qwp.cc	/^	dict<Cell*, int> cell_to_node;$/;"	m	struct:QwpWorker	typeref:typename:dict<Cell *,int>	file:
cell_type	yosys/passes/opt/opt_lut.cc	/^	IdString cell_type;$/;"	m	struct:dlogic_t	typeref:typename:IdString	file:
cell_types	yosys/kernel/celltypes.h	/^	dict<RTLIL::IdString, CellType> cell_types;$/;"	m	struct:CellTypes	typeref:typename:dict<RTLIL::IdString,CellType>
cell_types	yosys/passes/cmds/select.cc	/^		std::set<RTLIL::IdString> cell_types, port_names;$/;"	m	struct:__anon240a0d430111::expand_rule_t	typeref:typename:std::set<RTLIL::IdString>	file:
cell_warn_cache	yosys/passes/equiv/equiv_induct.cc	/^	pool<Cell*> cell_warn_cache;$/;"	m	struct:EquivInductWorker	typeref:typename:pool<Cell * >	file:
cellname	yosys/backends/firrtl/firrtl.cc	/^	std::string cellname(RTLIL::Cell *cell)$/;"	f	struct:FirrtlWorker	typeref:typename:std::string	file:
cellname	yosys/backends/verilog/verilog_backend.cc	/^std::string cellname(RTLIL::Cell *cell)$/;"	f	typeref:typename:std::string
cells	yosys/kernel/rtlil.h	/^	RTLIL::ObjRange<RTLIL::Cell*> cells() { return RTLIL::ObjRange<RTLIL::Cell*>(&cells_, &refcount/;"	f	struct:RTLIL::Module	typeref:typename:RTLIL::ObjRange<RTLIL::Cell * >
cells	yosys/passes/equiv/equiv_induct.cc	/^	vector<Cell*> cells;$/;"	m	struct:EquivInductWorker	typeref:typename:vector<Cell * >	file:
cells	yosys/passes/hierarchy/submod.cc	/^		pool<RTLIL::Cell*> cells;$/;"	m	struct:SubmodWorker::SubModule	typeref:typename:pool<RTLIL::Cell * >	file:
cells	yosys/passes/sat/expose.cc	/^	std::vector<RTLIL::IdString> cells;$/;"	m	struct:dff_map_info_t	typeref:typename:std::vector<RTLIL::IdString>	file:
cells	yosys/passes/techmap/alumacc.cc	/^		std::vector<RTLIL::Cell*> cells;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:std::vector<RTLIL::Cell * >	file:
cellsOnStack	yosys/passes/cmds/scc.cc	/^	std::set<RTLIL::Cell*> cellsOnStack;$/;"	m	struct:SccWorker	typeref:typename:std::set<RTLIL::Cell * >	file:
cells_	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, RTLIL::Cell*> cells_;$/;"	m	struct:RTLIL::Module	typeref:typename:dict<RTLIL::IdString,RTLIL::Cell * >
cells_to_remove	yosys/passes/opt/share.cc	/^	pool<RTLIL::Cell*> cells_to_remove;$/;"	m	struct:ShareWorker	typeref:typename:pool<RTLIL::Cell * >	file:
center_x	yosys/libs/ezsat/puzzle3d.cc	/^	int center_x, center_y, center_z;$/;"	m	struct:blockgeom_t	typeref:typename:int	file:
center_y	yosys/libs/ezsat/puzzle3d.cc	/^	int center_x, center_y, center_z;$/;"	m	struct:blockgeom_t	typeref:typename:int	file:
center_z	yosys/libs/ezsat/puzzle3d.cc	/^	int center_x, center_y, center_z;$/;"	m	struct:blockgeom_t	typeref:typename:int	file:
chain_start_cells	yosys/passes/opt/muxpack.cc	/^	pool<Cell*> chain_start_cells;$/;"	m	struct:MuxpackWorker	typeref:typename:pool<Cell * >	file:
chain_start_cells	yosys/passes/techmap/shregmap.cc	/^	pool<Cell*> chain_start_cells;$/;"	m	struct:ShregmapWorker	typeref:typename:pool<Cell * >	file:
check	yosys/kernel/mem.cc	/^void Mem::check() {$/;"	f	class:Mem	typeref:typename:void
check	yosys/kernel/modtools.h	/^	void check()$/;"	f	struct:ModIndex	typeref:typename:void
check	yosys/kernel/rtlil.cc	/^		void check()$/;"	f	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:void	file:
check	yosys/kernel/rtlil.cc	/^void RTLIL::Cell::check()$/;"	f	class:RTLIL::Cell	typeref:typename:void
check	yosys/kernel/rtlil.cc	/^void RTLIL::Design::check()$/;"	f	class:RTLIL::Design	typeref:typename:void
check	yosys/kernel/rtlil.cc	/^void RTLIL::Module::check()$/;"	f	class:RTLIL::Module	typeref:typename:void
check	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::check(Module *mod) const$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
check	yosys/kernel/rtlil.h	/^	void check(Module *mod = nullptr) const { (void)mod; }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:void
check	yosys/kernel/sigtools.h	/^	bool check(const RTLIL::SigBit &bit) const$/;"	f	struct:SigPool	typeref:typename:bool
check	yosys/libs/bigint/testsuite.cc	/^const BigInteger &check(const BigInteger &x) {$/;"	f	typeref:typename:const BigInteger &
check	yosys/libs/bigint/testsuite.cc	/^const BigUnsigned &check(const BigUnsigned &x) {$/;"	f	typeref:typename:const BigUnsigned &
check	yosys/libs/ezsat/testbench.cc	/^void check(const char *expr1_str, bool expr1, const char *expr2_str, bool expr2)$/;"	f	typeref:typename:void
check	yosys/manual/CHAPTER_StateOfTheArt/cmp_tbdata.c	/^void check(bool ok)$/;"	f	typeref:typename:void
check	yosys/passes/proc/proc_mux.cc	/^	bool check(RTLIL::SwitchRule *sw)$/;"	f	struct:SnippetSwCache	typeref:typename:bool	file:
check	yosys/passes/techmap/abc9_ops.cc	/^void check(RTLIL::Design *design, bool dff_mode)$/;"	f	typeref:typename:void
check	yosys/tests/tools/cmp_tbdata.c	/^void check(bool ok)$/;"	f	typeref:typename:void
checkCap	yosys/libs/minisat/Map.h	/^    bool    checkCap(int new_size) const { return new_size > cap; }$/;"	f	class:Minisat::Map	typeref:typename:bool
checkEnumerationMatrix	yosys/libs/subcircuit/subcircuit.cc	/^	bool checkEnumerationMatrix(std::vector<std::set<int>> &enumerationMatrix, int i, int j, const /;"	f	class:SubCircuit::SolverWorker	typeref:typename:bool	file:
checkGarbage	yosys/libs/minisat/Solver.h	/^inline void Solver::checkGarbage(double gf){$/;"	f	class:Minisat::Solver	typeref:typename:void
checkGarbage	yosys/libs/minisat/Solver.h	/^inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }$/;"	f	class:Minisat::Solver	typeref:typename:void
checkPortmapCandidate	yosys/libs/subcircuit/subcircuit.cc	/^	bool checkPortmapCandidate(const std::vector<std::set<int>> &enumerationMatrix, const GraphData/;"	f	class:SubCircuit::SolverWorker	typeref:typename:bool	file:
checkSignals	yosys/passes/sat/sim.cc	/^	bool checkSignals()$/;"	f	struct:SimInstance	typeref:typename:bool	file:
check_all	yosys/kernel/sigtools.h	/^	bool check_all(const RTLIL::SigSpec &sig) const$/;"	f	struct:SigPool	typeref:typename:bool
check_any	yosys/kernel/sigtools.h	/^	bool check_any(const RTLIL::SigSpec &sig) const$/;"	f	struct:SigPool	typeref:typename:bool
check_auto_nosync	yosys/frontends/ast/simplify.cc	/^static void check_auto_nosync(AstNode *node)$/;"	f	typeref:typename:void	file:
check_cell_connections	yosys/passes/hierarchy/hierarchy.cc	/^void check_cell_connections(const RTLIL::Module &module, RTLIL::Cell &cell, RTLIL::Module &mod)$/;"	f	typeref:typename:void
check_design	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void check_design(RTLIL::Design *design, bool &has_sync_init)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
check_expected	yosys/kernel/rtlil.cc	/^		void check_expected(bool check_matched_sign = false)$/;"	f	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:void	file:
check_expression	yosys/frontends/verific/verificsva.cc	/^	bool check_expression(Net *net, bool raise_error = false)$/;"	f	struct:VerificSvaImporter	typeref:typename:bool	file:
check_expression_cache	yosys/frontends/verific/verificsva.cc	/^	dict<Net*, bool, hash_ptr_ops> check_expression_cache;$/;"	m	struct:VerificSvaImporter	typeref:typename:dict<Net *,bool,hash_ptr_ops>	file:
check_file_exists	yosys/kernel/yosys.cc	/^bool check_file_exists(std::string filename, bool is_exec)$/;"	f	typeref:typename:bool
check_file_exists	yosys/kernel/yosys.cc	/^bool check_file_exists(std::string filename, bool)$/;"	f	typeref:typename:bool
check_if_top_has_changed	yosys/passes/hierarchy/hierarchy.cc	/^RTLIL::Module *check_if_top_has_changed(Design *design, Module *top_mod)$/;"	f	typeref:typename:RTLIL::Module *
check_label	yosys/kernel/register.cc	/^bool ScriptPass::check_label(std::string label, std::string info)$/;"	f	class:ScriptPass	typeref:typename:bool
check_logfile	yosys/passes/cmds/bugpoint.cc	/^	bool check_logfile(string grep)$/;"	f	struct:BugpointPass	typeref:typename:bool	file:
check_lut_critical_outputs	yosys/passes/techmap/flowmap.cc	/^	void check_lut_critical_outputs(const dict<RTLIL::SigBit, pool<RTLIL::SigBit>> &lut_critical_ou/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
check_lut_distances	yosys/passes/techmap/flowmap.cc	/^	void check_lut_distances(const dict<RTLIL::SigBit, int> &lut_distances, bool forward)$/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
check_muxed_operands	yosys/passes/opt/opt_share.cc	/^void check_muxed_operands(std::vector<const OpMuxConn *> &ports, const ExtSigSpec &shared_operan/;"	f	typeref:typename:void
check_noverific_env	yosys/frontends/verific/verific.cc	/^bool check_noverific_env()$/;"	f	typeref:typename:YOSYS_NAMESPACE_END PRIVATE_NAMESPACE_BEGIN bool
check_partition	yosys/passes/techmap/extract_fa.cc	/^	void check_partition(SigBit root, pool<SigBit> &leaves)$/;"	f	struct:ExtractFaWorker	typeref:typename:void	file:
check_pid	yosys/frontends/rpc/rpc_frontend.cc	/^	void check_pid() {$/;"	f	struct:FdRpcServer	typeref:typename:void	file:
check_public_name	yosys/passes/opt/opt_clean.cc	/^bool check_public_name(RTLIL::IdString id)$/;"	f	typeref:typename:bool
check_signal	yosys/passes/proc/proc_arst.cc	/^bool check_signal(RTLIL::Module *mod, RTLIL::SigSpec signal, RTLIL::SigSpec ref, bool &polarity)$/;"	f	typeref:typename:YOSYS_NAMESPACE_END USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
check_signal_in_fanout	yosys/passes/equiv/equiv_make.cc	/^	bool check_signal_in_fanout(pool<Cell*> & visited_cells, SigBit source_bit, SigBit target_bit)$/;"	f	struct:EquivMakeWorker	typeref:typename:bool	file:
check_state_mux_tree	yosys/passes/fsm/fsm_detect.cc	/^static bool check_state_mux_tree(RTLIL::SigSpec old_sig, RTLIL::SigSpec sig, pool<Cell*> &recurs/;"	f	typeref:typename:bool	file:
check_state_users	yosys/passes/fsm/fsm_detect.cc	/^static bool check_state_users(RTLIL::SigSpec sig)$/;"	f	typeref:typename:bool	file:
check_undef_enabled	yosys/passes/sat/sat.cc	/^	void check_undef_enabled(const RTLIL::SigSpec &sig)$/;"	f	struct:SatHelper	typeref:typename:void	file:
check_unique_id	yosys/frontends/ast/genrtlil.cc	/^static void check_unique_id(RTLIL::Module *module, RTLIL::IdString id,$/;"	f	typeref:typename:void	file:
check_vectors	yosys/passes/memory/memory_bram.cc	/^		void check_vectors() const$/;"	f	struct:rules_t::bram_t	typeref:typename:void	file:
check_zero_consecutive_repeat	yosys/frontends/verific/verificsva.cc	/^	bool check_zero_consecutive_repeat(Net *net)$/;"	f	struct:VerificSvaImporter	typeref:typename:bool	file:
checkpoint	yosys/kernel/rtlil.h	/^		static inline void checkpoint()$/;"	f	struct:RTLIL::IdString	typeref:typename:void
checksum	yosys/passes/opt/opt_merge.cc	/^	SHA1 checksum;$/;"	m	struct:OptMergeWorker	typeref:typename:SHA1	file:
child_pid	yosys/misc/launcher.c	/^int child_pid=0;$/;"	v	typeref:typename:int
children	yosys/backends/simplec/simplec.cc	/^	dict<IdString, HierDirtyFlags*> children;$/;"	m	struct:HierDirtyFlags	typeref:typename:dict<IdString,HierDirtyFlags * >	file:
children	yosys/frontends/ast/ast.h	/^		std::vector<AstNode*> children;$/;"	m	struct:AST::AstNode	typeref:typename:std::vector<AstNode * >
children	yosys/passes/proc/proc_dlatch.cc	/^		vector<int> children;$/;"	m	struct:proc_dlatch_db_t::rule_node_t	typeref:typename:vector<int>	file:
children	yosys/passes/sat/sim.cc	/^	dict<Cell*, SimInstance*> children;$/;"	m	struct:SimInstance	typeref:typename:dict<Cell *,SimInstance * >	file:
children	yosys/passes/techmap/libparse.h	/^		std::vector<LibertyAst*> children;$/;"	m	struct:Yosys::LibertyAst	typeref:typename:std::vector<LibertyAst * >
chunk	yosys/backends/cxxrtl/cxxrtl.h	/^	using chunk = chunk_traits<chunk_t>;$/;"	t	struct:cxxrtl::value	typeref:typename:chunk_traits<chunk_t>
chunk_t	yosys/backends/cxxrtl/cxxrtl.h	/^typedef uint32_t chunk_t;$/;"	t	namespace:cxxrtl	typeref:typename:uint32_t
chunk_traits	yosys/backends/cxxrtl/cxxrtl.h	/^struct chunk_traits {$/;"	s	namespace:cxxrtl
chunks	yosys/backends/cxxrtl/cxxrtl.h	/^	static constexpr size_t chunks = (Bits + chunk::bits - 1) \/ chunk::bits;$/;"	m	struct:cxxrtl::value	typeref:typename:size_t
chunks	yosys/kernel/rtlil.h	/^	inline const std::vector<RTLIL::SigChunk> &chunks() const { pack(); return chunks_; }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:const std::vector<RTLIL::SigChunk> &
chunks_	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::SigChunk> chunks_; \/\/ LSB at index 0$/;"	m	struct:RTLIL::SigSpec	typeref:typename:std::vector<RTLIL::SigChunk>
ci_bits	yosys/backends/aiger/xaiger.cc	/^	vector<SigBit> ci_bits, co_bits;$/;"	m	struct:XAigerWriter	typeref:typename:vector<SigBit>	file:
cid	yosys/backends/simplec/simplec.cc	/^static string cid(IdString id)$/;"	f	typeref:typename:string	file:
cid	yosys/backends/smv/smv.cc	/^	const char *cid()$/;"	f	struct:SmvWorker	typeref:typename:const char *	file:
cid	yosys/backends/smv/smv.cc	/^	const char *cid(IdString id, bool precache = false)$/;"	f	struct:SmvWorker	typeref:typename:const char *	file:
claBumpActivity	yosys/libs/minisat/Solver.h	/^inline void Solver::claBumpActivity (Clause& c) {$/;"	f	class:Minisat::Solver	typeref:typename:void
claDecayActivity	yosys/libs/minisat/Solver.h	/^inline void Solver::claDecayActivity() { cla_inc *= (1 \/ clause_decay); }$/;"	f	class:Minisat::Solver	typeref:typename:void
cla_inc	yosys/libs/minisat/Solver.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:Minisat::Solver	typeref:typename:double
clauseWord32Size	yosys/libs/minisat/SolverTypes.h	/^    static uint32_t clauseWord32Size(int size, bool has_extra){$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:uint32_t
clause_decay	yosys/libs/minisat/Solver.h	/^    double    clause_decay;$/;"	m	class:Minisat::Solver	typeref:typename:double
clause_lim	yosys/libs/minisat/SimpSolver.h	/^    int     clause_lim;        \/\/ Variables are not eliminated if it produces a resolvent with/;"	m	class:Minisat::SimpSolver	typeref:typename:int
clauses	yosys/libs/minisat/Solver.h	/^    vec<CRef>           clauses;          \/\/ List of problem clauses.$/;"	m	class:Minisat::Solver	typeref:typename:vec<CRef>
clausesBegin	yosys/libs/minisat/Solver.h	/^inline ClauseIterator Solver::clausesBegin() const { return ClauseIterator(ca, &clauses[0]); }$/;"	f	class:Minisat::Solver	typeref:typename:ClauseIterator
clausesEnd	yosys/libs/minisat/Solver.h	/^inline ClauseIterator Solver::clausesEnd  () const { return ClauseIterator(ca, &clauses[clauses./;"	f	class:Minisat::Solver	typeref:typename:ClauseIterator
clauses_literals	yosys/libs/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literal/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
clean	yosys/Makefile	/^clean:$/;"	t
clean	yosys/examples/osu035/Makefile	/^clean:$/;"	t
clean	yosys/examples/smtbmc/Makefile	/^clean:$/;"	t
clean	yosys/libs/bigint/Makefile	/^clean :$/;"	t
clean	yosys/libs/ezsat/Makefile	/^clean:$/;"	t
clean	yosys/libs/minisat/SolverTypes.h	/^void OccLists<K,Vec,Deleted,MkIndex>::clean(const K& idx)$/;"	f	class:Minisat::OccLists	typeref:typename:void
clean	yosys/libs/subcircuit/Makefile	/^clean:$/;"	t
clean	yosys/manual/CHAPTER_Prog/Makefile	/^clean:$/;"	t
clean	yosys/manual/PRESENTATION_ExSyn/Makefile	/^clean:$/;"	t
clean	yosys/tests/sva/Makefile	/^clean:$/;"	t
clean	yosys/tests/unit/Makefile	/^clean:$/;"	t
clean-abc	yosys/Makefile	/^clean-abc:$/;"	t
clean-unit-test	yosys/Makefile	/^clean-unit-test:$/;"	t
cleanAll	yosys/libs/minisat/SolverTypes.h	/^void OccLists<K,Vec,Deleted,MkIndex>::cleanAll()$/;"	f	class:Minisat::OccLists	typeref:typename:void
clean_case	yosys/passes/cmds/clean_zerowidth.cc	/^	void clean_case(RTLIL::CaseRule *cs)$/;"	f	struct:CleanZeroWidthPass	typeref:typename:void	file:
clean_design	yosys/passes/cmds/bugpoint.cc	/^	RTLIL::Design *clean_design(RTLIL::Design *design, bool do_clean = true, bool do_delete = false/;"	f	struct:BugpointPass	typeref:typename:RTLIL::Design *	file:
cleanup	yosys/passes/opt/muxpack.cc	/^	void cleanup()$/;"	f	struct:MuxpackWorker	typeref:typename:void	file:
cleanup	yosys/passes/techmap/abc9.cc	/^	bool dff_mode, cleanup;$/;"	m	struct:Abc9Pass	typeref:typename:bool	file:
cleanup	yosys/passes/techmap/shregmap.cc	/^	void cleanup()$/;"	f	struct:ShregmapWorker	typeref:typename:void	file:
clear	yosys/frontends/aiger/aigerparse.cc	/^	void clear()$/;"	f	struct:ConstEvalAig	typeref:typename:void	file:
clear	yosys/frontends/verilog/preproc.cc	/^void define_map_t::clear()$/;"	f	class:define_map_t	typeref:typename:void
clear	yosys/kernel/celltypes.h	/^	void clear()$/;"	f	struct:CellTypes	typeref:typename:void
clear	yosys/kernel/consteval.h	/^	void clear()$/;"	f	struct:ConstEval	typeref:typename:void
clear	yosys/kernel/ffinit.h	/^	void clear()$/;"	f	struct:FfInitVals	typeref:typename:void
clear	yosys/kernel/ffmerge.cc	/^void FfMergeHelper::clear() {$/;"	f	class:FfMergeHelper	typeref:typename:void
clear	yosys/kernel/hashlib.h	/^	void clear() { database.clear(); parents.clear(); }$/;"	f	class:hashlib::mfp	typeref:typename:void
clear	yosys/kernel/hashlib.h	/^	void clear() { database.clear(); }$/;"	f	class:hashlib::idict	typeref:typename:void
clear	yosys/kernel/hashlib.h	/^	void clear() { hashtable.clear(); entries.clear(); }$/;"	f	class:hashlib::dict	typeref:typename:void
clear	yosys/kernel/hashlib.h	/^	void clear() { hashtable.clear(); entries.clear(); }$/;"	f	class:hashlib::pool	typeref:typename:void
clear	yosys/kernel/rtlil.h	/^		void clear() {$/;"	f	struct:RTLIL::IdString	typeref:typename:void
clear	yosys/kernel/sigtools.h	/^	void clear()$/;"	f	struct:SigMap	typeref:typename:void
clear	yosys/kernel/sigtools.h	/^	void clear()$/;"	f	struct:SigPool	typeref:typename:void
clear	yosys/kernel/sigtools.h	/^	void clear()$/;"	f	struct:SigSet	typeref:typename:void
clear	yosys/libs/ezsat/ezminisat.cc	/^void ezMiniSAT::clear()$/;"	f	class:ezMiniSAT	typeref:typename:void
clear	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::clear()$/;"	f	class:ezSAT	typeref:typename:void
clear	yosys/libs/minisat/Heap.h	/^    void clear(bool dispose = false) $/;"	f	class:Minisat::Heap	typeref:typename:void
clear	yosys/libs/minisat/IntMap.h	/^        void     clear       (bool free = false){$/;"	f	class:Minisat::IntSet	typeref:typename:void
clear	yosys/libs/minisat/IntMap.h	/^        void     clear  (bool dispose = false) { map.clear(dispose); }$/;"	f	class:Minisat::IntMap	typeref:typename:void
clear	yosys/libs/minisat/Map.h	/^    void clear  () {$/;"	f	class:Minisat::Map	typeref:typename:void
clear	yosys/libs/minisat/Queue.h	/^    void clear (bool dealloc = false) { buf.clear(dealloc); buf.growTo(1); first = end = 0; }$/;"	f	class:Minisat::Queue	typeref:typename:void
clear	yosys/libs/minisat/SolverTypes.h	/^    void     clear       ()                           { map.clear(); }$/;"	f	class:Minisat::CMap	typeref:typename:void
clear	yosys/libs/minisat/SolverTypes.h	/^    void  clear(bool free = true){$/;"	f	class:Minisat::OccLists	typeref:typename:void
clear	yosys/libs/minisat/Vec.h	/^void vec<T,_Size>::clear(bool dealloc) {$/;"	f	class:Minisat::vec	typeref:typename:void
clearConfig	yosys/libs/subcircuit/subcircuit.cc	/^	void clearConfig()$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
clearConfig	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::clearConfig()$/;"	f	class:SubCircuit::Solver	typeref:typename:void
clearInterrupt	yosys/libs/minisat/Solver.h	/^inline void     Solver::clearInterrupt(){ asynch_interrupt = false; }$/;"	f	class:Minisat::Solver	typeref:typename:void
clearOverlapHistory	yosys/libs/subcircuit/subcircuit.cc	/^	void clearOverlapHistory()$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
clearOverlapHistory	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::clearOverlapHistory()$/;"	f	class:SubCircuit::Solver	typeref:typename:void
clear_flags	yosys/kernel/register.cc	/^void Pass::clear_flags()$/;"	f	class:Pass	typeref:typename:void
clear_flags	yosys/passes/equiv/equiv_opt.cc	/^	void clear_flags() override$/;"	f	struct:EquivOptPass	typeref:typename:void	file:
clear_flags	yosys/passes/techmap/abc9.cc	/^	void clear_flags() override$/;"	f	struct:Abc9Pass	typeref:typename:void	file:
clear_flags	yosys/techlibs/achronix/synth_achronix.cc	/^  void clear_flags() override$/;"	f	struct:SynthAchronixPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/anlogic/synth_anlogic.cc	/^	void clear_flags() override$/;"	f	struct:SynthAnlogicPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/common/prep.cc	/^	void clear_flags() override$/;"	f	struct:PrepPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/common/synth.cc	/^	void clear_flags() override$/;"	f	struct:SynthPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^	void clear_flags() override$/;"	f	struct:SynthCoolrunner2Pass	typeref:typename:void	file:
clear_flags	yosys/techlibs/easic/synth_easic.cc	/^	void clear_flags() override$/;"	f	struct:SynthEasicPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/ecp5/synth_ecp5.cc	/^	void clear_flags() override$/;"	f	struct:SynthEcp5Pass	typeref:typename:void	file:
clear_flags	yosys/techlibs/efinix/synth_efinix.cc	/^	void clear_flags() override$/;"	f	struct:SynthEfinixPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/gatemate/synth_gatemate.cc	/^	void clear_flags() override$/;"	f	struct:SynthGateMatePass	typeref:typename:void	file:
clear_flags	yosys/techlibs/gowin/synth_gowin.cc	/^	void clear_flags() override$/;"	f	struct:SynthGowinPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^	void clear_flags() override$/;"	f	struct:SynthGreenPAK4Pass	typeref:typename:void	file:
clear_flags	yosys/techlibs/ice40/synth_ice40.cc	/^	void clear_flags() override$/;"	f	struct:SynthIce40Pass	typeref:typename:void	file:
clear_flags	yosys/techlibs/intel/synth_intel.cc	/^	void clear_flags() override$/;"	f	struct:SynthIntelPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	void clear_flags() override$/;"	f	struct:SynthIntelALMPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/machxo2/synth_machxo2.cc	/^	void clear_flags() override$/;"	f	struct:SynthMachXO2Pass	typeref:typename:void	file:
clear_flags	yosys/techlibs/nexus/synth_nexus.cc	/^	void clear_flags() override$/;"	f	struct:SynthNexusPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	void clear_flags() override$/;"	f	struct:SynthQuickLogicPass	typeref:typename:void	file:
clear_flags	yosys/techlibs/sf2/synth_sf2.cc	/^	void clear_flags() override$/;"	f	struct:SynthSf2Pass	typeref:typename:void	file:
clear_flags	yosys/techlibs/xilinx/synth_xilinx.cc	/^	void clear_flags() override$/;"	f	struct:SynthXilinxPass	typeref:typename:void	file:
clear_inits	yosys/kernel/mem.cc	/^void Mem::clear_inits() {$/;"	f	class:Mem	typeref:typename:void
clear_preset_var	yosys/passes/techmap/libparse.cc	/^void clear_preset_var(std::string var, std::string type)$/;"	f	typeref:typename:void
clk	yosys/kernel/mem.h	/^	SigSpec clk, en, addr, data;$/;"	m	struct:MemWr	typeref:typename:SigSpec
clk	yosys/kernel/mem.h	/^	SigSpec clk, en, arst, srst, addr, data;$/;"	m	struct:MemRd	typeref:typename:SigSpec
clk	yosys/passes/techmap/extract_counter.cc	/^	RTLIL::SigSpec clk;				\/\/clock enable, if any$/;"	m	struct:CounterExtraction	typeref:typename:RTLIL::SigSpec	file:
clk_enable	yosys/kernel/mem.h	/^	bool clk_enable, clk_polarity, ce_over_srst;$/;"	m	struct:MemRd	typeref:typename:bool
clk_enable	yosys/kernel/mem.h	/^	bool clk_enable, clk_polarity;$/;"	m	struct:MemWr	typeref:typename:bool
clk_name	yosys/frontends/aiger/aigerparse.h	/^    RTLIL::IdString clk_name;$/;"	m	struct:AigerReader	typeref:typename:RTLIL::IdString
clk_polarity	yosys/kernel/mem.h	/^	bool clk_enable, clk_polarity, ce_over_srst;$/;"	m	struct:MemRd	typeref:typename:bool
clk_polarity	yosys/kernel/mem.h	/^	bool clk_enable, clk_polarity;$/;"	m	struct:MemWr	typeref:typename:bool
clk_polarity	yosys/passes/sat/expose.cc	/^	bool clk_polarity, arst_polarity;$/;"	m	struct:dff_map_bit_info_t	typeref:typename:bool	file:
clk_polarity	yosys/passes/sat/expose.cc	/^	bool clk_polarity, arst_polarity;$/;"	m	struct:dff_map_info_t	typeref:typename:bool	file:
clk_polarity	yosys/passes/techmap/abc.cc	/^bool clk_polarity, en_polarity, arst_polarity, srst_polarity;$/;"	v	typeref:typename:bool
clk_sig	yosys/passes/techmap/abc.cc	/^RTLIL::SigSpec clk_sig, en_sig, arst_sig, srst_sig;$/;"	v	typeref:typename:RTLIL::SigSpec
clk_signals	yosys/kernel/fstdata.h	/^	std::vector<fstHandle> clk_signals;$/;"	m	class:FstData	typeref:typename:std::vector<fstHandle>
clkbuf	yosys/techlibs/sf2/synth_sf2.cc	/^	bool flatten, retime, iobs, clkbuf;$/;"	m	struct:SynthSf2Pass	typeref:typename:bool	file:
clkdomain_t	yosys/passes/techmap/abc.cc	/^			typedef tuple<bool, RTLIL::SigSpec, bool, RTLIL::SigSpec, bool, RTLIL::SigSpec, bool, RTLIL::/;"	t	function:AbcPass::execute	typeref:typename:tuple<bool,RTLIL::SigSpec,bool,RTLIL::SigSpec,bool,RTLIL::SigSpec,bool,RTLIL::SigSpec>	file:
clkpol	yosys/passes/memory/memory_bram.cc	/^		int wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:int	file:
clkpol	yosys/passes/memory/memory_bram.cc	/^		vector<int> ports, wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::bram_t	typeref:typename:vector<int>	file:
clock	yosys/passes/sat/sim.cc	/^	pool<IdString> clock, clockn, reset, resetn;$/;"	m	struct:SimWorker	typeref:typename:pool<IdString>	file:
clock_negedge	yosys/backends/smt2/smt2.cc	/^	pool<SigBit> clock_posedge, clock_negedge;$/;"	m	struct:Smt2Worker	typeref:typename:pool<SigBit>	file:
clock_net	yosys/frontends/verific/verific.h	/^	Verific::Net *clock_net = nullptr;$/;"	m	struct:VerificClocking	typeref:typename:Verific::Net *
clock_posedge	yosys/backends/smt2/smt2.cc	/^	pool<SigBit> clock_posedge, clock_negedge;$/;"	m	struct:Smt2Worker	typeref:typename:pool<SigBit>	file:
clock_sig	yosys/frontends/verific/verific.h	/^	SigBit clock_sig = State::Sx;$/;"	m	struct:VerificClocking	typeref:typename:SigBit
clocking	yosys/frontends/verific/verificsva.cc	/^	VerificClocking clocking;$/;"	m	struct:SvaFsm	typeref:typename:VerificClocking	file:
clocking	yosys/frontends/verific/verificsva.cc	/^	VerificClocking clocking;$/;"	m	struct:VerificSvaImporter	typeref:typename:VerificClocking	file:
clockn	yosys/passes/sat/sim.cc	/^	pool<IdString> clock, clockn, reset, resetn;$/;"	m	struct:SimWorker	typeref:typename:pool<IdString>	file:
clocks	yosys/passes/memory/memory_bram.cc	/^		int wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:int	file:
clocks	yosys/passes/memory/memory_bram.cc	/^		vector<int> ports, wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::bram_t	typeref:typename:vector<int>	file:
clog2	yosys/libs/ezsat/ezsat.cc	/^static int clog2(int x)$/;"	f	typeref:typename:int	file:
clone	yosys/frontends/ast/ast.cc	/^AstNode *AstNode::clone() const$/;"	f	class:AstNode	typeref:typename:AstNode *
clone	yosys/frontends/ast/ast.cc	/^RTLIL::Module *AstModule::clone() const$/;"	f	class:AstModule	typeref:typename:RTLIL::Module *
clone	yosys/frontends/rpc/rpc_frontend.cc	/^	RTLIL::Module *clone() const override {$/;"	f	struct:RpcModule	typeref:typename:RTLIL::Module *	file:
clone	yosys/kernel/rtlil.cc	/^RTLIL::CaseRule *RTLIL::CaseRule::clone() const$/;"	f	class:RTLIL::CaseRule	typeref:typename:RTLIL::CaseRule *
clone	yosys/kernel/rtlil.cc	/^RTLIL::Module *RTLIL::Module::clone() const$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::Module *
clone	yosys/kernel/rtlil.cc	/^RTLIL::Process *RTLIL::Process::clone() const$/;"	f	class:RTLIL::Process	typeref:typename:RTLIL::Process *
clone	yosys/kernel/rtlil.cc	/^RTLIL::SwitchRule *RTLIL::SwitchRule::clone() const$/;"	f	class:RTLIL::SwitchRule	typeref:typename:RTLIL::SwitchRule *
clone	yosys/kernel/rtlil.cc	/^RTLIL::SyncRule *RTLIL::SyncRule::clone() const$/;"	f	class:RTLIL::SyncRule	typeref:typename:RTLIL::SyncRule *
cloneInto	yosys/frontends/ast/ast.cc	/^void AstNode::cloneInto(AstNode *other) const$/;"	f	class:AstNode	typeref:typename:void
cloneInto	yosys/kernel/rtlil.cc	/^void RTLIL::Module::cloneInto(RTLIL::Module *new_mod) const$/;"	f	class:RTLIL::Module	typeref:typename:void
cmd_error	yosys/kernel/register.cc	/^void Pass::cmd_error(const std::vector<std::string> &args, size_t argidx, std::string msg)$/;"	f	class:Pass	typeref:typename:void
cmd_log_args	yosys/kernel/register.cc	/^void Pass::cmd_log_args(const std::vector<std::string> &args)$/;"	f	class:Pass	typeref:typename:void
cmos_cost	yosys/passes/techmap/abc.cc	/^bool cmos_cost;$/;"	v	typeref:typename:bool
cmos_gate_cost	yosys/kernel/cost.h	/^	static const dict<RTLIL::IdString, int>& cmos_gate_cost() {$/;"	f	struct:CellCosts	typeref:typename:const dict<RTLIL::IdString,int> &
cmp	yosys/kernel/hashlib.h	/^	static inline bool cmp(T a, T b) {$/;"	f	struct:hashlib::hash_int_ops	typeref:typename:bool
cmp	yosys/kernel/hashlib.h	/^	static inline bool cmp(const T &a, const T &b) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:bool
cmp	yosys/kernel/hashlib.h	/^	static inline bool cmp(const char *a, const char *b) {$/;"	f	struct:hashlib::hash_cstr_ops	typeref:typename:bool
cmp	yosys/kernel/hashlib.h	/^	static inline bool cmp(const std::string &a, const std::string &b) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:bool
cmp	yosys/kernel/hashlib.h	/^	static inline bool cmp(const void *a, const void *b) {$/;"	f	struct:hashlib::hash_obj_ops	typeref:typename:bool
cmp	yosys/kernel/hashlib.h	/^	static inline bool cmp(const void *a, const void *b) {$/;"	f	struct:hashlib::hash_ptr_ops	typeref:typename:bool
cmp	yosys/kernel/hashlib.h	/^	static inline bool cmp(std::pair<P, Q> a, std::pair<P, Q> b) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:bool
cmp	yosys/kernel/hashlib.h	/^	static inline bool cmp(std::tuple<T...> a, std::tuple<T...> b) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:bool
cmp	yosys/kernel/hashlib.h	/^	static inline bool cmp(std::vector<T> a, std::vector<T> b) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:bool
cmp	yosys/passes/sat/sim.cc	/^	cmp,$/;"	e	enum:SimulationMode	file:
cmp	yosys/passes/techmap/alumacc.cc	/^		std::vector<tuple<bool, bool, bool, bool, RTLIL::SigSpec>> cmp;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:std::vector<tuple<bool,bool,bool,bool,RTLIL::SigSpec>>	file:
cmp_ctrl	yosys/frontends/verific/verificsva.cc	/^	bool cmp_ctrl(const pool<SigBit> &ctrl_bits, const SigSpec &ctrl)$/;"	f	struct:SvaFsm	typeref:typename:bool	file:
cmp_macc_ports	yosys/passes/opt/share.cc	/^	static bool cmp_macc_ports(const Macc::port_t &p1, const Macc::port_t &p2)$/;"	f	struct:ShareWorker	typeref:typename:bool	file:
cname_mode	yosys/backends/blif/blif.cc	/^	bool cname_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
cnf	yosys/libs/ezsat/ezsat.h	/^	const std::vector<std::vector<int>> &cnf() const { return cnfClauses; }$/;"	f	class:ezSAT	typeref:typename:const std::vector<std::vector<int>> &
cnfClauses	yosys/libs/ezsat/ezsat.h	/^	std::vector<std::vector<int>> cnfClauses, cnfClausesBackup;$/;"	m	class:ezSAT	typeref:typename:std::vector<std::vector<int>>
cnfClausesBackup	yosys/libs/ezsat/ezsat.h	/^	std::vector<std::vector<int>> cnfClauses, cnfClausesBackup;$/;"	m	class:ezSAT	typeref:typename:std::vector<std::vector<int>>
cnfClausesCount	yosys/libs/ezsat/ezsat.h	/^	int cnfVariableCount, cnfClausesCount;$/;"	m	class:ezSAT	typeref:typename:int
cnfConsumed	yosys/libs/ezsat/ezsat.h	/^	bool cnfConsumed;$/;"	m	class:ezSAT	typeref:typename:bool
cnfExpressionVariables	yosys/libs/ezsat/ezsat.h	/^	std::vector<int> cnfLiteralVariables, cnfExpressionVariables;$/;"	m	class:ezSAT	typeref:typename:std::vector<int>
cnfFrozenVars	yosys/libs/ezsat/ezminisat.h	/^	std::set<int> cnfFrozenVars;$/;"	m	class:ezMiniSAT	typeref:typename:std::set<int>
cnfLiteralInfo	yosys/libs/ezsat/ezsat.cc	/^std::string ezSAT::cnfLiteralInfo(int idx) const$/;"	f	class:ezSAT	typeref:typename:std::string
cnfLiteralVariables	yosys/libs/ezsat/ezsat.h	/^	std::vector<int> cnfLiteralVariables, cnfExpressionVariables;$/;"	m	class:ezSAT	typeref:typename:std::vector<int>
cnfVariableCount	yosys/libs/ezsat/ezsat.h	/^	int cnfVariableCount, cnfClausesCount;$/;"	m	class:ezSAT	typeref:typename:int
co_bits	yosys/backends/aiger/xaiger.cc	/^	vector<SigBit> ci_bits, co_bits;$/;"	m	struct:XAigerWriter	typeref:typename:vector<SigBit>	file:
coalesce_cells	yosys/backends/jny/jny.cc	/^        void coalesce_cells(Module* mod)$/;"	f	struct:JnyWriter	typeref:typename:void	file:
coalesce_inits	yosys/kernel/mem.cc	/^void Mem::coalesce_inits() {$/;"	f	class:Mem	typeref:typename:void
collapsed	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, pool<RTLIL::SigBit>> collapsed;$/;"	m	struct:FlowGraph	typeref:typename:dict<RTLIL::SigBit,pool<RTLIL::SigBit>>	file:
collchain_t	yosys/libs/fst/fstapi.cc	/^struct collchain_t$/;"	s	file:
collect_cell_eval	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void collect_cell_eval(const RTLIL::Cell *cell, bool for_debug, std::vector<const RTLIL::Cell*>/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
collect_connect	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void collect_connect(const RTLIL::SigSig &conn, bool for_debug, std::vector<const RTLIL::Cell*>/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
collect_lookaheadids	yosys/frontends/ast/genrtlil.cc	/^	void collect_lookaheadids(AstNode *node)$/;"	f	struct:AST_INTERNAL::LookaheadRewriter	typeref:typename:void	file:
collect_lvalues	yosys/frontends/ast/genrtlil.cc	/^	void collect_lvalues(RTLIL::SigSpec &reg, AstNode *ast, bool type_eq, bool type_le, bool run_so/;"	f	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:void	file:
collect_proc_signals	yosys/passes/cmds/show.cc	/^	void collect_proc_signals(RTLIL::CaseRule *obj, std::set<RTLIL::SigSpec> &input_signals, std::s/;"	f	struct:ShowWorker	typeref:typename:void	file:
collect_proc_signals	yosys/passes/cmds/show.cc	/^	void collect_proc_signals(RTLIL::Process *obj, std::set<RTLIL::SigSpec> &input_signals, std::se/;"	f	struct:ShowWorker	typeref:typename:void	file:
collect_proc_signals	yosys/passes/cmds/show.cc	/^	void collect_proc_signals(RTLIL::SwitchRule *obj, std::set<RTLIL::SigSpec> &input_signals, std:/;"	f	struct:ShowWorker	typeref:typename:void	file:
collect_proc_signals	yosys/passes/cmds/show.cc	/^	void collect_proc_signals(RTLIL::SyncRule *obj, std::set<RTLIL::SigSpec> &input_signals, std::s/;"	f	struct:ShowWorker	typeref:typename:void	file:
collect_proc_signals	yosys/passes/cmds/show.cc	/^	void collect_proc_signals(std::vector<RTLIL::SigSig> &obj, std::set<RTLIL::SigSpec> &input_sign/;"	f	struct:ShowWorker	typeref:typename:void	file:
collect_proc_signals	yosys/passes/cmds/show.cc	/^	void collect_proc_signals(std::vector<RTLIL::SigSpec> &obj, std::set<RTLIL::SigSpec> &signals)$/;"	f	struct:ShowWorker	typeref:typename:void	file:
collect_sigspec_rhs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void collect_sigspec_rhs(const RTLIL::SigSpec &sig, bool for_debug, std::vector<const RTLIL::Ce/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
collision_x_mask	yosys/kernel/mem.h	/^	std::vector<bool> collision_x_mask;$/;"	m	struct:MemRd	typeref:typename:std::vector<bool>
collision_x_mask	yosys/passes/memory/memory_dff.cc	/^	std::vector<bool> collision_x_mask;$/;"	m	struct:PortData	typeref:typename:std::vector<bool>	file:
color	yosys/passes/cmds/show.cc	/^	struct net_conn { std::set<std::pair<std::string, int>> in, out; std::string color; };$/;"	m	struct:ShowWorker::net_conn	typeref:typename:std::string	file:
color	yosys/passes/techmap/flowmap.cc	/^	string color, fillcolor;$/;"	m	struct:GraphStyle	typeref:typename:string	file:
color_selections	yosys/passes/cmds/show.cc	/^	const std::vector<std::pair<std::string, RTLIL::Selection>> &color_selections;$/;"	m	struct:ShowWorker	typeref:typename:const std::vector<std::pair<std::string,RTLIL::Selection>> &	file:
colorattr	yosys/passes/cmds/show.cc	/^	RTLIL::IdString colorattr;$/;"	m	struct:ShowWorker	typeref:typename:RTLIL::IdString	file:
colorattr_cache	yosys/passes/cmds/show.cc	/^	std::map<RTLIL::Const, int> colorattr_cache;$/;"	m	struct:ShowWorker	typeref:typename:std::map<RTLIL::Const,int>	file:
comb	yosys/kernel/timinginfo.h	/^		dict<BitBit, int> comb;$/;"	m	struct:TimingInfo::ModuleTiming	typeref:typename:dict<BitBit,int>
comb_ct	yosys/passes/equiv/equiv_make.cc	/^	CellTypes comb_ct;$/;"	m	struct:EquivMakeWorker	typeref:typename:CellTypes	file:
combine_const	yosys/passes/opt/opt_dff.cc	/^	State combine_const(State a, State b) {$/;"	f	struct:OptDffWorker	typeref:typename:State	file:
combine_resets	yosys/passes/opt/opt_dff.cc	/^	ctrl_t combine_resets(const ctrls_t &ctrls, bool make_gates)$/;"	f	struct:OptDffWorker	typeref:typename:ctrl_t	file:
combined_count	yosys/passes/opt/opt_lut.cc	/^	int eliminated_count = 0, combined_count = 0;$/;"	m	struct:OptLutWorker	typeref:typename:int	file:
combined_type	yosys/passes/sat/fmcombine.cc	/^	IdString orig_type, combined_type;$/;"	m	struct:FmcombineWorker	typeref:typename:IdString	file:
command	yosys/passes/equiv/equiv_opt.cc	/^	std::string command, techmap_opts, make_opts;$/;"	m	struct:EquivOptPass	typeref:typename:std::string	file:
commit	yosys/backends/cxxrtl/cxxrtl.h	/^	bool commit() {$/;"	f	struct:cxxrtl::memory	typeref:typename:bool
commit	yosys/backends/cxxrtl/cxxrtl.h	/^	bool commit() {$/;"	f	struct:cxxrtl::wire	typeref:typename:bool
compare	yosys/kernel/rtlil.h	/^		int compare(size_t pos, size_t len, const char* s) const {$/;"	f	struct:RTLIL::IdString	typeref:typename:int
compare	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::SigSpec> compare;$/;"	m	struct:RTLIL::CaseRule	typeref:typename:std::vector<RTLIL::SigSpec>
compare	yosys/libs/subcircuit/subcircuit.cc	/^		bool compare(const DiEdge &other, const std::map<std::string, std::set<std::set<std::string>>>/;"	f	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:bool	file:
compare	yosys/libs/subcircuit/subcircuit.cc	/^		bool compare(const DiEdge &other, const std::map<std::string, std::string> &mapFromPorts, cons/;"	f	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:bool	file:
compare	yosys/libs/subcircuit/subcircuit.cc	/^		bool compare(int needleEdge, int haystackEdge, const std::map<std::string, std::set<std::set<s/;"	f	struct:SubCircuit::SolverWorker::DiCache	typeref:typename:bool	file:
compare	yosys/libs/subcircuit/subcircuit.cc	/^		bool compare(int needleEdge, int haystackEdge, const std::map<std::string, std::string> &mapFr/;"	f	struct:SubCircuit::SolverWorker::DiCache	typeref:typename:bool	file:
compareAttributes	yosys/passes/techmap/extract.cc	/^	bool compareAttributes(const std::set<RTLIL::IdString> &attr, const dict<RTLIL::IdString, RTLIL/;"	f	class:SubCircuitSolver	typeref:typename:bool	file:
compareCache	yosys/libs/subcircuit/subcircuit.cc	/^		std::map<std::pair<int, int>, bool> compareCache;$/;"	m	struct:SubCircuit::SolverWorker::DiCache	typeref:typename:std::map<std::pair<int,int>,bool>	file:
compareSortNeedleList	yosys/passes/techmap/extract.cc	/^bool compareSortNeedleList(RTLIL::Module *left, RTLIL::Module *right)$/;"	f	typeref:typename:bool
compareTo	yosys/libs/bigint/BigInteger.cc	/^BigInteger::CmpRes BigInteger::compareTo(const BigInteger &x) const {$/;"	f	class:BigInteger	typeref:typename:BigInteger::CmpRes
compareTo	yosys/libs/bigint/BigUnsigned.cc	/^BigUnsigned::CmpRes BigUnsigned::compareTo(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned::CmpRes
compareWithFromAndToPermutations	yosys/libs/subcircuit/subcircuit.cc	/^		bool compareWithFromAndToPermutations(const DiEdge &other, const std::map<std::string, std::st/;"	f	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:bool	file:
compareWithToPermutations	yosys/libs/subcircuit/subcircuit.cc	/^		bool compareWithToPermutations(const DiEdge &other, const std::map<std::string, std::string> &/;"	f	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:bool	file:
compare_cell_parameters_and_connections	yosys/passes/opt/opt_merge.cc	/^	bool compare_cell_parameters_and_connections(const RTLIL::Cell *cell1, const RTLIL::Cell *cell2/;"	f	struct:OptMergeWorker	typeref:typename:bool	file:
compare_cells	yosys/passes/sat/expose.cc	/^bool compare_cells(RTLIL::Cell *cell1, RTLIL::Cell *cell2)$/;"	f	typeref:typename:bool
compare_op	yosys/kernel/celledges.cc	/^void compare_op(AbstractCellEdgesDatabase *db, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
compare_ptr_by_name	yosys/kernel/rtlil.h	/^		template<typename T> struct compare_ptr_by_name {$/;"	s	struct:RTLIL::IdString
compare_signals	yosys/passes/opt/opt_clean.cc	/^bool compare_signals(RTLIL::SigBit &s1, RTLIL::SigBit &s2, SigPool &regs, SigPool &conns, pool<R/;"	f	typeref:typename:bool
compare_wires	yosys/passes/sat/expose.cc	/^bool compare_wires(RTLIL::Wire *wire1, RTLIL::Wire *wire2)$/;"	f	typeref:typename:bool
compat_int_mode	yosys/backends/json/json.cc	/^	bool compat_int_mode;$/;"	m	struct:JsonWriter	typeref:typename:bool	file:
compatibleConstants	yosys/libs/subcircuit/subcircuit.cc	/^	std::map<int, std::set<int>> compatibleConstants;$/;"	m	class:SubCircuit::SolverWorker	typeref:typename:std::map<int,std::set<int>>	file:
compatibleTypes	yosys/libs/subcircuit/subcircuit.cc	/^	std::map<std::string, std::set<std::string>> compatibleTypes;$/;"	m	class:SubCircuit::SolverWorker	typeref:typename:std::map<std::string,std::set<std::string>>	file:
component	yosys/libs/fst/fstapi.h	/^            const char *component;$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierScope	typeref:typename:const char *
component_length	yosys/libs/fst/fstapi.h	/^            uint32_t component_length; \/* strlen(u.scope.component) *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierScope	typeref:typename:uint32_t
compress_en	yosys/kernel/mem.cc	/^std::pair<SigSpec, std::vector<int>> MemWr::compress_en() {$/;"	f	class:MemWr	typeref:typename:std::pair<SigSpec,std::vector<int>>
compress_hier	yosys/libs/fst/fstapi.cc	/^    unsigned compress_hier : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
compute_deps	yosys/frontends/aiger/aigerparse.cc	/^	void compute_deps(RTLIL::SigBit output, const pool<RTLIL::SigBit> &inputs)$/;"	f	struct:ConstEvalAig	typeref:typename:void	file:
compute_lut_critical_outputs	yosys/passes/techmap/flowmap.cc	/^	void compute_lut_critical_outputs(dict<RTLIL::SigBit, pool<RTLIL::SigBit>> &lut_critical_output/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
compute_lut_distances	yosys/passes/techmap/flowmap.cc	/^	void compute_lut_distances(dict<RTLIL::SigBit, int> &lut_distances, bool forward,$/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
concat	yosys/backends/cxxrtl/cxxrtl.h	/^	concat_expr<T, typename std::remove_reference<U>::type> concat(U &&other) {$/;"	f	struct:cxxrtl::expr_base	typeref:typename:CXXRTL_ALWAYS_INLINE concat_expr<T,typename std::remove_reference<U>::type>
concat	yosys/backends/cxxrtl/cxxrtl.h	/^	concat_expr<const T, typename std::remove_reference<const U>::type> concat(const U &other) cons/;"	f	struct:cxxrtl::expr_base	typeref:typename:CXXRTL_ALWAYS_INLINE concat_expr<const T,typename std::remove_reference<const U>::type>
concat_expr	yosys/backends/cxxrtl/cxxrtl.h	/^	concat_expr(T &ms_expr, U &ls_expr) : ms_expr(ms_expr), ls_expr(ls_expr) {}$/;"	f	struct:cxxrtl::concat_expr
concat_expr	yosys/backends/cxxrtl/cxxrtl.h	/^struct concat_expr : public expr_base<concat_expr<T, U>> {$/;"	s	namespace:cxxrtl
concat_name	yosys/passes/techmap/flatten.cc	/^IdString concat_name(RTLIL::Cell *cell, IdString object_name)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN IdString
cond	yosys/frontends/verific/verificsva.cc	/^	vector<SigSpec> accept, cond;$/;"	m	struct:SvaUFsmNode	typeref:typename:vector<SigSpec>	file:
condNode	yosys/frontends/verific/verificsva.cc	/^	int startNode, acceptNode, condNode;$/;"	m	struct:SvaFsm	typeref:typename:int	file:
cond_eq_cache	yosys/frontends/verific/verificsva.cc	/^	dict<pair<SigSpec, SigSpec>, SigBit> cond_eq_cache;$/;"	m	struct:SvaFsm	typeref:typename:dict<pair<SigSpec,SigSpec>,SigBit>	file:
cond_net	yosys/frontends/verific/verific.h	/^	Verific::Net *cond_net = nullptr;$/;"	m	struct:VerificClocking	typeref:typename:Verific::Net *
condense_exclusives	yosys/libs/ezsat/puzzle3d.cc	/^void condense_exclusives(std::vector<int> &vars)$/;"	f	typeref:typename:void
condition	yosys/passes/opt/opt_mem_feedback.cc	/^	dict<RTLIL::SigBit, bool> condition;$/;"	m	struct:FeedbackPath	typeref:typename:dict<RTLIL::SigBit,bool>	file:
conditions_logic_cache	yosys/passes/opt/opt_mem_feedback.cc	/^	dict<pair<pool<dict<SigBit, bool>>, SigBit>, SigBit> conditions_logic_cache;$/;"	m	struct:OptMemFeedbackWorker	typeref:typename:dict<pair<pool<dict<SigBit,bool>>,SigBit>,SigBit>	file:
conditions_to_logic	yosys/passes/opt/opt_mem_feedback.cc	/^	RTLIL::SigBit conditions_to_logic(pool<dict<RTLIL::SigBit, bool>> &conditions, SigBit olden)$/;"	f	struct:OptMemFeedbackWorker	typeref:typename:RTLIL::SigBit	file:
cone_ct	yosys/passes/opt/share.cc	/^	CellTypes fwd_ct, cone_ct;$/;"	m	struct:ShareWorker	typeref:typename:CellTypes	file:
cone_size	yosys/passes/sat/freduce.cc	/^	int cone_size;$/;"	m	struct:PerformReduction	typeref:typename:int	file:
config	yosys/backends/blif/blif.cc	/^	BlifDumperConfig *config;$/;"	m	struct:BlifDumper	typeref:typename:BlifDumperConfig *	file:
config	yosys/passes/cmds/qwp.cc	/^	QwpConfig &config;$/;"	m	struct:QwpWorker	typeref:typename:QwpConfig &	file:
config	yosys/passes/opt/share.cc	/^	const ShareWorkerConfig config;$/;"	m	struct:ShareWorker	typeref:typename:const ShareWorkerConfig	file:
config	yosys/passes/opt/wreduce.cc	/^	WreduceConfig *config;$/;"	m	struct:WreduceWorker	typeref:typename:WreduceConfig *	file:
config	yosys/passes/techmap/extract_fa.cc	/^	const ExtractFaConfig &config;$/;"	m	struct:ExtractFaWorker	typeref:typename:const ExtractFaConfig &	file:
config	yosys/passes/techmap/nlutmap.cc	/^	const NlutmapConfig &config;$/;"	m	struct:NlutmapWorker	typeref:typename:const NlutmapConfig &	file:
config	yosys/passes/techmap/tribuf.cc	/^	const TribufConfig &config;$/;"	m	struct:TribufWorker	typeref:typename:const TribufConfig &	file:
config-afl-gcc	yosys/Makefile	/^config-afl-gcc: clean$/;"	t
config-clang	yosys/Makefile	/^config-clang: clean$/;"	t
config-clean	yosys/Makefile	/^config-clean: clean$/;"	t
config-cygwin	yosys/Makefile	/^config-cygwin: clean$/;"	t
config-emcc	yosys/Makefile	/^config-emcc: clean$/;"	t
config-gcc	yosys/Makefile	/^config-gcc: clean$/;"	t
config-gcc-4.8	yosys/Makefile	/^config-gcc-4.8: clean$/;"	t
config-gcc-static	yosys/Makefile	/^config-gcc-static: clean$/;"	t
config-gcov	yosys/Makefile	/^config-gcov: clean$/;"	t
config-gprof	yosys/Makefile	/^config-gprof: clean$/;"	t
config-msys2-32	yosys/Makefile	/^config-msys2-32: clean$/;"	t
config-msys2-64	yosys/Makefile	/^config-msys2-64: clean$/;"	t
config-mxe	yosys/Makefile	/^config-mxe: clean$/;"	t
config-sudo	yosys/Makefile	/^config-sudo:$/;"	t
config-wasi	yosys/Makefile	/^config-wasi: clean$/;"	t
conflict	yosys/libs/minisat/Solver.h	/^    LSet       conflict;          \/\/ If problem is unsatisfiable (possibly under assumptions),$/;"	m	class:Minisat::Solver	typeref:typename:LSet
conflict_budget	yosys/libs/minisat/Solver.h	/^    int64_t             conflict_budget;    \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver	typeref:typename:int64_t
conflicts	yosys/libs/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
conn_mode	yosys/backends/blif/blif.cc	/^	bool conn_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
connect	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		RTLIL::SigSig connect = {};$/;"	m	struct:FlowGraph::Node	typeref:typename:RTLIL::SigSig	file:
connect	yosys/kernel/rtlil.cc	/^void RTLIL::Module::connect(const RTLIL::SigSig &conn)$/;"	f	class:RTLIL::Module	typeref:typename:void
connect	yosys/kernel/rtlil.cc	/^void RTLIL::Module::connect(const RTLIL::SigSpec &lhs, const RTLIL::SigSpec &rhs)$/;"	f	class:RTLIL::Module	typeref:typename:void
connections	yosys/kernel/rtlil.cc	/^const dict<RTLIL::IdString, RTLIL::SigSpec> &RTLIL::Cell::connections() const$/;"	f	class:RTLIL::Cell	typeref:typename:const dict<RTLIL::IdString,RTLIL::SigSpec> &
connections	yosys/kernel/rtlil.cc	/^const std::vector<RTLIL::SigSig> &RTLIL::Module::connections() const$/;"	f	class:RTLIL::Module	typeref:typename:const std::vector<RTLIL::SigSig> &
connections	yosys/passes/equiv/equiv_struct.cc	/^		vector<tuple<IdString, int, SigBit>> connections;$/;"	m	struct:EquivStructWorker::merge_key_t	typeref:typename:vector<tuple<IdString,int,SigBit>>	file:
connections_	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, RTLIL::SigSpec> connections_;$/;"	m	struct:RTLIL::Cell	typeref:typename:dict<RTLIL::IdString,RTLIL::SigSpec>
connections_	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::SigSig>   connections_;$/;"	m	struct:RTLIL::Module	typeref:typename:std::vector<RTLIL::SigSig>
connections_to_add_name	yosys/passes/hierarchy/hierarchy.cc	/^	std::vector<RTLIL::IdString>            connections_to_add_name;$/;"	m	struct:IFExpander	typeref:typename:std::vector<RTLIL::IdString>	file:
connections_to_add_signal	yosys/passes/hierarchy/hierarchy.cc	/^	std::vector<RTLIL::SigSpec>             connections_to_add_signal;$/;"	m	struct:IFExpander	typeref:typename:std::vector<RTLIL::SigSpec>	file:
connections_to_remove	yosys/passes/hierarchy/hierarchy.cc	/^	std::vector<RTLIL::IdString>            connections_to_remove;$/;"	m	struct:IFExpander	typeref:typename:std::vector<RTLIL::IdString>	file:
consider_cell	yosys/passes/sat/expose.cc	/^bool consider_cell(RTLIL::Design *design, std::set<RTLIL::IdString> &dff_cells, RTLIL::Cell *cel/;"	f	typeref:typename:bool
consider_wire	yosys/passes/sat/expose.cc	/^bool consider_wire(RTLIL::Wire *wire, std::map<RTLIL::IdString, dff_map_info_t> &dff_dq_map)$/;"	f	typeref:typename:bool
consolidate_rd_by_addr	yosys/passes/memory/memory_share.cc	/^	bool consolidate_rd_by_addr(Mem &mem)$/;"	f	struct:MemoryShareWorker	typeref:typename:bool	file:
consolidate_wr_by_addr	yosys/passes/memory/memory_share.cc	/^	bool consolidate_wr_by_addr(Mem &mem)$/;"	f	struct:MemoryShareWorker	typeref:typename:bool	file:
consolidate_wr_using_sat	yosys/passes/memory/memory_share.cc	/^	void consolidate_wr_using_sat(Mem &mem)$/;"	f	struct:MemoryShareWorker	typeref:typename:void	file:
const2ast	yosys/frontends/verilog/const2ast.cc	/^AstNode *VERILOG_FRONTEND::const2ast(std::string code, char case_type, bool warn_z)$/;"	f	class:VERILOG_FRONTEND	typeref:typename:AstNode *
const2big	yosys/kernel/calc.cc	/^static BigInteger const2big(const RTLIL::Const &val, bool as_signed, int &undef_bit_pos)$/;"	f	typeref:typename:BigInteger	file:
constValue	yosys/libs/subcircuit/subcircuit.h	/^			int constValue;$/;"	m	struct:SubCircuit::Graph::Edge	typeref:typename:int
const_activated	yosys/passes/opt/opt_muxtree.cc	/^		bool const_activated;$/;"	m	struct:OptMuxtreeWorker::portinfo_t	typeref:typename:bool	file:
const_add	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_add(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_and	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_and(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_bmux	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_bmux(const RTLIL::Const &arg1, const RTLIL::Const &arg2)$/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_deactivated	yosys/passes/opt/opt_muxtree.cc	/^		bool const_deactivated;$/;"	m	struct:OptMuxtreeWorker::portinfo_t	typeref:typename:bool	file:
const_demux	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_demux(const RTLIL::Const &arg1, const RTLIL::Const &arg2)$/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_div	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_div(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_divfloor	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_divfloor(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool sign/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_eq	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_eq(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, b/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_eqx	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_eqx(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_ge	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_ge(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, b/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_gt	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_gt(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, b/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_iterator	yosys/kernel/hashlib.h	/^		const_iterator() { }$/;"	f	class:hashlib::dict::const_iterator
const_iterator	yosys/kernel/hashlib.h	/^		const_iterator() { }$/;"	f	class:hashlib::idict::const_iterator
const_iterator	yosys/kernel/hashlib.h	/^		const_iterator() { }$/;"	f	class:hashlib::pool::const_iterator
const_iterator	yosys/kernel/hashlib.h	/^		const_iterator(const dict *ptr, int index) : ptr(ptr), index(index) { }$/;"	f	class:hashlib::dict::const_iterator
const_iterator	yosys/kernel/hashlib.h	/^		const_iterator(const idict &container, int index) : container(container), index(index) { }$/;"	f	class:hashlib::idict::const_iterator
const_iterator	yosys/kernel/hashlib.h	/^		const_iterator(const pool *ptr, int index) : ptr(ptr), index(index) { }$/;"	f	class:hashlib::pool::const_iterator
const_iterator	yosys/kernel/hashlib.h	/^	class const_iterator : public std::iterator<std::forward_iterator_tag, K>$/;"	c	class:hashlib::idict
const_iterator	yosys/kernel/hashlib.h	/^	class const_iterator : public std::iterator<std::forward_iterator_tag, K>$/;"	c	class:hashlib::pool
const_iterator	yosys/kernel/hashlib.h	/^	class const_iterator : public std::iterator<std::forward_iterator_tag, std::pair<K, T>>$/;"	c	class:hashlib::dict
const_iterator	yosys/kernel/hashlib.h	/^	typedef typename idict<K, 0, OPS>::const_iterator const_iterator;$/;"	t	class:hashlib::mfp	typeref:typename:idict<K,0,OPS>::const_iterator
const_le	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_le(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, b/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_logic_and	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_logic_and(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool sig/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_logic_not	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_logic_not(const RTLIL::Const &arg1, const RTLIL::Const&, bool signed1,/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_logic_or	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_logic_or(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool sign/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_lt	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_lt(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, b/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_mod	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_mod(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_modfloor	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_modfloor(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool sign/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_mul	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_mul(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_ne	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_ne(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, b/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_neg	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_neg(const RTLIL::Const &arg1, const RTLIL::Const&, bool signed1, bool,/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_nex	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_nex(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_not	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_not(const RTLIL::Const &arg1, const RTLIL::Const&, bool signed1, bool,/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_or	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_or(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, b/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_pos	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_pos(const RTLIL::Const &arg1, const RTLIL::Const&, bool signed1, bool,/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_pow	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_pow(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_reduce_and	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_reduce_and(const RTLIL::Const &arg1, const RTLIL::Const&, bool, bool, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_reduce_bool	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_reduce_bool(const RTLIL::Const &arg1, const RTLIL::Const&, bool, bool,/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_reduce_or	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_reduce_or(const RTLIL::Const &arg1, const RTLIL::Const&, bool, bool, i/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_reduce_xnor	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_reduce_xnor(const RTLIL::Const &arg1, const RTLIL::Const&, bool, bool,/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_reduce_xor	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_reduce_xor(const RTLIL::Const &arg1, const RTLIL::Const&, bool, bool, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_shift	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_shift(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_shift_worker	yosys/kernel/calc.cc	/^static RTLIL::Const const_shift_worker(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool /;"	f	typeref:typename:RTLIL::Const	file:
const_shiftx	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_shiftx(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool, bool /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_shl	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_shl(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_shr	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_shr(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_sshl	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_sshl(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1,/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_sshr	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_sshr(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1,/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_sub	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_sub(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_xnor	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_xnor(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1,/;"	f	class:RTLIL	typeref:typename:RTLIL::Const
const_xor	yosys/kernel/calc.cc	/^RTLIL::Const RTLIL::const_xor(const RTLIL::Const &arg1, const RTLIL::Const &arg2, bool signed1, /;"	f	class:RTLIL	typeref:typename:RTLIL::Const
constmap_tpl_name	yosys/passes/techmap/techmap.cc	/^	std::string constmap_tpl_name(SigMap &sigmap, RTLIL::Module *tpl, RTLIL::Cell *cell, bool verbo/;"	f	struct:TechmapWorker	typeref:typename:std::string	file:
constpad	yosys/kernel/rtlil.cc	/^dict<std::string, std::string> RTLIL::constpad;$/;"	m	class:RTLIL	typeref:typename:dict<std::string,std::string>
consts	yosys/backends/btor/btor.cc	/^	dict<Const, int> consts;$/;"	m	struct:BtorWorker	typeref:typename:dict<Const,int>	file:
consumeCnf	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::consumeCnf()$/;"	f	class:ezSAT	typeref:typename:void
consumeCnf	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::consumeCnf(std::vector<std::vector<int>> &cnf)$/;"	f	class:ezSAT	typeref:typename:void
consume_comment	yosys/libs/json11/json11.cpp	/^    bool consume_comment() {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:bool	file:
consume_garbage	yosys/libs/json11/json11.cpp	/^    void consume_garbage() {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:void	file:
consume_whitespace	yosys/libs/json11/json11.cpp	/^    void consume_whitespace() {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:void	file:
container	yosys/kernel/hashlib.h	/^		const idict &container;$/;"	m	class:hashlib::idict::const_iterator	typeref:typename:const idict &
contains	yosys/frontends/ast/ast.cc	/^bool AstNode::contains(const AstNode *other) const$/;"	f	class:AstNode	typeref:typename:bool
contains	yosys/kernel/rtlil.h	/^		bool contains(const char* str) const {$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
contains_geom_section	yosys/libs/fst/fstapi.cc	/^    unsigned contains_geom_section : 1;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
contains_hier_section	yosys/libs/fst/fstapi.cc	/^    unsigned contains_hier_section : 1;        \/* valid for hier_pos *\/$/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
contains_hier_section_lz4	yosys/libs/fst/fstapi.cc	/^    unsigned contains_hier_section_lz4 : 1;    \/* valid for hier_pos *\/$/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
contains_hier_section_lz4duo	yosys/libs/fst/fstapi.cc	/^    unsigned contains_hier_section_lz4duo : 1; \/* valid for hier_pos (contains_hier_section_lz4/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
contains_unbased_unsized	yosys/frontends/ast/simplify.cc	/^static bool contains_unbased_unsized(const AstNode *node)$/;"	f	typeref:typename:bool	file:
content	yosys/kernel/yosys.h	/^	std::shared_ptr<string> content;$/;"	m	struct:shared_str	typeref:typename:std::shared_ptr<string>
control_handler	yosys/misc/launcher.c	/^BOOL control_handler(DWORD control_type) {$/;"	f	typeref:typename:BOOL
convertBigUnsignedToPrimitiveAccess	yosys/libs/bigint/BigInteger.cc	/^inline X convertBigUnsignedToPrimitiveAccess(const BigUnsigned &a) {$/;"	f	typeref:typename:X
convertToPrimitive	yosys/libs/bigint/BigUnsigned.hh	/^X BigUnsigned::convertToPrimitive() const {$/;"	f	class:BigUnsigned	typeref:typename:X
convertToSignedPrimitive	yosys/libs/bigint/BigUnsigned.hh	/^X BigUnsigned::convertToSignedPrimitive() const {$/;"	f	class:BigUnsigned	typeref:typename:X
convertToUnsignedPrimitive	yosys/libs/bigint/BigInteger.cc	/^X BigInteger::convertToUnsignedPrimitive() const {$/;"	f	class:BigInteger	typeref:typename:X
convert_ce_over_srst	yosys/kernel/ff.cc	/^void FfData::convert_ce_over_srst(bool val) {$/;"	f	class:FfData	typeref:typename:void
copy	yosys/libs/minisat/Alg.h	/^static inline void copy(const T& from, T& to)$/;"	f	namespace:Minisat	typeref:typename:void
copy	yosys/libs/minisat/Alg.h	/^static inline void copy(const vec<T>& from, vec<T>& to, bool append = false)$/;"	f	namespace:Minisat	typeref:typename:void
copyTo	yosys/libs/minisat/IntMap.h	/^        void     copyTo (IntMap& to) const     { map.copyTo(to.map); to.index = index; }$/;"	f	class:Minisat::IntMap	typeref:typename:void
copyTo	yosys/libs/minisat/Vec.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (Size i = 0; i < sz; i+/;"	f	class:Minisat::vec	typeref:typename:void
copy_from_cell	yosys/passes/fsm/fsmdata.h	/^	void copy_from_cell(RTLIL::Cell *cell)$/;"	f	struct:FsmData	typeref:typename:void
copy_mode	yosys/passes/hierarchy/submod.cc	/^	bool copy_mode;$/;"	m	struct:SubmodWorker	typeref:typename:bool	file:
copy_to_cell	yosys/passes/fsm/fsmdata.h	/^	void copy_to_cell(RTLIL::Cell *cell)$/;"	f	struct:FsmData	typeref:typename:void
copy_to_equiv	yosys/passes/equiv/equiv_make.cc	/^	void copy_to_equiv()$/;"	f	struct:EquivMakeWorker	typeref:typename:void	file:
copy_to_miter	yosys/passes/equiv/equiv_miter.cc	/^	void copy_to_miter()$/;"	f	struct:EquivMiterWorker	typeref:typename:void	file:
cost	yosys/libs/minisat/SimpSolver.h	/^        uint64_t cost  (Var x)        const { return (uint64_t)n_occ[mkLit(x)] * (uint64_t)n_occ/;"	f	struct:Minisat::SimpSolver::ElimLt	typeref:typename:uint64_t
cost	yosys/passes/techmap/muxcover.cc	/^		int cost;$/;"	m	struct:MuxcoverWorker::newmux_t	typeref:typename:int	file:
cost_dmux	yosys/passes/techmap/muxcover.cc	/^	int cost_dmux;$/;"	m	struct:MuxcoverWorker	typeref:typename:int	file:
cost_model_wire_name	yosys/passes/cmds/glift.cc	/^	const RTLIL::IdString cost_model_wire_name = ID(__glift_weight);$/;"	m	struct:GliftWorker	typeref:typename:const RTLIL::IdString	file:
cost_mux16	yosys/passes/techmap/muxcover.cc	/^	int cost_mux16;$/;"	m	struct:MuxcoverWorker	typeref:typename:int	file:
cost_mux2	yosys/passes/techmap/muxcover.cc	/^	int cost_mux2;$/;"	m	struct:MuxcoverWorker	typeref:typename:int	file:
cost_mux4	yosys/passes/techmap/muxcover.cc	/^	int cost_mux4;$/;"	m	struct:MuxcoverWorker	typeref:typename:int	file:
cost_mux8	yosys/passes/techmap/muxcover.cc	/^	int cost_mux8;$/;"	m	struct:MuxcoverWorker	typeref:typename:int	file:
count	yosys/backends/cxxrtl/cxxrtl.h	/^	size_t count(const std::string &name) const {$/;"	f	struct:cxxrtl::debug_items	typeref:typename:size_t
count	yosys/kernel/hashlib.h	/^	int count(const K &key) const$/;"	f	class:hashlib::dict	typeref:typename:int
count	yosys/kernel/hashlib.h	/^	int count(const K &key) const$/;"	f	class:hashlib::idict	typeref:typename:int
count	yosys/kernel/hashlib.h	/^	int count(const K &key) const$/;"	f	class:hashlib::pool	typeref:typename:int
count	yosys/kernel/hashlib.h	/^	int count(const K &key, const_iterator it) const$/;"	f	class:hashlib::dict	typeref:typename:int
count	yosys/kernel/hashlib.h	/^	int count(const K &key, const_iterator it) const$/;"	f	class:hashlib::pool	typeref:typename:int
count	yosys/kernel/timinginfo.h	/^	int count(RTLIL::IdString module_name) const { return data.count(module_name); }$/;"	f	struct:TimingInfo	typeref:typename:int
count_bit_users	yosys/passes/techmap/alumacc.cc	/^	void count_bit_users()$/;"	f	struct:AlumaccWorker	typeref:typename:void	file:
count_func2	yosys/passes/techmap/extract_fa.cc	/^	int count_func2;$/;"	m	struct:ExtractFaWorker	typeref:typename:int	file:
count_func3	yosys/passes/techmap/extract_fa.cc	/^	int count_func3;$/;"	m	struct:ExtractFaWorker	typeref:typename:int	file:
count_id	yosys/kernel/rtlil.cc	/^size_t RTLIL::Module::count_id(RTLIL::IdString id)$/;"	f	class:RTLIL::Module	typeref:typename:size_t
count_is_up	yosys/passes/techmap/extract_counter.cc	/^	bool count_is_up;				\/\/count up (else down)$/;"	m	struct:CounterExtraction	typeref:typename:bool	file:
count_mux	yosys/passes/techmap/extract_counter.cc	/^	RTLIL::Cell* count_mux;			\/\/counter mux$/;"	m	struct:CounterExtraction	typeref:typename:RTLIL::Cell *	file:
count_nontrivial_wire_attrs	yosys/passes/opt/opt_clean.cc	/^int count_nontrivial_wire_attrs(RTLIL::Wire *w)$/;"	f	typeref:typename:int
count_nontrivial_wire_attrs	yosys/passes/opt/wreduce.cc	/^	static int count_nontrivial_wire_attrs(RTLIL::Wire *w)$/;"	f	struct:WreduceWorker	typeref:typename:int	file:
count_reg	yosys/passes/techmap/extract_counter.cc	/^	RTLIL::Cell* count_reg;			\/\/counter register$/;"	m	struct:CounterExtraction	typeref:typename:RTLIL::Cell *	file:
count_rm_cells	yosys/passes/opt/opt_clean.cc	/^int count_rm_cells, count_rm_wires;$/;"	v	typeref:typename:int
count_rm_wires	yosys/passes/opt/opt_clean.cc	/^int count_rm_cells, count_rm_wires;$/;"	v	typeref:typename:int
count_value	yosys/passes/techmap/extract_counter.cc	/^	int count_value;				\/\/value we count from$/;"	m	struct:CounterExtraction	typeref:typename:int	file:
counter	yosys/backends/edif/edif.cc	/^	int counter;$/;"	m	struct:EdifNames	typeref:typename:int	file:
counter	yosys/kernel/log.h	/^	int line, counter;$/;"	m	struct:CoverData	typeref:typename:int
counter	yosys/passes/sat/eval.cc	/^	int counter, errors;$/;"	m	struct:BruteForceEquivChecker	typeref:typename:int	file:
counter_00.pdf	yosys/manual/PRESENTATION_Intro/Makefile	/^counter_00.pdf: counter.v counter.ys mycells.lib$/;"	t
counter_01.pdf	yosys/manual/PRESENTATION_Intro/Makefile	/^counter_01.pdf: counter_00.pdf$/;"	t
counter_02.pdf	yosys/manual/PRESENTATION_Intro/Makefile	/^counter_02.pdf: counter_00.pdf$/;"	t
counter_03.pdf	yosys/manual/PRESENTATION_Intro/Makefile	/^counter_03.pdf: counter_00.pdf$/;"	t
counter_tryextract	yosys/passes/techmap/extract_counter.cc	/^int counter_tryextract($/;"	f	typeref:typename:int
counter_worker	yosys/passes/techmap/extract_counter.cc	/^void counter_worker($/;"	f	typeref:typename:void
cover	yosys/kernel/log.h	/^#  define cover(/;"	d
cover	yosys/kernel/log.h	/^#define cover(/;"	d
cover_extra	yosys/kernel/log.cc	/^void cover_extra(std::string parent, std::string id, bool increment) {$/;"	f	typeref:typename:void
cover_list	yosys/kernel/log.h	/^#  define cover_list(/;"	d
cover_list	yosys/kernel/log.h	/^#define cover_list(/;"	d
cover_list_worker	yosys/kernel/log.h	/^static inline std::string cover_list_worker(std::string, std::string last) {$/;"	f	typeref:typename:std::string
cover_list_worker	yosys/kernel/log.h	/^std::string cover_list_worker(std::string prefix, std::string first, T... rest) {$/;"	f	typeref:typename:std::string
cover_mode	yosys/backends/btor/btor.cc	/^	bool cover_mode;$/;"	m	struct:BtorWorker	typeref:typename:bool	file:
coverage	yosys/Makefile	/^coverage:$/;"	t
coverdb_t	yosys/passes/sat/mutate.cc	/^struct coverdb_t$/;"	s	file:
cpuTime	yosys/libs/minisat/System.h	/^static inline double Minisat::cpuTime(void) { return (double)clock() \/ CLOCKS_PER_SEC; }$/;"	f	class:Minisat	typeref:typename:double
cpuTime	yosys/libs/minisat/System.h	/^static inline double Minisat::cpuTime(void) {$/;"	f	class:Minisat	typeref:typename:double
create	yosys/kernel/register.cc	/^	ezSAT *create() override {$/;"	f	struct:MinisatSatSolver	typeref:typename:ezSAT *	file:
createConnection	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Graph::createConnection(std::string fromNodeId, std::string fromPortId, int fro/;"	f	class:SubCircuit::Graph	typeref:typename:void
createConnection	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Graph::createConnection(std::string fromNodeId, std::string fromPortId, std::st/;"	f	class:SubCircuit::Graph	typeref:typename:void
createConstant	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Graph::createConstant(std::string toNodeId, std::string toPortId, int constValu/;"	f	class:SubCircuit::Graph	typeref:typename:void
createConstant	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Graph::createConstant(std::string toNodeId, std::string toPortId, int toBit, in/;"	f	class:SubCircuit::Graph	typeref:typename:void
createEdge	yosys/frontends/verific/verificsva.cc	/^	void createEdge(int from_node, int to_node, SigBit ctrl = State::S1)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
createLink	yosys/frontends/verific/verificsva.cc	/^	void createLink(int from_node, int to_node, SigBit ctrl = State::S1)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
createNode	yosys/frontends/verific/verificsva.cc	/^	int createNode(int link_node = -1)$/;"	f	struct:SvaFsm	typeref:typename:int	file:
createNode	yosys/libs/subcircuit/subcircuit.cc	/^void  SubCircuit::Graph::createNode(std::string nodeId, std::string typeId, void *userData, bool/;"	f	class:SubCircuit::Graph	typeref:typename:void
createPort	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Graph::createPort(std::string nodeId, std::string portId, int width, int minWid/;"	f	class:SubCircuit::Graph	typeref:typename:void
createStartNode	yosys/frontends/verific/verificsva.cc	/^	int createStartNode()$/;"	f	struct:SvaFsm	typeref:typename:int	file:
createWireIfNotExists	yosys/frontends/aiger/aigerparse.cc	/^RTLIL::Wire* AigerReader::createWireIfNotExists(RTLIL::Module *module, unsigned literal)$/;"	f	class:AigerReader	typeref:typename:RTLIL::Wire *
create_and_cell	yosys/frontends/liberty/liberty.cc	/^static RTLIL::SigSpec create_and_cell(RTLIL::Module *module, RTLIL::SigSpec A, RTLIL::SigSpec B)$/;"	f	typeref:typename:RTLIL::SigSpec	file:
create_and_wait_for_subprocess	yosys/misc/launcher.c	/^int create_and_wait_for_subprocess(char* command) {$/;"	f	typeref:typename:int
create_chain	yosys/passes/opt/muxpack.cc	/^	vector<Cell*> create_chain(Cell *start_cell)$/;"	f	struct:MuxpackWorker	typeref:typename:vector<Cell * >	file:
create_chain	yosys/passes/techmap/shregmap.cc	/^	vector<Cell*> create_chain(Cell *start_cell)$/;"	f	struct:ShregmapWorker	typeref:typename:vector<Cell * >	file:
create_current_set	yosys/passes/fsm/fsm_expand.cc	/^	void create_current_set()$/;"	f	struct:FsmExpand	typeref:typename:void	file:
create_dff_dq_map	yosys/passes/sat/expose.cc	/^void create_dff_dq_map(std::map<RTLIL::IdString, dff_map_info_t> &map, RTLIL::Module *module)$/;"	f	typeref:typename:void
create_dnode	yosys/frontends/verific/verificsva.cc	/^	void create_dnode(const vector<int> &state, bool firstmatch, bool condaccept)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
create_ff	yosys/frontends/liberty/liberty.cc	/^static void create_ff(RTLIL::Module *module, LibertyAst *node)$/;"	f	typeref:typename:void	file:
create_glift_logic	yosys/passes/cmds/glift.cc	/^	void create_glift_logic() {$/;"	f	struct:GliftWorker	typeref:typename:void	file:
create_gold_module	yosys/passes/tests/test_cell.cc	/^static void create_gold_module(RTLIL::Design *design, RTLIL::IdString cell_type, std::string cel/;"	f	typeref:typename:void	file:
create_ice40_dsp	yosys/passes/pmgen/ice40_dsp.cc	/^void create_ice40_dsp(ice40_dsp_pm &pm)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
create_ice40_wrapcarry	yosys/passes/pmgen/ice40_wrapcarry.cc	/^void create_ice40_wrapcarry(ice40_wrapcarry_pm &pm)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
create_inv_cell	yosys/frontends/liberty/liberty.cc	/^static RTLIL::SigSpec create_inv_cell(RTLIL::Module *module, RTLIL::SigSpec A)$/;"	f	typeref:typename:RTLIL::SigSpec	file:
create_latch	yosys/frontends/liberty/liberty.cc	/^static bool create_latch(RTLIL::Module *module, LibertyAst *node, bool flag_ignore_miss_data_lat/;"	f	typeref:typename:bool	file:
create_miter_assert	yosys/passes/sat/miter.cc	/^void create_miter_assert(struct Pass *that, std::vector<std::string> args, RTLIL::Design *design/;"	f	typeref:typename:void
create_miter_equiv	yosys/passes/sat/miter.cc	/^void create_miter_equiv(struct Pass *that, std::vector<std::string> args, RTLIL::Design *design)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
create_module_struct	yosys/backends/simplec/simplec.cc	/^	void create_module_struct(Module *mod)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
create_or_cell	yosys/frontends/liberty/liberty.cc	/^static RTLIL::SigSpec create_or_cell(RTLIL::Module *module, RTLIL::SigSpec A, RTLIL::SigSpec B)$/;"	f	typeref:typename:RTLIL::SigSpec	file:
create_prompt	yosys/kernel/yosys.cc	/^const char *create_prompt(RTLIL::Design *design, int recursion_counter)$/;"	f	typeref:typename:const char *
create_timestep	yosys/passes/equiv/equiv_induct.cc	/^	void create_timestep(int step)$/;"	f	struct:EquivInductWorker	typeref:typename:void	file:
create_xor_cell	yosys/frontends/liberty/liberty.cc	/^static RTLIL::SigSpec create_xor_cell(RTLIL::Module *module, RTLIL::SigSpec A, RTLIL::SigSpec B)$/;"	f	typeref:typename:RTLIL::SigSpec	file:
cref	yosys/libs/minisat/Solver.h	/^        CRef cref;$/;"	m	struct:Minisat::Solver::Watcher	typeref:typename:CRef
crefs	yosys/libs/minisat/SolverTypes.h	/^    const CRef*            crefs;$/;"	m	class:Minisat::ClauseIterator	typeref:typename:const CRef *
cstr_bits_seen	yosys/backends/blif/blif.cc	/^	pool<SigBit> cstr_bits_seen;$/;"	m	struct:BlifDumper	typeref:typename:pool<SigBit>	file:
ct	yosys/backends/blif/blif.cc	/^	CellTypes ct;$/;"	m	struct:BlifDumper	typeref:typename:CellTypes	file:
ct	yosys/backends/smt2/smt2.cc	/^	CellTypes ct;$/;"	m	struct:Smt2Worker	typeref:typename:CellTypes	file:
ct	yosys/backends/smv/smv.cc	/^	CellTypes ct;$/;"	m	struct:SmvWorker	typeref:typename:CellTypes	file:
ct	yosys/kernel/modtools.h	/^	CellTypes ct;$/;"	m	struct:ModWalker	typeref:typename:CellTypes
ct	yosys/passes/cmds/scc.cc	/^	CellTypes ct, specifyCells;$/;"	m	struct:SccWorker	typeref:typename:CellTypes	file:
ct	yosys/passes/cmds/show.cc	/^	CellTypes ct;$/;"	m	struct:ShowWorker	typeref:typename:CellTypes	file:
ct	yosys/passes/cmds/splice.cc	/^	CellTypes ct;$/;"	m	struct:SpliceWorker	typeref:typename:CellTypes	file:
ct	yosys/passes/equiv/equiv_make.cc	/^	CellTypes ct;$/;"	m	struct:EquivMakeWorker	typeref:typename:CellTypes	file:
ct	yosys/passes/equiv/equiv_miter.cc	/^	CellTypes ct;$/;"	m	struct:EquivMiterWorker	typeref:typename:CellTypes	file:
ct	yosys/passes/fsm/fsm_expand.cc	/^	CellTypes ct;$/;"	m	struct:FsmExpand	typeref:typename:CellTypes	file:
ct	yosys/passes/hierarchy/submod.cc	/^	CellTypes ct;$/;"	m	struct:SubmodWorker	typeref:typename:CellTypes	file:
ct	yosys/passes/opt/opt_merge.cc	/^	CellTypes ct;$/;"	m	struct:OptMergeWorker	typeref:typename:CellTypes	file:
ct	yosys/passes/sat/sat.cc	/^	CellTypes ct;$/;"	m	struct:SatHelper	typeref:typename:CellTypes	file:
ct_all	yosys/passes/opt/opt_clean.cc	/^CellTypes ct_reg, ct_all;$/;"	v	typeref:typename:CellTypes
ct_reg	yosys/passes/opt/opt_clean.cc	/^CellTypes ct_reg, ct_all;$/;"	v	typeref:typename:CellTypes
ctlz	yosys/backends/cxxrtl/cxxrtl.h	/^	size_t ctlz() const {$/;"	f	struct:cxxrtl::value	typeref:typename:size_t
ctpop	yosys/backends/cxxrtl/cxxrtl.h	/^	size_t ctpop() const {$/;"	f	struct:cxxrtl::value	typeref:typename:size_t
ctrl	yosys/frontends/verific/verificsva.cc	/^	SigSpec ctrl;$/;"	m	struct:SvaDFsmNode	typeref:typename:SigSpec	file:
ctrl_in	yosys/passes/fsm/fsmdata.h	/^	struct transition_t { int state_in, state_out; RTLIL::Const ctrl_in, ctrl_out; };$/;"	m	struct:FsmData::transition_t	typeref:typename:RTLIL::Const
ctrl_name	yosys/passes/sat/mutate.cc	/^	IdString ctrl_name;$/;"	m	struct:mutate_opts_t	typeref:typename:IdString	file:
ctrl_out	yosys/passes/fsm/fsmdata.h	/^	struct transition_t { int state_in, state_out; RTLIL::Const ctrl_in, ctrl_out; };$/;"	m	struct:FsmData::transition_t	typeref:typename:RTLIL::Const
ctrl_sig	yosys/passes/opt/opt_muxtree.cc	/^		int ctrl_sig;$/;"	m	struct:OptMuxtreeWorker::portinfo_t	typeref:typename:int	file:
ctrl_t	yosys/passes/opt/opt_dff.cc	/^	typedef std::pair<RTLIL::SigBit, bool> ctrl_t;$/;"	t	struct:OptDffWorker	typeref:typename:std::pair<RTLIL::SigBit,bool>	file:
ctrl_value	yosys/passes/sat/mutate.cc	/^	int ctrl_width = -1, ctrl_value = -1;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
ctrl_width	yosys/passes/sat/mutate.cc	/^	int ctrl_width = -1, ctrl_value = -1;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
ctrlbit	yosys/passes/sat/mutate.cc	/^	int ctrlbit = -1;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
ctrlbit	yosys/passes/sat/mutate.cc	/^	int ctrlbit = -1;$/;"	m	struct:mutate_t	typeref:typename:int	file:
ctrls_t	yosys/passes/opt/opt_dff.cc	/^	typedef std::set<ctrl_t> ctrls_t;$/;"	t	struct:OptDffWorker	typeref:typename:std::set<ctrl_t>	file:
ctx	yosys/kernel/fstdata.h	/^	struct fstReaderContext *ctx;$/;"	m	class:FstData	typeref:struct:fstReaderContext *
curr	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> curr;$/;"	m	struct:cxxrtl::wire	typeref:typename:value<Bits>
curr	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	uint32_t *curr;$/;"	m	struct:cxxrtl_object	typeref:typename:uint32_t *
curr	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^		chunk_t *curr;$/;"	m	struct:cxxrtl::vcd_writer::variable	typeref:typename:chunk_t *
curr_flat_hier_nam	yosys/libs/fst/fstapi.cc	/^    char *curr_flat_hier_nam;$/;"	m	struct:fstReaderContext	typeref:typename:char *	file:
curr_hier	yosys/libs/fst/fstapi.cc	/^    struct fstCurrHier *curr_hier;$/;"	m	struct:fstReaderContext	typeref:struct:fstCurrHier *	file:
currentColor	yosys/passes/cmds/show.cc	/^	uint32_t currentColor;$/;"	m	struct:ShowWorker	typeref:typename:uint32_t	file:
currentOffset	yosys/libs/fst/lz4.cc	/^    U32 currentOffset;$/;"	m	struct:__anon9390dffe0208	typeref:typename:U32	file:
current_always	yosys/frontends/ast/ast.cc	/^	AstNode *current_always, *current_top_block, *current_block, *current_block_child;$/;"	v	namespace:AST_INTERNAL	typeref:typename:AstNode *
current_always_clocked	yosys/frontends/ast/ast.cc	/^	bool current_always_clocked;$/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
current_ast	yosys/frontends/ast/ast.cc	/^	AstNode *current_ast, *current_ast_mod;$/;"	v	namespace:AST_INTERNAL	typeref:typename:AstNode *
current_ast_mod	yosys/frontends/ast/ast.cc	/^	AstNode *current_ast, *current_ast_mod;$/;"	v	namespace:AST_INTERNAL	typeref:typename:AstNode *
current_block	yosys/frontends/ast/ast.cc	/^	AstNode *current_always, *current_top_block, *current_block, *current_block_child;$/;"	v	namespace:AST_INTERNAL	typeref:typename:AstNode *
current_block_child	yosys/frontends/ast/ast.cc	/^	AstNode *current_always, *current_top_block, *current_block, *current_block_child;$/;"	v	namespace:AST_INTERNAL	typeref:typename:AstNode *
current_case	yosys/frontends/ast/genrtlil.cc	/^	RTLIL::CaseRule *current_case;$/;"	m	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:RTLIL::CaseRule *	file:
current_count	yosys/kernel/log.h	/^	int current_count;$/;"	m	struct:LogExpectedItem	typeref:typename:int
current_filename	yosys/frontends/ast/ast.cc	/^	std::string current_filename;$/;"	v	namespace:AST	typeref:typename:std::string
current_handle	yosys/libs/fst/fstapi.cc	/^    fstHandle current_handle;$/;"	m	struct:fstReaderContext	typeref:typename:fstHandle	file:
current_memwr_count	yosys/frontends/ast/ast.cc	/^	dict<std::string, int> current_memwr_count;$/;"	v	namespace:AST_INTERNAL	typeref:typename:dict<std::string,int>
current_memwr_visible	yosys/frontends/ast/ast.cc	/^	dict<std::string, pool<int>> current_memwr_visible;$/;"	v	namespace:AST_INTERNAL	typeref:typename:dict<std::string,pool<int>>
current_module	yosys/frontends/ast/ast.cc	/^	Module *current_module;$/;"	v	namespace:AST_INTERNAL	typeref:typename:Module *
current_pass	yosys/kernel/register.cc	/^Pass *current_pass;$/;"	v	typeref:typename:Pass *
current_scope	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	std::vector<std::string> current_scope;$/;"	m	class:cxxrtl::vcd_writer	typeref:typename:std::vector<std::string>
current_scope	yosys/frontends/ast/ast.cc	/^	std::map<std::string, AstNode*> current_scope;$/;"	v	namespace:AST_INTERNAL	typeref:typename:std::map<std::string,AstNode * >
current_script_file	yosys/kernel/register.cc	/^FILE *Frontend::current_script_file = NULL;$/;"	m	class:Frontend	typeref:typename:FILE *
current_script_file	yosys/kernel/register.h	/^	static FILE *current_script_file;$/;"	m	struct:Frontend	typeref:typename:FILE *
current_set	yosys/passes/fsm/fsm_expand.cc	/^	std::set<RTLIL::Cell*, RTLIL::sort_by_name_id<RTLIL::Cell>> current_set;$/;"	m	struct:FsmExpand	typeref:typename:std::set<RTLIL::Cell *,RTLIL::sort_by_name_id<RTLIL::Cell>>	file:
current_snippet	yosys/passes/proc/proc_mux.cc	/^	int current_snippet;$/;"	m	struct:SnippetSwCache	typeref:typename:int	file:
current_state	yosys/kernel/utils.h	/^	dict<Key, T, OPS> current_state;$/;"	m	struct:stackmap	typeref:typename:dict<Key,T,OPS>
current_top_block	yosys/frontends/ast/ast.cc	/^	AstNode *current_always, *current_top_block, *current_block, *current_block_child;$/;"	v	namespace:AST_INTERNAL	typeref:typename:AstNode *
currmodule	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	string top_opt, blif_file, family, currmodule, verilog_file;$/;"	m	struct:SynthQuickLogicPass	typeref:typename:string	file:
curtime	yosys/libs/fst/fstapi.cc	/^    uint64_t curtime;$/;"	m	struct:fstWriterContext	typeref:typename:uint64_t	file:
curval_handle	yosys/libs/fst/fstapi.cc	/^    FILE *curval_handle;$/;"	m	struct:fstWriterContext	typeref:typename:FILE *	file:
curval_handle_nam	yosys/libs/fst/fstapi.cc	/^    char *curval_handle_nam;$/;"	m	struct:fstWriterContext	typeref:typename:char *	file:
curval_mem	yosys/libs/fst/fstapi.cc	/^    unsigned char *curval_mem;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned char *	file:
cut_lut_at_gate	yosys/passes/techmap/flowmap.cc	/^	pair<pool<RTLIL::SigBit>, pool<RTLIL::SigBit>> cut_lut_at_gate(RTLIL::SigBit lut, RTLIL::SigBit/;"	f	struct:FlowmapWorker	typeref:typename:pair<pool<RTLIL::SigBit>,pool<RTLIL::SigBit>>	file:
cxxrtl	yosys/backends/cxxrtl/cxxrtl.h	/^namespace cxxrtl {$/;"	n
cxxrtl	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^namespace cxxrtl {$/;"	n
cxxrtl_commit	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^int cxxrtl_commit(cxxrtl_handle handle) {$/;"	f	typeref:typename:int
cxxrtl_create	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^cxxrtl_handle cxxrtl_create(cxxrtl_toplevel design) {$/;"	f	typeref:typename:cxxrtl_handle
cxxrtl_create_at	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^cxxrtl_handle cxxrtl_create_at(cxxrtl_toplevel design, const char *root) {$/;"	f	typeref:typename:cxxrtl_handle
cxxrtl_debug_items_from_handle	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^const cxxrtl::debug_items &cxxrtl_debug_items_from_handle(cxxrtl_handle handle) {$/;"	f	typeref:typename:const cxxrtl::debug_items &
cxxrtl_destroy	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^void cxxrtl_destroy(cxxrtl_handle handle) {$/;"	f	typeref:typename:void
cxxrtl_enum	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^void cxxrtl_enum(cxxrtl_handle handle, void *data,$/;"	f	typeref:typename:void
cxxrtl_eval	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^int cxxrtl_eval(cxxrtl_handle handle) {$/;"	f	typeref:typename:int
cxxrtl_flag	yosys/backends/cxxrtl/cxxrtl_capi.h	/^enum cxxrtl_flag {$/;"	g
cxxrtl_get	yosys/backends/cxxrtl/cxxrtl_capi.h	/^static inline struct cxxrtl_object *cxxrtl_get(cxxrtl_handle handle, const char *name) {$/;"	f	typeref:struct:cxxrtl_object *
cxxrtl_get_parts	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^struct cxxrtl_object *cxxrtl_get_parts(cxxrtl_handle handle, const char *name, size_t *parts) {$/;"	f	typeref:struct:cxxrtl_object *
cxxrtl_handle	yosys/backends/cxxrtl/cxxrtl_capi.h	/^typedef struct _cxxrtl_handle *cxxrtl_handle;$/;"	t	typeref:struct:_cxxrtl_handle *
cxxrtl_object	yosys/backends/cxxrtl/cxxrtl_capi.h	/^struct cxxrtl_object {$/;"	s
cxxrtl_outline	yosys/backends/cxxrtl/cxxrtl.h	/^} *cxxrtl_outline;$/;"	t	typeref:struct:_cxxrtl_outline *
cxxrtl_outline	yosys/backends/cxxrtl/cxxrtl_capi.h	/^typedef struct _cxxrtl_outline *cxxrtl_outline;$/;"	t	typeref:struct:_cxxrtl_outline *
cxxrtl_outline_eval	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^void cxxrtl_outline_eval(cxxrtl_outline outline) {$/;"	f	typeref:typename:void
cxxrtl_port_type	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^CxxrtlPortType cxxrtl_port_type(RTLIL::Module *module, RTLIL::IdString port)$/;"	f	typeref:typename:CxxrtlPortType
cxxrtl_port_type	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^CxxrtlPortType cxxrtl_port_type(const RTLIL::Cell *cell, RTLIL::IdString port)$/;"	f	typeref:typename:CxxrtlPortType
cxxrtl_reset	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^void cxxrtl_reset(cxxrtl_handle handle) {$/;"	f	typeref:typename:void
cxxrtl_step	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^size_t cxxrtl_step(cxxrtl_handle handle) {$/;"	f	typeref:typename:size_t
cxxrtl_toplevel	yosys/backends/cxxrtl/cxxrtl.h	/^} *cxxrtl_toplevel;$/;"	t	typeref:struct:_cxxrtl_toplevel *
cxxrtl_toplevel	yosys/backends/cxxrtl/cxxrtl_capi.h	/^typedef struct _cxxrtl_toplevel *cxxrtl_toplevel;$/;"	t	typeref:struct:_cxxrtl_toplevel *
cxxrtl_type	yosys/backends/cxxrtl/cxxrtl_capi.h	/^enum cxxrtl_type {$/;"	g
cxxrtl_vcd	yosys/backends/cxxrtl/cxxrtl_vcd_capi.h	/^typedef struct _cxxrtl_vcd *cxxrtl_vcd;$/;"	t	typeref:struct:_cxxrtl_vcd *
cxxrtl_vcd_add	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^void cxxrtl_vcd_add(cxxrtl_vcd vcd, const char *name, cxxrtl_object *object) {$/;"	f	typeref:typename:void
cxxrtl_vcd_add_from	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^void cxxrtl_vcd_add_from(cxxrtl_vcd vcd, cxxrtl_handle handle) {$/;"	f	typeref:typename:void
cxxrtl_vcd_add_from_if	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^void cxxrtl_vcd_add_from_if(cxxrtl_vcd vcd, cxxrtl_handle handle, void *data,$/;"	f	typeref:typename:void
cxxrtl_vcd_add_from_without_memories	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^void cxxrtl_vcd_add_from_without_memories(cxxrtl_vcd vcd, cxxrtl_handle handle) {$/;"	f	typeref:typename:void
cxxrtl_vcd_create	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^cxxrtl_vcd cxxrtl_vcd_create() {$/;"	f	typeref:typename:cxxrtl_vcd
cxxrtl_vcd_destroy	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^void cxxrtl_vcd_destroy(cxxrtl_vcd vcd) {$/;"	f	typeref:typename:void
cxxrtl_vcd_read	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^void cxxrtl_vcd_read(cxxrtl_vcd vcd, const char **data, size_t *size) {$/;"	f	typeref:typename:void
cxxrtl_vcd_sample	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^void cxxrtl_vcd_sample(cxxrtl_vcd vcd, uint64_t time) {$/;"	f	typeref:typename:void
cxxrtl_vcd_timescale	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^void cxxrtl_vcd_timescale(cxxrtl_vcd vcd, int number, const char *unit) {$/;"	f	typeref:typename:void
cxxrtl_yosys	yosys/backends/cxxrtl/cxxrtl.h	/^namespace cxxrtl_yosys {$/;"	n
cycles_set	yosys/passes/sat/sim.cc	/^	bool cycles_set = false;$/;"	m	struct:SimShared	typeref:typename:bool	file:
d	yosys/libs/fst/fstapi.cc	/^                            double d;$/;"	m	union:fstReaderInit::__anonaa21f10b010a	typeref:typename:double	file:
data	yosys/backends/cxxrtl/cxxrtl.h	/^	chunk::type data[chunks] = {};$/;"	m	struct:cxxrtl::value	typeref:typename:chunk::type[]
data	yosys/backends/cxxrtl/cxxrtl.h	/^	std::unique_ptr<value<Width>[]> data;$/;"	m	struct:cxxrtl::memory	typeref:typename:std::unique_ptr<value<Width>[]>
data	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		T *data;$/;"	m	struct:Scheduler::Vertex	typeref:typename:T *	file:
data	yosys/kernel/mem.h	/^	Const data;$/;"	m	struct:MemInit	typeref:typename:Const
data	yosys/kernel/mem.h	/^	SigSpec clk, en, addr, data;$/;"	m	struct:MemWr	typeref:typename:SigSpec
data	yosys/kernel/mem.h	/^	SigSpec clk, en, arst, srst, addr, data;$/;"	m	struct:MemRd	typeref:typename:SigSpec
data	yosys/kernel/rtlil.h	/^		RTLIL::State data; \/\/ used if wire == NULL$/;"	m	union:RTLIL::SigBit::__anon4f1f9148010a	typeref:typename:RTLIL::State
data	yosys/kernel/rtlil.h	/^	RTLIL::SigSpec data;$/;"	m	struct:RTLIL::MemWriteAction	typeref:typename:RTLIL::SigSpec
data	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::State> data; \/\/ only used if wire == NULL, LSB at index 0$/;"	m	struct:RTLIL::SigChunk	typeref:typename:std::vector<RTLIL::State>
data	yosys/kernel/timinginfo.h	/^	dict<RTLIL::IdString, ModuleTiming> data;$/;"	m	struct:TimingInfo	typeref:typename:dict<RTLIL::IdString,ModuleTiming>
data	yosys/libs/minisat/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair	typeref:typename:D
data	yosys/libs/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	class:Minisat::Clause	typeref:union:Minisat::Clause::__anonb7535e3e020a[0]
data	yosys/libs/minisat/Vec.h	/^    T*   data;$/;"	m	class:Minisat::vec	typeref:typename:T *
data	yosys/passes/cmds/sta.cc	/^	dict<SigBit, t_data> data;$/;"	m	struct:StaWorker	typeref:typename:dict<SigBit,t_data>	file:
data	yosys/passes/sat/sim.cc	/^		Const data;$/;"	m	struct:SimInstance::mem_state_t	typeref:typename:Const	file:
data	yosys/passes/sat/sim.cc	/^		FfData data;$/;"	m	struct:SimInstance::ff_state_t	typeref:typename:FfData	file:
dataToBigInteger	yosys/libs/bigint/BigIntegerUtils.hh	/^BigInteger dataToBigInteger(const T* data, BigInteger::Index length, BigInteger::Sign sign) {$/;"	f	typeref:typename:BigInteger
data_array	yosys/frontends/json/jsonparse.cc	/^	vector<JsonNode*> data_array;$/;"	m	struct:JsonNode	typeref:typename:vector<JsonNode * >	file:
data_bit_idx	yosys/passes/opt/opt_mem_feedback.cc	/^	int data_bit_idx;$/;"	m	struct:FeedbackPath	typeref:typename:int	file:
data_dict	yosys/frontends/json/jsonparse.cc	/^	dict<string, JsonNode*> data_dict;$/;"	m	struct:JsonNode	typeref:typename:dict<string,JsonNode * >	file:
data_dict_keys	yosys/frontends/json/jsonparse.cc	/^	vector<string> data_dict_keys;$/;"	m	struct:JsonNode	typeref:typename:vector<string>	file:
data_eq	yosys/passes/memory/memory_dff.cc	/^	bool data_eq(SigBit sel, bool neg_sel, SigBit dbit, SigBit odbit) {$/;"	f	struct:MemQueryCache	typeref:typename:bool	file:
data_number	yosys/frontends/json/jsonparse.cc	/^	int64_t data_number;$/;"	m	struct:JsonNode	typeref:typename:int64_t	file:
data_string	yosys/frontends/json/jsonparse.cc	/^	string data_string;$/;"	m	struct:JsonNode	typeref:typename:string	file:
database	yosys/kernel/bitpattern.h	/^	pool<bits_t> database;$/;"	m	struct:BitPatternPool	typeref:typename:pool<bits_t>
database	yosys/kernel/hashlib.h	/^	mutable idict<K, 0, OPS> database;$/;"	m	class:hashlib::mfp	typeref:typename:idict<K,0,OPS>
database	yosys/kernel/hashlib.h	/^	pool<K, OPS> database;$/;"	m	class:hashlib::idict	typeref:typename:pool<K,OPS>
database	yosys/kernel/modtools.h	/^	std::map<RTLIL::SigBit, SigBitInfo> database;$/;"	m	struct:ModIndex	typeref:typename:std::map<RTLIL::SigBit,SigBitInfo>
database	yosys/kernel/sigtools.h	/^	mfp<SigBit> database;$/;"	m	struct:SigMap	typeref:typename:mfp<SigBit>
database	yosys/kernel/utils.h	/^	std::map<T, std::set<T, C>, C> database;$/;"	m	struct:TopoSort	typeref:typename:std::map<T,std::set<T,C>,C>
database_add	yosys/passes/sat/mutate.cc	/^void database_add(std::vector<mutate_t> &database, const mutate_opts_t &opts, const mutate_t &en/;"	f	typeref:typename:void
database_reduce	yosys/passes/sat/mutate.cc	/^void database_reduce(std::vector<mutate_t> &database, const mutate_opts_t &opts, int N, xs128_t /;"	f	typeref:typename:void
date	yosys/libs/fst/fstapi.cc	/^    char date[FST_HDR_DATE_SIZE + 1];$/;"	m	struct:fstReaderContext	typeref:typename:char[]	file:
date	yosys/passes/sat/sim.cc	/^	bool date = false;$/;"	m	struct:SimShared	typeref:typename:bool	file:
db	yosys/kernel/celledges.h	/^	dict<SigBit, pool<SigBit>> db;$/;"	m	struct:FwdCellEdgesDatabase	typeref:typename:dict<SigBit,pool<SigBit>>
db	yosys/kernel/celledges.h	/^	dict<SigBit, pool<SigBit>> db;$/;"	m	struct:RevCellEdgesDatabase	typeref:typename:dict<SigBit,pool<SigBit>>
db	yosys/passes/sat/mutate.cc	/^	dict<K, T> db;$/;"	m	struct:mutate_chain_queue_t	typeref:typename:dict<K,T>	file:
db	yosys/passes/sat/mutate.cc	/^	dict<K, T> db;$/;"	m	struct:mutate_once_queue_t	typeref:typename:dict<K,T>	file:
db	yosys/passes/sat/mutate.cc	/^	pool<mutate_t*, hash_ptr_ops> db;$/;"	m	struct:mutate_queue_t	typeref:typename:pool<mutate_t *,hash_ptr_ops>	file:
dbits	yosys/passes/memory/memory_bram.cc	/^		int groups, abits, dbits, init;$/;"	m	struct:rules_t::bram_t	typeref:typename:int	file:
debug	yosys/libs/minisat/SolverTypes.h	/^    void debug(){$/;"	f	class:Minisat::CMap	typeref:typename:void
debug	yosys/passes/sat/sim.cc	/^	bool debug = false;$/;"	m	struct:SimShared	typeref:typename:bool	file:
debug	yosys/passes/techmap/flowmap.cc	/^	bool debug, debug_relax;$/;"	m	struct:FlowmapWorker	typeref:typename:bool	file:
debug_alias	yosys/backends/cxxrtl/cxxrtl.h	/^struct debug_alias {};$/;"	s	namespace:cxxrtl
debug_alias	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool debug_alias = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
debug_eval	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool debug_eval = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
debug_info	yosys/backends/cxxrtl/cxxrtl.h	/^	virtual void debug_info(debug_items &items, std::string path = "") {$/;"	f	struct:cxxrtl::module	typeref:typename:void
debug_info	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool debug_info = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
debug_item	yosys/backends/cxxrtl/cxxrtl.h	/^	debug_item(const ::cxxrtl_object &object) : cxxrtl_object(object) {}$/;"	f	struct:cxxrtl::debug_item
debug_item	yosys/backends/cxxrtl/cxxrtl.h	/^	debug_item(const value<Bits> &item, size_t lsb_offset = 0) {$/;"	f	struct:cxxrtl::debug_item
debug_item	yosys/backends/cxxrtl/cxxrtl.h	/^	debug_item(debug_alias, const value<Bits> &item, size_t lsb_offset = 0) {$/;"	f	struct:cxxrtl::debug_item
debug_item	yosys/backends/cxxrtl/cxxrtl.h	/^	debug_item(debug_alias, const wire<Bits> &item, size_t lsb_offset = 0) {$/;"	f	struct:cxxrtl::debug_item
debug_item	yosys/backends/cxxrtl/cxxrtl.h	/^	debug_item(debug_outline &group, const value<Bits> &item, size_t lsb_offset = 0) {$/;"	f	struct:cxxrtl::debug_item
debug_item	yosys/backends/cxxrtl/cxxrtl.h	/^	debug_item(memory<Width> &item, size_t zero_offset = 0) {$/;"	f	struct:cxxrtl::debug_item
debug_item	yosys/backends/cxxrtl/cxxrtl.h	/^	debug_item(value<Bits> &item, size_t lsb_offset = 0, uint32_t flags_ = 0) {$/;"	f	struct:cxxrtl::debug_item
debug_item	yosys/backends/cxxrtl/cxxrtl.h	/^	debug_item(wire<Bits> &item, size_t lsb_offset = 0, uint32_t flags_ = 0) {$/;"	f	struct:cxxrtl::debug_item
debug_item	yosys/backends/cxxrtl/cxxrtl.h	/^struct debug_item : ::cxxrtl_object {$/;"	s	namespace:cxxrtl
debug_items	yosys/backends/cxxrtl/cxxrtl.h	/^struct debug_items {$/;"	s	namespace:cxxrtl
debug_member	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool debug_member = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
debug_outline	yosys/backends/cxxrtl/cxxrtl.h	/^using debug_outline = ::_cxxrtl_outline;$/;"	t	namespace:cxxrtl	typeref:typename:::_cxxrtl_outline
debug_relax	yosys/passes/techmap/flowmap.cc	/^	bool debug, debug_relax;$/;"	m	struct:FlowmapWorker	typeref:typename:bool	file:
debug_schedule	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Module*, std::vector<FlowGraph::Node>> schedule, debug_schedule;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<const RTLIL::Module *,std::vector<FlowGraph::Node>>	file:
debug_wire_types	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Wire*, WireType> wire_types, debug_wire_types;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<const RTLIL::Wire *,WireType>	file:
dec_indent	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dec_indent() {$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dec_vars	yosys/libs/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literal/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
decimal	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
decimal_digits	yosys/frontends/aiger/aigerparse.cc	/^static int decimal_digits(uint32_t n) {$/;"	f	typeref:typename:int	file:
decision	yosys/libs/minisat/Solver.h	/^    VMap<char>          decision;         \/\/ Declares if a variable is eligible for selection /;"	m	class:Minisat::Solver	typeref:typename:VMap<char>
decisionLevel	yosys/libs/minisat/Solver.h	/^inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }$/;"	f	class:Minisat::Solver	typeref:typename:int
decisions	yosys/libs/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
decl_celltypes	yosys/passes/cmds/connwrappers.cc	/^	std::set<RTLIL::IdString> decl_celltypes;$/;"	m	struct:ConnwrappersWorker	typeref:typename:std::set<RTLIL::IdString>	file:
decls	yosys/backends/smt2/smt2.cc	/^	std::vector<std::string> decls, trans, hier, dtmembers;$/;"	m	struct:Smt2Worker	typeref:typename:std::vector<std::string>	file:
decls	yosys/passes/cmds/connwrappers.cc	/^	std::map<std::pair<RTLIL::IdString, RTLIL::IdString>, portdecl_t> decls;$/;"	m	struct:ConnwrappersWorker	typeref:typename:std::map<std::pair<RTLIL::IdString,RTLIL::IdString>,portdecl_t>	file:
decode_mux_cache	yosys/passes/techmap/muxcover.cc	/^	dict<tuple<SigBit, SigBit, SigBit>, tuple<SigBit, pool<SigBit>, bool>> decode_mux_cache;$/;"	m	struct:MuxcoverWorker	typeref:typename:dict<tuple<SigBit,SigBit,SigBit>,tuple<SigBit,pool<SigBit>,bool>>	file:
decode_mux_counter	yosys/passes/techmap/muxcover.cc	/^	int decode_mux_counter;$/;"	m	struct:MuxcoverWorker	typeref:typename:int	file:
decode_mux_reverse_cache	yosys/passes/techmap/muxcover.cc	/^	dict<SigBit, tuple<SigBit, SigBit, SigBit>> decode_mux_reverse_cache;$/;"	m	struct:MuxcoverWorker	typeref:typename:dict<SigBit,tuple<SigBit,SigBit,SigBit>>	file:
decode_port	yosys/passes/opt/opt_share.cc	/^ExtSigSpec decode_port(RTLIL::Cell *cell, RTLIL::IdString port_name, const SigMap &sigmap)$/;"	f	typeref:typename:ExtSigSpec
decode_port_semantics	yosys/passes/opt/opt_share.cc	/^RTLIL::IdString decode_port_semantics(RTLIL::Cell *cell, RTLIL::IdString port_name)$/;"	f	typeref:typename:RTLIL::IdString
decode_port_sign	yosys/passes/opt/opt_share.cc	/^RTLIL::SigSpec decode_port_sign(RTLIL::Cell *cell, RTLIL::IdString port_name) {$/;"	f	typeref:typename:RTLIL::SigSpec
decode_port_signed	yosys/passes/opt/opt_share.cc	/^bool decode_port_signed(RTLIL::Cell *cell, RTLIL::IdString port_name)$/;"	f	typeref:typename:bool
decode_string	yosys/kernel/rtlil.cc	/^std::string RTLIL::Const::decode_string() const$/;"	f	class:RTLIL::Const	typeref:typename:std::string
decoder_cache	yosys/passes/memory/memory_map.cc	/^	std::map<std::pair<RTLIL::SigSpec, RTLIL::SigSpec>, RTLIL::SigBit> decoder_cache;$/;"	m	struct:MemoryMapWorker	typeref:typename:std::map<std::pair<RTLIL::SigSpec,RTLIL::SigSpec>,RTLIL::SigBit>	file:
decompress_en	yosys/kernel/mem.cc	/^SigSpec MemWr::decompress_en(const std::vector<int> &swizzle, SigSpec sig) {$/;"	f	class:MemWr	typeref:typename:SigSpec
decompress_gzip	yosys/kernel/register.cc	/^void decompress_gzip(const std::string &filename, std::stringstream &out)$/;"	f	typeref:typename:PRIVATE_NAMESPACE_BEGIN void
decrease	yosys/libs/minisat/Heap.h	/^    void decrease  (K k) { assert(inHeap(k)); percolateUp  (indices[k]); }$/;"	f	class:Minisat::Heap	typeref:typename:void
default_gate_cost	yosys/kernel/cost.h	/^	static const dict<RTLIL::IdString, int>& default_gate_cost() {$/;"	f	struct:CellCosts	typeref:typename:const dict<RTLIL::IdString,int> &
default_reached	yosys/passes/proc/proc_rmdead.cc	/^	bool default_reached = false;$/;"	m	struct:FullyDefinedPool	typeref:typename:bool	file:
default_value	yosys/frontends/verilog/preproc.cc	/^	std::string default_value;$/;"	m	struct:macro_arg_t	typeref:typename:std::string	file:
defaultval	yosys/kernel/consteval.h	/^	RTLIL::State defaultval;$/;"	m	struct:ConstEval	typeref:typename:RTLIL::State
define_body_t	yosys/frontends/verilog/preproc.cc	/^	define_body_t(const std::string &body, const arg_map_t *args = nullptr)$/;"	f	struct:define_body_t	file:
define_body_t	yosys/frontends/verilog/preproc.cc	/^struct define_body_t$/;"	s	file:
define_map_t	yosys/frontends/verilog/preproc.cc	/^define_map_t::define_map_t()$/;"	f	class:define_map_t
define_map_t	yosys/frontends/verilog/preproc.h	/^struct define_map_t$/;"	s
define_signal	yosys/passes/sat/sim.cc	/^	std::string define_signal(Wire *wire)$/;"	f	struct:SimWorker	typeref:typename:std::string	file:
defines	yosys/frontends/verilog/preproc.h	/^	std::map<std::string, std::unique_ptr<define_body_t>> defines;$/;"	m	struct:define_map_t	typeref:typename:std::map<std::string,std::unique_ptr<define_body_t>>
definitions	yosys/backends/smv/smv.cc	/^	vector<string> inputvars, vars, definitions, assignments, invarspecs;$/;"	m	struct:SmvWorker	typeref:typename:vector<string>	file:
defparam	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
del	yosys/kernel/sigtools.h	/^	void del(const RTLIL::SigSpec &sig)$/;"	f	struct:SigPool	typeref:typename:void
del	yosys/kernel/sigtools.h	/^	void del(const SigPool &other)$/;"	f	struct:SigPool	typeref:typename:void
delays	yosys/passes/techmap/abc9_ops.cc	/^		std::vector<int> delays;$/;"	m	struct:prep_lut::t_lut	typeref:typename:std::vector<int>	file:
delete_children	yosys/frontends/ast/ast.cc	/^void AstNode::delete_children()$/;"	f	class:AstNode	typeref:typename:void
deleted	yosys/libs/minisat/SolverTypes.h	/^    Deleted                  deleted;$/;"	m	class:Minisat::OccLists	typeref:typename:Deleted
delim_left	yosys/backends/edif/edif.cc	/^	char delim_left, delim_right;$/;"	m	struct:EdifNames	typeref:typename:char	file:
delim_right	yosys/backends/edif/edif.cc	/^	char delim_left, delim_right;$/;"	m	struct:EdifNames	typeref:typename:char	file:
delta	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		int delta() const$/;"	f	struct:Scheduler::Vertex	typeref:typename:int	file:
demo	yosys/libs/subcircuit/Makefile	/^demo: demo.o subcircuit.o$/;"	t
demo1	yosys/examples/smtbmc/Makefile	/^demo1: demo1.smt2$/;"	t
demo1.smt2	yosys/examples/smtbmc/Makefile	/^demo1.smt2: demo1.v$/;"	t
demo2	yosys/examples/smtbmc/Makefile	/^demo2: demo2.smt2$/;"	t
demo2.smt2	yosys/examples/smtbmc/Makefile	/^demo2.smt2: demo2.v$/;"	t
demo3	yosys/examples/smtbmc/Makefile	/^demo3: demo3.smt2$/;"	t
demo3.smt2	yosys/examples/smtbmc/Makefile	/^demo3.smt2: demo3.v$/;"	t
demo4	yosys/examples/smtbmc/Makefile	/^demo4: demo4.smt2$/;"	t
demo4.smt2	yosys/examples/smtbmc/Makefile	/^demo4.smt2: demo4.v$/;"	t
demo5	yosys/examples/smtbmc/Makefile	/^demo5: demo5.smt2$/;"	t
demo5.smt2	yosys/examples/smtbmc/Makefile	/^demo5.smt2: demo5.v$/;"	t
demo6	yosys/examples/smtbmc/Makefile	/^demo6: demo6.smt2$/;"	t
demo6.smt2	yosys/examples/smtbmc/Makefile	/^demo6.smt2: demo6.v$/;"	t
demo7	yosys/examples/smtbmc/Makefile	/^demo7: demo7.smt2$/;"	t
demo7.smt2	yosys/examples/smtbmc/Makefile	/^demo7.smt2: demo7.v$/;"	t
demo8	yosys/examples/smtbmc/Makefile	/^demo8: demo8.smt2$/;"	t
demo8.smt2	yosys/examples/smtbmc/Makefile	/^demo8.smt2: demo8.v$/;"	t
demo9	yosys/examples/smtbmc/Makefile	/^demo9: demo9.smt2$/;"	t
demo9.smt2	yosys/examples/smtbmc/Makefile	/^demo9.smt2: demo9.v$/;"	t
demo_bit	yosys/libs/ezsat/Makefile	/^demo_bit: demo_bit.o ezsat.o ezminisat.o$/;"	t
demo_cmp	yosys/libs/ezsat/Makefile	/^demo_cmp: demo_cmp.o ezsat.o ezminisat.o$/;"	t
demo_vec	yosys/libs/ezsat/Makefile	/^demo_vec: demo_vec.o ezsat.o ezminisat.o$/;"	t
demorgan_worker	yosys/passes/opt/opt_demorgan.cc	/^void demorgan_worker($/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
demux	yosys/backends/cxxrtl/cxxrtl.h	/^	value<ResultBits> demux(const value<SelBits> &sel) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<ResultBits>
demux_op	yosys/kernel/celledges.cc	/^void demux_op(AbstractCellEdgesDatabase *db, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
depth	yosys/backends/cxxrtl/cxxrtl.h	/^	const size_t depth;$/;"	m	struct:cxxrtl::memory	typeref:typename:const size_t
depth	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	size_t depth;$/;"	m	struct:cxxrtl_object	typeref:typename:size_t
depth	yosys/passes/sat/freduce.cc	/^	int depth;$/;"	m	struct:equiv_bit_t	typeref:typename:int	file:
derive	yosys/frontends/ast/ast.cc	/^RTLIL::IdString AstModule::derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Cons/;"	f	class:AstModule	typeref:typename:RTLIL::IdString
derive	yosys/frontends/rpc/rpc_frontend.cc	/^	RTLIL::IdString derive(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Const> &parame/;"	f	struct:RpcModule	typeref:typename:RTLIL::IdString	file:
derive	yosys/kernel/rtlil.cc	/^RTLIL::IdString RTLIL::Module::derive(RTLIL::Design*, const dict<RTLIL::IdString, RTLIL::Const> /;"	f	class:RTLIL::Module	typeref:typename:RTLIL::IdString
derive_common	yosys/frontends/ast/ast.cc	/^std::string AstModule::derive_common(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::C/;"	f	class:AstModule	typeref:typename:std::string
derive_module	yosys/frontends/rpc/rpc_frontend.cc	/^	std::pair<std::string, std::string> derive_module(const std::string &module, const dict<RTLIL::/;"	f	struct:RpcServer	typeref:typename:std::pair<std::string,std::string>	file:
derive_name_from_cell_output_wire	yosys/passes/cmds/rename.cc	/^static IdString derive_name_from_cell_output_wire(const RTLIL::Cell *cell)$/;"	f	typeref:typename:IdString	file:
derive_name_from_src	yosys/passes/cmds/rename.cc	/^static std::string derive_name_from_src(const std::string &src, int counter)$/;"	f	typeref:typename:std::string	file:
derived_module_name	yosys/frontends/ast/ast.cc	/^std::string AST::derived_module_name(std::string stripped_name, const std::vector<std::pair<RTLI/;"	f	class:AST	typeref:typename:std::string
describe	yosys/frontends/ast/ast_binding.cc	/^AST::Binding::describe() const$/;"	f	class:AST::Binding	typeref:typename:std::string
describe_selection_for_assert	yosys/passes/cmds/select.cc	/^static std::string describe_selection_for_assert(RTLIL::Design *design, RTLIL::Selection *sel)$/;"	f	typeref:typename:std::string	file:
description	yosys/libs/minisat/Options.h	/^    const char* description;$/;"	m	class:Minisat::Option	typeref:typename:const char *
description	yosys/passes/sat/sat.cc	/^		std::string description;$/;"	m	struct:SatHelper::ModelBlockInfo	typeref:typename:std::string	file:
design	yosys/backends/aiger/xaiger.cc	/^	Design *design;$/;"	m	struct:XAigerWriter	typeref:typename:Design *	file:
design	yosys/backends/blif/blif.cc	/^	RTLIL::Design *design;$/;"	m	struct:BlifDumper	typeref:typename:RTLIL::Design *	file:
design	yosys/backends/firrtl/firrtl.cc	/^	RTLIL::Design *design;$/;"	m	struct:FirrtlWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/backends/json/json.cc	/^	Design *design;$/;"	m	struct:JsonWriter	typeref:typename:Design *	file:
design	yosys/backends/simplec/simplec.cc	/^	Design *design;$/;"	m	struct:SimplecWorker	typeref:typename:Design *	file:
design	yosys/frontends/aiger/aigerparse.h	/^    RTLIL::Design *design;$/;"	m	struct:AigerReader	typeref:typename:RTLIL::Design *
design	yosys/kernel/cost.h	/^	Design *design = nullptr;$/;"	m	struct:CellCosts	typeref:typename:Design *
design	yosys/kernel/modtools.h	/^	RTLIL::Design *design;$/;"	m	struct:ModWalker	typeref:typename:RTLIL::Design *
design	yosys/kernel/rtlil.h	/^	RTLIL::Design *design;$/;"	m	struct:RTLIL::Module	typeref:typename:RTLIL::Design *
design	yosys/passes/cmds/ltp.cc	/^	RTLIL::Design *design;$/;"	m	struct:LtpWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/cmds/scc.cc	/^	RTLIL::Design *design;$/;"	m	struct:SccWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/cmds/show.cc	/^	RTLIL::Design *design;$/;"	m	struct:ShowWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/cmds/splice.cc	/^	RTLIL::Design *design;$/;"	m	struct:SpliceWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/cmds/sta.cc	/^	Design *design;$/;"	m	struct:StaWorker	typeref:typename:Design *	file:
design	yosys/passes/hierarchy/submod.cc	/^	RTLIL::Design *design;$/;"	m	struct:SubmodWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/memory/memory_map.cc	/^	RTLIL::Design *design;$/;"	m	struct:MemoryMapWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/memory/memory_share.cc	/^	RTLIL::Design *design;$/;"	m	struct:MemoryShareWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/opt/opt_clean.cc	/^	Design *design;$/;"	m	struct:keep_cache_t	typeref:typename:Design *	file:
design	yosys/passes/opt/opt_mem_feedback.cc	/^	RTLIL::Design *design;$/;"	m	struct:OptMemFeedbackWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/opt/opt_merge.cc	/^	RTLIL::Design *design;$/;"	m	struct:OptMergeWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/opt/opt_muxtree.cc	/^	RTLIL::Design *design;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/opt/opt_reduce.cc	/^	RTLIL::Design *design;$/;"	m	struct:OptReduceWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/opt/share.cc	/^	RTLIL::Design *design;$/;"	m	struct:ShareWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/sat/eval.cc	/^	RTLIL::Design *design;$/;"	m	struct:VlogHammerReporter	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/sat/fmcombine.cc	/^	Design *design;$/;"	m	struct:FmcombineWorker	typeref:typename:Design *	file:
design	yosys/passes/sat/freduce.cc	/^	RTLIL::Design *design;$/;"	m	struct:FreduceWorker	typeref:typename:RTLIL::Design *	file:
design	yosys/passes/sat/sat.cc	/^	RTLIL::Design *design;$/;"	m	struct:SatHelper	typeref:typename:RTLIL::Design *	file:
design_	yosys/backends/protobuf/protobuf.cc	/^	Design *design_;$/;"	m	struct:ProtobufDesignSerializer	typeref:typename:Design *	file:
design_ns	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string design_ns = "cxxrtl_design";$/;"	m	struct:CxxrtlWorker	typeref:typename:std::string	file:
destruct_guard	yosys/kernel/rtlil.cc	/^RTLIL::IdString::destruct_guard_t RTLIL::IdString::destruct_guard;$/;"	m	class:RTLIL::IdString	typeref:typename:YOSYS_NAMESPACE_BEGIN RTLIL::IdString::destruct_guard_t
destruct_guard	yosys/kernel/rtlil.h	/^		} destruct_guard;$/;"	m	struct:RTLIL::IdString	typeref:struct:RTLIL::IdString::destruct_guard_t
destruct_guard_t	yosys/kernel/rtlil.h	/^			destruct_guard_t() { ok = true; }$/;"	f	struct:RTLIL::IdString::destruct_guard_t
destruct_guard_t	yosys/kernel/rtlil.h	/^		static struct destruct_guard_t {$/;"	s	struct:RTLIL::IdString
detachClause	yosys/libs/minisat/Solver.cc	/^void Solver::detachClause(CRef cr, bool strict){$/;"	f	class:Solver	typeref:typename:void
detectSignWidth	yosys/frontends/ast/genrtlil.cc	/^void AstNode::detectSignWidth(int &width_hint, bool &sign_hint, bool *found_real)$/;"	f	class:AstNode	typeref:typename:void
detectSignWidthWorker	yosys/frontends/ast/genrtlil.cc	/^void AstNode::detectSignWidthWorker(int &width_hint, bool &sign_hint, bool *found_real)$/;"	f	class:AstNode	typeref:typename:void
detect_fsm	yosys/passes/fsm/fsm_detect.cc	/^static void detect_fsm(RTLIL::Wire *wire)$/;"	f	typeref:typename:void	file:
detect_latch	yosys/frontends/ast/simplify.cc	/^bool AstNode::detect_latch(const std::string &var)$/;"	f	class:AstNode	typeref:typename:bool
device_opt	yosys/techlibs/ice40/synth_ice40.cc	/^	string top_opt, blif_file, edif_file, json_file, device_opt;$/;"	m	struct:SynthIce40Pass	typeref:typename:string	file:
dff	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
dff	yosys/techlibs/gatemate/synth_gatemate.cc	/^	bool noflatten, nobram, noaddf, nomult, nomx4, nomx8, dff, retime, noiopad, noclkbuf;$/;"	m	struct:SynthGateMatePass	typeref:typename:bool	file:
dff	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
dff	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	bool flatten, quartus, nolutram, nobram, dff, nodsp, noiopad, noclkbuf;$/;"	m	struct:SynthIntelALMPass	typeref:typename:bool	file:
dff	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
dff	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool abc9, dff;$/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
dff_cells	yosys/passes/opt/opt_dff.cc	/^	std::vector<Cell *> dff_cells;$/;"	m	struct:OptDffWorker	typeref:typename:std::vector<Cell * >	file:
dff_count	yosys/passes/techmap/shregmap.cc	/^	int dff_count, shreg_count;$/;"	m	struct:ShregmapWorker	typeref:typename:int	file:
dff_driver	yosys/kernel/ffmerge.h	/^	dict<SigBit, std::pair<Cell*, int>> dff_driver;$/;"	m	struct:FfMergeHelper	typeref:typename:dict<SigBit,std::pair<Cell *,int>>
dff_map_bit_info_t	yosys/passes/sat/expose.cc	/^struct dff_map_bit_info_t {$/;"	s	file:
dff_map_info_t	yosys/passes/sat/expose.cc	/^struct dff_map_info_t {$/;"	s	file:
dff_mode	yosys/passes/techmap/abc9.cc	/^	bool dff_mode, cleanup;$/;"	m	struct:Abc9Pass	typeref:typename:bool	file:
dff_sink	yosys/kernel/ffmerge.h	/^	dict<SigBit, pool<std::pair<Cell*, int>>> dff_sink;$/;"	m	struct:FfMergeHelper	typeref:typename:dict<SigBit,pool<std::pair<Cell *,int>>>
dfflibmap	yosys/passes/techmap/dfflibmap.cc	/^static void dfflibmap(RTLIL::Design *design, RTLIL::Module *module)$/;"	f	typeref:typename:void	file:
diCache	yosys/libs/subcircuit/subcircuit.cc	/^	DiCache diCache;$/;"	m	class:SubCircuit::SolverWorker	typeref:typename:DiCache	file:
dict	yosys/kernel/hashlib.h	/^	dict()$/;"	f	class:hashlib::dict
dict	yosys/kernel/hashlib.h	/^	dict(InputIterator first, InputIterator last)$/;"	f	class:hashlib::dict
dict	yosys/kernel/hashlib.h	/^	dict(const dict &other)$/;"	f	class:hashlib::dict
dict	yosys/kernel/hashlib.h	/^	dict(const std::initializer_list<std::pair<K, T>> &list)$/;"	f	class:hashlib::dict
dict	yosys/kernel/hashlib.h	/^	dict(dict &&other)$/;"	f	class:hashlib::dict
dict	yosys/kernel/hashlib.h	/^class dict$/;"	c	namespace:hashlib
dictIssue_directive	yosys/libs/fst/lz4.cc	/^} dictIssue_directive;$/;"	t	typeref:enum:__anon9390dffe0603	file:
dictSize	yosys/libs/fst/lz4.cc	/^    U32 dictSize;$/;"	m	struct:__anon9390dffe0208	typeref:typename:U32	file:
dictSmall	yosys/libs/fst/lz4.cc	/^    dictSmall$/;"	e	enum:__anon9390dffe0603	file:
dict_directive	yosys/libs/fst/lz4.cc	/^} dict_directive;$/;"	t	typeref:enum:__anon9390dffe0503	file:
dictionary	yosys/libs/fst/lz4.cc	/^    const BYTE *dictionary;$/;"	m	struct:__anon9390dffe0208	typeref:typename:const BYTE *	file:
did_something	yosys/passes/opt/opt_expr.cc	/^bool did_something;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
did_something	yosys/passes/opt/opt_reduce.cc	/^	bool did_something;$/;"	m	struct:OptReduceWorker	typeref:typename:bool	file:
did_something	yosys/passes/pmgen/peepopt.cc	/^bool did_something;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
difference	yosys/passes/sat/qbfsat.cc	/^static inline unsigned int difference(unsigned int a, unsigned int b) {$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN unsigned int	file:
difference_type	yosys/kernel/rtlil.h	/^		using difference_type = ptrdiff_t;$/;"	t	struct:RTLIL::ObjIterator	typeref:typename:ptrdiff_t
digest	yosys/libs/sha1/sha1.h	/^    uint32_t digest[DIGEST_INTS];$/;"	m	class:SHA1	typeref:typename:uint32_t[]
direction	yosys/libs/fst/fstapi.h	/^            unsigned char direction;     \/* FST_VD_MIN ... FST_VD_MAX *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierVar	typeref:typename:unsigned char
direction	yosys/passes/cmds/qwp.cc	/^	char direction;$/;"	m	struct:QwpWorker	typeref:typename:char	file:
dirties	yosys/libs/minisat/SolverTypes.h	/^    vec<K>                   dirties;$/;"	m	class:Minisat::OccLists	typeref:typename:vec<K>
dirty	yosys/backends/simplec/simplec.cc	/^	int dirty;$/;"	m	struct:HierDirtyFlags	typeref:typename:int	file:
dirty	yosys/libs/minisat/SolverTypes.h	/^    IntMap<K, char, MkIndex> dirty;$/;"	m	class:Minisat::OccLists	typeref:typename:IntMap<K,char,MkIndex>
dirty_bits	yosys/backends/simplec/simplec.cc	/^	pool<SigBit> dirty_bits;$/;"	m	struct:HierDirtyFlags	typeref:typename:pool<SigBit>	file:
dirty_bits	yosys/passes/sat/sim.cc	/^	pool<SigBit> dirty_bits;$/;"	m	struct:SimInstance	typeref:typename:pool<SigBit>	file:
dirty_cells	yosys/backends/simplec/simplec.cc	/^	pool<Cell*> dirty_cells;$/;"	m	struct:HierDirtyFlags	typeref:typename:pool<Cell * >	file:
dirty_cells	yosys/passes/sat/sim.cc	/^	pool<Cell*> dirty_cells;$/;"	m	struct:SimInstance	typeref:typename:pool<Cell * >	file:
dirty_children	yosys/passes/sat/sim.cc	/^	pool<SimInstance*, hash_ptr_ops> dirty_children;$/;"	m	struct:SimInstance	typeref:typename:pool<SimInstance *,hash_ptr_ops>	file:
dirty_memories	yosys/passes/sat/sim.cc	/^	pool<IdString> dirty_memories;$/;"	m	struct:SimInstance	typeref:typename:pool<IdString>	file:
disable_net	yosys/frontends/verific/verific.h	/^	Verific::Net *disable_net = nullptr;$/;"	m	struct:VerificClocking	typeref:typename:Verific::Net *
disable_sig	yosys/frontends/verific/verific.h	/^	SigBit disable_sig = State::S0;$/;"	m	struct:VerificClocking	typeref:typename:SigBit
disable_sig	yosys/frontends/verific/verificsva.cc	/^	SigBit trigger_sig = State::S1, disable_sig;$/;"	m	struct:SvaFsm	typeref:typename:SigBit	file:
disable_stack	yosys/frontends/verific/verificsva.cc	/^	vector<SigBit> disable_stack;$/;"	m	struct:SvaFsm	typeref:typename:vector<SigBit>	file:
discover_nodes	yosys/passes/techmap/flowmap.cc	/^	void discover_nodes(pool<IdString> cell_types)$/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
div_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> div_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
div_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> div_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
divideWithRemainder	yosys/libs/bigint/BigInteger.cc	/^void BigInteger::divideWithRemainder(const BigInteger &b, BigInteger &q) {$/;"	f	class:BigInteger	typeref:typename:void
divideWithRemainder	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::divideWithRemainder(const BigUnsigned &b, BigUnsigned &q) {$/;"	f	class:BigUnsigned	typeref:typename:void
divmod_ss	yosys/backends/cxxrtl/cxxrtl.h	/^std::pair<value<BitsY>, value<BitsY>> divmod_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE std::pair<value<BitsY>,value<BitsY>>
divmod_uu	yosys/backends/cxxrtl/cxxrtl.h	/^std::pair<value<BitsY>, value<BitsY>> divmod_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE std::pair<value<BitsY>,value<BitsY>>
dlogic	yosys/passes/opt/opt_lut.cc	/^	const std::vector<dlogic_t> &dlogic;$/;"	m	struct:OptLutWorker	typeref:typename:const std::vector<dlogic_t> &	file:
dlogic_t	yosys/passes/opt/opt_lut.cc	/^struct dlogic_t {$/;"	s	file:
dnodes	yosys/frontends/verific/verificsva.cc	/^	dict<vector<int>, SvaDFsmNode> dnodes;$/;"	m	struct:SvaFsm	typeref:typename:dict<vector<int>,SvaDFsmNode>	file:
do_assert	yosys/kernel/hashlib.h	/^	static inline void do_assert(bool cond) {$/;"	f	class:hashlib::dict	typeref:typename:void
do_assert	yosys/kernel/hashlib.h	/^	static inline void do_assert(bool cond) {$/;"	f	class:hashlib::pool	typeref:typename:void
do_assert	yosys/kernel/hashlib.h	/^	static inline void do_assert(bool) { }$/;"	f	class:hashlib::dict	typeref:typename:void
do_assert	yosys/kernel/hashlib.h	/^	static inline void do_assert(bool) { }$/;"	f	class:hashlib::pool	typeref:typename:void
do_case	yosys/passes/proc/proc_prune.cc	/^	pool<RTLIL::SigBit> do_case(RTLIL::CaseRule *cs, pool<RTLIL::SigBit> assigned, pool<RTLIL::SigB/;"	f	struct:PruneWorker	typeref:typename:pool<RTLIL::SigBit>	file:
do_erase	yosys/kernel/hashlib.h	/^	int do_erase(int index, int hash)$/;"	f	class:hashlib::dict	typeref:typename:int
do_erase	yosys/kernel/hashlib.h	/^	int do_erase(int index, int hash)$/;"	f	class:hashlib::pool	typeref:typename:int
do_hash	yosys/kernel/hashlib.h	/^	int do_hash(const K &key) const$/;"	f	class:hashlib::dict	typeref:typename:int
do_hash	yosys/kernel/hashlib.h	/^	int do_hash(const K &key) const$/;"	f	class:hashlib::pool	typeref:typename:int
do_insert	yosys/kernel/hashlib.h	/^	int do_insert(K &&rvalue, int &hash)$/;"	f	class:hashlib::pool	typeref:typename:int
do_insert	yosys/kernel/hashlib.h	/^	int do_insert(const K &key, int &hash)$/;"	f	class:hashlib::dict	typeref:typename:int
do_insert	yosys/kernel/hashlib.h	/^	int do_insert(const K &value, int &hash)$/;"	f	class:hashlib::pool	typeref:typename:int
do_insert	yosys/kernel/hashlib.h	/^	int do_insert(const std::pair<K, T> &value, int &hash)$/;"	f	class:hashlib::dict	typeref:typename:int
do_insert	yosys/kernel/hashlib.h	/^	int do_insert(std::pair<K, T> &&rvalue, int &hash)$/;"	f	class:hashlib::dict	typeref:typename:int
do_lookup	yosys/kernel/hashlib.h	/^	int do_lookup(const K &key, int &hash) const$/;"	f	class:hashlib::dict	typeref:typename:int
do_lookup	yosys/kernel/hashlib.h	/^	int do_lookup(const K &key, int &hash) const$/;"	f	class:hashlib::pool	typeref:typename:int
do_process	yosys/passes/proc/proc_prune.cc	/^	void do_process(RTLIL::Process *pr)$/;"	f	struct:PruneWorker	typeref:typename:void	file:
do_rehash	yosys/kernel/hashlib.h	/^	void do_rehash()$/;"	f	class:hashlib::dict	typeref:typename:void
do_rehash	yosys/kernel/hashlib.h	/^	void do_rehash()$/;"	f	class:hashlib::pool	typeref:typename:void
do_rewind	yosys/libs/fst/fstapi.cc	/^    unsigned do_rewind : 1;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
do_setunset	yosys/passes/cmds/setattr.cc	/^static void do_setunset(dict<RTLIL::IdString, RTLIL::Const> &attrs, const std::vector<setunset_t/;"	f	typeref:typename:void	file:
do_subtract	yosys/kernel/macc.h	/^		bool is_signed, do_subtract;$/;"	m	struct:Macc::port_t	typeref:typename:bool
do_switch	yosys/passes/proc/proc_prune.cc	/^	pool<RTLIL::SigBit> do_switch(RTLIL::SwitchRule *sw, pool<RTLIL::SigBit> assigned, pool<RTLIL::/;"	f	struct:PruneWorker	typeref:typename:pool<RTLIL::SigBit>	file:
do_wires	yosys/passes/cmds/splice.cc	/^	bool do_wires;$/;"	m	struct:SpliceWorker	typeref:typename:bool	file:
done_register	yosys/kernel/register.cc	/^void Pass::done_register()$/;"	f	class:Pass	typeref:typename:void
dot_escape	yosys/passes/techmap/flowmap.cc	/^static string dot_escape(string value)$/;"	f	typeref:typename:string	file:
dot_escape_store	yosys/passes/cmds/show.cc	/^	vector<shared_str> dot_escape_store;$/;"	m	struct:ShowWorker	typeref:typename:vector<shared_str>	file:
dot_id2num_store	yosys/passes/cmds/show.cc	/^	std::map<RTLIL::IdString, int> dot_id2num_store;$/;"	m	struct:ShowWorker	typeref:typename:std::map<RTLIL::IdString,int>	file:
double_endian_match	yosys/libs/fst/fstapi.cc	/^    unsigned double_endian_match : 1;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
double_value	yosys/backends/cxxrtl/cxxrtl.h	/^	const double      double_value = 0.0;$/;"	m	struct:cxxrtl::metadata	typeref:typename:const double
dpi_call	yosys/frontends/ast/dpicall.cc	/^AST::AstNode *AST::dpi_call(const std::string &rtype, const std::string &fname, const std::vecto/;"	f	class:AST	typeref:typename:AST::AstNode *
drand	yosys/libs/minisat/Rnd.h	/^static inline double drand(double& seed)$/;"	f	namespace:Minisat	typeref:typename:double
drand	yosys/libs/minisat/Solver.h	/^    static inline double drand(double& seed) {$/;"	f	class:Minisat::Solver	typeref:typename:double
driven	yosys/passes/cmds/sta.cc	/^	pool<SigBit> driven;$/;"	m	struct:StaWorker	typeref:typename:pool<SigBit>	file:
driven_bits	yosys/backends/simplec/simplec.cc	/^	dict<Module*, pool<SigBit>> driven_bits;$/;"	m	struct:SimplecWorker	typeref:typename:dict<Module *,pool<SigBit>>	file:
driven_bits	yosys/passes/cmds/splice.cc	/^	std::vector<RTLIL::SigBit> driven_bits;$/;"	m	struct:SpliceWorker	typeref:typename:std::vector<RTLIL::SigBit>	file:
driven_bits_map	yosys/passes/cmds/splice.cc	/^	std::map<RTLIL::SigBit, int> driven_bits_map;$/;"	m	struct:SpliceWorker	typeref:typename:std::map<RTLIL::SigBit,int>	file:
driven_chunks	yosys/passes/cmds/splice.cc	/^	std::set<RTLIL::SigSpec> driven_chunks;$/;"	m	struct:SpliceWorker	typeref:typename:std::set<RTLIL::SigSpec>	file:
driver	yosys/passes/cmds/sta.cc	/^		Cell* driver;$/;"	m	struct:StaWorker::t_data	typeref:typename:Cell *	file:
driver	yosys/passes/techmap/extract_fa.cc	/^	dict<SigBit, Cell*> driver;$/;"	m	struct:ExtractFaWorker	typeref:typename:dict<SigBit,Cell * >	file:
drivers	yosys/passes/sat/freduce.cc	/^	drivers_t &drivers;$/;"	m	struct:FindReducedInputs	typeref:typename:drivers_t &	file:
drivers	yosys/passes/sat/freduce.cc	/^	drivers_t &drivers;$/;"	m	struct:PerformReduction	typeref:typename:drivers_t &	file:
drivers	yosys/passes/sat/freduce.cc	/^	drivers_t drivers;$/;"	m	struct:FreduceWorker	typeref:typename:drivers_t	file:
drivers_t	yosys/passes/sat/freduce.cc	/^typedef std::map<RTLIL::SigBit, std::pair<RTLIL::Cell*, std::set<RTLIL::SigBit>>> drivers_t;$/;"	t	typeref:typename:std::map<RTLIL::SigBit,std::pair<RTLIL::Cell *,std::set<RTLIL::SigBit>>>	file:
drv	yosys/passes/sat/freduce.cc	/^	RTLIL::Cell *drv;$/;"	m	struct:equiv_bit_t	typeref:typename:RTLIL::Cell *	file:
dsp	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
dsp_rules	yosys/techlibs/nexus/synth_nexus.cc	/^	const std::vector<DSPRule> dsp_rules = {$/;"	m	struct:SynthNexusPass	typeref:typename:const std::vector<DSPRule>	file:
dst_port	yosys/passes/cmds/sta.cc	/^		IdString dst_port, src_port;$/;"	m	struct:StaWorker::t_data	typeref:typename:IdString	file:
dtmembers	yosys/backends/smt2/smt2.cc	/^	std::vector<std::string> decls, trans, hier, dtmembers;$/;"	m	struct:Smt2Worker	typeref:typename:std::vector<std::string>	file:
dump	yosys/backends/blif/blif.cc	/^	static void dump(std::ostream &f, RTLIL::Module *module, RTLIL::Design *design, BlifDumperConfi/;"	f	struct:BlifDumper	typeref:typename:void	file:
dump	yosys/backends/blif/blif.cc	/^	void dump()$/;"	f	struct:BlifDumper	typeref:typename:void	file:
dump	yosys/frontends/verific/verificsva.cc	/^	void dump()$/;"	f	struct:SvaFsm	typeref:typename:void	file:
dump	yosys/libs/json11/json11.cpp	/^    void dump(string &out) const override { json11::dump(m_value, out); }$/;"	f	class:json11::Value	typeref:typename:void	file:
dump	yosys/libs/json11/json11.cpp	/^static void dump(NullStruct, string &out) {$/;"	f	namespace:json11	typeref:typename:void	file:
dump	yosys/libs/json11/json11.cpp	/^static void dump(bool value, string &out) {$/;"	f	namespace:json11	typeref:typename:void	file:
dump	yosys/libs/json11/json11.cpp	/^static void dump(const Json::array &values, string &out) {$/;"	f	namespace:json11	typeref:typename:void	file:
dump	yosys/libs/json11/json11.cpp	/^static void dump(const Json::object &values, string &out) {$/;"	f	namespace:json11	typeref:typename:void	file:
dump	yosys/libs/json11/json11.cpp	/^static void dump(const string &value, string &out) {$/;"	f	namespace:json11	typeref:typename:void	file:
dump	yosys/libs/json11/json11.cpp	/^static void dump(double value, string &out) {$/;"	f	namespace:json11	typeref:typename:void	file:
dump	yosys/libs/json11/json11.cpp	/^static void dump(int value, string &out) {$/;"	f	namespace:json11	typeref:typename:void	file:
dump	yosys/libs/json11/json11.cpp	/^void Json::dump(string &out) const {$/;"	f	class:json11::Json	typeref:typename:void
dump	yosys/libs/json11/json11.hpp	/^    std::string dump() const {$/;"	f	class:json11::Json	typeref:typename:std::string
dump	yosys/passes/sat/freduce.cc	/^	void dump()$/;"	f	struct:FreduceWorker	typeref:typename:void	file:
dump	yosys/passes/techmap/libparse.cc	/^void LibertyAst::dump(FILE *f, std::string indent, std::string path, bool path_ok)$/;"	f	class:LibertyAst	typeref:typename:void
dumpAst	yosys/frontends/ast/ast.cc	/^void AstNode::dumpAst(FILE *f, std::string indent) const$/;"	f	class:AstNode	typeref:typename:void
dumpVlog	yosys/frontends/ast/ast.cc	/^void AstNode::dumpVlog(FILE *f, std::string indent) const$/;"	f	class:AstNode	typeref:typename:void
dump_assign	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_assign(const RTLIL::SigSig &sigsig, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_attributes	yosys/backends/verilog/verilog_backend.cc	/^void dump_attributes(std::ostream &f, std::string indent, dict<RTLIL::IdString, RTLIL::Const> &a/;"	f	typeref:typename:void
dump_attrs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_attrs(const RTLIL::AttrObject *object)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_case_body	yosys/backends/verilog/verilog_backend.cc	/^void dump_case_body(std::ostream &f, std::string indent, RTLIL::CaseRule *cs, bool omit_trailing/;"	f	typeref:typename:void
dump_case_rule	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_case_rule(const RTLIL::CaseRule *rule, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_cell	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_cell(std::ostream &f, std::string indent, const RTLIL::Cell *cell)$/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_cell	yosys/backends/verilog/verilog_backend.cc	/^void dump_cell(std::ostream &f, std::string indent, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
dump_cell_eval	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_cell_eval(const RTLIL::Cell *cell, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_cell_expr	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_cell_expr(const RTLIL::Cell *cell, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_cell_expr	yosys/backends/verilog/verilog_backend.cc	/^bool dump_cell_expr(std::ostream &f, std::string indent, RTLIL::Cell *cell)$/;"	f	typeref:typename:bool
dump_cell_expr_binop	yosys/backends/verilog/verilog_backend.cc	/^void dump_cell_expr_binop(std::ostream &f, std::string indent, RTLIL::Cell *cell, std::string op/;"	f	typeref:typename:void
dump_cell_expr_port	yosys/backends/verilog/verilog_backend.cc	/^void dump_cell_expr_port(std::ostream &f, RTLIL::Cell *cell, std::string port, bool gen_signed =/;"	f	typeref:typename:void
dump_cell_expr_uniop	yosys/backends/verilog/verilog_backend.cc	/^void dump_cell_expr_uniop(std::ostream &f, std::string indent, RTLIL::Cell *cell, std::string op/;"	f	typeref:typename:void
dump_cell_sync	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_cell_sync(const RTLIL::Cell *cell, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_commit_method	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_commit_method(RTLIL::Module *module)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_config	yosys/passes/memory/memory_bram.cc	/^		void dump_config() const$/;"	f	struct:rules_t::bram_t	typeref:typename:void	file:
dump_conn	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_conn(std::ostream &f, std::string indent, const RTLIL::SigSpec &left, c/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_conn	yosys/backends/verilog/verilog_backend.cc	/^void dump_conn(std::ostream &f, std::string indent, const RTLIL::SigSpec &left, const RTLIL::Sig/;"	f	typeref:typename:void
dump_connect	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_connect(const RTLIL::SigSig &conn, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_connect_expr	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_connect_expr(const RTLIL::SigSig &conn, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_const	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_const(const RTLIL::Const &data)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_const	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_const(const RTLIL::Const &data, int width, int offset = 0, bool fixed_width = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_const	yosys/backends/firrtl/firrtl.cc	/^std::string dump_const(const RTLIL::Const &data)$/;"	f	typeref:typename:std::string
dump_const	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_const(std::ostream &f, const RTLIL::Const &data, int width, int offset,/;"	f	class:RTLIL_BACKEND	typeref:typename:YOSYS_NAMESPACE_BEGIN void
dump_const	yosys/backends/verilog/verilog_backend.cc	/^void dump_const(std::ostream &f, const RTLIL::Const &data, int width = -1, int offset = 0, bool /;"	f	typeref:typename:void
dump_const_init	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_const_init(const RTLIL::Const &data, int width, int offset = 0, bool fixed_width = fa/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_const_string	yosys/backends/firrtl/firrtl.cc	/^std::string dump_const_string(const RTLIL::Const &data)$/;"	f	typeref:typename:std::string
dump_db	yosys/kernel/modtools.h	/^	void dump_db()$/;"	f	struct:ModIndex	typeref:typename:void
dump_debug_eval_method	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_debug_eval_method(RTLIL::Module *module)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_debug_info_method	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_debug_info_method(RTLIL::Module *module)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_debug_wire	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_debug_wire(const RTLIL::Wire *wire, bool is_local)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_design	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_design(RTLIL::Design *design)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_design	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_design(std::ostream &f, RTLIL::Design *design, bool only_selected, bool/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_dnodes	yosys/frontends/verific/verificsva.cc	/^	void dump_dnodes()$/;"	f	struct:SvaFsm	typeref:typename:void	file:
dump_dot_graph	yosys/passes/techmap/flowmap.cc	/^	void dump_dot_graph(string filename)$/;"	f	struct:FlowGraph	typeref:typename:void	file:
dump_dot_graph	yosys/passes/techmap/flowmap.cc	/^	void dump_dot_graph(string filename, GraphMode mode,$/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
dump_dot_graph	yosys/passes/techmap/flowmap.cc	/^static void dump_dot_graph(string filename,$/;"	f	typeref:typename:void
dump_dot_lut_graph	yosys/passes/techmap/flowmap.cc	/^	void dump_dot_lut_graph(string filename, GraphMode mode)$/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
dump_eval_method	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_eval_method(RTLIL::Module *module)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_file	yosys/passes/cmds/qwp.cc	/^	std::ofstream dump_file;$/;"	m	struct:QwpConfig	typeref:typename:std::ofstream	file:
dump_final_smt2	yosys/passes/sat/qbfsat.h	/^	bool dump_final_smt2 = false, assume_outputs = false, assume_neg = false, nooptimize = false;$/;"	m	struct:QbfSolveOptions	typeref:typename:bool
dump_final_smt2_file	yosys/passes/sat/qbfsat.h	/^	std::string dump_final_smt2_file = "";$/;"	m	struct:QbfSolveOptions	typeref:typename:std::string
dump_inlined_cells	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_inlined_cells(const std::vector<const RTLIL::Cell*> &cells)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_loop_graph	yosys/passes/techmap/abc.cc	/^void dump_loop_graph(FILE *f, int &nr, std::map<int, std::set<int>> &edges, std::set<int> &workp/;"	f	typeref:typename:void
dump_mem_rdport	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_mem_rdport(const Mem *mem, int portidx, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_mem_wrports	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_mem_wrports(const Mem *mem, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_memory	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_memory(std::ostream &f, std::string indent, const RTLIL::Memory *memory/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_memory	yosys/backends/verilog/verilog_backend.cc	/^void dump_memory(std::ostream &f, std::string indent, Mem &mem)$/;"	f	typeref:typename:void
dump_metadata_map	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_metadata_map(const dict<RTLIL::IdString, RTLIL::Const> &metadata_map)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_model	yosys/passes/sat/qbfsat.h	/^	void dump_model(RTLIL::Module *module) const {$/;"	f	struct:QbfSolutionType	typeref:typename:void
dump_model_to_json	yosys/passes/sat/sat.cc	/^	void dump_model_to_json(std::string json_file_name)$/;"	f	struct:SatHelper	typeref:typename:void	file:
dump_model_to_vcd	yosys/passes/sat/sat.cc	/^	void dump_model_to_vcd(std::string vcd_file_name)$/;"	f	struct:SatHelper	typeref:typename:void	file:
dump_module	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_module(std::ostream &f, std::string indent, RTLIL::Module *module, RTLI/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_module	yosys/backends/verilog/verilog_backend.cc	/^void dump_module(std::ostream &f, std::string indent, RTLIL::Module *module)$/;"	f	typeref:typename:void
dump_module_impl	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_module_impl(RTLIL::Module *module)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_module_intf	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_module_intf(RTLIL::Module *module)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_nodes	yosys/frontends/verific/verificsva.cc	/^	void dump_nodes()$/;"	f	struct:SvaFsm	typeref:typename:void	file:
dump_params	yosys/backends/blif/blif.cc	/^	void dump_params(const char *command, dict<IdString, Const> &params)$/;"	f	struct:BlifDumper	typeref:typename:void	file:
dump_prefix	yosys/passes/sat/freduce.cc	/^std::string dump_prefix;$/;"	v	typeref:typename:std::string
dump_proc	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_proc(std::ostream &f, std::string indent, const RTLIL::Process *proc)$/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_proc_case_body	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_proc_case_body(std::ostream &f, std::string indent, const RTLIL::CaseRu/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_proc_switch	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_proc_switch(std::ostream &f, std::string indent, const RTLIL::SwitchRul/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_proc_switch	yosys/backends/verilog/verilog_backend.cc	/^void dump_proc_switch(std::ostream &f, std::string indent, RTLIL::SwitchRule *sw)$/;"	f	typeref:typename:void
dump_proc_sync	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_proc_sync(std::ostream &f, std::string indent, const RTLIL::SyncRule *s/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_process	yosys/backends/verilog/verilog_backend.cc	/^void dump_process(std::ostream &f, std::string indent, RTLIL::Process *proc, bool find_regs = fa/;"	f	typeref:typename:void
dump_process_case	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_process_case(const RTLIL::Process *proc, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_process_syncs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_process_syncs(const RTLIL::Process *proc, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_reg_init	yosys/backends/verilog/verilog_backend.cc	/^void dump_reg_init(std::ostream &f, SigSpec sig)$/;"	f	typeref:typename:void
dump_reset_method	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_reset_method(RTLIL::Module *module)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_sigchunk	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool dump_sigchunk(const RTLIL::SigChunk &chunk, bool is_lhs, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:bool	file:
dump_sigchunk	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_sigchunk(std::ostream &f, const RTLIL::SigChunk &chunk, bool autoint)$/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_sigchunk	yosys/backends/verilog/verilog_backend.cc	/^void dump_sigchunk(std::ostream &f, const RTLIL::SigChunk &chunk, bool no_decimal = false)$/;"	f	typeref:typename:void
dump_sigspec	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool dump_sigspec(const RTLIL::SigSpec &sig, bool is_lhs, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:bool	file:
dump_sigspec	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_sigspec(std::ostream &f, const RTLIL::SigSpec &sig, bool autoint)$/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_sigspec	yosys/backends/verilog/verilog_backend.cc	/^void dump_sigspec(std::ostream &f, const RTLIL::SigSpec &sig)$/;"	f	typeref:typename:void
dump_sigspec_lhs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_sigspec_lhs(const RTLIL::SigSpec &sig, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_sigspec_rhs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_sigspec_rhs(const RTLIL::SigSpec &sig, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_size_limit	yosys/libs/fst/fstapi.cc	/^    uint64_t dump_size_limit;$/;"	m	struct:fstWriterContext	typeref:typename:uint64_t	file:
dump_svg	yosys/passes/cmds/qwp.cc	/^	void dump_svg(const pool<int> *green_nodes = nullptr, double median = -1)$/;"	f	struct:QwpWorker	typeref:typename:void	file:
dump_switch_rule	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_switch_rule(const RTLIL::SwitchRule *rule, bool for_debug = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_unodes	yosys/frontends/verific/verificsva.cc	/^	void dump_unodes()$/;"	f	struct:SvaFsm	typeref:typename:void	file:
dump_wire	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void dump_wire(const RTLIL::Wire *wire, bool is_local)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
dump_wire	yosys/backends/rtlil/rtlil_backend.cc	/^void RTLIL_BACKEND::dump_wire(std::ostream &f, std::string indent, const RTLIL::Wire *wire)$/;"	f	class:RTLIL_BACKEND	typeref:typename:void
dump_wire	yosys/backends/verilog/verilog_backend.cc	/^void dump_wire(std::ostream &f, std::string indent, RTLIL::Wire *wire)$/;"	f	typeref:typename:void
dupidx	yosys/passes/memory/memory_bram.cc	/^		int group, index, dupidx;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:int	file:
eagerMatch	yosys/libs/minisat/ParseUtils.h	/^static bool eagerMatch(B& in, const char* str) {$/;"	f	namespace:Minisat	typeref:typename:bool
earlyEnd_directive	yosys/libs/fst/lz4.cc	/^} earlyEnd_directive;$/;"	t	typeref:enum:__anon9390dffe0803	file:
echo-abc-rev	yosys/Makefile	/^echo-abc-rev:$/;"	t
echo-git-rev	yosys/Makefile	/^echo-git-rev:$/;"	t
echo-yosys-ver	yosys/Makefile	/^echo-yosys-ver:$/;"	t
echo_mode	yosys/kernel/register.cc	/^bool echo_mode = false;$/;"	v	typeref:typename:PRIVATE_NAMESPACE_END YOSYS_NAMESPACE_BEGIN bool
edge	yosys/kernel/utils.h	/^	void edge(T left, T right)$/;"	f	struct:TopoSort	typeref:typename:void
edgeIdx	yosys/libs/subcircuit/subcircuit.h	/^			int edgeIdx;$/;"	m	struct:SubCircuit::Graph::PortBit	typeref:typename:int
edgeTypes	yosys/libs/subcircuit/subcircuit.cc	/^		std::vector<DiEdge> edgeTypes;$/;"	m	struct:SubCircuit::SolverWorker::DiCache	typeref:typename:std::vector<DiEdge>	file:
edgeTypesMap	yosys/libs/subcircuit/subcircuit.cc	/^		std::map<DiEdge, int> edgeTypesMap;$/;"	m	struct:SubCircuit::SolverWorker::DiCache	typeref:typename:std::map<DiEdge,int>	file:
edge_cells	yosys/passes/equiv/equiv_mark.cc	/^	pool<IdString> edge_cells, equiv_cells;$/;"	m	struct:EquivMarkWorker	typeref:typename:pool<IdString>	file:
edge_cut	yosys/passes/techmap/flowmap.cc	/^	pair<pool<RTLIL::SigBit>, pool<RTLIL::SigBit>> edge_cut()$/;"	f	struct:FlowGraph	typeref:typename:pair<pool<RTLIL::SigBit>,pool<RTLIL::SigBit>>	file:
edge_flow	yosys/passes/techmap/flowmap.cc	/^	dict<pair<RTLIL::SigBit, RTLIL::SigBit>, int> edge_flow;$/;"	m	struct:FlowGraph	typeref:typename:dict<pair<RTLIL::SigBit,RTLIL::SigBit>,int>	file:
edge_types	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<RTLIL::SigBit, RTLIL::SyncType> edge_types;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<RTLIL::SigBit,RTLIL::SyncType>	file:
edge_wires	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	pool<const RTLIL::Wire*> edge_wires;$/;"	m	struct:CxxrtlWorker	typeref:typename:pool<const RTLIL::Wire * >	file:
edges	yosys/frontends/verific/verificsva.cc	/^	vector<pair<int, SigBit>> edges, links;$/;"	m	struct:SvaNFsmNode	typeref:typename:vector<pair<int,SigBit>>	file:
edges	yosys/frontends/verific/verificsva.cc	/^	vector<pair<int, SigSpec>> edges;$/;"	m	struct:SvaUFsmNode	typeref:typename:vector<pair<int,SigSpec>>	file:
edges	yosys/frontends/verific/verificsva.cc	/^	vector<pair<vector<int>, Const>> edges;$/;"	m	struct:SvaDFsmNode	typeref:typename:vector<pair<vector<int>,Const>>	file:
edges	yosys/libs/subcircuit/subcircuit.h	/^		std::vector<Edge> edges;$/;"	m	class:SubCircuit::Graph	typeref:typename:std::vector<Edge>
edges	yosys/passes/cmds/qwp.cc	/^	dict<pair<int, int>, double> edges;$/;"	m	struct:QwpWorker	typeref:typename:dict<pair<int,int>,double>	file:
edges_bw	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, pool<RTLIL::SigBit>> edges_fw, edges_bw;$/;"	m	struct:FlowGraph	typeref:typename:dict<RTLIL::SigBit,pool<RTLIL::SigBit>>	file:
edges_bw	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, pool<RTLIL::SigBit>> edges_fw, edges_bw;$/;"	m	struct:FlowmapWorker	typeref:typename:dict<RTLIL::SigBit,pool<RTLIL::SigBit>>	file:
edges_fw	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, pool<RTLIL::SigBit>> edges_fw, edges_bw;$/;"	m	struct:FlowGraph	typeref:typename:dict<RTLIL::SigBit,pool<RTLIL::SigBit>>	file:
edges_fw	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, pool<RTLIL::SigBit>> edges_fw, edges_bw;$/;"	m	struct:FlowmapWorker	typeref:typename:dict<RTLIL::SigBit,pool<RTLIL::SigBit>>	file:
edif_file	yosys/techlibs/anlogic/synth_anlogic.cc	/^	string top_opt, edif_file, json_file;$/;"	m	struct:SynthAnlogicPass	typeref:typename:string	file:
edif_file	yosys/techlibs/ecp5/synth_ecp5.cc	/^	string top_opt, blif_file, edif_file, json_file;$/;"	m	struct:SynthEcp5Pass	typeref:typename:string	file:
edif_file	yosys/techlibs/efinix/synth_efinix.cc	/^	string top_opt, edif_file, json_file;$/;"	m	struct:SynthEfinixPass	typeref:typename:string	file:
edif_file	yosys/techlibs/ice40/synth_ice40.cc	/^	string top_opt, blif_file, edif_file, json_file, device_opt;$/;"	m	struct:SynthIce40Pass	typeref:typename:string	file:
edif_file	yosys/techlibs/machxo2/synth_machxo2.cc	/^	string top_opt, blif_file, edif_file, json_file;$/;"	m	struct:SynthMachXO2Pass	typeref:typename:string	file:
edif_file	yosys/techlibs/sf2/synth_sf2.cc	/^	string top_opt, edif_file, vlog_file, json_file;$/;"	m	struct:SynthSf2Pass	typeref:typename:string	file:
edif_file	yosys/techlibs/xilinx/synth_xilinx.cc	/^	std::string top_opt, edif_file, blif_file, family;$/;"	m	struct:SynthXilinxPass	typeref:typename:std::string	file:
elem_count	yosys/libs/fst/fstapi.h	/^    uint32_t elem_count;$/;"	m	struct:fstETab	typeref:typename:uint32_t
element	yosys/kernel/hashlib.h	/^	const_iterator element(int n) const { return const_iterator(*this, n); }$/;"	f	class:hashlib::idict	typeref:typename:const_iterator
element	yosys/kernel/hashlib.h	/^	const_iterator element(int n) const { return const_iterator(this, int(entries.size())-1-n); }$/;"	f	class:hashlib::dict	typeref:typename:const_iterator
element	yosys/kernel/hashlib.h	/^	const_iterator element(int n) const { return const_iterator(this, int(entries.size())-1-n); }$/;"	f	class:hashlib::pool	typeref:typename:const_iterator
element	yosys/kernel/hashlib.h	/^	const_iterator element(int n) const { return database.element(n); }$/;"	f	class:hashlib::mfp	typeref:typename:const_iterator
element	yosys/kernel/hashlib.h	/^	iterator element(int n) { return iterator(this, int(entries.size())-1-n); }$/;"	f	class:hashlib::dict	typeref:typename:iterator
element	yosys/kernel/hashlib.h	/^	iterator element(int n) { return iterator(this, int(entries.size())-1-n); }$/;"	f	class:hashlib::pool	typeref:typename:iterator
element_ops_t	yosys/kernel/hashlib.h	/^		typedef hash_ops<typename std::tuple_element<I, std::tuple<T...>>::type> element_ops_t;$/;"	t	function:hashlib::hash_ops::hash	typeref:typename:hash_ops<typename std::tuple_element<I,std::tuple<T...>>::type>
elems	yosys/libs/minisat/Map.h	/^    int  elems() const { return size; }$/;"	f	class:Minisat::Map	typeref:typename:int
elim_heap	yosys/libs/minisat/SimpSolver.h	/^    Heap<Var,ElimLt>    elim_heap;$/;"	m	class:Minisat::SimpSolver	typeref:typename:Heap<Var,ElimLt>
elimclauses	yosys/libs/minisat/SimpSolver.h	/^    vec<uint32_t>       elimclauses;$/;"	m	class:Minisat::SimpSolver	typeref:typename:vec<uint32_t>
eliminate	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::eliminate(bool turn_off_elim)$/;"	f	class:SimpSolver	typeref:typename:bool
eliminateVar	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::eliminateVar(Var v)$/;"	f	class:SimpSolver	typeref:typename:bool
eliminate_const	yosys/passes/proc/proc_arst.cc	/^void eliminate_const(RTLIL::Module *mod, RTLIL::CaseRule *cs, RTLIL::SigSpec const_sig, bool pol/;"	f	typeref:typename:void
eliminated	yosys/libs/ezsat/ezminisat.cc	/^bool ezMiniSAT::eliminated(int idx)$/;"	f	class:ezMiniSAT	typeref:typename:bool
eliminated	yosys/libs/ezsat/ezsat.cc	/^bool ezSAT::eliminated(int)$/;"	f	class:ezSAT	typeref:typename:bool
eliminated	yosys/libs/minisat/SimpSolver.h	/^    VMap<char>          eliminated;$/;"	m	class:Minisat::SimpSolver	typeref:typename:VMap<char>
eliminated_count	yosys/passes/opt/opt_lut.cc	/^	int eliminated_count = 0, combined_count = 0;$/;"	m	struct:OptLutWorker	typeref:typename:int	file:
eliminated_vars	yosys/libs/minisat/SimpSolver.h	/^    int     eliminated_vars;$/;"	m	class:Minisat::SimpSolver	typeref:typename:int
elimorder	yosys/libs/minisat/SimpSolver.h	/^    int                 elimorder;$/;"	m	class:Minisat::SimpSolver	typeref:typename:int
emit	yosys/kernel/ff.cc	/^Cell *FfData::emit() {$/;"	f	class:FfData	typeref:typename:Cell *
emit	yosys/kernel/mem.cc	/^void Mem::emit() {$/;"	f	class:Mem	typeref:typename:void
emit_elaborated_extmodules	yosys/backends/firrtl/firrtl.cc	/^void emit_elaborated_extmodules(RTLIL::Design *design, std::ostream &f)$/;"	f	typeref:typename:void
emit_enddefinitions	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void emit_enddefinitions() {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
emit_extmodule	yosys/backends/firrtl/firrtl.cc	/^void emit_extmodule(RTLIL::Cell *cell, RTLIL::Module *mod_instance, std::ostream &f)$/;"	f	typeref:typename:void
emit_ident	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void emit_ident(size_t ident) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
emit_module	yosys/backends/firrtl/firrtl.cc	/^	void emit_module()$/;"	f	struct:FirrtlWorker	typeref:typename:void	file:
emit_name	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void emit_name(const std::string &name) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
emit_scalar	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void emit_scalar(const variable &var) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
emit_scope	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void emit_scope(const std::vector<std::string> &scope) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
emit_time	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void emit_time(uint64_t timestamp) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
emit_timescale	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void emit_timescale(unsigned number, const std::string &unit) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
emit_var	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void emit_var(const variable &var, const std::string &type, const std::string &name,$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
emit_vector	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void emit_vector(const variable &var) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
emplace	yosys/kernel/hashlib.h	/^	std::pair<iterator, bool> emplace(Args&&... args)$/;"	f	class:hashlib::pool	typeref:typename:std::pair<iterator,bool>
emplace	yosys/kernel/hashlib.h	/^	std::pair<iterator, bool> emplace(K &&rkey, T &&rvalue)$/;"	f	class:hashlib::dict	typeref:typename:std::pair<iterator,bool>
emplace	yosys/kernel/hashlib.h	/^	std::pair<iterator, bool> emplace(K &&rkey, T const &value)$/;"	f	class:hashlib::dict	typeref:typename:std::pair<iterator,bool>
emplace	yosys/kernel/hashlib.h	/^	std::pair<iterator, bool> emplace(K const &key, T &&rvalue)$/;"	f	class:hashlib::dict	typeref:typename:std::pair<iterator,bool>
emplace	yosys/kernel/hashlib.h	/^	std::pair<iterator, bool> emplace(K const &key, T const &value)$/;"	f	class:hashlib::dict	typeref:typename:std::pair<iterator,bool>
empty	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		bool empty() const$/;"	f	struct:Scheduler::Vertex	typeref:typename:bool	file:
empty	yosys/kernel/bitpattern.h	/^	bool empty()$/;"	f	struct:BitPatternPool	typeref:typename:bool
empty	yosys/kernel/hashlib.h	/^	bool empty() const { return database.empty(); }$/;"	f	class:hashlib::idict	typeref:typename:bool
empty	yosys/kernel/hashlib.h	/^	bool empty() const { return database.empty(); }$/;"	f	class:hashlib::mfp	typeref:typename:bool
empty	yosys/kernel/hashlib.h	/^	bool empty() const { return entries.empty(); }$/;"	f	class:hashlib::dict	typeref:typename:bool
empty	yosys/kernel/hashlib.h	/^	bool empty() const { return entries.empty(); }$/;"	f	class:hashlib::pool	typeref:typename:bool
empty	yosys/kernel/rtlil.cc	/^bool RTLIL::CaseRule::empty() const$/;"	f	class:RTLIL::CaseRule	typeref:typename:bool
empty	yosys/kernel/rtlil.cc	/^bool RTLIL::SwitchRule::empty() const$/;"	f	class:RTLIL::SwitchRule	typeref:typename:bool
empty	yosys/kernel/rtlil.h	/^		bool empty() const {$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
empty	yosys/kernel/rtlil.h	/^	bool empty() const {$/;"	f	struct:RTLIL::Selection	typeref:typename:bool
empty	yosys/kernel/rtlil.h	/^	inline bool empty() const { return bits.empty(); }$/;"	f	struct:RTLIL::Const	typeref:typename:bool
empty	yosys/kernel/rtlil.h	/^	inline bool empty() const { return width_ == 0; }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:bool
empty	yosys/libs/minisat/Heap.h	/^    bool empty     ()          const { return heap.size() == 0; }$/;"	f	class:Minisat::Heap	typeref:typename:bool
empty	yosys/passes/opt/opt_share.cc	/^	bool empty() const { return sig.empty(); }$/;"	f	struct:ExtSigSpec	typeref:typename:bool	file:
empty	yosys/passes/proc/proc_rmdead.cc	/^	bool empty()$/;"	f	struct:FullyDefinedPool	typeref:typename:bool	file:
empty_map	yosys/libs/json11/json11.cpp	/^    const map<string, Json> empty_map;$/;"	m	struct:json11::Statics	typeref:typename:const map<string,Json>	file:
empty_string	yosys/libs/json11/json11.cpp	/^    const string empty_string;$/;"	m	struct:json11::Statics	typeref:typename:const string	file:
empty_tuple	yosys/kernel/utils.h	/^	static T empty_tuple;$/;"	m	struct:stackmap	typeref:typename:T
empty_vector	yosys/libs/json11/json11.cpp	/^    const vector<Json> empty_vector;$/;"	m	struct:json11::Statics	typeref:typename:const vector<Json>	file:
emulate_priority	yosys/kernel/mem.cc	/^void Mem::emulate_priority(int idx1, int idx2, FfInitVals *initvals)$/;"	f	class:Mem	typeref:typename:void
emulate_rd_ce_over_srst	yosys/kernel/mem.cc	/^void Mem::emulate_rd_ce_over_srst(int idx) {$/;"	f	class:Mem	typeref:typename:void
emulate_rd_srst_over_ce	yosys/kernel/mem.cc	/^void Mem::emulate_rd_srst_over_ce(int idx) {$/;"	f	class:Mem	typeref:typename:void
emulate_rden	yosys/kernel/mem.cc	/^void Mem::emulate_rden(int idx, FfInitVals *initvals) {$/;"	f	class:Mem	typeref:typename:void
emulate_read_first	yosys/kernel/mem.cc	/^void Mem::emulate_read_first(FfInitVals *initvals) {$/;"	f	class:Mem	typeref:typename:void
emulate_read_first_ok	yosys/kernel/mem.cc	/^bool Mem::emulate_read_first_ok() {$/;"	f	class:Mem	typeref:typename:bool
emulate_reset	yosys/kernel/mem.cc	/^void Mem::emulate_reset(int idx, bool emu_init, bool emu_arst, bool emu_srst, FfInitVals *initva/;"	f	class:Mem	typeref:typename:void
emulate_split_init_arst	yosys/passes/techmap/dfflegalize.cc	/^	void emulate_split_init_arst(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
emulate_split_set_clr	yosys/passes/techmap/dfflegalize.cc	/^	void emulate_split_set_clr(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
emulate_transparency	yosys/kernel/mem.cc	/^void Mem::emulate_transparency(int widx, int ridx, FfInitVals *initvals) {$/;"	f	class:Mem	typeref:typename:void
en	yosys/kernel/mem.h	/^	Const en;$/;"	m	struct:MemInit	typeref:typename:Const
en	yosys/kernel/mem.h	/^	SigSpec clk, en, addr, data;$/;"	m	struct:MemWr	typeref:typename:SigSpec
en	yosys/kernel/mem.h	/^	SigSpec clk, en, arst, srst, addr, data;$/;"	m	struct:MemRd	typeref:typename:SigSpec
en_polarity	yosys/passes/techmap/abc.cc	/^bool clk_polarity, en_polarity, arst_polarity, srst_polarity;$/;"	v	typeref:typename:bool
en_sig	yosys/passes/techmap/abc.cc	/^RTLIL::SigSpec clk_sig, en_sig, arst_sig, srst_sig;$/;"	v	typeref:typename:RTLIL::SigSpec
enable	yosys/kernel/rtlil.h	/^	RTLIL::SigSpec enable;$/;"	m	struct:RTLIL::MemWriteAction	typeref:typename:RTLIL::SigSpec
enable	yosys/passes/memory/memory_bram.cc	/^		int wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:int	file:
enable	yosys/passes/memory/memory_bram.cc	/^		vector<int> ports, wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::bram_t	typeref:typename:vector<int>	file:
enable_fa	yosys/passes/techmap/extract_fa.cc	/^	bool enable_fa = false;$/;"	m	struct:ExtractFaConfig	typeref:typename:bool	file:
enable_ha	yosys/passes/techmap/extract_fa.cc	/^	bool enable_ha = false;$/;"	m	struct:ExtractFaConfig	typeref:typename:bool	file:
enable_net	yosys/frontends/verific/verific.h	/^	Verific::Net *enable_net = nullptr;$/;"	m	struct:VerificClocking	typeref:typename:Verific::Net *
enable_sig	yosys/frontends/verific/verific.h	/^	SigBit enable_sig = State::S1;$/;"	m	struct:VerificClocking	typeref:typename:SigBit
enable_undef	yosys/passes/sat/sat.cc	/^	bool enable_undef, set_init_def, set_init_undef, set_init_zero, ignore_unknown_cells;$/;"	m	struct:SatHelper	typeref:typename:bool	file:
enabled	yosys/passes/opt/opt_muxtree.cc	/^		bool enabled;$/;"	m	struct:OptMuxtreeWorker::portinfo_t	typeref:typename:bool	file:
enabled_gates	yosys/passes/techmap/abc.cc	/^pool<std::string> enabled_gates;$/;"	v	typeref:typename:pool<std::string>
encdata	yosys/passes/equiv/equiv_make.cc	/^	dict<IdString, dict<Const, Const>> encdata;$/;"	m	struct:EquivMakeWorker	typeref:typename:dict<IdString,dict<Const,Const>>	file:
encfiles	yosys/passes/equiv/equiv_make.cc	/^	vector<string> encfiles;$/;"	m	struct:EquivMakeWorker	typeref:typename:vector<string>	file:
encode_utf8	yosys/libs/json11/json11.cpp	/^    void encode_utf8(long pt, string & out) {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:void	file:
end	yosys/kernel/hashlib.h	/^	const_iterator end() const { return const_iterator(*this, offset + size()); }$/;"	f	class:hashlib::idict	typeref:typename:const_iterator
end	yosys/kernel/hashlib.h	/^	const_iterator end() const { return const_iterator(nullptr, -1); }$/;"	f	class:hashlib::dict	typeref:typename:const_iterator
end	yosys/kernel/hashlib.h	/^	const_iterator end() const { return const_iterator(nullptr, -1); }$/;"	f	class:hashlib::pool	typeref:typename:const_iterator
end	yosys/kernel/hashlib.h	/^	const_iterator end() const { return database.end(); }$/;"	f	class:hashlib::mfp	typeref:typename:const_iterator
end	yosys/kernel/hashlib.h	/^	iterator end() { return iterator(nullptr, -1); }$/;"	f	class:hashlib::dict	typeref:typename:iterator
end	yosys/kernel/hashlib.h	/^	iterator end() { return iterator(nullptr, -1); }$/;"	f	class:hashlib::pool	typeref:typename:iterator
end	yosys/kernel/log.h	/^	void end() {$/;"	f	struct:PerformanceTimer	typeref:typename:void
end	yosys/kernel/rtlil.h	/^		RTLIL::ObjIterator<T> end() { return RTLIL::ObjIterator<T>(); }$/;"	f	struct:RTLIL::ObjRange	typeref:typename:RTLIL::ObjIterator<T>
end	yosys/kernel/rtlil.h	/^	inline RTLIL::SigSpecConstIterator end() const { RTLIL::SigSpecConstIterator it; it.sig_p = thi/;"	f	struct:RTLIL::SigSpec	typeref:typename:RTLIL::SigSpecConstIterator
end	yosys/kernel/rtlil.h	/^	inline RTLIL::SigSpecIterator end() { RTLIL::SigSpecIterator it; it.sig_p = this; it.index = wi/;"	f	struct:RTLIL::SigSpec	typeref:typename:RTLIL::SigSpecIterator
end	yosys/kernel/rtlil.h	/^	inline decltype(bits)::iterator end() { return bits.end(); }$/;"	f	struct:RTLIL::Const	typeref:typename:decltype(bits)::iterator
end	yosys/kernel/timinginfo.h	/^	decltype(data)::const_iterator end() const { return data.end(); }$/;"	f	struct:TimingInfo	typeref:typename:decltype(data)::const_iterator
end	yosys/libs/minisat/IntMap.h	/^        V*       end    ()       { return &map[map.size()]; }$/;"	f	class:Minisat::IntMap	typeref:typename:V *
end	yosys/libs/minisat/IntMap.h	/^        const V* end    () const { return &map[map.size()]; }$/;"	f	class:Minisat::IntMap	typeref:typename:const V *
end	yosys/libs/minisat/Options.h	/^    double end;$/;"	m	struct:Minisat::DoubleRange	typeref:typename:double
end	yosys/libs/minisat/Options.h	/^    int end;$/;"	m	struct:Minisat::IntRange	typeref:typename:int
end	yosys/libs/minisat/Options.h	/^    int64_t end;$/;"	m	struct:Minisat::Int64Range	typeref:typename:int64_t
end	yosys/libs/minisat/Queue.h	/^    int     end;$/;"	m	class:Minisat::Queue	typeref:typename:int
endCondition_directive	yosys/libs/fst/lz4.cc	/^} endCondition_directive;$/;"	t	typeref:enum:__anon9390dffe0703	file:
endOnInputSize	yosys/libs/fst/lz4.cc	/^    endOnInputSize = 1$/;"	e	enum:__anon9390dffe0703	file:
endOnOutputSize	yosys/libs/fst/lz4.cc	/^    endOnOutputSize = 0,$/;"	e	enum:__anon9390dffe0703	file:
end_inclusive	yosys/libs/minisat/Options.h	/^    bool  end_inclusive;$/;"	m	struct:Minisat::DoubleRange	typeref:typename:bool
end_time	yosys/kernel/fstdata.h	/^	uint64_t end_time;$/;"	m	class:FstData	typeref:typename:uint64_t
end_time	yosys/libs/fst/fstapi.cc	/^    uint64_t start_time, end_time;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
endpoints	yosys/passes/cmds/sta.cc	/^	dict<SigBit, t_endpoint> endpoints;$/;"	m	struct:StaWorker	typeref:typename:dict<SigBit,t_endpoint>	file:
ends_with	yosys/kernel/rtlil.h	/^		bool ends_with(const char* suffix) const {$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
enqueue	yosys/libs/minisat/Solver.h	/^inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? v/;"	f	class:Minisat::Solver	typeref:typename:bool
entries	yosys/kernel/hashlib.h	/^	std::vector<entry_t> entries;$/;"	m	class:hashlib::dict	typeref:typename:std::vector<entry_t>
entries	yosys/kernel/hashlib.h	/^	std::vector<entry_t> entries;$/;"	m	class:hashlib::pool	typeref:typename:std::vector<entry_t>
entry_t	yosys/kernel/hashlib.h	/^		entry_t() { }$/;"	f	struct:hashlib::dict::entry_t
entry_t	yosys/kernel/hashlib.h	/^		entry_t() { }$/;"	f	struct:hashlib::pool::entry_t
entry_t	yosys/kernel/hashlib.h	/^		entry_t(K &&udata, int next) : udata(std::move(udata)), next(next) { }$/;"	f	struct:hashlib::pool::entry_t
entry_t	yosys/kernel/hashlib.h	/^		entry_t(const K &udata, int next) : udata(udata), next(next) { }$/;"	f	struct:hashlib::pool::entry_t
entry_t	yosys/kernel/hashlib.h	/^		entry_t(const std::pair<K, T> &udata, int next) : udata(udata), next(next) { }$/;"	f	struct:hashlib::dict::entry_t
entry_t	yosys/kernel/hashlib.h	/^		entry_t(std::pair<K, T> &&udata, int next) : udata(std::move(udata)), next(next) { }$/;"	f	struct:hashlib::dict::entry_t
entry_t	yosys/kernel/hashlib.h	/^	struct entry_t$/;"	s	class:hashlib::dict
entry_t	yosys/kernel/hashlib.h	/^	struct entry_t$/;"	s	class:hashlib::pool
enumerateIds	yosys/passes/cmds/show.cc	/^	bool enumerateIds;$/;"	m	struct:ShowWorker	typeref:typename:bool	file:
enumvaluetypes	yosys/libs/fst/fstapi.cc	/^static const char *enumvaluetypes[] = {"integer",$/;"	v	typeref:typename:const char * []	file:
eq_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> eq_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
eq_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> eq_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
equal	yosys/libs/bigint/BigInteger.hh	/^		equal   = BigUnsigned::equal  ,$/;"	m	class:BigInteger	typeref:typename:const CmpRes
equal	yosys/libs/bigint/BigUnsigned.hh	/^	enum CmpRes { less = -1, equal = 0, greater = 1 };$/;"	e	enum:BigUnsigned::CmpRes
equals	yosys/libs/json11/json11.cpp	/^    bool equals(const JsonValue * other) const override { return m_value == other->number_value(/;"	f	class:json11::JsonDouble	typeref:typename:bool	file:
equals	yosys/libs/json11/json11.cpp	/^    bool equals(const JsonValue * other) const override { return m_value == other->number_value(/;"	f	class:json11::JsonInt	typeref:typename:bool	file:
equals	yosys/libs/json11/json11.cpp	/^    bool equals(const JsonValue * other) const override {$/;"	f	class:json11::Value	typeref:typename:bool	file:
equals	yosys/libs/minisat/Map.h	/^    E          equals;$/;"	m	class:Minisat::Map	typeref:typename:E
equiv.log	yosys/manual/PRESENTATION_ExOth/Makefile	/^equiv.log: equiv.ys$/;"	t
equiv_bit_t	yosys/passes/sat/freduce.cc	/^struct equiv_bit_t$/;"	s	file:
equiv_bits	yosys/passes/equiv/equiv_struct.cc	/^	SigMap equiv_bits;$/;"	m	struct:EquivStructWorker	typeref:typename:SigMap	file:
equiv_cell	yosys/passes/equiv/equiv_simple.cc	/^	Cell *equiv_cell;$/;"	m	struct:EquivSimpleWorker	typeref:typename:Cell *	file:
equiv_cells	yosys/passes/equiv/equiv_mark.cc	/^	pool<IdString> edge_cells, equiv_cells;$/;"	m	struct:EquivMarkWorker	typeref:typename:pool<IdString>	file:
equiv_cells	yosys/passes/equiv/equiv_simple.cc	/^	const vector<Cell*> &equiv_cells;$/;"	m	struct:EquivSimpleWorker	typeref:typename:const vector<Cell * > &	file:
equiv_mod	yosys/passes/equiv/equiv_make.cc	/^	Module *gold_mod, *gate_mod, *equiv_mod;$/;"	m	struct:EquivMakeWorker	typeref:typename:Module *	file:
eqx_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> eqx_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
eqx_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> eqx_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
erase	yosys/frontends/verilog/preproc.cc	/^void define_map_t::erase(const std::string &name)$/;"	f	class:define_map_t	typeref:typename:void
erase	yosys/kernel/hashlib.h	/^	int erase(const K &key)$/;"	f	class:hashlib::dict	typeref:typename:int
erase	yosys/kernel/hashlib.h	/^	int erase(const K &key)$/;"	f	class:hashlib::pool	typeref:typename:int
erase	yosys/kernel/hashlib.h	/^	iterator erase(iterator it)$/;"	f	class:hashlib::dict	typeref:typename:iterator
erase	yosys/kernel/hashlib.h	/^	iterator erase(iterator it)$/;"	f	class:hashlib::pool	typeref:typename:iterator
erase	yosys/kernel/sigtools.h	/^	void erase(const RTLIL::SigSpec &sig, T data)$/;"	f	struct:SigSet	typeref:typename:void
erase	yosys/kernel/sigtools.h	/^	void erase(const RTLIL::SigSpec &sig, const std::set<T> &data)$/;"	f	struct:SigSet	typeref:typename:void
erase	yosys/kernel/sigtools.h	/^	void erase(const RTLIL::SigSpec& sig)$/;"	f	struct:SigSet	typeref:typename:void
err	yosys/libs/json11/json11.cpp	/^    string &err;$/;"	m	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:string &	file:
errmsg	yosys/kernel/driver.cc	/^const char *errmsg()$/;"	f	typeref:typename:const char *
error	yosys/kernel/rtlil.cc	/^		void error(int linenr)$/;"	f	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:void	file:
error	yosys/passes/techmap/libparse.cc	/^void LibertyParser::error()$/;"	f	class:LibertyParser	typeref:typename:void
error	yosys/passes/techmap/libparse.cc	/^void LibertyParser::error(const std::string &str)$/;"	f	class:LibertyParser	typeref:typename:void
error_on_dpi_function	yosys/frontends/verilog/verilog_frontend.cc	/^static void error_on_dpi_function(AST::AstNode *node)$/;"	f	typeref:typename:void	file:
errors	yosys/passes/sat/eval.cc	/^	int counter, errors;$/;"	m	struct:BruteForceEquivChecker	typeref:typename:int	file:
esc	yosys/libs/json11/json11.cpp	/^static inline string esc(char c) {$/;"	f	namespace:json11	typeref:typename:string	file:
escape	yosys/passes/cmds/show.cc	/^	const char *escape(std::string id, bool is_name = false)$/;"	f	struct:ShowWorker	typeref:typename:const char *	file:
escape_cxx_string	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^std::string escape_cxx_string(const std::string &input)$/;"	f	typeref:typename:std::string
escape_filename_spaces	yosys/kernel/yosys.cc	/^std::string escape_filename_spaces(const std::string& filename)$/;"	f	typeref:typename:std::string
escape_html	yosys/kernel/register.cc	/^	void escape_html(std::string &html)$/;"	f	struct:HelpPass	typeref:typename:void	file:
escape_id	yosys/kernel/rtlil.h	/^	static inline std::string escape_id(const std::string &str) {$/;"	f	namespace:RTLIL	typeref:typename:std::string
escape_seq_state	yosys/passes/techmap/abc.cc	/^	int escape_seq_state;$/;"	m	struct:abc_output_filter	typeref:typename:int	file:
escape_seq_state	yosys/passes/techmap/abc9_exe.cc	/^	int escape_seq_state;$/;"	m	struct:abc9_output_filter	typeref:typename:int	file:
escape_string	yosys/backends/jny/jny.cc	/^        string escape_string(string str) {$/;"	f	struct:JnyWriter	typeref:typename:string	file:
escape_tex	yosys/kernel/register.cc	/^	void escape_tex(std::string &tex)$/;"	f	struct:HelpPass	typeref:typename:void	file:
etools_path	yosys/techlibs/easic/synth_easic.cc	/^	string top_opt, vlog_file, etools_path;$/;"	m	struct:SynthEasicPass	typeref:typename:string	file:
eval	yosys/backends/cxxrtl/cxxrtl.h	/^	std::function<void()> eval;$/;"	m	struct:_cxxrtl_outline	typeref:typename:std::function<void ()>
eval	yosys/frontends/aiger/aigerparse.cc	/^	bool eval(RTLIL::Cell *cell)$/;"	f	struct:ConstEvalAig	typeref:typename:bool	file:
eval	yosys/frontends/aiger/aigerparse.cc	/^	bool eval(RTLIL::SigBit &sig)$/;"	f	struct:ConstEvalAig	typeref:typename:bool	file:
eval	yosys/kernel/celltypes.h	/^	static RTLIL::Const eval(RTLIL::Cell *cell, const RTLIL::Const &arg1, const RTLIL::Const &arg2,/;"	f	struct:CellTypes	typeref:typename:RTLIL::Const
eval	yosys/kernel/celltypes.h	/^	static RTLIL::Const eval(RTLIL::IdString type, const RTLIL::Const &arg1, const RTLIL::Const &ar/;"	f	struct:CellTypes	typeref:typename:RTLIL::Const
eval	yosys/kernel/consteval.h	/^	bool eval(RTLIL::Cell *cell, RTLIL::SigSpec &undef)$/;"	f	struct:ConstEval	typeref:typename:bool
eval	yosys/kernel/consteval.h	/^	bool eval(RTLIL::SigSpec &sig)$/;"	f	struct:ConstEval	typeref:typename:bool
eval	yosys/kernel/consteval.h	/^	bool eval(RTLIL::SigSpec &sig, RTLIL::SigSpec &undef, RTLIL::Cell *busy_cell = NULL)$/;"	f	struct:ConstEval	typeref:typename:bool
eval	yosys/kernel/macc.h	/^	bool eval(RTLIL::Const &result) const$/;"	f	struct:Macc	typeref:typename:bool
eval	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::eval(int id, const std::vector<int> &values) const$/;"	f	class:ezSAT	typeref:typename:int
eval_cell	yosys/backends/simplec/simplec.cc	/^	void eval_cell(HierDirtyFlags *work, Cell *cell)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
eval_const_function	yosys/frontends/ast/simplify.cc	/^AstNode *AstNode::eval_const_function(AstNode *fcall, bool must_succeed)$/;"	f	class:AstNode	typeref:typename:AstNode *
eval_converges	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Module*, bool> eval_converges;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<const RTLIL::Module *,bool>	file:
eval_dirty	yosys/backends/simplec/simplec.cc	/^	void eval_dirty(HierDirtyFlags *work)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
eval_init	yosys/backends/simplec/simplec.cc	/^	void eval_init(HierDirtyFlags *work, vector<string> &preamble)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
eval_mux	yosys/passes/opt/opt_muxtree.cc	/^	void eval_mux(knowledge_t &knowledge, int mux_idx, bool do_replace_known, bool do_enable_ports,/;"	f	struct:OptMuxtreeWorker	typeref:typename:void	file:
eval_mux_port	yosys/passes/opt/opt_muxtree.cc	/^	void eval_mux_port(knowledge_t &knowledge, int mux_idx, int port_idx, bool do_replace_known, bo/;"	f	struct:OptMuxtreeWorker	typeref:typename:void	file:
eval_not	yosys/kernel/celltypes.h	/^	static RTLIL::Const eval_not(RTLIL::Const v)$/;"	f	struct:CellTypes	typeref:typename:RTLIL::Const
eval_root_mux	yosys/passes/opt/opt_muxtree.cc	/^	void eval_root_mux(int mux_idx)$/;"	f	struct:OptMuxtreeWorker	typeref:typename:void	file:
eval_select_args	yosys/passes/cmds/select.cc	/^RTLIL::Selection eval_select_args(const vector<string> &args, RTLIL::Design *design)$/;"	f	typeref:typename:RTLIL::Selection
eval_select_op	yosys/passes/cmds/select.cc	/^void eval_select_op(vector<RTLIL::Selection> &work, const string &op, RTLIL::Design *design)$/;"	f	typeref:typename:void
eval_sticky_dirty	yosys/backends/simplec/simplec.cc	/^	void eval_sticky_dirty(HierDirtyFlags *work)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
evaluate_lut	yosys/passes/opt/opt_lut.cc	/^	bool evaluate_lut(RTLIL::Cell *lut, dict<SigBit, bool> inputs)$/;"	f	struct:OptLutWorker	typeref:typename:bool	file:
event2vl	yosys/passes/techmap/libparse.cc	/^void event2vl(LibertyAst *ast, std::string &edge, std::string &expr)$/;"	f	typeref:typename:void
eventually_property	yosys/frontends/verific/verificsva.cc	/^	bool eventually_property(Net *&net, SigBit &trig)$/;"	f	struct:VerificSvaImporter	typeref:typename:bool	file:
ex_input_eq	yosys/backends/smt2/smt2.cc	/^	vector<string> ex_state_eq, ex_input_eq;$/;"	m	struct:Smt2Worker	typeref:typename:vector<string>	file:
ex_state_eq	yosys/backends/smt2/smt2.cc	/^	vector<string> ex_state_eq, ex_input_eq;$/;"	m	struct:Smt2Worker	typeref:typename:vector<string>	file:
example.edif	yosys/examples/osu035/Makefile	/^example.edif: example.ys example.v example.constr osu035_stdcells.lib$/;"	t
excl_db	yosys/passes/opt/muxpack.cc	/^	ExclusiveDatabase excl_db;$/;"	m	struct:MuxpackWorker	typeref:typename:ExclusiveDatabase	file:
exclusive_ctrls	yosys/passes/fsm/fsm_extract.cc	/^static std::map<RTLIL::SigBit, std::set<RTLIL::SigBit>> exclusive_ctrls;$/;"	v	typeref:typename:std::map<RTLIL::SigBit,std::set<RTLIL::SigBit>>	file:
exe_cmd	yosys/passes/techmap/abc9.cc	/^	std::stringstream exe_cmd;$/;"	m	struct:Abc9Pass	typeref:typename:std::stringstream	file:
execute	yosys/backends/aiger/aiger.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:AigerBackend	typeref:typename:void	file:
execute	yosys/backends/aiger/xaiger.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:XAigerBackend	typeref:typename:void	file:
execute	yosys/backends/blif/blif.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:BlifBackend	typeref:typename:void	file:
execute	yosys/backends/btor/btor.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:BtorBackend	typeref:typename:void	file:
execute	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:CxxrtlBackend	typeref:typename:void	file:
execute	yosys/backends/edif/edif.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:EdifBackend	typeref:typename:void	file:
execute	yosys/backends/firrtl/firrtl.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:FirrtlBackend	typeref:typename:void	file:
execute	yosys/backends/intersynth/intersynth.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:IntersynthBackend	typeref:typename:void	file:
execute	yosys/backends/jny/jny.cc	/^    void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::D/;"	f	struct:JnyBackend	typeref:typename:void	file:
execute	yosys/backends/jny/jny.cc	/^    void execute(std::vector<std::string> args, RTLIL::Design *design) override {$/;"	f	struct:JnyPass	typeref:typename:void	file:
execute	yosys/backends/json/json.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:JsonBackend	typeref:typename:void	file:
execute	yosys/backends/json/json.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:JsonPass	typeref:typename:void	file:
execute	yosys/backends/protobuf/protobuf.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:ProtobufBackend	typeref:typename:void	file:
execute	yosys/backends/protobuf/protobuf.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProtobufPass	typeref:typename:void	file:
execute	yosys/backends/rtlil/rtlil_backend.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:IlangBackend	typeref:typename:void	file:
execute	yosys/backends/rtlil/rtlil_backend.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:RTLILBackend	typeref:typename:void	file:
execute	yosys/backends/rtlil/rtlil_backend.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:DumpPass	typeref:typename:void	file:
execute	yosys/backends/simplec/simplec.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:SimplecBackend	typeref:typename:void	file:
execute	yosys/backends/smt2/smt2.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:Smt2Backend	typeref:typename:void	file:
execute	yosys/backends/smv/smv.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:SmvBackend	typeref:typename:void	file:
execute	yosys/backends/spice/spice.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:SpiceBackend	typeref:typename:void	file:
execute	yosys/backends/table/table.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:TableBackend	typeref:typename:void	file:
execute	yosys/backends/verilog/verilog_backend.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:VerilogBackend	typeref:typename:void	file:
execute	yosys/examples/cxx-api/evaldemo.cc	/^	void execute(vector<string>, Design *design) override$/;"	f	struct:EvalDemoPass	typeref:typename:void	file:
execute	yosys/frontends/aiger/aigerparse.cc	/^	void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:AigerFrontend	typeref:typename:void	file:
execute	yosys/frontends/blif/blifparse.cc	/^	void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:BlifFrontend	typeref:typename:void	file:
execute	yosys/frontends/json/jsonparse.cc	/^	void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:JsonFrontend	typeref:typename:void	file:
execute	yosys/frontends/liberty/liberty.cc	/^	void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:LibertyFrontend	typeref:typename:void	file:
execute	yosys/frontends/rpc/rpc_frontend.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:RpcFrontend	typeref:typename:void	file:
execute	yosys/frontends/rtlil/rtlil_frontend.cc	/^	void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:IlangFrontend	typeref:typename:void	file:
execute	yosys/frontends/rtlil/rtlil_frontend.cc	/^	void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:RTLILFrontend	typeref:typename:void	file:
execute	yosys/frontends/verific/verific.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ReadPass	typeref:typename:void	file:
execute	yosys/frontends/verific/verific.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:VerificPass	typeref:typename:void	file:
execute	yosys/frontends/verific/verific.cc	/^	void execute(std::vector<std::string>, RTLIL::Design *) override {$/;"	f	struct:VerificPass	typeref:typename:void	file:
execute	yosys/frontends/verilog/verilog_frontend.cc	/^	void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:VerilogFrontend	typeref:typename:void	file:
execute	yosys/frontends/verilog/verilog_frontend.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:VerilogDefines	typeref:typename:void	file:
execute	yosys/frontends/verilog/verilog_frontend.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design*) override$/;"	f	struct:VerilogDefaults	typeref:typename:void	file:
execute	yosys/kernel/register.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design*) override$/;"	f	struct:EchoPass	typeref:typename:void	file:
execute	yosys/kernel/register.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design*) override$/;"	f	struct:HelpPass	typeref:typename:void	file:
execute	yosys/kernel/register.cc	/^void Backend::execute(std::vector<std::string> args, RTLIL::Design *design)$/;"	f	class:Backend	typeref:typename:void
execute	yosys/kernel/register.cc	/^void Frontend::execute(std::vector<std::string> args, RTLIL::Design *design)$/;"	f	class:Frontend	typeref:typename:void
execute	yosys/kernel/yosys.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *) override {$/;"	f	struct:TclPass	typeref:typename:void	file:
execute	yosys/kernel/yosys.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override {$/;"	f	struct:HistoryPass	typeref:typename:void	file:
execute	yosys/kernel/yosys.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override {$/;"	f	struct:ShellPass	typeref:typename:void	file:
execute	yosys/kernel/yosys.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ScriptCmdPass	typeref:typename:void	file:
execute	yosys/manual/CHAPTER_Prog/stubnets.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:StubnetsPass	typeref:typename:void	file:
execute	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^    void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MyPass	typeref:typename:void	file:
execute	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^    void execute(std::vector<std::string>, RTLIL::Design *design) override$/;"	f	struct:Test1Pass	typeref:typename:void	file:
execute	yosys/manual/PRESENTATION_Prog/my_cmd.cc	/^    void execute(std::vector<std::string>, RTLIL::Design *design) override$/;"	f	struct:Test2Pass	typeref:typename:void	file:
execute	yosys/passes/cmds/add.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:AddPass	typeref:typename:void	file:
execute	yosys/passes/cmds/autoname.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:AutonamePass	typeref:typename:void	file:
execute	yosys/passes/cmds/blackbox.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:BlackboxPass	typeref:typename:void	file:
execute	yosys/passes/cmds/bugpoint.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:BugpointPass	typeref:typename:void	file:
execute	yosys/passes/cmds/check.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:CheckPass	typeref:typename:void	file:
execute	yosys/passes/cmds/chformal.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ChformalPass	typeref:typename:void	file:
execute	yosys/passes/cmds/chtype.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ChtypePass	typeref:typename:void	file:
execute	yosys/passes/cmds/clean_zerowidth.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:CleanZeroWidthPass	typeref:typename:void	file:
execute	yosys/passes/cmds/connect.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ConnectPass	typeref:typename:void	file:
execute	yosys/passes/cmds/connwrappers.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ConnwrappersPass	typeref:typename:void	file:
execute	yosys/passes/cmds/copy.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:CopyPass	typeref:typename:void	file:
execute	yosys/passes/cmds/cover.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:CoverPass	typeref:typename:void	file:
execute	yosys/passes/cmds/delete.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:DeletePass	typeref:typename:void	file:
execute	yosys/passes/cmds/design.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:DesignPass	typeref:typename:void	file:
execute	yosys/passes/cmds/edgetypes.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:EdgetypePass	typeref:typename:void	file:
execute	yosys/passes/cmds/exec.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ExecPass	typeref:typename:void	file:
execute	yosys/passes/cmds/glift.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:GliftPass	typeref:typename:void	file:
execute	yosys/passes/cmds/logcmd.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design*) override$/;"	f	struct:LogPass	typeref:typename:void	file:
execute	yosys/passes/cmds/logger.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design * design) override$/;"	f	struct:LoggerPass	typeref:typename:void	file:
execute	yosys/passes/cmds/ltp.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:LtpPass	typeref:typename:void	file:
execute	yosys/passes/cmds/plugin.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:PluginPass	typeref:typename:void	file:
execute	yosys/passes/cmds/portlist.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:PortlistPass	typeref:typename:void	file:
execute	yosys/passes/cmds/printattrs.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:PrintAttrsPass	typeref:typename:void	file:
execute	yosys/passes/cmds/qwp.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:QwpPass	typeref:typename:void	file:
execute	yosys/passes/cmds/rename.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:RenamePass	typeref:typename:void	file:
execute	yosys/passes/cmds/scatter.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ScatterPass	typeref:typename:void	file:
execute	yosys/passes/cmds/scc.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SccPass	typeref:typename:void	file:
execute	yosys/passes/cmds/scratchpad.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ScratchpadPass	typeref:typename:void	file:
execute	yosys/passes/cmds/select.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:CdPass	typeref:typename:void	file:
execute	yosys/passes/cmds/select.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:LsPass	typeref:typename:void	file:
execute	yosys/passes/cmds/select.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SelectPass	typeref:typename:void	file:
execute	yosys/passes/cmds/setattr.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ChparamPass	typeref:typename:void	file:
execute	yosys/passes/cmds/setattr.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SetattrPass	typeref:typename:void	file:
execute	yosys/passes/cmds/setattr.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SetparamPass	typeref:typename:void	file:
execute	yosys/passes/cmds/setattr.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:WbflipPass	typeref:typename:void	file:
execute	yosys/passes/cmds/setundef.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SetundefPass	typeref:typename:void	file:
execute	yosys/passes/cmds/show.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ShowPass	typeref:typename:void	file:
execute	yosys/passes/cmds/splice.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SplicePass	typeref:typename:void	file:
execute	yosys/passes/cmds/splitnets.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SplitnetsPass	typeref:typename:void	file:
execute	yosys/passes/cmds/sta.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:StaPass	typeref:typename:void	file:
execute	yosys/passes/cmds/stat.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:StatPass	typeref:typename:void	file:
execute	yosys/passes/cmds/tee.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:TeePass	typeref:typename:void	file:
execute	yosys/passes/cmds/torder.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:TorderPass	typeref:typename:void	file:
execute	yosys/passes/cmds/trace.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:DebugPass	typeref:typename:void	file:
execute	yosys/passes/cmds/trace.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:TracePass	typeref:typename:void	file:
execute	yosys/passes/cmds/write_file.cc	/^	void execute(std::istream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:WriteFileFrontend	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_add.cc	/^	void execute(std::vector<std::string> args, Design *design) override$/;"	f	struct:EquivAddPass	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_induct.cc	/^	void execute(std::vector<std::string> args, Design *design) override$/;"	f	struct:EquivInductPass	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_make.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:EquivMakePass	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_mark.cc	/^	void execute(std::vector<std::string> args, Design *design) override$/;"	f	struct:EquivMarkPass	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_miter.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:EquivMiterPass	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_opt.cc	/^	void execute(std::vector < std::string > args, RTLIL::Design * design) override$/;"	f	struct:EquivOptPass	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_purge.cc	/^	void execute(std::vector<std::string> args, Design *design) override$/;"	f	struct:EquivPurgePass	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_remove.cc	/^	void execute(std::vector<std::string> args, Design *design) override$/;"	f	struct:EquivRemovePass	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_simple.cc	/^	void execute(std::vector<std::string> args, Design *design) override$/;"	f	struct:EquivSimplePass	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_status.cc	/^	void execute(std::vector<std::string> args, Design *design) override$/;"	f	struct:EquivStatusPass	typeref:typename:void	file:
execute	yosys/passes/equiv/equiv_struct.cc	/^	void execute(std::vector<std::string> args, Design *design) override$/;"	f	struct:EquivStructPass	typeref:typename:void	file:
execute	yosys/passes/fsm/fsm.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FsmPass	typeref:typename:void	file:
execute	yosys/passes/fsm/fsm_detect.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FsmDetectPass	typeref:typename:void	file:
execute	yosys/passes/fsm/fsm_expand.cc	/^	void execute()$/;"	f	struct:FsmExpand	typeref:typename:void	file:
execute	yosys/passes/fsm/fsm_expand.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FsmExpandPass	typeref:typename:void	file:
execute	yosys/passes/fsm/fsm_export.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FsmExportPass	typeref:typename:void	file:
execute	yosys/passes/fsm/fsm_extract.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FsmExtractPass	typeref:typename:void	file:
execute	yosys/passes/fsm/fsm_info.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FsmInfoPass	typeref:typename:void	file:
execute	yosys/passes/fsm/fsm_map.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FsmMapPass	typeref:typename:void	file:
execute	yosys/passes/fsm/fsm_opt.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FsmOptPass	typeref:typename:void	file:
execute	yosys/passes/fsm/fsm_recode.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FsmRecodePass	typeref:typename:void	file:
execute	yosys/passes/hierarchy/hierarchy.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:HierarchyPass	typeref:typename:void	file:
execute	yosys/passes/hierarchy/submod.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SubmodPass	typeref:typename:void	file:
execute	yosys/passes/hierarchy/uniquify.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:UniquifyPass	typeref:typename:void	file:
execute	yosys/passes/memory/memory.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MemoryPass	typeref:typename:void	file:
execute	yosys/passes/memory/memory_bram.cc	/^	void execute(vector<string> args, Design *design) override$/;"	f	struct:MemoryBramPass	typeref:typename:void	file:
execute	yosys/passes/memory/memory_collect.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override {$/;"	f	struct:MemoryCollectPass	typeref:typename:void	file:
execute	yosys/passes/memory/memory_dff.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MemoryDffPass	typeref:typename:void	file:
execute	yosys/passes/memory/memory_map.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MemoryMapPass	typeref:typename:void	file:
execute	yosys/passes/memory/memory_memx.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override {$/;"	f	struct:MemoryMemxPass	typeref:typename:void	file:
execute	yosys/passes/memory/memory_narrow.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MemoryNarrowPass	typeref:typename:void	file:
execute	yosys/passes/memory/memory_nordff.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MemoryNordffPass	typeref:typename:void	file:
execute	yosys/passes/memory/memory_share.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override {$/;"	f	struct:MemorySharePass	typeref:typename:void	file:
execute	yosys/passes/memory/memory_unpack.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override {$/;"	f	struct:MemoryUnpackPass	typeref:typename:void	file:
execute	yosys/passes/opt/muxpack.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MuxpackPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_clean.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:CleanPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_clean.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptCleanPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_demorgan.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptDemorganPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_dff.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptDffPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_expr.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptExprPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_lut.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptLutPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_lut_ins.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptLutInsPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_mem.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptMemPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_mem_feedback.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override {$/;"	f	struct:OptMemFeedbackPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_mem_priority.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override {$/;"	f	struct:OptMemPriorityPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_mem_widen.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptMemWidenPass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_merge.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptMergePass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_muxtree.cc	/^	void execute(vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptMuxtreePass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_reduce.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptReducePass	typeref:typename:void	file:
execute	yosys/passes/opt/opt_share.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OptSharePass	typeref:typename:void	file:
execute	yosys/passes/opt/pmux2shiftx.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:OnehotPass	typeref:typename:void	file:
execute	yosys/passes/opt/pmux2shiftx.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Pmux2ShiftxPass	typeref:typename:void	file:
execute	yosys/passes/opt/rmports.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:RmportsPassPass	typeref:typename:void	file:
execute	yosys/passes/opt/share.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SharePass	typeref:typename:void	file:
execute	yosys/passes/opt/wreduce.cc	/^	void execute(std::vector<std::string> args, Design *design) override$/;"	f	struct:WreducePass	typeref:typename:void	file:
execute	yosys/passes/pmgen/ice40_dsp.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Ice40DspPass	typeref:typename:void	file:
execute	yosys/passes/pmgen/ice40_wrapcarry.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Ice40WrapCarryPass	typeref:typename:void	file:
execute	yosys/passes/pmgen/peepopt.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:PeepoptPass	typeref:typename:void	file:
execute	yosys/passes/pmgen/test_pmgen.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:TestPmgenPass	typeref:typename:void	file:
execute	yosys/passes/pmgen/xilinx_dsp.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:XilinxDspPass	typeref:typename:void	file:
execute	yosys/passes/pmgen/xilinx_srl.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:XilinxSrlPass	typeref:typename:void	file:
execute	yosys/passes/proc/proc.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProcPass	typeref:typename:void	file:
execute	yosys/passes/proc/proc_arst.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProcArstPass	typeref:typename:void	file:
execute	yosys/passes/proc/proc_clean.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProcCleanPass	typeref:typename:void	file:
execute	yosys/passes/proc/proc_dff.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProcDffPass	typeref:typename:void	file:
execute	yosys/passes/proc/proc_dlatch.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProcDlatchPass	typeref:typename:void	file:
execute	yosys/passes/proc/proc_init.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProcInitPass	typeref:typename:void	file:
execute	yosys/passes/proc/proc_memwr.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProcMemWrPass	typeref:typename:void	file:
execute	yosys/passes/proc/proc_mux.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProcMuxPass	typeref:typename:void	file:
execute	yosys/passes/proc/proc_prune.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProcPrunePass	typeref:typename:void	file:
execute	yosys/passes/proc/proc_rmdead.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ProcRmdeadPass	typeref:typename:void	file:
execute	yosys/passes/sat/assertpmux.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:AssertpmuxPass	typeref:typename:void	file:
execute	yosys/passes/sat/async2sync.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Async2syncPass	typeref:typename:void	file:
execute	yosys/passes/sat/clk2fflogic.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Clk2fflogicPass	typeref:typename:void	file:
execute	yosys/passes/sat/cutpoint.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:CutpointPass	typeref:typename:void	file:
execute	yosys/passes/sat/eval.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:EvalPass	typeref:typename:void	file:
execute	yosys/passes/sat/expose.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ExposePass	typeref:typename:void	file:
execute	yosys/passes/sat/fmcombine.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FmcombinePass	typeref:typename:void	file:
execute	yosys/passes/sat/fminit.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FminitPass	typeref:typename:void	file:
execute	yosys/passes/sat/freduce.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FreducePass	typeref:typename:void	file:
execute	yosys/passes/sat/miter.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MiterPass	typeref:typename:void	file:
execute	yosys/passes/sat/mutate.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MutatePass	typeref:typename:void	file:
execute	yosys/passes/sat/qbfsat.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:QbfSatPass	typeref:typename:void	file:
execute	yosys/passes/sat/sat.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SatPass	typeref:typename:void	file:
execute	yosys/passes/sat/sim.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Fst2TbPass	typeref:typename:void	file:
execute	yosys/passes/sat/sim.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SimPass	typeref:typename:void	file:
execute	yosys/passes/sat/supercover.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SupercoverPass	typeref:typename:void	file:
execute	yosys/passes/techmap/abc.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:AbcPass	typeref:typename:void	file:
execute	yosys/passes/techmap/abc9.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Abc9Pass	typeref:typename:void	file:
execute	yosys/passes/techmap/abc9_exe.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Abc9ExePass	typeref:typename:void	file:
execute	yosys/passes/techmap/abc9_ops.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Abc9OpsPass	typeref:typename:void	file:
execute	yosys/passes/techmap/aigmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:AigmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/alumacc.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:AlumaccPass	typeref:typename:void	file:
execute	yosys/passes/techmap/attrmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:AttrmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/attrmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ParamapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/attrmvcp.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:AttrmvcpPass	typeref:typename:void	file:
execute	yosys/passes/techmap/bmuxmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:BmuxmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/clkbufmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ClkbufmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/deminout.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:DeminoutPass	typeref:typename:void	file:
execute	yosys/passes/techmap/demuxmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:DemuxmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/dffinit.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:DffinitPass	typeref:typename:void	file:
execute	yosys/passes/techmap/dfflegalize.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
execute	yosys/passes/techmap/dfflibmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:DfflibmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/dffunmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:DffunmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/extract.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ExtractPass	typeref:typename:void	file:
execute	yosys/passes/techmap/extract_counter.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ExtractCounterPass	typeref:typename:void	file:
execute	yosys/passes/techmap/extract_fa.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ExtractFaPass	typeref:typename:void	file:
execute	yosys/passes/techmap/extract_reduce.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ExtractReducePass	typeref:typename:void	file:
execute	yosys/passes/techmap/extractinv.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ExtractinvPass	typeref:typename:void	file:
execute	yosys/passes/techmap/flatten.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FlattenPass	typeref:typename:void	file:
execute	yosys/passes/techmap/flowmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:FlowmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/hilomap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:HilomapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/insbuf.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:InsbufPass	typeref:typename:void	file:
execute	yosys/passes/techmap/iopadmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:IopadmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/lut2mux.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Lut2muxPass	typeref:typename:void	file:
execute	yosys/passes/techmap/maccmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MaccmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/muxcover.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:MuxcoverPass	typeref:typename:void	file:
execute	yosys/passes/techmap/nlutmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:NlutmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/pmuxtree.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:PmuxtreePass	typeref:typename:void	file:
execute	yosys/passes/techmap/shregmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ShregmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/simplemap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SimplemapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/techmap.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:TechmapPass	typeref:typename:void	file:
execute	yosys/passes/techmap/tribuf.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:TribufPass	typeref:typename:void	file:
execute	yosys/passes/techmap/zinit.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:ZinitPass	typeref:typename:void	file:
execute	yosys/passes/tests/test_abcloop.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design*) override$/;"	f	struct:TestAbcloopPass	typeref:typename:void	file:
execute	yosys/passes/tests/test_autotb.cc	/^	void execute(std::ostream *&f, std::string filename, std::vector<std::string> args, RTLIL::Desi/;"	f	struct:TestAutotbBackend	typeref:typename:void	file:
execute	yosys/passes/tests/test_cell.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design*) override$/;"	f	struct:TestCellPass	typeref:typename:void	file:
execute	yosys/techlibs/achronix/synth_achronix.cc	/^  void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthAchronixPass	typeref:typename:void	file:
execute	yosys/techlibs/anlogic/anlogic_eqn.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:AnlogicEqnPass	typeref:typename:void	file:
execute	yosys/techlibs/anlogic/anlogic_fixcarry.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:AnlogicCarryFixPass	typeref:typename:void	file:
execute	yosys/techlibs/anlogic/synth_anlogic.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthAnlogicPass	typeref:typename:void	file:
execute	yosys/techlibs/common/prep.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:PrepPass	typeref:typename:void	file:
execute	yosys/techlibs/common/synth.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthPass	typeref:typename:void	file:
execute	yosys/techlibs/coolrunner2/coolrunner2_fixup.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Coolrunner2FixupPass	typeref:typename:void	file:
execute	yosys/techlibs/coolrunner2/coolrunner2_sop.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Coolrunner2SopPass	typeref:typename:void	file:
execute	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthCoolrunner2Pass	typeref:typename:void	file:
execute	yosys/techlibs/easic/synth_easic.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthEasicPass	typeref:typename:void	file:
execute	yosys/techlibs/ecp5/ecp5_gsr.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Ecp5GsrPass	typeref:typename:void	file:
execute	yosys/techlibs/ecp5/synth_ecp5.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthEcp5Pass	typeref:typename:void	file:
execute	yosys/techlibs/efinix/efinix_fixcarry.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:EfinixCarryFixPass	typeref:typename:void	file:
execute	yosys/techlibs/efinix/synth_efinix.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthEfinixPass	typeref:typename:void	file:
execute	yosys/techlibs/gatemate/synth_gatemate.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthGateMatePass	typeref:typename:void	file:
execute	yosys/techlibs/gowin/synth_gowin.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthGowinPass	typeref:typename:void	file:
execute	yosys/techlibs/greenpak4/greenpak4_dffinv.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Greenpak4DffInvPass	typeref:typename:void	file:
execute	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthGreenPAK4Pass	typeref:typename:void	file:
execute	yosys/techlibs/ice40/ice40_braminit.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Ice40BRAMInitPass	typeref:typename:void	file:
execute	yosys/techlibs/ice40/ice40_opt.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:Ice40OptPass	typeref:typename:void	file:
execute	yosys/techlibs/ice40/synth_ice40.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthIce40Pass	typeref:typename:void	file:
execute	yosys/techlibs/intel/synth_intel.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthIntelPass	typeref:typename:void	file:
execute	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthIntelALMPass	typeref:typename:void	file:
execute	yosys/techlibs/machxo2/synth_machxo2.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthMachXO2Pass	typeref:typename:void	file:
execute	yosys/techlibs/nexus/synth_nexus.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthNexusPass	typeref:typename:void	file:
execute	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthQuickLogicPass	typeref:typename:void	file:
execute	yosys/techlibs/sf2/synth_sf2.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthSf2Pass	typeref:typename:void	file:
execute	yosys/techlibs/xilinx/synth_xilinx.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:SynthXilinxPass	typeref:typename:void	file:
execute	yosys/techlibs/xilinx/xilinx_dffopt.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:XilinxDffOptPass	typeref:typename:void	file:
execute	yosys/tests/various/plugin.cc	/^	void execute(std::vector<std::string> args, RTLIL::Design *design) override$/;"	f	struct:TestPass	typeref:typename:void	file:
execute_eqpmux	yosys/passes/pmgen/test_pmgen.cc	/^	void execute_eqpmux(std::vector<std::string> args, RTLIL::Design *design)$/;"	f	struct:TestPmgenPass	typeref:typename:void	file:
execute_generate	yosys/passes/pmgen/test_pmgen.cc	/^	void execute_generate(std::vector<std::string> args, RTLIL::Design *design)$/;"	f	struct:TestPmgenPass	typeref:typename:void	file:
execute_reduce_chain	yosys/passes/pmgen/test_pmgen.cc	/^	void execute_reduce_chain(std::vector<std::string> args, RTLIL::Design *design)$/;"	f	struct:TestPmgenPass	typeref:typename:void	file:
execute_reduce_tree	yosys/passes/pmgen/test_pmgen.cc	/^	void execute_reduce_tree(std::vector<std::string> args, RTLIL::Design *design)$/;"	f	struct:TestPmgenPass	typeref:typename:void	file:
expand	yosys/kernel/sigtools.h	/^	void expand(const RTLIL::SigSpec &from, const RTLIL::SigSpec &to)$/;"	f	struct:SigPool	typeref:typename:void
expand_genblock	yosys/frontends/ast/simplify.cc	/^void AstNode::expand_genblock(const std::string &prefix)$/;"	f	class:AstNode	typeref:typename:void
expand_interfaces	yosys/frontends/ast/ast.cc	/^void AstModule::expand_interfaces(RTLIL::Design *design, const dict<RTLIL::IdString, RTLIL::Modu/;"	f	class:AstModule	typeref:typename:void
expand_interfaces	yosys/kernel/rtlil.cc	/^void RTLIL::Module::expand_interfaces(RTLIL::Design *, const dict<RTLIL::IdString, RTLIL::Module/;"	f	class:RTLIL::Module	typeref:typename:void
expand_module	yosys/passes/hierarchy/hierarchy.cc	/^bool expand_module(RTLIL::Design *design, RTLIL::Module *module, bool flag_check, bool flag_simc/;"	f	typeref:typename:bool
expand_rule_t	yosys/passes/cmds/select.cc	/^	struct expand_rule_t {$/;"	s	namespace:__anon240a0d430111	file:
expect	yosys/kernel/hashlib.h	/^	void expect(const K &key, int i)$/;"	f	class:hashlib::idict	typeref:typename:void
expect	yosys/libs/fst/lz4.cc	/^#define expect(/;"	d	file:
expect	yosys/libs/json11/json11.cpp	/^    Json expect(const string &expected, Json res) {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:Json	file:
expect_stdout_elem	yosys/passes/cmds/exec.cc	/^			expect_stdout_elem() : matched(false), polarity(true), str(), re(){};$/;"	f	struct:ExecPass::execute::expect_stdout_elem	file:
expect_stdout_elem	yosys/passes/cmds/exec.cc	/^		struct expect_stdout_elem {$/;"	s	function:ExecPass::execute	file:
expected_count	yosys/kernel/log.h	/^	int expected_count;$/;"	m	struct:LogExpectedItem	typeref:typename:int
expected_params	yosys/kernel/rtlil.cc	/^		pool<RTLIL::IdString> expected_params, expected_ports;$/;"	m	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:pool<RTLIL::IdString>	file:
expected_ports	yosys/kernel/rtlil.cc	/^		pool<RTLIL::IdString> expected_params, expected_ports;$/;"	m	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:pool<RTLIL::IdString>	file:
experimental	yosys/kernel/register.h	/^	void experimental() {$/;"	f	struct:Pass	typeref:typename:void
experimental_flag	yosys/kernel/register.h	/^	bool experimental_flag = false;$/;"	m	struct:Pass	typeref:typename:bool
explicitly_sized	yosys/frontends/ast/ast.h	/^			bool explicitly_sized;$/;"	m	struct:AST::AstNode::varinfo_t	typeref:typename:bool
explode_interface_port	yosys/frontends/ast/ast.cc	/^void AST::explode_interface_port(AstNode *module_ast, RTLIL::Module * intfmodule, std::string in/;"	f	class:AST	typeref:typename:void
export_all	yosys/kernel/sigtools.h	/^	RTLIL::SigSpec export_all() const$/;"	f	struct:SigPool	typeref:typename:RTLIL::SigSpec
export_bvop	yosys/backends/smt2/smt2.cc	/^	void export_bvop(RTLIL::Cell *cell, std::string expr, char type = 0)$/;"	f	struct:Smt2Worker	typeref:typename:void	file:
export_cell	yosys/backends/btor/btor.cc	/^	void export_cell(Cell *cell)$/;"	f	struct:BtorWorker	typeref:typename:void	file:
export_cell	yosys/backends/smt2/smt2.cc	/^	void export_cell(RTLIL::Cell *cell)$/;"	f	struct:Smt2Worker	typeref:typename:void	file:
export_gate	yosys/backends/smt2/smt2.cc	/^	void export_gate(RTLIL::Cell *cell, std::string expr)$/;"	f	struct:Smt2Worker	typeref:typename:void	file:
export_one	yosys/kernel/sigtools.h	/^	RTLIL::SigSpec export_one() const$/;"	f	struct:SigPool	typeref:typename:RTLIL::SigSpec
export_reduce	yosys/backends/smt2/smt2.cc	/^	void export_reduce(RTLIL::Cell *cell, std::string expr, bool identity_val)$/;"	f	struct:Smt2Worker	typeref:typename:void	file:
exported_cells	yosys/backends/smt2/smt2.cc	/^	std::set<RTLIL::Cell*> exported_cells, hiercells, hiercells_queue;$/;"	m	struct:Smt2Worker	typeref:typename:std::set<RTLIL::Cell * >	file:
expr	yosys/backends/cxxrtl/cxxrtl.h	/^	T &expr;$/;"	m	struct:cxxrtl::slice_expr	typeref:typename:T &
expr_base	yosys/backends/cxxrtl/cxxrtl.h	/^struct expr_base {$/;"	s	namespace:cxxrtl
expression	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::expression(OpId op, const std::vector<int> &args)$/;"	f	class:ezSAT	typeref:typename:int
expression	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::expression(OpId op, int a, int b, int c, int d, int e, int f)$/;"	f	class:ezSAT	typeref:typename:int
expression2str	yosys/libs/ezsat/ezsat.cc	/^static std::string expression2str(const std::pair<ezSAT::OpId, std::vector<int>> &data)$/;"	f	typeref:typename:std::string	file:
expressions	yosys/libs/ezsat/ezsat.h	/^	std::vector<std::pair<OpId, std::vector<int>>> expressions;$/;"	m	class:ezSAT	typeref:typename:std::vector<std::pair<OpId,std::vector<int>>>
expressionsCache	yosys/libs/ezsat/ezsat.h	/^	std::map<std::pair<OpId, std::vector<int>>, int> expressionsCache;$/;"	m	class:ezSAT	typeref:typename:std::map<std::pair<OpId,std::vector<int>>,int>
extDictSize	yosys/libs/fst/lz4.cc	/^    size_t extDictSize;$/;"	m	struct:__anon9390dffe0908	typeref:typename:size_t	file:
extend	yosys/libs/subcircuit/subcircuit.cc	/^		void extend(const NodeSet &other) {$/;"	f	struct:SubCircuit::SolverWorker::NodeSet	typeref:typename:void	file:
extendCandidate	yosys/libs/subcircuit/subcircuit.cc	/^		int extendCandidate(const NodeSet &other) const {$/;"	f	struct:SubCircuit::SolverWorker::NodeSet	typeref:typename:int	file:
extendModel	yosys/libs/minisat/SimpSolver.cc	/^void SimpSolver::extendModel()$/;"	f	class:SimpSolver	typeref:typename:void
extendSignalWidth	yosys/kernel/satgen.h	/^	void extendSignalWidth(std::vector<int> &vec_a, std::vector<int> &vec_b, RTLIL::Cell *cell, siz/;"	f	struct:SatGen	typeref:typename:void
extendSignalWidth	yosys/kernel/satgen.h	/^	void extendSignalWidth(std::vector<int> &vec_a, std::vector<int> &vec_b, std::vector<int> &vec_/;"	f	struct:SatGen	typeref:typename:void
extendSignalWidthUnary	yosys/kernel/satgen.h	/^	void extendSignalWidthUnary(std::vector<int> &vec_a, std::vector<int> &vec_y, RTLIL::Cell *cell/;"	f	struct:SatGen	typeref:typename:void
extend_model	yosys/libs/minisat/SimpSolver.h	/^    bool    extend_model;      \/\/ Flag to indicate whether the user needs to look at the full /;"	m	class:Minisat::SimpSolver	typeref:typename:bool
extend_u0	yosys/kernel/calc.cc	/^static void extend_u0(RTLIL::Const &arg, int width, bool is_signed)$/;"	f	typeref:typename:YOSYS_NAMESPACE_BEGIN void	file:
extend_u0	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::extend_u0(int width, bool is_signed)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
extendedEuclidean	yosys/libs/bigint/BigIntegerAlgorithms.cc	/^void extendedEuclidean(BigInteger m, BigInteger n,$/;"	f	typeref:typename:void
extern_mode	yosys/passes/techmap/techmap.cc	/^	bool extern_mode = false;$/;"	m	struct:TechmapWorker	typeref:typename:bool	file:
externalDict	yosys/libs/fst/lz4.cc	/^    const BYTE *externalDict;$/;"	m	struct:__anon9390dffe0908	typeref:typename:const BYTE *	file:
extmem	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
extmem_counter	yosys/backends/verilog/verilog_backend.cc	/^int auto_name_counter, auto_name_offset, auto_name_digits, extmem_counter;$/;"	v	typeref:typename:int
extmem_prefix	yosys/backends/verilog/verilog_backend.cc	/^std::string auto_prefix, extmem_prefix;$/;"	v	typeref:typename:std::string
extmodule_name	yosys/backends/firrtl/firrtl.cc	/^std::string extmodule_name(RTLIL::Cell *cell, RTLIL::Module *mod_instance)$/;"	f	typeref:typename:std::string
extra_args	yosys/kernel/register.cc	/^void Backend::extra_args(std::ostream *&f, std::string &filename, std::vector<std::string> args,/;"	f	class:Backend	typeref:typename:void
extra_args	yosys/kernel/register.cc	/^void Frontend::extra_args(std::istream *&f, std::string &filename, std::vector<std::string> args/;"	f	class:Frontend	typeref:typename:void
extra_args	yosys/kernel/register.cc	/^void Pass::extra_args(std::vector<std::string> args, size_t argidx, RTLIL::Design *design, bool /;"	f	class:Pass	typeref:typename:void
extra_clause_field	yosys/libs/minisat/SolverTypes.h	/^    bool extra_clause_field;$/;"	m	class:Minisat::ClauseAllocator	typeref:typename:bool
extra_coverage_data	yosys/kernel/log.cc	/^dict<std::string, std::pair<std::string, int>> extra_coverage_data;$/;"	v	typeref:typename:dict<std::string,std::pair<std::string,int>>
extract	yosys/kernel/rtlil.cc	/^RTLIL::SigChunk RTLIL::SigChunk::extract(int offset, int length) const$/;"	f	class:RTLIL::SigChunk	typeref:typename:RTLIL::SigChunk
extract	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec RTLIL::SigSpec::extract(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec *othe/;"	f	class:RTLIL::SigSpec	typeref:typename:RTLIL::SigSpec
extract	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec RTLIL::SigSpec::extract(const pool<RTLIL::SigBit> &pattern, const RTLIL::SigSpec /;"	f	class:RTLIL::SigSpec	typeref:typename:RTLIL::SigSpec
extract	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec RTLIL::SigSpec::extract(int offset, int length) const$/;"	f	class:RTLIL::SigSpec	typeref:typename:RTLIL::SigSpec
extract	yosys/kernel/rtlil.h	/^	inline RTLIL::Const extract(int offset, int len = 1, RTLIL::State padding = RTLIL::State::S0) c/;"	f	struct:RTLIL::Const	typeref:typename:RTLIL::Const
extract	yosys/kernel/sigtools.h	/^	RTLIL::SigSpec extract(const RTLIL::SigSpec &sig) const$/;"	f	struct:SigPool	typeref:typename:RTLIL::SigSpec
extractVarNames	yosys/kernel/fstdata.cc	/^void FstData::extractVarNames()$/;"	f	class:FstData	typeref:typename:void
extract_cell	yosys/passes/techmap/abc.cc	/^void extract_cell(RTLIL::Cell *cell, bool keepff)$/;"	f	typeref:typename:void
extract_cmp_alu	yosys/passes/techmap/alumacc.cc	/^	void extract_cmp_alu()$/;"	f	struct:AlumaccWorker	typeref:typename:void	file:
extract_end	yosys/kernel/rtlil.h	/^	RTLIL::SigSpec extract_end(int offset) const { return extract(offset, width_ - offset); }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:RTLIL::SigSpec
extract_fsm	yosys/passes/fsm/fsm_extract.cc	/^static void extract_fsm(RTLIL::Wire *wire)$/;"	f	typeref:typename:void	file:
extract_macc	yosys/passes/techmap/alumacc.cc	/^	void extract_macc()$/;"	f	struct:AlumaccWorker	typeref:typename:void	file:
extract_rdff	yosys/kernel/mem.cc	/^Cell *Mem::extract_rdff(int idx, FfInitVals *initvals) {$/;"	f	class:Mem	typeref:typename:Cell *
exts	yosys/kernel/rtlil.h	/^	void exts(int width) {$/;"	f	struct:RTLIL::Const	typeref:typename:void
extu	yosys/kernel/rtlil.h	/^	void extu(int width) {$/;"	f	struct:RTLIL::Const	typeref:typename:void
ez	yosys/kernel/qcsat.h	/^	ezSatPtr ez;$/;"	m	struct:QuickConeSat	typeref:typename:ezSatPtr
ez	yosys/kernel/satgen.h	/^	ezSAT *ez;$/;"	m	struct:SatGen	typeref:typename:ezSAT *
ez	yosys/libs/ezsat/puzzle3d.cc	/^ezMiniSAT ez;$/;"	v	typeref:typename:ezMiniSAT
ez	yosys/passes/equiv/equiv_induct.cc	/^	ezSatPtr ez;$/;"	m	struct:EquivInductWorker	typeref:typename:ezSatPtr	file:
ez	yosys/passes/equiv/equiv_simple.cc	/^	ezSatPtr ez;$/;"	m	struct:EquivSimpleWorker	typeref:typename:ezSatPtr	file:
ez	yosys/passes/sat/freduce.cc	/^	ezSatPtr ez;$/;"	m	struct:FindReducedInputs	typeref:typename:ezSatPtr	file:
ez	yosys/passes/sat/freduce.cc	/^	ezSatPtr ez;$/;"	m	struct:PerformReduction	typeref:typename:ezSatPtr	file:
ez	yosys/passes/sat/sat.cc	/^	ezSatPtr ez;$/;"	m	struct:SatHelper	typeref:typename:ezSatPtr	file:
ezMiniSAT	yosys/libs/ezsat/ezminisat.cc	/^ezMiniSAT::ezMiniSAT() : minisatSolver(NULL)$/;"	f	class:ezMiniSAT
ezMiniSAT	yosys/libs/ezsat/ezminisat.h	/^class ezMiniSAT : public ezSAT$/;"	c
ezSAT	yosys/libs/ezsat/ezsat.cc	/^ezSAT::ezSAT()$/;"	f	class:ezSAT
ezSAT	yosys/libs/ezsat/ezsat.h	/^class ezSAT$/;"	c
ezSATbit	yosys/libs/ezsat/ezsat.h	/^	ezSATbit(ezSAT &sat, ezSAT::_V a) : sat(sat), id(sat.VAR(a)) { }$/;"	f	struct:ezSATbit
ezSATbit	yosys/libs/ezsat/ezsat.h	/^struct ezSATbit$/;"	s
ezSATvec	yosys/libs/ezsat/ezsat.h	/^	ezSATvec(ezSAT &sat, const std::vector<int> &vec) : sat(sat), vec(vec) { }$/;"	f	struct:ezSATvec
ezSATvec	yosys/libs/ezsat/ezsat.h	/^struct ezSATvec$/;"	s
ezSatPtr	yosys/kernel/satgen.h	/^	ezSatPtr() : unique_ptr<ezSAT>(yosys_satsolver->create()) { }$/;"	f	struct:ezSatPtr
ezSatPtr	yosys/kernel/satgen.h	/^struct ezSatPtr : public std::unique_ptr<ezSAT> {$/;"	s
ez_cells	yosys/passes/sat/freduce.cc	/^	std::set<RTLIL::Cell*> ez_cells;$/;"	m	struct:FindReducedInputs	typeref:typename:std::set<RTLIL::Cell * >	file:
ez_step_is_consistent	yosys/passes/equiv/equiv_induct.cc	/^	dict<int, int> ez_step_is_consistent;$/;"	m	struct:EquivInductWorker	typeref:typename:dict<int,int>	file:
f	yosys/backends/blif/blif.cc	/^	std::ostream &f;$/;"	m	struct:BlifDumper	typeref:typename:std::ostream &	file:
f	yosys/backends/btor/btor.cc	/^	std::ostream &f;$/;"	m	struct:BtorWorker	typeref:typename:std::ostream &	file:
f	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::ostringstream f;$/;"	m	struct:CxxrtlWorker	typeref:typename:std::ostringstream	file:
f	yosys/backends/firrtl/firrtl.cc	/^	std::ostream &f;$/;"	m	struct:FirrtlWorker	typeref:typename:std::ostream &	file:
f	yosys/backends/jny/jny.cc	/^        std::ostream &f;$/;"	m	struct:JnyWriter	typeref:typename:std::ostream &	file:
f	yosys/backends/json/json.cc	/^	std::ostream &f;$/;"	m	struct:JsonWriter	typeref:typename:std::ostream &	file:
f	yosys/backends/smv/smv.cc	/^	std::ostream &f;$/;"	m	struct:SmvWorker	typeref:typename:std::ostream &	file:
f	yosys/frontends/aiger/aigerparse.h	/^    std::istream &f;$/;"	m	struct:AigerReader	typeref:typename:std::istream &
f	yosys/libs/fst/fstapi.cc	/^    FILE *f, *fh;$/;"	m	struct:fstReaderContext	typeref:typename:FILE *	file:
f	yosys/libs/json11/json11.cpp	/^    const std::shared_ptr<JsonValue> f = make_shared<JsonBoolean>(false);$/;"	m	struct:json11::Statics	typeref:typename:const std::shared_ptr<JsonValue>	file:
f	yosys/passes/cmds/show.cc	/^	FILE *f;$/;"	m	struct:ShowWorker	typeref:typename:FILE *	file:
f	yosys/passes/techmap/libparse.h	/^		std::istream &f;$/;"	m	struct:Yosys::LibertyParser	typeref:typename:std::istream &
f32	yosys/frontends/ast/dpicall.cc	/^	union { double f64; float f32; int32_t i32; void *ptr; } value_store [args.size() + 1];$/;"	m	union:AST::dpi_call::__anonad5aa9e1010a	typeref:typename:float	file:
f64	yosys/frontends/ast/dpicall.cc	/^	union { double f64; float f32; int32_t i32; void *ptr; } value_store [args.size() + 1];$/;"	m	union:AST::dpi_call::__anonad5aa9e1010a	typeref:typename:double	file:
f_nam	yosys/libs/fst/fstapi.cc	/^    char *f_nam;$/;"	m	struct:fstReaderContext	typeref:typename:char *	file:
fail	yosys/libs/json11/json11.cpp	/^    Json fail(string &&msg) {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:Json	file:
fail	yosys/libs/json11/json11.cpp	/^    T fail(string &&msg, const T err_ret) {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:T	file:
fail	yosys/misc/launcher.c	/^int fail(const char *format, const char *data) {$/;"	f	typeref:typename:int
fail_ff	yosys/passes/techmap/dfflegalize.cc	/^	void fail_ff(const FfData &ff, const char *reason) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
failed	yosys/libs/json11/json11.cpp	/^    bool failed;$/;"	m	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:bool	file:
fairness	yosys/backends/aiger/aiger.cc	/^	vector<pair<SigBit, SigBit>> liveness, fairness;$/;"	m	struct:AigerWriter	typeref:typename:vector<pair<SigBit,SigBit>>	file:
false_node	yosys/passes/proc/proc_dlatch.cc	/^		false_node = 2$/;"	e	enum:proc_dlatch_db_t::tf_node_types_t	file:
false_out	yosys/backends/blif/blif.cc	/^	std::string true_type, true_out, false_type, false_out, undef_type, undef_out;$/;"	m	struct:BlifDumperConfig	typeref:typename:std::string	file:
false_type	yosys/backends/blif/blif.cc	/^	std::string true_type, true_out, false_type, false_out, undef_type, undef_out;$/;"	m	struct:BlifDumperConfig	typeref:typename:std::string	file:
family	yosys/techlibs/nexus/synth_nexus.cc	/^	string top_opt, json_file, vm_file, family;$/;"	m	struct:SynthNexusPass	typeref:typename:string	file:
family	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	string top_opt, blif_file, family, currmodule, verilog_file;$/;"	m	struct:SynthQuickLogicPass	typeref:typename:string	file:
family	yosys/techlibs/xilinx/synth_xilinx.cc	/^	std::string top_opt, edif_file, blif_file, family;$/;"	m	struct:SynthXilinxPass	typeref:typename:std::string	file:
family_opt	yosys/techlibs/achronix/synth_achronix.cc	/^  string top_opt, family_opt, vout_file;$/;"	m	struct:SynthAchronixPass	typeref:typename:string	file:
family_opt	yosys/techlibs/intel/synth_intel.cc	/^	string top_opt, family_opt, vout_file, blif_file;$/;"	m	struct:SynthIntelPass	typeref:typename:string	file:
family_opt	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	string top_opt, family_opt, bram_type, vout_file;$/;"	m	struct:SynthIntelALMPass	typeref:typename:string	file:
fanouts	yosys/passes/cmds/sta.cc	/^		vector<tuple<SigBit,int,IdString>> fanouts;$/;"	m	struct:StaWorker::t_data	typeref:typename:vector<tuple<SigBit,int,IdString>>	file:
fastlz_compress	yosys/libs/fst/fastlz.cc	/^int fastlz_compress(const void *input, int length, void *output)$/;"	f	typeref:typename:int
fastlz_compress_level	yosys/libs/fst/fastlz.cc	/^int fastlz_compress_level(int level, const void *input, int length, void *output)$/;"	f	typeref:typename:int
fastlz_decompress	yosys/libs/fst/fastlz.cc	/^int fastlz_decompress(const void *input, int length, void *output, int maxout)$/;"	f	typeref:typename:int
fastpack	yosys/libs/fst/fstapi.cc	/^    unsigned fastpack : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
fcache	yosys/backends/smt2/smt2.cc	/^	std::map<RTLIL::SigBit, std::pair<int, int>> fcache;$/;"	m	struct:Smt2Worker	typeref:typename:std::map<RTLIL::SigBit,std::pair<int,int>>	file:
fdrecv	yosys/frontends/rpc/rpc_frontend.cc	/^	int fdsend, fdrecv;$/;"	m	struct:FdRpcServer	typeref:typename:int	file:
fdsend	yosys/frontends/rpc/rpc_frontend.cc	/^	int fdsend, fdrecv;$/;"	m	struct:FdRpcServer	typeref:typename:int	file:
feedback_bit	yosys/passes/opt/opt_mem_feedback.cc	/^	SigBit feedback_bit;$/;"	m	struct:FeedbackPath	typeref:typename:SigBit	file:
ff	yosys/passes/memory/memory_dff.cc	/^	FfData &ff;$/;"	m	struct:MemQueryCache	typeref:typename:FfData &	file:
ff_database	yosys/passes/sat/sim.cc	/^	dict<Cell*, ff_state_t> ff_database;$/;"	m	struct:SimInstance	typeref:typename:dict<Cell *,ff_state_t>	file:
ff_list	yosys/backends/aiger/xaiger.cc	/^	vector<Cell*> ff_list;$/;"	m	struct:XAigerWriter	typeref:typename:vector<Cell * >	file:
ff_map	yosys/backends/aiger/aiger.cc	/^	dict<SigBit, SigBit> not_map, ff_map, alias_map;$/;"	m	struct:AigerWriter	typeref:typename:dict<SigBit,SigBit>	file:
ff_state_t	yosys/passes/sat/sim.cc	/^	struct ff_state_t$/;"	s	struct:SimInstance	file:
ff_todo	yosys/backends/btor/btor.cc	/^	vector<pair<int, Cell*>> ff_todo;$/;"	m	struct:BtorWorker	typeref:typename:vector<pair<int,Cell * >>	file:
ffcells	yosys/passes/techmap/shregmap.cc	/^	dict<IdString, pair<IdString, IdString>> ffcells;$/;"	m	struct:ShregmapOptions	typeref:typename:dict<IdString,pair<IdString,IdString>>	file:
ffe	yosys/passes/techmap/shregmap.cc	/^	bool zinit, init, params, ffe;$/;"	m	struct:ShregmapOptions	typeref:typename:bool	file:
ffi_fptr	yosys/frontends/ast/dpicall.cc	/^typedef void (*ffi_fptr) ();$/;"	t	typeref:typename:void (*)()	file:
ffoutwire	yosys/frontends/verific/verificsva.cc	/^	Wire *ffoutwire;$/;"	m	struct:SvaDFsmNode	typeref:typename:Wire *	file:
fgetline	yosys/kernel/yosys.cc	/^bool fgetline(FILE *f, std::string &buffer)$/;"	f	typeref:typename:bool
fh	yosys/libs/fst/fstapi.cc	/^    FILE *f, *fh;$/;"	m	struct:fstReaderContext	typeref:typename:FILE *	file:
fh_nam	yosys/libs/fst/fstapi.cc	/^    char *fh_nam;$/;"	m	struct:fstReaderContext	typeref:typename:char *	file:
fid	yosys/backends/firrtl/firrtl.cc	/^	std::string fid(RTLIL::IdString internal_id)$/;"	f	struct:FirrtlWorker	typeref:typename:std::string	file:
file	yosys/kernel/log.h	/^	const char *file, *func, *id;$/;"	m	struct:CoverData	typeref:typename:const char *
file_base_name	yosys/kernel/fstdata.cc	/^static std::string file_base_name(std::string const & path)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE std::string	file:
file_base_name	yosys/passes/sat/sim.cc	/^	static std::string file_base_name(std::string const & path)$/;"	f	struct:SimPass	typeref:typename:std::string	file:
filename	yosys/frontends/ast/ast.h	/^		std::string filename;$/;"	m	struct:AST::AstNode	typeref:typename:std::string
filename	yosys/libs/fst/fstapi.cc	/^    char *filename, *filename_unpacked;$/;"	m	struct:fstReaderContext	typeref:typename:char *	file:
filename	yosys/libs/fst/fstapi.cc	/^    char *filename;$/;"	m	struct:fstWriterContext	typeref:typename:char *	file:
filename_unpacked	yosys/libs/fst/fstapi.cc	/^    char *filename, *filename_unpacked;$/;"	m	struct:fstReaderContext	typeref:typename:char *	file:
fileno	yosys/kernel/yosys.h	/^#    define fileno /;"	d
fileno	yosys/libs/fst/fstapi.h	/^#define fileno /;"	d
filetype	yosys/libs/fst/fstapi.cc	/^    unsigned char filetype; \/* default is 0, FST_FT_VERILOG *\/$/;"	m	struct:fstWriterContext	typeref:typename:unsigned char	file:
filetype	yosys/libs/fst/fstapi.cc	/^    unsigned char filetype;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned char	file:
fillcolor	yosys/passes/techmap/flowmap.cc	/^	string color, fillcolor;$/;"	m	struct:GraphStyle	typeref:typename:string	file:
filter_activation_patterns	yosys/passes/opt/share.cc	/^	void filter_activation_patterns(pool<ssc_pair_t> &out,$/;"	f	struct:ShareWorker	typeref:typename:void	file:
final	yosys/libs/sha1/sha1.cpp	/^std::string SHA1::final()$/;"	f	class:SHA1	typeref:typename:std::string
final_accept_sig	yosys/frontends/verific/verificsva.cc	/^	SigBit final_accept_sig = State::Sx;$/;"	m	struct:SvaFsm	typeref:typename:SigBit	file:
final_collision_x	yosys/passes/memory/memory_dff.cc	/^	bool final_collision_x;$/;"	m	struct:PortData	typeref:typename:bool	file:
final_reject_sig	yosys/frontends/verific/verificsva.cc	/^	SigBit final_reject_sig = State::Sx;$/;"	m	struct:SvaFsm	typeref:typename:SigBit	file:
final_transparency	yosys/passes/memory/memory_dff.cc	/^	bool final_transparency;$/;"	m	struct:PortData	typeref:typename:bool	file:
find	yosys/frontends/verilog/preproc.cc	/^	const macro_arg_t *find(const std::string &name, int *pos = nullptr) const$/;"	f	struct:arg_map_t	typeref:typename:const macro_arg_t *	file:
find	yosys/frontends/verilog/preproc.cc	/^const define_body_t *define_map_t::find(const std::string &name) const$/;"	f	class:define_map_t	typeref:typename:const define_body_t *
find	yosys/kernel/hashlib.h	/^	const K &find(const K &a) const$/;"	f	class:hashlib::mfp	typeref:typename:const K &
find	yosys/kernel/hashlib.h	/^	const_iterator find(const K &key) const$/;"	f	class:hashlib::dict	typeref:typename:const_iterator
find	yosys/kernel/hashlib.h	/^	const_iterator find(const K &key) const$/;"	f	class:hashlib::pool	typeref:typename:const_iterator
find	yosys/kernel/hashlib.h	/^	iterator find(const K &key)$/;"	f	class:hashlib::dict	typeref:typename:iterator
find	yosys/kernel/hashlib.h	/^	iterator find(const K &key)$/;"	f	class:hashlib::pool	typeref:typename:iterator
find	yosys/kernel/sigtools.h	/^	std::set<T> find(const RTLIL::SigSpec &sig)$/;"	f	struct:SigSet	typeref:typename:std::set<T>
find	yosys/kernel/sigtools.h	/^	void find(const RTLIL::SigSpec &sig, pool<T> &result)$/;"	f	struct:SigSet	typeref:typename:void
find	yosys/kernel/sigtools.h	/^	void find(const RTLIL::SigSpec &sig, std::set<T> &result)$/;"	f	struct:SigSet	typeref:typename:void
find	yosys/kernel/timinginfo.h	/^	decltype(data)::const_iterator find(RTLIL::IdString module_name) const { return data.find(modul/;"	f	struct:TimingInfo	typeref:typename:decltype(data)::const_iterator
find	yosys/libs/minisat/Alg.h	/^static inline bool find(V& ts, const T& t)$/;"	f	namespace:Minisat	typeref:typename:bool
find	yosys/passes/techmap/libparse.cc	/^LibertyAst *LibertyAst::find(std::string name)$/;"	f	class:LibertyAst	typeref:typename:LibertyAst *
findColor	yosys/passes/cmds/show.cc	/^	const char *findColor(std::string member_name)$/;"	f	struct:ShowWorker	typeref:typename:const char *	file:
findEdgesInGraph	yosys/libs/subcircuit/subcircuit.cc	/^		static void findEdgesInGraph(const Graph &graph, std::map<std::pair<int, int>, DiEdge> &edges)$/;"	f	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:void	file:
findLabel	yosys/passes/cmds/show.cc	/^	const char *findLabel(std::string member_name)$/;"	f	struct:ShowWorker	typeref:typename:const char *	file:
findNextPool	yosys/libs/subcircuit/subcircuit.cc	/^	void findNextPool(std::vector<Solver::MineResult> &results, std::set<NodeSet> &pool,$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
findNodePairs	yosys/libs/subcircuit/subcircuit.cc	/^	void findNodePairs(std::vector<Solver::MineResult> &results, std::set<NodeSet> &nodePairs, int /;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
find_any_lvalue	yosys/passes/proc/proc_dff.cc	/^RTLIL::SigSpec find_any_lvalue(const RTLIL::Process *proc)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN RTLIL::SigSpec
find_augmenting_path	yosys/passes/techmap/flowmap.cc	/^	bool find_augmenting_path(bool commit)$/;"	f	struct:FlowGraph	typeref:typename:bool	file:
find_best_cover	yosys/passes/techmap/muxcover.cc	/^	int find_best_cover(tree_t &tree, SigBit bit)$/;"	f	struct:MuxcoverWorker	typeref:typename:int	file:
find_best_covers	yosys/passes/techmap/muxcover.cc	/^	void find_best_covers(tree_t &tree, const vector<SigBit> &bits)$/;"	f	struct:MuxcoverWorker	typeref:typename:void	file:
find_bit_in_cone	yosys/passes/sat/freduce.cc	/^	bool find_bit_in_cone(RTLIL::SigBit needle, RTLIL::SigBit haystack)$/;"	f	struct:FreduceWorker	typeref:typename:bool	file:
find_bit_in_cone	yosys/passes/sat/freduce.cc	/^	bool find_bit_in_cone(std::set<RTLIL::Cell*> &celldone, RTLIL::SigBit needle, RTLIL::SigBit hay/;"	f	struct:FreduceWorker	typeref:typename:bool	file:
find_cell	yosys/passes/techmap/dfflibmap.cc	/^static void find_cell(LibertyAst *ast, IdString cell_type, bool clkpol, bool has_reset, bool rst/;"	f	typeref:typename:void	file:
find_cell_activation_patterns	yosys/passes/opt/share.cc	/^	const pool<ssc_pair_t> &find_cell_activation_patterns(RTLIL::Cell *cell, const char *indent)$/;"	f	struct:ShareWorker	typeref:typename:const pool<ssc_pair_t> &	file:
find_cell_sr	yosys/passes/techmap/dfflibmap.cc	/^static void find_cell_sr(LibertyAst *ast, IdString cell_type, bool clkpol, bool setpol, bool clr/;"	f	typeref:typename:void	file:
find_chain_start_cells	yosys/passes/opt/muxpack.cc	/^	void find_chain_start_cells()$/;"	f	struct:MuxpackWorker	typeref:typename:void	file:
find_chain_start_cells	yosys/passes/techmap/shregmap.cc	/^	void find_chain_start_cells()$/;"	f	struct:ShregmapWorker	typeref:typename:void	file:
find_common_ancestor	yosys/frontends/verific/verific.cc	/^	Netlist *find_common_ancestor(Netlist *A, Netlist *B)$/;"	f	struct:VerificExtNets	typeref:typename:Netlist *	file:
find_data_feedback	yosys/passes/opt/opt_mem_feedback.cc	/^	void find_data_feedback(const pool<RTLIL::SigBit> &async_rd_bits, RTLIL::SigBit sig,$/;"	f	struct:OptMemFeedbackWorker	typeref:typename:void	file:
find_dff_wires	yosys/passes/sat/expose.cc	/^void find_dff_wires(std::set<RTLIL::IdString> &dff_wires, RTLIL::Module *module)$/;"	f	typeref:typename:void
find_exe	yosys/misc/launcher.c	/^char *find_exe(char *exename, char *script) {$/;"	f	typeref:typename:char *
find_forbidden_controls	yosys/passes/opt/share.cc	/^	const pool<RTLIL::SigBit> &find_forbidden_controls(RTLIL::Cell *cell)$/;"	f	struct:ShareWorker	typeref:typename:const pool<RTLIL::SigBit> &	file:
find_implicit_port_wire	yosys/passes/hierarchy/hierarchy.cc	/^RTLIL::Wire *find_implicit_port_wire(Module *module, Cell *cell, const std::string& port)$/;"	f	typeref:typename:RTLIL::Wire *
find_in_input_cone	yosys/passes/opt/share.cc	/^	bool find_in_input_cone(RTLIL::Cell *root, RTLIL::Cell *needle)$/;"	f	struct:ShareWorker	typeref:typename:bool	file:
find_in_input_cone_worker	yosys/passes/opt/share.cc	/^	bool find_in_input_cone_worker(RTLIL::Cell *root, RTLIL::Cell *needle, pool<RTLIL::Cell*> &stop/;"	f	struct:ShareWorker	typeref:typename:bool	file:
find_input_cone	yosys/passes/equiv/equiv_simple.cc	/^	bool find_input_cone(pool<SigBit> &next_seed, pool<Cell*> &cells_cone, pool<SigBit> &bits_cone,/;"	f	struct:EquivSimpleWorker	typeref:typename:bool	file:
find_input_cone	yosys/passes/equiv/equiv_simple.cc	/^	void find_input_cone(pool<SigBit> &next_seed, pool<Cell*> &cells_cone, pool<SigBit> &bits_cone,/;"	f	struct:EquivSimpleWorker	typeref:typename:void	file:
find_input_ff	yosys/kernel/ffmerge.cc	/^bool FfMergeHelper::find_input_ff(RTLIL::SigSpec sig, FfData &ff, pool<std::pair<Cell *, int>> &/;"	f	class:FfMergeHelper	typeref:typename:bool
find_miter_cells_wires	yosys/passes/equiv/equiv_miter.cc	/^	void find_miter_cells_wires()$/;"	f	struct:EquivMiterWorker	typeref:typename:void	file:
find_modport	yosys/frontends/ast/ast.cc	/^AstNode * AST::find_modport(AstNode *intf, std::string name)$/;"	f	class:AST	typeref:typename:AstNode *
find_mux_feedback	yosys/passes/proc/proc_dlatch.cc	/^	int find_mux_feedback(SigBit haystack, SigBit needle, bool set_undef)$/;"	f	struct:proc_dlatch_db_t	typeref:typename:int	file:
find_muxtree_feedback_patterns	yosys/passes/opt/opt_dff.cc	/^	patterns_t find_muxtree_feedback_patterns(RTLIL::SigBit d, RTLIL::SigBit q, pattern_t path)$/;"	f	struct:OptDffWorker	typeref:typename:patterns_t	file:
find_non_null	yosys/passes/techmap/libparse.cc	/^LibertyAst *find_non_null(LibertyAst *node, const char *name)$/;"	f	typeref:typename:LibertyAst *
find_output_ff	yosys/kernel/ffmerge.cc	/^bool FfMergeHelper::find_output_ff(RTLIL::SigSpec sig, FfData &ff, pool<std::pair<Cell *, int>> /;"	f	class:FfMergeHelper	typeref:typename:bool
find_partitions	yosys/passes/techmap/extract_fa.cc	/^	void find_partitions(SigBit root, pool<SigBit> &leaves, pool<pool<SigBit>> &cache, int maxdepth/;"	f	struct:ExtractFaWorker	typeref:typename:void	file:
find_same_cells	yosys/passes/equiv/equiv_make.cc	/^	void find_same_cells()$/;"	f	struct:EquivMakeWorker	typeref:typename:void	file:
find_same_wires	yosys/passes/equiv/equiv_make.cc	/^	void find_same_wires()$/;"	f	struct:EquivMakeWorker	typeref:typename:void	file:
find_shareable_cells	yosys/passes/opt/share.cc	/^	void find_shareable_cells()$/;"	f	struct:ShareWorker	typeref:typename:void	file:
find_shareable_partners	yosys/passes/opt/share.cc	/^	void find_shareable_partners(std::vector<RTLIL::Cell*> &results, RTLIL::Cell *cell)$/;"	f	struct:ShareWorker	typeref:typename:void	file:
find_shared_operand	yosys/passes/opt/opt_share.cc	/^ExtSigSpec find_shared_operand(const OpMuxConn* seed, std::vector<const OpMuxConn *> &ports, con/;"	f	typeref:typename:ExtSigSpec
find_states	yosys/passes/fsm/fsm_extract.cc	/^static bool find_states(RTLIL::SigSpec sig, const RTLIL::SigSpec &dff_out, RTLIL::SigSpec &ctrl,/;"	f	typeref:typename:bool	file:
find_stub_nets	yosys/manual/CHAPTER_Prog/stubnets.cc	/^static void find_stub_nets(RTLIL::Design *design, RTLIL::Module *module, bool report_bits)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void	file:
find_subgraph	yosys/passes/techmap/flowmap.cc	/^	pool<RTLIL::SigBit> find_subgraph(RTLIL::SigBit sink)$/;"	f	struct:FlowmapWorker	typeref:typename:pool<RTLIL::SigBit>	file:
find_terminal_bits	yosys/passes/opt/share.cc	/^	void find_terminal_bits()$/;"	f	struct:ShareWorker	typeref:typename:void	file:
find_top_mod_score	yosys/passes/hierarchy/hierarchy.cc	/^int find_top_mod_score(Design *design, Module *module, dict<Module*, int> &db)$/;"	f	typeref:typename:int
find_transitions	yosys/passes/fsm/fsm_extract.cc	/^static void find_transitions(ConstEval &ce, ConstEval &ce_nostop, FsmData &fsm_data, std::map<RT/;"	f	typeref:typename:void	file:
find_undriven_nets	yosys/passes/equiv/equiv_make.cc	/^	void find_undriven_nets(bool mark)$/;"	f	struct:EquivMakeWorker	typeref:typename:void	file:
find_variant_params	yosys/passes/memory/memory_bram.cc	/^		void find_variant_params(dict<IdString, Const> &variant_params, const bram_t &other) const$/;"	f	struct:rules_t::bram_t	typeref:typename:void	file:
find_xorshift128_init_state	yosys/libs/ezsat/demo_vec.cc	/^void find_xorshift128_init_state(uint32_t &x, uint32_t &y, uint32_t &z, uint32_t &w, uint32_t w1/;"	f	typeref:typename:void
first	yosys/kernel/timinginfo.h	/^		NameBit first, second;$/;"	m	struct:TimingInfo::BitBit	typeref:typename:NameBit
first	yosys/libs/minisat/Queue.h	/^    int     first;$/;"	m	class:Minisat::Queue	typeref:typename:int
first_column	yosys/frontends/ast/ast.h	/^		unsigned int first_column, last_column;$/;"	m	struct:AST::AstSrcLocType	typeref:typename:unsigned int
first_line	yosys/frontends/ast/ast.h	/^		unsigned int first_line, last_line;$/;"	m	struct:AST::AstSrcLocType	typeref:typename:unsigned int
first_queued_pass	yosys/kernel/register.cc	/^Pass *first_queued_pass;$/;"	v	typeref:typename:Pass *
firsttime	yosys/libs/fst/fstapi.cc	/^    uint64_t firsttime;$/;"	m	struct:fstWriterContext	typeref:typename:uint64_t	file:
fix_carry_chain	yosys/techlibs/anlogic/anlogic_fixcarry.cc	/^static void fix_carry_chain(Module *module)$/;"	f	typeref:typename:void	file:
fix_carry_chain	yosys/techlibs/efinix/efinix_fixcarry.cc	/^static void fix_carry_chain(Module *module)$/;"	f	typeref:typename:void	file:
fixup	yosys/passes/techmap/shregmap.cc	/^	bool fixup(Cell *cell, dict<int, SigBit> &taps)$/;"	f	struct:ShregmapTechGreenpak4	typeref:typename:bool	file:
fixup_mux	yosys/passes/proc/proc_dlatch.cc	/^	void fixup_mux(Cell *cell)$/;"	f	struct:proc_dlatch_db_t	typeref:typename:void	file:
fixup_muxes	yosys/passes/proc/proc_dlatch.cc	/^	void fixup_muxes()$/;"	f	struct:proc_dlatch_db_t	typeref:typename:void	file:
fixup_parameters	yosys/kernel/rtlil.cc	/^void RTLIL::Cell::fixup_parameters(bool set_a_signed, bool set_b_signed)$/;"	f	class:RTLIL::Cell	typeref:typename:void
fixup_ports	yosys/kernel/rtlil.cc	/^void RTLIL::Module::fixup_ports()$/;"	f	class:RTLIL::Module	typeref:typename:void
fixup_ports_compare	yosys/kernel/rtlil.cc	/^static bool fixup_ports_compare(const RTLIL::Wire *a, const RTLIL::Wire *b)$/;"	f	typeref:typename:bool	file:
fixup_reset_x	yosys/passes/techmap/dfflegalize.cc	/^	void fixup_reset_x(FfData &ff, int supported) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
flag_always	yosys/passes/sat/assertpmux.cc	/^	bool flag_always;$/;"	m	struct:AssertpmuxWorker	typeref:typename:bool	file:
flag_autowire	yosys/frontends/ast/ast.cc	/^	bool flag_nomem2reg, flag_mem2reg, flag_noblackbox, flag_lib, flag_nowb, flag_noopt, flag_icell/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_dump_ast1	yosys/frontends/ast/ast.cc	/^	bool flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_vlog1, flag_dump_vlog2, flag_d/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_dump_ast2	yosys/frontends/ast/ast.cc	/^	bool flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_vlog1, flag_dump_vlog2, flag_d/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_dump_rtlil	yosys/frontends/ast/ast.cc	/^	bool flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_vlog1, flag_dump_vlog2, flag_d/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_dump_vlog1	yosys/frontends/ast/ast.cc	/^	bool flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_vlog1, flag_dump_vlog2, flag_d/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_dump_vlog2	yosys/frontends/ast/ast.cc	/^	bool flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_vlog1, flag_dump_vlog2, flag_d/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_found_something	yosys/passes/hierarchy/submod.cc	/^	bool flag_found_something;$/;"	m	struct:SubmodWorker	typeref:typename:bool	file:
flag_icells	yosys/frontends/ast/ast.cc	/^	bool flag_nomem2reg, flag_mem2reg, flag_noblackbox, flag_lib, flag_nowb, flag_noopt, flag_icell/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_keep_cnf	yosys/libs/ezsat/ezsat.h	/^	bool flag_keep_cnf;$/;"	m	class:ezSAT	typeref:typename:bool
flag_lib	yosys/frontends/ast/ast.cc	/^	bool flag_nomem2reg, flag_mem2reg, flag_noblackbox, flag_lib, flag_nowb, flag_noopt, flag_icell/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_mem2reg	yosys/frontends/ast/ast.cc	/^	bool flag_nomem2reg, flag_mem2reg, flag_noblackbox, flag_lib, flag_nowb, flag_noopt, flag_icell/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_no_dump_ptr	yosys/frontends/ast/ast.cc	/^	bool flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_vlog1, flag_dump_vlog2, flag_d/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_noblackbox	yosys/frontends/ast/ast.cc	/^	bool flag_nomem2reg, flag_mem2reg, flag_noblackbox, flag_lib, flag_nowb, flag_noopt, flag_icell/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_noinit	yosys/passes/sat/assertpmux.cc	/^	bool flag_noinit;$/;"	m	struct:AssertpmuxWorker	typeref:typename:bool	file:
flag_nolatches	yosys/frontends/ast/ast.cc	/^	bool flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_vlog1, flag_dump_vlog2, flag_d/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_nomem2reg	yosys/frontends/ast/ast.cc	/^	bool flag_nomem2reg, flag_mem2reg, flag_noblackbox, flag_lib, flag_nowb, flag_noopt, flag_icell/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_nomeminit	yosys/frontends/ast/ast.cc	/^	bool flag_dump_ast1, flag_dump_ast2, flag_no_dump_ptr, flag_dump_vlog1, flag_dump_vlog2, flag_d/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_non_incremental	yosys/libs/ezsat/ezsat.h	/^	bool flag_non_incremental;$/;"	m	class:ezSAT	typeref:typename:bool
flag_noopt	yosys/frontends/ast/ast.cc	/^	bool flag_nomem2reg, flag_mem2reg, flag_noblackbox, flag_lib, flag_nowb, flag_noopt, flag_icell/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_nowb	yosys/frontends/ast/ast.cc	/^	bool flag_nomem2reg, flag_mem2reg, flag_noblackbox, flag_lib, flag_nowb, flag_noopt, flag_icell/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_pwires	yosys/frontends/ast/ast.cc	/^	bool flag_nomem2reg, flag_mem2reg, flag_noblackbox, flag_lib, flag_nowb, flag_noopt, flag_icell/;"	v	namespace:AST_INTERNAL	typeref:typename:bool
flag_sat	yosys/passes/memory/memory_share.cc	/^	bool flag_sat;$/;"	m	struct:MemoryShareWorker	typeref:typename:bool	file:
flag_signal	yosys/passes/hierarchy/submod.cc	/^	void flag_signal(const RTLIL::SigSpec &sig, bool create, bool set_int_driven, bool set_int_used/;"	f	struct:SubmodWorker	typeref:typename:void	file:
flag_widen	yosys/passes/memory/memory_share.cc	/^	bool flag_widen;$/;"	m	struct:MemoryShareWorker	typeref:typename:bool	file:
flag_wire	yosys/passes/hierarchy/submod.cc	/^	void flag_wire(RTLIL::Wire *wire, bool create, bool set_int_used, bool set_ext_driven, bool set/;"	f	struct:SubmodWorker	typeref:typename:void	file:
flags	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	uint32_t flags; \/\/ actually bit mask of `enum cxxrtl_flags`$/;"	m	struct:cxxrtl_object	typeref:typename:uint32_t
flags	yosys/kernel/rtlil.h	/^	int flags;$/;"	m	struct:RTLIL::Const	typeref:typename:int
flat_hier_alloc_len	yosys/libs/fst/fstapi.cc	/^    int flat_hier_alloc_len;$/;"	m	struct:fstReaderContext	typeref:typename:int	file:
flatten	yosys/techlibs/achronix/synth_achronix.cc	/^  bool retime, flatten;$/;"	m	struct:SynthAchronixPass	typeref:typename:bool	file:
flatten	yosys/techlibs/anlogic/synth_anlogic.cc	/^	bool flatten, retime, nolutram, nobram;$/;"	m	struct:SynthAnlogicPass	typeref:typename:bool	file:
flatten	yosys/techlibs/common/prep.cc	/^	bool autotop, flatten, ifxmode, memxmode, nomemmode, nokeepdc, rdff;$/;"	m	struct:PrepPass	typeref:typename:bool	file:
flatten	yosys/techlibs/common/synth.cc	/^	bool autotop, flatten, noalumacc, nofsm, noabc, noshare, flowmap;$/;"	m	struct:SynthPass	typeref:typename:bool	file:
flatten	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^	bool flatten, retime;$/;"	m	struct:SynthCoolrunner2Pass	typeref:typename:bool	file:
flatten	yosys/techlibs/easic/synth_easic.cc	/^	bool flatten, retime;$/;"	m	struct:SynthEasicPass	typeref:typename:bool	file:
flatten	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
flatten	yosys/techlibs/efinix/synth_efinix.cc	/^	bool flatten, retime, nobram;$/;"	m	struct:SynthEfinixPass	typeref:typename:bool	file:
flatten	yosys/techlibs/gowin/synth_gowin.cc	/^	bool retime, nobram, nolutram, flatten, nodffe, nowidelut, abc9, noiopads, noalu;$/;"	m	struct:SynthGowinPass	typeref:typename:bool	file:
flatten	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^	bool flatten, retime;$/;"	m	struct:SynthGreenPAK4Pass	typeref:typename:bool	file:
flatten	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
flatten	yosys/techlibs/intel/synth_intel.cc	/^	bool retime, flatten, nobram, iopads;$/;"	m	struct:SynthIntelPass	typeref:typename:bool	file:
flatten	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	bool flatten, quartus, nolutram, nobram, dff, nodsp, noiopad, noclkbuf;$/;"	m	struct:SynthIntelALMPass	typeref:typename:bool	file:
flatten	yosys/techlibs/machxo2/synth_machxo2.cc	/^	bool flatten, vpr, noiopad;$/;"	m	struct:SynthMachXO2Pass	typeref:typename:bool	file:
flatten	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
flatten	yosys/techlibs/sf2/synth_sf2.cc	/^	bool flatten, retime, iobs, clkbuf;$/;"	m	struct:SynthSf2Pass	typeref:typename:bool	file:
flatten	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
flatten_before_abc	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten_before_abc;$/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
flatten_cell	yosys/passes/techmap/flatten.cc	/^	void flatten_cell(RTLIL::Design *design, RTLIL::Module *module, RTLIL::Cell *cell, RTLIL::Modul/;"	f	struct:FlattenWorker	typeref:typename:void	file:
flatten_module	yosys/passes/techmap/flatten.cc	/^	void flatten_module(RTLIL::Design *design, RTLIL::Module *module, pool<RTLIL::Module*> &used_mo/;"	f	struct:FlattenWorker	typeref:typename:void	file:
flipSign	yosys/libs/bigint/BigInteger.hh	/^inline void BigInteger::flipSign() {$/;"	f	class:BigInteger	typeref:typename:void
flip_bits	yosys/kernel/ff.cc	/^void FfData::flip_bits(const pool<int> &bits) {$/;"	f	class:FfData	typeref:typename:void
flip_initmask	yosys/passes/techmap/dfflegalize.cc	/^	int flip_initmask(int mask) {$/;"	f	struct:DffLegalizePass	typeref:typename:int	file:
flip_pol	yosys/passes/techmap/dfflegalize.cc	/^	void flip_pol(FfData &ff, SigSpec &sig, bool &pol) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
flopNum	yosys/frontends/aiger/aigerparse.h	/^    uint32_t piNum, flopNum;$/;"	m	struct:AigerReader	typeref:typename:uint32_t
flowmap	yosys/techlibs/common/synth.cc	/^	bool autotop, flatten, noalumacc, nofsm, noabc, noshare, flowmap;$/;"	m	struct:SynthPass	typeref:typename:bool	file:
flowmap	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
flush	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^	bool flush = false;$/;"	m	struct:_cxxrtl_vcd	typeref:typename:bool	file:
flush_context_pending	yosys/libs/fst/fstapi.cc	/^    unsigned flush_context_pending : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
flzuint16	yosys/libs/fst/fastlz.h	/^#define flzuint16 /;"	d
flzuint32	yosys/libs/fst/fastlz.h	/^#define flzuint32 /;"	d
flzuint8	yosys/libs/fst/fastlz.h	/^#define flzuint8 /;"	d
fm_set_fsm_print	yosys/passes/fsm/fsm_recode.cc	/^static void fm_set_fsm_print(RTLIL::Cell *cell, RTLIL::Module *module, FsmData &fsm_data, const /;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void	file:
fold_abc9_cmd	yosys/passes/techmap/abc9_exe.cc	/^std::string fold_abc9_cmd(std::string str)$/;"	f	typeref:typename:std::string
fold_abc_cmd	yosys/passes/techmap/abc.cc	/^std::string fold_abc_cmd(std::string str)$/;"	f	typeref:typename:std::string
follow_cone	yosys/passes/equiv/equiv_miter.cc	/^	void follow_cone(pool<Cell*> &cone, pool<Cell*> &leaves, Cell *c, bool gold_mode)$/;"	f	struct:EquivMiterWorker	typeref:typename:void	file:
follow_muxtree	yosys/passes/techmap/muxcover.cc	/^	bool follow_muxtree(SigBit &ret_bit, tree_t &tree, SigBit bit, const char *path, bool first_lay/;"	f	struct:MuxcoverWorker	typeref:typename:bool	file:
forallmode	yosys/backends/smt2/smt2.cc	/^	bool bvmode, memmode, wiresmode, verbose, statebv, statedt, forallmode;$/;"	m	struct:Smt2Worker	typeref:typename:bool	file:
forbidden_controls_cache	yosys/passes/opt/share.cc	/^	std::map<RTLIL::Cell*, pool<RTLIL::SigBit>, cell_ptr_cmp> forbidden_controls_cache;$/;"	m	struct:ShareWorker	typeref:typename:std::map<RTLIL::Cell *,pool<RTLIL::SigBit>,cell_ptr_cmp>	file:
force_unique_state	yosys/passes/sat/sat.cc	/^	void force_unique_state(int timestep_from, int timestep_to)$/;"	f	struct:SatHelper	typeref:typename:void	file:
formal_database	yosys/passes/sat/sim.cc	/^	pool<Cell*> formal_database;$/;"	m	struct:SimInstance	typeref:typename:pool<Cell * >	file:
foundContradiction	yosys/libs/ezsat/ezminisat.h	/^	bool foundContradiction;$/;"	m	class:ezMiniSAT	typeref:typename:bool
found_loops	yosys/kernel/utils.h	/^	bool analyze_loops, found_loops;$/;"	m	struct:TopoSort	typeref:typename:bool
fourpack	yosys/libs/fst/fstapi.cc	/^    unsigned fourpack : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
free	yosys/libs/minisat/Alloc.h	/^    void     free      (int size)    { wasted_ += size; }$/;"	f	class:Minisat::RegionAllocator	typeref:typename:void
free	yosys/libs/minisat/SolverTypes.h	/^    void free(CRef cid)$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:void
free_reference	yosys/kernel/rtlil.h	/^		static inline void free_reference(int idx)$/;"	f	struct:RTLIL::IdString	typeref:typename:void
free_vars	yosys/libs/minisat/Solver.h	/^    vec<Var>            free_vars;$/;"	m	class:Minisat::Solver	typeref:typename:vec<Var>
freeze	yosys/libs/ezsat/ezminisat.cc	/^void ezMiniSAT::freeze(int id)$/;"	f	class:ezMiniSAT	typeref:typename:void
freeze	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::freeze(int)$/;"	f	class:ezSAT	typeref:typename:void
freezeVar	yosys/libs/minisat/SimpSolver.h	/^inline void SimpSolver::freezeVar(Var v){$/;"	f	class:Minisat::SimpSolver	typeref:typename:void
fresh_temporary	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string fresh_temporary()$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
fromBit	yosys/libs/subcircuit/subcircuit.cc	/^		int fromBit, toBit;$/;"	m	struct:SubCircuit::SolverWorker::DiBit	typeref:typename:int	file:
fromNode	yosys/libs/subcircuit/subcircuit.cc	/^		DiNode fromNode, toNode;$/;"	m	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:DiNode	file:
fromPort	yosys/libs/subcircuit/subcircuit.cc	/^		std::string fromPort, toPort;$/;"	m	struct:SubCircuit::SolverWorker::DiBit	typeref:typename:std::string	file:
from_big_endian	yosys/frontends/aiger/aigerparse.cc	/^inline int32_t from_big_endian(int32_t i32) {$/;"	f	typeref:typename:YOSYS_NAMESPACE_BEGIN int32_t
from_cell	yosys/kernel/macc.h	/^	void from_cell(RTLIL::Cell *cell)$/;"	f	struct:Macc	typeref:typename:void
from_file	yosys/libs/sha1/sha1.cpp	/^std::string SHA1::from_file(const std::string &filename)$/;"	f	class:SHA1	typeref:typename:std::string
from_string	yosys/kernel/rtlil.cc	/^RTLIL::Const RTLIL::Const::from_string(const std::string &str)$/;"	f	class:RTLIL::Const	typeref:typename:RTLIL::Const
frontend_call	yosys/kernel/register.cc	/^void Frontend::frontend_call(RTLIL::Design *design, std::istream *f, std::string filename, std::/;"	f	class:Frontend	typeref:typename:void
frontend_name	yosys/kernel/register.h	/^	std::string frontend_name;$/;"	m	struct:Frontend	typeref:typename:std::string
frontend_register	yosys/kernel/register.cc	/^std::map<std::string, Frontend*> frontend_register;$/;"	v	typeref:typename:std::map<std::string,Frontend * >
frontend_verilog_preproc	yosys/frontends/verilog/preproc.cc	/^frontend_verilog_preproc(std::istream                 &f,$/;"	f	typeref:typename:std::string
frontend_verilog_yyerror	yosys/frontends/verilog/verilog_frontend.cc	/^void frontend_verilog_yyerror(char const *fmt, ...)$/;"	f	typeref:typename:YOSYS_NAMESPACE_END void
frozen	yosys/libs/minisat/SimpSolver.h	/^    VMap<char>          frozen;$/;"	m	class:Minisat::SimpSolver	typeref:typename:VMap<char>
frozen_literal	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::frozen_literal()$/;"	f	class:ezSAT	typeref:typename:int
frozen_literal	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::frozen_literal(const std::string &name)$/;"	f	class:ezSAT	typeref:typename:int
frozen_vars	yosys/libs/minisat/SimpSolver.h	/^    vec<Var>            frozen_vars;$/;"	m	class:Minisat::SimpSolver	typeref:typename:vec<Var>
fseek_failed	yosys/libs/fst/fstapi.cc	/^    unsigned fseek_failed : 1;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
fseek_failed	yosys/libs/fst/fstapi.cc	/^    unsigned fseek_failed : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
fseeko	yosys/libs/fst/fstapi.cc	/^#define fseeko /;"	d	file:
fsm_cell	yosys/passes/fsm/fsm_expand.cc	/^	RTLIL::Cell *fsm_cell;$/;"	m	struct:FsmExpand	typeref:typename:RTLIL::Cell *	file:
fsm_data	yosys/passes/fsm/fsm_opt.cc	/^	FsmData fsm_data;$/;"	m	struct:FsmOpt	typeref:typename:FsmData	file:
fsm_opts	yosys/techlibs/common/prep.cc	/^	string top_module, fsm_opts;$/;"	m	struct:PrepPass	typeref:typename:string	file:
fsm_opts	yosys/techlibs/common/synth.cc	/^	string top_module, fsm_opts, memory_opts, abc;$/;"	m	struct:SynthPass	typeref:typename:string	file:
fsm_recode	yosys/passes/fsm/fsm_recode.cc	/^static void fsm_recode(RTLIL::Cell *cell, RTLIL::Module *module, FILE *fm_set_fsm_file, FILE *en/;"	f	typeref:typename:void	file:
fst	yosys/passes/sat/sim.cc	/^	FstData *fst = nullptr;$/;"	m	struct:SimShared	typeref:typename:FstData *	file:
fstArrayType	yosys/libs/fst/fstapi.h	/^enum fstArrayType$/;"	g
fstAttrType	yosys/libs/fst/fstapi.h	/^enum fstAttrType$/;"	g
fstBlackoutChain	yosys/libs/fst/fstapi.cc	/^struct fstBlackoutChain$/;"	s	file:
fstBlockType	yosys/libs/fst/fstapi.h	/^enum fstBlockType$/;"	g
fstCopyVarint32ToLeft	yosys/libs/fst/fstapi.cc	/^static unsigned char *fstCopyVarint32ToLeft(unsigned char *pnt, uint32_t v)$/;"	f	typeref:typename:unsigned char *	file:
fstCopyVarint64ToRight	yosys/libs/fst/fstapi.cc	/^static unsigned char *fstCopyVarint64ToRight(unsigned char *pnt, uint64_t v)$/;"	f	typeref:typename:unsigned char *	file:
fstCurrHier	yosys/libs/fst/fstapi.cc	/^struct fstCurrHier$/;"	s	file:
fstDestroyMmaps	yosys/libs/fst/fstapi.cc	/^static void fstDestroyMmaps(struct fstWriterContext *xc, int is_closing)$/;"	f	typeref:typename:void	file:
fstDetermineBreakSize	yosys/libs/fst/fstapi.cc	/^static void fstDetermineBreakSize(struct fstWriterContext *xc)$/;"	f	typeref:typename:void	file:
fstETab	yosys/libs/fst/fstapi.h	/^struct fstETab$/;"	s
fstEnumHandle	yosys/libs/fst/fstapi.h	/^typedef uint32_t fstEnumHandle;$/;"	t	typeref:typename:uint32_t
fstEnumValueType	yosys/libs/fst/fstapi.h	/^enum fstEnumValueType$/;"	g
fstExtractRvatDataFromFrame	yosys/libs/fst/fstapi.cc	/^static char *fstExtractRvatDataFromFrame(struct fstReaderContext *xc, fstHandle facidx, char *bu/;"	f	typeref:typename:char *	file:
fstFileType	yosys/libs/fst/fstapi.h	/^enum fstFileType$/;"	g
fstFread	yosys/libs/fst/fstapi.cc	/^static size_t fstFread(void *buf, size_t siz, size_t cnt, FILE *fp) { return (fread(buf, siz, cn/;"	f	typeref:typename:size_t	file:
fstFtruncate	yosys/libs/fst/fstapi.cc	/^static int fstFtruncate(int fd, fst_off_t length) { return (ftruncate(fd, length)); }$/;"	f	typeref:typename:int	file:
fstFwrite	yosys/libs/fst/fstapi.cc	/^static size_t fstFwrite(const void *buf, size_t siz, size_t cnt, FILE *fp) { return (fwrite(buf,/;"	f	typeref:typename:size_t	file:
fstGetSVarint64	yosys/libs/fst/fstapi.cc	/^static int64_t fstGetSVarint64(unsigned char *mem, int *skiplen)$/;"	f	typeref:typename:int64_t	file:
fstGetUint32	yosys/libs/fst/fstapi.cc	/^#define fstGetUint32(/;"	d	file:
fstGetUint32	yosys/libs/fst/fstapi.cc	/^static uint32_t fstGetUint32(unsigned char *mem)$/;"	f	typeref:typename:uint32_t	file:
fstGetVarint32	yosys/libs/fst/fstapi.cc	/^static uint32_t fstGetVarint32(unsigned char *mem, int *skiplen)$/;"	f	typeref:typename:uint32_t	file:
fstGetVarint32Length	yosys/libs/fst/fstapi.cc	/^static uint32_t fstGetVarint32Length(unsigned char *mem)$/;"	f	typeref:typename:uint32_t	file:
fstGetVarint32NoSkip	yosys/libs/fst/fstapi.cc	/^static uint32_t fstGetVarint32NoSkip(unsigned char *mem)$/;"	f	typeref:typename:uint32_t	file:
fstGetVarint64	yosys/libs/fst/fstapi.cc	/^static uint64_t fstGetVarint64(unsigned char *mem, int *skiplen)$/;"	f	typeref:typename:uint64_t	file:
fstHandle	yosys/libs/fst/fstapi.h	/^typedef uint32_t fstHandle;$/;"	t	typeref:typename:uint32_t
fstHier	yosys/libs/fst/fstapi.h	/^struct fstHier$/;"	s
fstHierAttr	yosys/libs/fst/fstapi.h	/^        struct fstHierAttr$/;"	s	union:fstHier::__anonafd27bad010a
fstHierScope	yosys/libs/fst/fstapi.h	/^        struct fstHierScope$/;"	s	union:fstHier::__anonafd27bad010a
fstHierType	yosys/libs/fst/fstapi.h	/^enum fstHierType$/;"	g
fstHierVar	yosys/libs/fst/fstapi.h	/^        struct fstHierVar$/;"	s	union:fstHier::__anonafd27bad010a
fstMiscType	yosys/libs/fst/fstapi.h	/^enum fstMiscType$/;"	g
fstMmap	yosys/libs/fst/fstapi.cc	/^#define fstMmap(/;"	d	file:
fstMmap2	yosys/libs/fst/fstapi.cc	/^static void *fstMmap2(size_t __len, int __fd, fst_off_t __off)$/;"	f	typeref:typename:void *	file:
fstMunmap	yosys/libs/fst/fstapi.cc	/^#define fstMunmap(/;"	d	file:
fstPackType	yosys/libs/fst/fstapi.h	/^enum fstPackType$/;"	g
fstReaderClose	yosys/libs/fst/fstapi.cc	/^void fstReaderClose(void *ctx)$/;"	f	typeref:typename:void
fstReaderClrFacProcessMask	yosys/libs/fst/fstapi.cc	/^void fstReaderClrFacProcessMask(void *ctx, fstHandle facidx)$/;"	f	typeref:typename:void
fstReaderClrFacProcessMaskAll	yosys/libs/fst/fstapi.cc	/^void fstReaderClrFacProcessMaskAll(void *ctx)$/;"	f	typeref:typename:void
fstReaderContext	yosys/libs/fst/fstapi.cc	/^struct fstReaderContext$/;"	s	file:
fstReaderDeallocateRvatData	yosys/libs/fst/fstapi.cc	/^static void fstReaderDeallocateRvatData(void *ctx)$/;"	f	typeref:typename:void	file:
fstReaderDeallocateScopeData	yosys/libs/fst/fstapi.cc	/^static void fstReaderDeallocateScopeData(struct fstReaderContext *xc)$/;"	f	typeref:typename:void	file:
fstReaderFseeko	yosys/libs/fst/fstapi.cc	/^int fstReaderFseeko(struct fstReaderContext *xc, FILE *stream, fst_off_t offset, int whence)$/;"	f	typeref:typename:int
fstReaderGetAliasCount	yosys/libs/fst/fstapi.cc	/^uint64_t fstReaderGetAliasCount(void *ctx)$/;"	f	typeref:typename:uint64_t
fstReaderGetCurrentFlatScope	yosys/libs/fst/fstapi.cc	/^const char *fstReaderGetCurrentFlatScope(void *ctx)$/;"	f	typeref:typename:const char *
fstReaderGetCurrentScopeLen	yosys/libs/fst/fstapi.cc	/^int fstReaderGetCurrentScopeLen(void *ctx)$/;"	f	typeref:typename:int
fstReaderGetCurrentScopeUserInfo	yosys/libs/fst/fstapi.cc	/^void *fstReaderGetCurrentScopeUserInfo(void *ctx)$/;"	f	typeref:typename:void *
fstReaderGetDateString	yosys/libs/fst/fstapi.cc	/^const char *fstReaderGetDateString(void *ctx)$/;"	f	typeref:typename:const char *
fstReaderGetDoubleEndianMatchState	yosys/libs/fst/fstapi.cc	/^int fstReaderGetDoubleEndianMatchState(void *ctx)$/;"	f	typeref:typename:int
fstReaderGetDumpActivityChangeTime	yosys/libs/fst/fstapi.cc	/^uint64_t fstReaderGetDumpActivityChangeTime(void *ctx, uint32_t idx)$/;"	f	typeref:typename:uint64_t
fstReaderGetDumpActivityChangeValue	yosys/libs/fst/fstapi.cc	/^unsigned char fstReaderGetDumpActivityChangeValue(void *ctx, uint32_t idx)$/;"	f	typeref:typename:unsigned char
fstReaderGetEndTime	yosys/libs/fst/fstapi.cc	/^uint64_t fstReaderGetEndTime(void *ctx)$/;"	f	typeref:typename:uint64_t
fstReaderGetFacProcessMask	yosys/libs/fst/fstapi.cc	/^int fstReaderGetFacProcessMask(void *ctx, fstHandle facidx)$/;"	f	typeref:typename:int
fstReaderGetFileType	yosys/libs/fst/fstapi.cc	/^int fstReaderGetFileType(void *ctx)$/;"	f	typeref:typename:int
fstReaderGetFseekFailed	yosys/libs/fst/fstapi.cc	/^int fstReaderGetFseekFailed(void *ctx)$/;"	f	typeref:typename:int
fstReaderGetMaxHandle	yosys/libs/fst/fstapi.cc	/^fstHandle fstReaderGetMaxHandle(void *ctx)$/;"	f	typeref:typename:fstHandle
fstReaderGetMemoryUsedByWriter	yosys/libs/fst/fstapi.cc	/^uint64_t fstReaderGetMemoryUsedByWriter(void *ctx)$/;"	f	typeref:typename:uint64_t
fstReaderGetNumberDumpActivityChanges	yosys/libs/fst/fstapi.cc	/^uint32_t fstReaderGetNumberDumpActivityChanges(void *ctx)$/;"	f	typeref:typename:uint32_t
fstReaderGetScopeCount	yosys/libs/fst/fstapi.cc	/^uint64_t fstReaderGetScopeCount(void *ctx)$/;"	f	typeref:typename:uint64_t
fstReaderGetStartTime	yosys/libs/fst/fstapi.cc	/^uint64_t fstReaderGetStartTime(void *ctx)$/;"	f	typeref:typename:uint64_t
fstReaderGetTimescale	yosys/libs/fst/fstapi.cc	/^signed char fstReaderGetTimescale(void *ctx)$/;"	f	typeref:typename:signed char
fstReaderGetTimezero	yosys/libs/fst/fstapi.cc	/^int64_t fstReaderGetTimezero(void *ctx)$/;"	f	typeref:typename:int64_t
fstReaderGetValueChangeSectionCount	yosys/libs/fst/fstapi.cc	/^uint64_t fstReaderGetValueChangeSectionCount(void *ctx)$/;"	f	typeref:typename:uint64_t
fstReaderGetValueFromHandleAtTime	yosys/libs/fst/fstapi.cc	/^char *fstReaderGetValueFromHandleAtTime(void *ctx, uint64_t tim, fstHandle facidx, char *buf)$/;"	f	typeref:typename:char *
fstReaderGetVarCount	yosys/libs/fst/fstapi.cc	/^uint64_t fstReaderGetVarCount(void *ctx)$/;"	f	typeref:typename:uint64_t
fstReaderGetVersionString	yosys/libs/fst/fstapi.cc	/^const char *fstReaderGetVersionString(void *ctx)$/;"	f	typeref:typename:const char *
fstReaderInit	yosys/libs/fst/fstapi.cc	/^int fstReaderInit(struct fstReaderContext *xc)$/;"	f	typeref:typename:int
fstReaderIterBlocks	yosys/libs/fst/fstapi.cc	/^int fstReaderIterBlocks(void *ctx,$/;"	f	typeref:typename:int
fstReaderIterBlocks2	yosys/libs/fst/fstapi.cc	/^int fstReaderIterBlocks2(void *ctx,$/;"	f	typeref:typename:int
fstReaderIterBlocksSetNativeDoublesOnCallback	yosys/libs/fst/fstapi.cc	/^void fstReaderIterBlocksSetNativeDoublesOnCallback(void *ctx, int enable)$/;"	f	typeref:typename:void
fstReaderIterateHier	yosys/libs/fst/fstapi.cc	/^struct fstHier *fstReaderIterateHier(void *ctx)$/;"	f	typeref:struct:fstHier *
fstReaderIterateHierRewind	yosys/libs/fst/fstapi.cc	/^int fstReaderIterateHierRewind(void *ctx)$/;"	f	typeref:typename:int
fstReaderOpen	yosys/libs/fst/fstapi.cc	/^void *fstReaderOpen(const char *nam)$/;"	f	typeref:typename:void *
fstReaderOpenForUtilitiesOnly	yosys/libs/fst/fstapi.cc	/^void *fstReaderOpenForUtilitiesOnly(void)$/;"	f	typeref:typename:void *
fstReaderPopScope	yosys/libs/fst/fstapi.cc	/^const char *fstReaderPopScope(void *ctx)$/;"	f	typeref:typename:const char *
fstReaderProcessHier	yosys/libs/fst/fstapi.cc	/^int fstReaderProcessHier(void *ctx, FILE *fv)$/;"	f	typeref:typename:int
fstReaderPushScope	yosys/libs/fst/fstapi.cc	/^const char *fstReaderPushScope(void *ctx, const char *nam, void *user_info)$/;"	f	typeref:typename:const char *
fstReaderRecreateHierFile	yosys/libs/fst/fstapi.cc	/^static int fstReaderRecreateHierFile(struct fstReaderContext *xc)$/;"	f	typeref:typename:int	file:
fstReaderResetScope	yosys/libs/fst/fstapi.cc	/^void fstReaderResetScope(void *ctx)$/;"	f	typeref:typename:void
fstReaderSetFacProcessMask	yosys/libs/fst/fstapi.cc	/^void fstReaderSetFacProcessMask(void *ctx, fstHandle facidx)$/;"	f	typeref:typename:void
fstReaderSetFacProcessMaskAll	yosys/libs/fst/fstapi.cc	/^void fstReaderSetFacProcessMaskAll(void *ctx)$/;"	f	typeref:typename:void
fstReaderSetLimitTimeRange	yosys/libs/fst/fstapi.cc	/^void fstReaderSetLimitTimeRange(void *ctx, uint64_t start_time, uint64_t end_time)$/;"	f	typeref:typename:void
fstReaderSetUnlimitedTimeRange	yosys/libs/fst/fstapi.cc	/^void fstReaderSetUnlimitedTimeRange(void *ctx)$/;"	f	typeref:typename:void
fstReaderSetVcdExtensions	yosys/libs/fst/fstapi.cc	/^void fstReaderSetVcdExtensions(void *ctx, int enable)$/;"	f	typeref:typename:void
fstReaderUint64	yosys/libs/fst/fstapi.cc	/^static uint64_t fstReaderUint64(FILE *f)$/;"	f	typeref:typename:uint64_t	file:
fstReaderVarint32	yosys/libs/fst/fstapi.cc	/^static uint32_t fstReaderVarint32(FILE *f)$/;"	f	typeref:typename:uint32_t	file:
fstReaderVarint32WithSkip	yosys/libs/fst/fstapi.cc	/^static uint32_t fstReaderVarint32WithSkip(FILE *f, uint32_t *skiplen)$/;"	f	typeref:typename:uint32_t	file:
fstReaderVarint64	yosys/libs/fst/fstapi.cc	/^static uint64_t fstReaderVarint64(FILE *f)$/;"	f	typeref:typename:uint64_t	file:
fstRealpath	yosys/libs/fst/fstapi.cc	/^static char *fstRealpath(const char *path, char *resolved_path)$/;"	f	typeref:typename:char *	file:
fstScopeType	yosys/libs/fst/fstapi.h	/^enum fstScopeType$/;"	g
fstSupplementalDataType	yosys/libs/fst/fstapi.h	/^enum fstSupplementalDataType$/;"	g
fstSupplementalVarType	yosys/libs/fst/fstapi.h	/^enum fstSupplementalVarType$/;"	g
fstUtilityBinToEsc	yosys/libs/fst/fstapi.cc	/^int fstUtilityBinToEsc(unsigned char *d, const unsigned char *s, int len)$/;"	f	typeref:typename:int
fstUtilityBinToEscConvertedLen	yosys/libs/fst/fstapi.cc	/^int fstUtilityBinToEscConvertedLen(const unsigned char *s, int len)$/;"	f	typeref:typename:int
fstUtilityEscToBin	yosys/libs/fst/fstapi.cc	/^int fstUtilityEscToBin(unsigned char *d, unsigned char *s, int len)$/;"	f	typeref:typename:int
fstUtilityExtractEnumTableFromString	yosys/libs/fst/fstapi.cc	/^struct fstETab *fstUtilityExtractEnumTableFromString(const char *s)$/;"	f	typeref:struct:fstETab *
fstUtilityFreeEnumTable	yosys/libs/fst/fstapi.cc	/^void fstUtilityFreeEnumTable(struct fstETab *etab)$/;"	f	typeref:typename:void
fstVarDir	yosys/libs/fst/fstapi.h	/^enum fstVarDir$/;"	g
fstVarType	yosys/libs/fst/fstapi.h	/^enum fstVarType$/;"	g
fstVcdID	yosys/libs/fst/fstapi.cc	/^static void fstVcdID(char *buf, unsigned int value)$/;"	f	typeref:typename:void	file:
fstVcdIDForFwrite	yosys/libs/fst/fstapi.cc	/^static int fstVcdIDForFwrite(char *buf, unsigned int value)$/;"	f	typeref:typename:int	file:
fstWriterClose	yosys/libs/fst/fstapi.cc	/^void fstWriterClose(void *ctx)$/;"	f	typeref:typename:void
fstWriterContext	yosys/libs/fst/fstapi.cc	/^struct fstWriterContext$/;"	s	file:
fstWriterCreate	yosys/libs/fst/fstapi.cc	/^void *fstWriterCreate(const char *nam, int use_compressed_hier)$/;"	f	typeref:typename:void *
fstWriterCreateEnumTable	yosys/libs/fst/fstapi.cc	/^fstEnumHandle fstWriterCreateEnumTable(void *ctx, const char *name, uint32_t elem_count, unsigne/;"	f	typeref:typename:fstEnumHandle
fstWriterCreateMmaps	yosys/libs/fst/fstapi.cc	/^static void fstWriterCreateMmaps(struct fstWriterContext *xc)$/;"	f	typeref:typename:void	file:
fstWriterCreateVar	yosys/libs/fst/fstapi.cc	/^fstHandle fstWriterCreateVar(void *ctx, enum fstVarType vt, enum fstVarDir vd, uint32_t len, con/;"	f	typeref:typename:fstHandle
fstWriterCreateVar2	yosys/libs/fst/fstapi.cc	/^fstHandle fstWriterCreateVar2(void *ctx, enum fstVarType vt, enum fstVarDir vd, uint32_t len, co/;"	f	typeref:typename:fstHandle
fstWriterEmitDumpActive	yosys/libs/fst/fstapi.cc	/^void fstWriterEmitDumpActive(void *ctx, int enable)$/;"	f	typeref:typename:void
fstWriterEmitEnumTableRef	yosys/libs/fst/fstapi.cc	/^void fstWriterEmitEnumTableRef(void *ctx, fstEnumHandle handle)$/;"	f	typeref:typename:void
fstWriterEmitHdrBytes	yosys/libs/fst/fstapi.cc	/^static void fstWriterEmitHdrBytes(struct fstWriterContext *xc)$/;"	f	typeref:typename:void	file:
fstWriterEmitSectionHeader	yosys/libs/fst/fstapi.cc	/^static void fstWriterEmitSectionHeader(void *ctx)$/;"	f	typeref:typename:void	file:
fstWriterEmitTimeChange	yosys/libs/fst/fstapi.cc	/^void fstWriterEmitTimeChange(void *ctx, uint64_t tim)$/;"	f	typeref:typename:void
fstWriterEmitValueChange	yosys/libs/fst/fstapi.cc	/^void fstWriterEmitValueChange(void *ctx, fstHandle handle, const void *val)$/;"	f	typeref:typename:void
fstWriterEmitValueChange32	yosys/libs/fst/fstapi.cc	/^void fstWriterEmitValueChange32(void *ctx, fstHandle handle, uint32_t bits, uint32_t val)$/;"	f	typeref:typename:void
fstWriterEmitValueChange64	yosys/libs/fst/fstapi.cc	/^void fstWriterEmitValueChange64(void *ctx, fstHandle handle, uint32_t bits, uint64_t val)$/;"	f	typeref:typename:void
fstWriterEmitValueChangeVec32	yosys/libs/fst/fstapi.cc	/^void fstWriterEmitValueChangeVec32(void *ctx, fstHandle handle, uint32_t bits, const uint32_t *v/;"	f	typeref:typename:void
fstWriterEmitValueChangeVec64	yosys/libs/fst/fstapi.cc	/^void fstWriterEmitValueChangeVec64(void *ctx, fstHandle handle, uint32_t bits, const uint64_t *v/;"	f	typeref:typename:void
fstWriterEmitVariableLengthValueChange	yosys/libs/fst/fstapi.cc	/^void fstWriterEmitVariableLengthValueChange(void *ctx, fstHandle handle, const void *val, uint32/;"	f	typeref:typename:void
fstWriterFlushContext	yosys/libs/fst/fstapi.cc	/^void fstWriterFlushContext(void *ctx)$/;"	f	typeref:typename:void
fstWriterFlushContextPrivate	yosys/libs/fst/fstapi.cc	/^static void fstWriterFlushContextPrivate(void *ctx)$/;"	f	typeref:typename:void	file:
fstWriterFlushContextPrivate1	yosys/libs/fst/fstapi.cc	/^static void *fstWriterFlushContextPrivate1(void *ctx)$/;"	f	typeref:typename:void *	file:
fstWriterFlushContextPrivate2	yosys/libs/fst/fstapi.cc	/^static void fstWriterFlushContextPrivate2(void *ctx)$/;"	f	typeref:typename:void	file:
fstWriterFseeko	yosys/libs/fst/fstapi.cc	/^static int fstWriterFseeko(struct fstWriterContext *xc, FILE *stream, fst_off_t offset, int when/;"	f	typeref:typename:int	file:
fstWriterGetDumpSizeLimitReached	yosys/libs/fst/fstapi.cc	/^int fstWriterGetDumpSizeLimitReached(void *ctx)$/;"	f	typeref:typename:int
fstWriterGetFseekFailed	yosys/libs/fst/fstapi.cc	/^int fstWriterGetFseekFailed(void *ctx)$/;"	f	typeref:typename:int
fstWriterMmapSanity	yosys/libs/fst/fstapi.cc	/^static void fstWriterMmapSanity(void *pnt, const char *file, int line, const char *usage)$/;"	f	typeref:typename:void	file:
fstWriterPackType	yosys/libs/fst/fstapi.h	/^enum fstWriterPackType$/;"	g
fstWriterSVarint	yosys/libs/fst/fstapi.cc	/^static int fstWriterSVarint(FILE *handle, int64_t v)$/;"	f	typeref:typename:int	file:
fstWriterSetAttrBegin	yosys/libs/fst/fstapi.cc	/^void fstWriterSetAttrBegin(void *ctx, enum fstAttrType attrtype, int subtype, const char *attrna/;"	f	typeref:typename:void
fstWriterSetAttrDoubleArgGeneric	yosys/libs/fst/fstapi.cc	/^static void fstWriterSetAttrDoubleArgGeneric(void *ctx, int typ, uint64_t arg1, uint64_t arg2)$/;"	f	typeref:typename:void	file:
fstWriterSetAttrEnd	yosys/libs/fst/fstapi.cc	/^void fstWriterSetAttrEnd(void *ctx)$/;"	f	typeref:typename:void
fstWriterSetAttrGeneric	yosys/libs/fst/fstapi.cc	/^static void fstWriterSetAttrGeneric(void *ctx, const char *comm, int typ, uint64_t arg)$/;"	f	typeref:typename:void	file:
fstWriterSetComment	yosys/libs/fst/fstapi.cc	/^void fstWriterSetComment(void *ctx, const char *comm) { fstWriterSetAttrGeneric(ctx, comm, FST_M/;"	f	typeref:typename:void
fstWriterSetDate	yosys/libs/fst/fstapi.cc	/^void fstWriterSetDate(void *ctx, const char *dat)$/;"	f	typeref:typename:void
fstWriterSetDumpSizeLimit	yosys/libs/fst/fstapi.cc	/^void fstWriterSetDumpSizeLimit(void *ctx, uint64_t numbytes)$/;"	f	typeref:typename:void
fstWriterSetEnvVar	yosys/libs/fst/fstapi.cc	/^void fstWriterSetEnvVar(void *ctx, const char *envvar) { fstWriterSetAttrGeneric(ctx, envvar, FS/;"	f	typeref:typename:void
fstWriterSetFileType	yosys/libs/fst/fstapi.cc	/^void fstWriterSetFileType(void *ctx, enum fstFileType filetype)$/;"	f	typeref:typename:void
fstWriterSetPackType	yosys/libs/fst/fstapi.cc	/^void fstWriterSetPackType(void *ctx, enum fstWriterPackType typ)$/;"	f	typeref:typename:void
fstWriterSetParallelMode	yosys/libs/fst/fstapi.cc	/^void fstWriterSetParallelMode(void *ctx, int enable)$/;"	f	typeref:typename:void
fstWriterSetRepackOnClose	yosys/libs/fst/fstapi.cc	/^void fstWriterSetRepackOnClose(void *ctx, int enable)$/;"	f	typeref:typename:void
fstWriterSetScope	yosys/libs/fst/fstapi.cc	/^void fstWriterSetScope(void *ctx, enum fstScopeType scopetype, const char *scopename, const char/;"	f	typeref:typename:void
fstWriterSetSourceInstantiationStem	yosys/libs/fst/fstapi.cc	/^void fstWriterSetSourceInstantiationStem(void *ctx, const char *path, unsigned int line, unsigne/;"	f	typeref:typename:void
fstWriterSetSourceStem	yosys/libs/fst/fstapi.cc	/^void fstWriterSetSourceStem(void *ctx, const char *path, unsigned int line, unsigned int use_rea/;"	f	typeref:typename:void
fstWriterSetSourceStem_2	yosys/libs/fst/fstapi.cc	/^static void fstWriterSetSourceStem_2(void *ctx, const char *path, unsigned int line, unsigned in/;"	f	typeref:typename:void	file:
fstWriterSetTimescale	yosys/libs/fst/fstapi.cc	/^void fstWriterSetTimescale(void *ctx, int ts)$/;"	f	typeref:typename:void
fstWriterSetTimescaleFromString	yosys/libs/fst/fstapi.cc	/^void fstWriterSetTimescaleFromString(void *ctx, const char *s)$/;"	f	typeref:typename:void
fstWriterSetTimezero	yosys/libs/fst/fstapi.cc	/^void fstWriterSetTimezero(void *ctx, int64_t tim)$/;"	f	typeref:typename:void
fstWriterSetUpscope	yosys/libs/fst/fstapi.cc	/^void fstWriterSetUpscope(void *ctx)$/;"	f	typeref:typename:void
fstWriterSetValueList	yosys/libs/fst/fstapi.cc	/^void fstWriterSetValueList(void *ctx, const char *vl) { fstWriterSetAttrGeneric(ctx, vl, FST_MT_/;"	f	typeref:typename:void
fstWriterSetVersion	yosys/libs/fst/fstapi.cc	/^void fstWriterSetVersion(void *ctx, const char *vers)$/;"	f	typeref:typename:void
fstWriterUint32WithVarint32	yosys/libs/fst/fstapi.cc	/^static uint32_t fstWriterUint32WithVarint32(struct fstWriterContext *xc, uint32_t *u, uint32_t v/;"	f	typeref:typename:uint32_t	file:
fstWriterUint32WithVarint32AndLength	yosys/libs/fst/fstapi.cc	/^static uint32_t fstWriterUint32WithVarint32AndLength(struct fstWriterContext *xc, uint32_t *u, u/;"	f	typeref:typename:uint32_t	file:
fstWriterUint64	yosys/libs/fst/fstapi.cc	/^static int fstWriterUint64(FILE *handle, uint64_t v)$/;"	f	typeref:typename:int	file:
fstWriterVarint	yosys/libs/fst/fstapi.cc	/^static int fstWriterVarint(FILE *handle, uint64_t v)$/;"	f	typeref:typename:int	file:
fstWritex	yosys/libs/fst/fstapi.cc	/^#define fstWritex(/;"	d	file:
fstWritex	yosys/libs/fst/fstapi.cc	/^static void fstWritex(struct fstReaderContext *xc, void *v, int len)$/;"	f	typeref:typename:void	file:
fst_break_add_size	yosys/libs/fst/fstapi.cc	/^    size_t fst_break_add_size;$/;"	m	struct:fstWriterContext	typeref:typename:size_t	file:
fst_break_size	yosys/libs/fst/fstapi.cc	/^    size_t fst_break_size;$/;"	m	struct:fstWriterContext	typeref:typename:size_t	file:
fst_end_of_data_exception	yosys/kernel/fstdata.h	/^struct fst_end_of_data_exception { };$/;"	s
fst_handles	yosys/passes/sat/sim.cc	/^	dict<Wire*, fstHandle> fst_handles;$/;"	m	struct:SimInstance	typeref:typename:dict<Wire *,fstHandle>	file:
fst_huge_break_size	yosys/libs/fst/fstapi.cc	/^    size_t fst_huge_break_size;$/;"	m	struct:fstWriterContext	typeref:typename:size_t	file:
fst_off_t	yosys/libs/fst/fstapi.cc	/^typedef int64_t fst_off_t;$/;"	t	typeref:typename:int64_t	file:
fst_off_t	yosys/libs/fst/fstapi.cc	/^typedef off_t fst_off_t;$/;"	t	typeref:typename:off_t	file:
fst_orig_break_add_size	yosys/libs/fst/fstapi.cc	/^    size_t fst_orig_break_add_size;$/;"	m	struct:fstWriterContext	typeref:typename:size_t	file:
fst_orig_break_size	yosys/libs/fst/fstapi.cc	/^    size_t fst_orig_break_size;$/;"	m	struct:fstWriterContext	typeref:typename:size_t	file:
fstfile	yosys/passes/sat/sim.cc	/^	struct fstContext *fstfile = nullptr;$/;"	m	struct:FSTWriter	typeref:struct:fstContext *	file:
ftello	yosys/libs/fst/fstapi.cc	/^#define ftello /;"	d	file:
ftruncate	yosys/libs/fst/fstapi.h	/^#define ftruncate /;"	d
full	yosys/libs/fst/lz4.cc	/^    full = 0,$/;"	e	enum:__anon9390dffe0803	file:
full_case_bits_cache	yosys/passes/proc/proc_mux.cc	/^	dict<RTLIL::SwitchRule*, pool<RTLIL::SigBit>, hash_ptr_ops> full_case_bits_cache;$/;"	m	struct:SnippetSwCache	typeref:typename:dict<RTLIL::SwitchRule *,pool<RTLIL::SigBit>,hash_ptr_ops>	file:
full_mode	yosys/passes/fsm/fsm_expand.cc	/^	bool full_mode;$/;"	m	struct:FsmExpand	typeref:typename:bool	file:
full_name	yosys/passes/hierarchy/submod.cc	/^		std::string name, full_name;$/;"	m	struct:SubmodWorker::SubModule	typeref:typename:std::string	file:
full_selection	yosys/kernel/rtlil.h	/^	bool full_selection() const {$/;"	f	struct:RTLIL::Design	typeref:typename:bool
full_selection	yosys/kernel/rtlil.h	/^	bool full_selection;$/;"	m	struct:RTLIL::Selection	typeref:typename:bool
fulladd	yosys/passes/techmap/maccmap.cc	/^	void fulladd(RTLIL::SigSpec &in1, RTLIL::SigSpec &in2, RTLIL::SigSpec &in3, RTLIL::SigSpec &out/;"	f	struct:MaccmapWorker	typeref:typename:void	file:
fulladder	yosys/libs/ezsat/ezsat.cc	/^static void fulladder(ezSAT *that, int a, int b, int c, int &y, int &x)$/;"	f	typeref:typename:void	file:
fullhash	yosys/libs/fst/fstapi.cc	/^    uint32_t fullhash, length;$/;"	m	struct:collchain_t	typeref:typename:uint32_t	file:
func	yosys/kernel/log.h	/^	const char *file, *func, *id;$/;"	m	struct:CoverData	typeref:typename:const char *
func2	yosys/passes/techmap/extract_fa.cc	/^	dict<tuple<SigBit, SigBit>, dict<int, pool<SigBit>>> func2;$/;"	m	struct:ExtractFaWorker	typeref:typename:dict<tuple<SigBit,SigBit>,dict<int,pool<SigBit>>>	file:
func2_and_info	yosys/passes/techmap/extract_fa.cc	/^	dict<int, func2_and_info_t> func2_and_info;$/;"	m	struct:ExtractFaWorker	typeref:typename:dict<int,func2_and_info_t>	file:
func2_and_info_t	yosys/passes/techmap/extract_fa.cc	/^	struct func2_and_info_t {$/;"	s	struct:ExtractFaWorker	file:
func2vl	yosys/passes/techmap/libparse.cc	/^std::string func2vl(std::string str)$/;"	f	typeref:typename:std::string
func3	yosys/passes/techmap/extract_fa.cc	/^	dict<tuple<SigBit, SigBit, SigBit>, dict<int, pool<SigBit>>> func3;$/;"	m	struct:ExtractFaWorker	typeref:typename:dict<tuple<SigBit,SigBit,SigBit>,dict<int,pool<SigBit>>>	file:
func3_maj_info	yosys/passes/techmap/extract_fa.cc	/^	dict<int, func3_maj_info_t> func3_maj_info;$/;"	m	struct:ExtractFaWorker	typeref:typename:dict<int,func3_maj_info_t>	file:
func3_maj_info_t	yosys/passes/techmap/extract_fa.cc	/^	struct func3_maj_info_t {$/;"	s	struct:ExtractFaWorker	file:
funct_declarations	yosys/backends/simplec/simplec.cc	/^	vector<string> funct_declarations;$/;"	m	struct:SimplecWorker	typeref:typename:vector<string>	file:
fwd	yosys/passes/sat/fmcombine.cc	/^	bool fwd = false;$/;"	m	struct:opts_t	typeref:typename:bool	file:
fwd_ct	yosys/passes/opt/share.cc	/^	CellTypes fwd_ct, cone_ct;$/;"	m	struct:ShareWorker	typeref:typename:CellTypes	file:
fwd_merge_cache	yosys/passes/equiv/equiv_struct.cc	/^	pool<merge_key_t> fwd_merge_cache, bwd_merge_cache;$/;"	m	struct:EquivStructWorker	typeref:typename:pool<merge_key_t>	file:
fwonly_cells	yosys/passes/equiv/equiv_struct.cc	/^	const pool<IdString> &fwonly_cells;$/;"	m	struct:EquivStructWorker	typeref:typename:const pool<IdString> &	file:
g_units	yosys/passes/sat/sim.cc	/^static const std::map<std::string, int> g_units =$/;"	v	typeref:typename:const std::map<std::string,int>	file:
garbageCollect	yosys/libs/minisat/SimpSolver.cc	/^void SimpSolver::garbageCollect()$/;"	f	class:SimpSolver	typeref:typename:void
garbageCollect	yosys/libs/minisat/Solver.cc	/^void Solver::garbageCollect()$/;"	f	class:Solver	typeref:typename:void
garbage_frac	yosys/libs/minisat/Solver.h	/^    double    garbage_frac;       \/\/ The fraction of wasted memory allowed before a garbage co/;"	m	class:Minisat::Solver	typeref:typename:double
gate	yosys/passes/sat/sim.cc	/^	gate,$/;"	e	enum:SimulationMode	file:
gate_area	yosys/passes/techmap/flowmap.cc	/^	int gate_area = 0, lut_area = 0;$/;"	m	struct:FlowmapWorker	typeref:typename:int	file:
gate_cost	yosys/kernel/cost.h	/^	const dict<RTLIL::IdString, int> *gate_cost = nullptr;$/;"	m	struct:CellCosts	typeref:typename:const dict<RTLIL::IdString,int> *
gate_count	yosys/passes/techmap/flowmap.cc	/^	int gate_count = 0, lut_count = 0, packed_count = 0;$/;"	m	struct:FlowmapWorker	typeref:typename:int	file:
gate_mod	yosys/passes/equiv/equiv_make.cc	/^	Module *gold_mod, *gate_mod, *equiv_mod;$/;"	m	struct:EquivMakeWorker	typeref:typename:Module *	file:
gate_t	yosys/passes/techmap/abc.cc	/^struct gate_t$/;"	s	file:
gate_type_t	yosys/passes/techmap/abc.cc	/^enum class gate_type_t {$/;"	g	file:
gates_mode	yosys/backends/blif/blif.cc	/^	bool gates_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
gatherTouchedClauses	yosys/libs/minisat/SimpSolver.cc	/^void SimpSolver::gatherTouchedClauses()$/;"	f	class:SimpSolver	typeref:typename:void
gcd	yosys/libs/bigint/BigIntegerAlgorithms.cc	/^BigUnsigned gcd(BigUnsigned a, BigUnsigned b) {$/;"	f	typeref:typename:BigUnsigned
gclk	yosys/frontends/verific/verific.h	/^	bool gclk = false;$/;"	m	struct:VerificClocking	typeref:typename:bool
ge_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> ge_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
ge_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> ge_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
genBindings	yosys/frontends/ast/genrtlil.cc	/^std::vector<RTLIL::Binding *> AstNode::genBindings() const$/;"	f	class:AstNode	typeref:typename:std::vector<RTLIL::Binding * >
genRTLIL	yosys/frontends/ast/genrtlil.cc	/^RTLIL::SigSpec AstNode::genRTLIL(int width_hint, bool sign_hint)$/;"	f	class:AstNode	typeref:typename:RTLIL::SigSpec
genRTLIL_subst_ptr	yosys/frontends/ast/ast.cc	/^	const dict<RTLIL::SigBit, RTLIL::SigBit> *genRTLIL_subst_ptr = NULL;$/;"	v	namespace:AST_INTERNAL	typeref:typename:const dict<RTLIL::SigBit,RTLIL::SigBit> *
genSignedLabels	yosys/passes/cmds/show.cc	/^	bool genSignedLabels;$/;"	m	struct:ShowWorker	typeref:typename:bool	file:
genWidthLabels	yosys/passes/cmds/show.cc	/^	bool genWidthLabels;$/;"	m	struct:ShowWorker	typeref:typename:bool	file:
genWidthRTLIL	yosys/frontends/ast/genrtlil.cc	/^RTLIL::SigSpec AstNode::genWidthRTLIL(int width, bool sgn, const dict<RTLIL::SigBit, RTLIL::SigB/;"	f	class:AstNode	typeref:typename:RTLIL::SigSpec
gen_aldff	yosys/passes/proc/proc_dff.cc	/^void gen_aldff(RTLIL::Module *mod, RTLIL::SigSpec sig_in, RTLIL::SigSpec sig_set, RTLIL::SigSpec/;"	f	typeref:typename:void
gen_cmp	yosys/passes/proc/proc_mux.cc	/^RTLIL::SigSpec gen_cmp(RTLIL::Module *mod, const RTLIL::SigSpec &signal, const std::vector<RTLIL/;"	f	typeref:typename:RTLIL::SigSpec
gen_dff	yosys/passes/proc/proc_dff.cc	/^void gen_dff(RTLIL::Module *mod, RTLIL::SigSpec sig_in, RTLIL::Const val_rst, RTLIL::SigSpec sig/;"	f	typeref:typename:void
gen_dffsr_complex	yosys/passes/proc/proc_dff.cc	/^void gen_dffsr_complex(RTLIL::Module *mod, RTLIL::SigSpec sig_d, RTLIL::SigSpec sig_q, RTLIL::Si/;"	f	typeref:typename:void
gen_dshl	yosys/backends/firrtl/firrtl.cc	/^	std::string gen_dshl(const string b_expr, const int b_width)$/;"	f	struct:FirrtlWorker	typeref:typename:std::string	file:
gen_indent	yosys/backends/jny/jny.cc	/^        std::string gen_indent(const uint16_t level)$/;"	f	struct:JnyWriter	typeref:typename:std::string	file:
gen_mux	yosys/passes/proc/proc_mux.cc	/^RTLIL::SigSpec gen_mux(RTLIL::Module *mod, const RTLIL::SigSpec &signal, const std::vector<RTLIL/;"	f	typeref:typename:RTLIL::SigSpec
gen_portbox	yosys/passes/cmds/show.cc	/^	std::string gen_portbox(std::string port, RTLIL::SigSpec sig, bool driver, std::string *node = /;"	f	struct:ShowWorker	typeref:typename:std::string	file:
gen_signode_simple	yosys/passes/cmds/show.cc	/^	std::string gen_signode_simple(RTLIL::SigSpec sig, bool range_check = true)$/;"	f	struct:ShowWorker	typeref:typename:std::string	file:
gen_verilogsim	yosys/passes/techmap/libparse.cc	/^void gen_verilogsim(LibertyAst *ast)$/;"	f	typeref:typename:void
gen_verilogsim_cell	yosys/passes/techmap/libparse.cc	/^void gen_verilogsim_cell(LibertyAst *ast)$/;"	f	typeref:typename:void
generate	yosys/passes/hierarchy/hierarchy.cc	/^void generate(RTLIL::Design *design, const std::vector<std::string> &celltypes, const std::vecto/;"	f	typeref:typename:void
generate	yosys/passes/sat/fmcombine.cc	/^	void generate()$/;"	f	struct:FmcombineWorker	typeref:typename:void	file:
generateEnumerationMatrix	yosys/libs/subcircuit/subcircuit.cc	/^	void generateEnumerationMatrix(std::vector<std::set<int>> &enumerationMatrix, const GraphData &/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
generatePortmapCandidates	yosys/libs/subcircuit/subcircuit.cc	/^	void generatePortmapCandidates(std::set<std::map<std::string, std::string>> &portmapCandidates,/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
generate_model	yosys/passes/sat/sat.cc	/^	void generate_model()$/;"	f	struct:SatHelper	typeref:typename:void	file:
generate_pattern	yosys/passes/pmgen/generate.h	/^void generate_pattern(std::function<void(pm&,std::function<void()>)> run, const char *pmclass, c/;"	f	typeref:typename:void
generate_port_decl_t	yosys/passes/hierarchy/hierarchy.cc	/^struct generate_port_decl_t {$/;"	s	file:
generate_tb	yosys/passes/sat/sim.cc	/^	void generate_tb(Module *topmod, std::string tb_filename, int numcycles)$/;"	f	struct:SimWorker	typeref:typename:void	file:
generated_dlatches	yosys/passes/proc/proc_dlatch.cc	/^	pool<Cell*> generated_dlatches;$/;"	m	struct:proc_dlatch_db_t	typeref:typename:pool<Cell * >	file:
generated_names	yosys/backends/edif/edif.cc	/^	std::set<std::string> generated_names, used_names;$/;"	m	struct:EdifNames	typeref:typename:std::set<std::string>	file:
generated_sigtypes	yosys/backends/simplec/simplec.cc	/^	pool<int> generated_sigtypes;$/;"	m	struct:SimplecWorker	typeref:typename:pool<int>	file:
generated_structs	yosys/backends/simplec/simplec.cc	/^	pool<IdString> generated_structs;$/;"	m	struct:SimplecWorker	typeref:typename:pool<IdString>	file:
generated_utils	yosys/backends/simplec/simplec.cc	/^	pool<string> generated_utils;$/;"	m	struct:SimplecWorker	typeref:typename:pool<string>	file:
generic_bin_ops	yosys/passes/opt/share.cc	/^	pool<RTLIL::IdString> generic_uni_ops, generic_bin_ops, generic_cbin_ops, generic_other_ops;$/;"	m	struct:ShareWorkerConfig	typeref:typename:pool<RTLIL::IdString>	file:
generic_cbin_ops	yosys/passes/opt/share.cc	/^	pool<RTLIL::IdString> generic_uni_ops, generic_bin_ops, generic_cbin_ops, generic_other_ops;$/;"	m	struct:ShareWorkerConfig	typeref:typename:pool<RTLIL::IdString>	file:
generic_ops	yosys/passes/opt/share.cc	/^	pool<RTLIL::IdString> generic_ops;$/;"	m	struct:ShareWorker	typeref:typename:pool<RTLIL::IdString>	file:
generic_other_ops	yosys/passes/opt/share.cc	/^	pool<RTLIL::IdString> generic_uni_ops, generic_bin_ops, generic_cbin_ops, generic_other_ops;$/;"	m	struct:ShareWorkerConfig	typeref:typename:pool<RTLIL::IdString>	file:
generic_uni_ops	yosys/passes/opt/share.cc	/^	pool<RTLIL::IdString> generic_uni_ops, generic_bin_ops, generic_cbin_ops, generic_other_ops;$/;"	m	struct:ShareWorkerConfig	typeref:typename:pool<RTLIL::IdString>	file:
genid	yosys/passes/memory/memory_map.cc	/^	std::string genid(RTLIL::IdString name, std::string token1 = "", int i = -1, std::string token2/;"	f	struct:MemoryMapWorker	typeref:typename:std::string	file:
geom_handle	yosys/libs/fst/fstapi.cc	/^    FILE *geom_handle;$/;"	m	struct:fstWriterContext	typeref:typename:FILE *	file:
geom_handle_nam	yosys/libs/fst/fstapi.cc	/^    char *geom_handle_nam;$/;"	m	struct:fstWriterContext	typeref:typename:char *	file:
get	yosys/backends/cxxrtl/cxxrtl.h	/^	IntegerT get() const {$/;"	f	struct:cxxrtl::debug_item	typeref:typename:IntegerT
get	yosys/backends/cxxrtl/cxxrtl.h	/^	IntegerT get() const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE IntegerT
get	yosys/backends/cxxrtl/cxxrtl.h	/^	IntegerT get() const {$/;"	f	struct:cxxrtl::wire	typeref:typename:CXXRTL_ALWAYS_INLINE IntegerT
get	yosys/kernel/cost.h	/^	int get(RTLIL::Cell *cell)$/;"	f	struct:CellCosts	typeref:typename:int
get	yosys/kernel/cost.h	/^	int get(RTLIL::IdString type) const$/;"	f	struct:CellCosts	typeref:typename:int
get	yosys/kernel/utils.h	/^	const T &get(const Key &k)$/;"	f	struct:stackmap	typeref:typename:const T &
get	yosys/libs/ezsat/ezsat.h	/^		int get(ezSAT *that) {$/;"	f	struct:ezSAT::_V	typeref:typename:int
getAccept	yosys/frontends/verific/verificsva.cc	/^	SigBit getAccept()$/;"	f	struct:SvaFsm	typeref:typename:SigBit	file:
getAllReject	yosys/frontends/verific/verificsva.cc	/^	SigBit getAllReject()$/;"	f	struct:SvaFsm	typeref:typename:SigBit	file:
getAnyAllRejectWorker	yosys/frontends/verific/verificsva.cc	/^	SigBit getAnyAllRejectWorker(bool \/* allMode *\/)$/;"	f	struct:SvaFsm	typeref:typename:SigBit	file:
getAnyReject	yosys/frontends/verific/verificsva.cc	/^	SigBit getAnyReject()$/;"	f	struct:SvaFsm	typeref:typename:SigBit	file:
getAsserts	yosys/kernel/satgen.h	/^	void getAsserts(RTLIL::SigSpec &sig_a, RTLIL::SigSpec &sig_en, int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:void
getAssumes	yosys/kernel/satgen.h	/^	void getAssumes(RTLIL::SigSpec &sig_a, RTLIL::SigSpec &sig_en, int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:void
getBase	yosys/libs/bigint/BigUnsignedInABase.hh	/^	Base getBase() const { return base; }$/;"	f	class:BigUnsignedInABase	typeref:typename:Base
getBit	yosys/libs/bigint/BigUnsigned.hh	/^	bool getBit(Index bi) const {$/;"	f	class:BigUnsigned	typeref:typename:bool
getBlock	yosys/libs/bigint/BigInteger.hh	/^	Blk getBlock(Index i) const { return mag.getBlock(i); }$/;"	f	class:BigInteger	typeref:typename:Blk
getBlock	yosys/libs/bigint/BigUnsigned.hh	/^	Blk getBlock(Index i) const { return i >= len ? 0 : blk[i]; }$/;"	f	class:BigUnsigned	typeref:typename:Blk
getBlock	yosys/libs/bigint/NumberlikeArray.hh	/^	Blk   getBlock(Index i) const { return blk[i];   }$/;"	f	class:NumberlikeArray	typeref:typename:Blk
getCapacity	yosys/libs/bigint/BigInteger.hh	/^	Index getCapacity() const { return mag.getCapacity(); }$/;"	f	class:BigInteger	typeref:typename:Index
getCapacity	yosys/libs/bigint/NumberlikeArray.hh	/^	Index getCapacity()     const { return cap;      }$/;"	f	class:NumberlikeArray	typeref:typename:Index
getDFsm	yosys/frontends/verific/verificsva.cc	/^	void getDFsm(SvaFsm &output_fsm, int output_start_node, int output_accept_node, int output_reje/;"	f	struct:SvaFsm	typeref:typename:void	file:
getDigit	yosys/libs/bigint/BigUnsignedInABase.hh	/^	Digit getDigit(Index i) const { return i >= len ? 0 : blk[i]; }$/;"	f	class:BigUnsignedInABase	typeref:typename:Digit
getEndTime	yosys/kernel/fstdata.cc	/^uint64_t FstData::getEndTime() { return fstReaderGetEndTime(ctx); }$/;"	f	class:FstData	typeref:typename:uint64_t
getFileinfo	yosys/backends/firrtl/firrtl.cc	/^std::string getFileinfo(const RTLIL::AttrObject *design_entity)$/;"	f	typeref:typename:std::string
getFirstAccept	yosys/frontends/verific/verificsva.cc	/^	SigBit getFirstAccept()$/;"	f	struct:SvaFsm	typeref:typename:SigBit	file:
getFirstAcceptReject	yosys/frontends/verific/verificsva.cc	/^	void getFirstAcceptReject(SigBit *accept_p, SigBit *reject_p)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
getFullCnf	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::getFullCnf(std::vector<std::vector<int>> &full_cnf) const$/;"	f	class:ezSAT	typeref:typename:void
getHandle	yosys/kernel/fstdata.cc	/^fstHandle FstData::getHandle(std::string name) { $/;"	f	class:FstData	typeref:typename:fstHandle
getHelpPrefixString	yosys/libs/minisat/Options.h	/^    static const char*&  getHelpPrefixString() { static const char* help_prefix_str = ""; return/;"	f	class:Minisat::Option	typeref:typename:const char * &
getLength	yosys/libs/bigint/BigInteger.hh	/^	Index getLength() const { return mag.getLength(); }$/;"	f	class:BigInteger	typeref:typename:Index
getLength	yosys/libs/bigint/NumberlikeArray.hh	/^	Index getLength()       const { return len;      }$/;"	f	class:NumberlikeArray	typeref:typename:Index
getMagnitude	yosys/libs/bigint/BigInteger.hh	/^	const BigUnsigned &getMagnitude() const { return mag; }$/;"	f	class:BigInteger	typeref:typename:const BigUnsigned &
getOptionList	yosys/libs/minisat/Options.h	/^    static vec<Option*>& getOptionList () { static vec<Option*> options; return options; }$/;"	f	class:Minisat::Option	typeref:typename:vec<Option * > &
getParam	yosys/kernel/rtlil.cc	/^const RTLIL::Const &RTLIL::Cell::getParam(RTLIL::IdString paramname) const$/;"	f	class:RTLIL::Cell	typeref:typename:const RTLIL::Const &
getPort	yosys/kernel/rtlil.cc	/^const RTLIL::SigSpec &RTLIL::Cell::getPort(RTLIL::IdString portname) const$/;"	f	class:RTLIL::Cell	typeref:typename:const RTLIL::SigSpec &
getPortFDirection	yosys/backends/firrtl/firrtl.cc	/^FDirection getPortFDirection(IdString id, Module *module)$/;"	f	typeref:typename:FDirection
getReject	yosys/frontends/verific/verificsva.cc	/^	SigBit getReject()$/;"	f	struct:SvaFsm	typeref:typename:SigBit	file:
getShiftedBlock	yosys/libs/bigint/BigUnsigned.cc	/^inline BigUnsigned::Blk getShiftedBlock(const BigUnsigned &num,$/;"	f	typeref:typename:BigUnsigned::Blk
getSign	yosys/libs/bigint/BigInteger.hh	/^	Sign getSign() const { return sign; }$/;"	f	class:BigInteger	typeref:typename:Sign
getSolverTimoutStatus	yosys/libs/ezsat/ezsat.h	/^	bool getSolverTimoutStatus() {$/;"	f	class:ezSAT	typeref:typename:bool
getStartTime	yosys/kernel/fstdata.cc	/^uint64_t FstData::getStartTime() { return fstReaderGetStartTime(ctx); }$/;"	f	class:FstData	typeref:typename:uint64_t
getTimescale	yosys/kernel/fstdata.h	/^	double getTimescale() { return timescale; }$/;"	f	class:FstData	typeref:typename:double
getTimescaleString	yosys/kernel/fstdata.h	/^	const char *getTimescaleString() { return timescale_str.c_str(); }$/;"	f	class:FstData	typeref:typename:const char *
getUsageString	yosys/libs/minisat/Options.h	/^    static const char*&  getUsageString() { static const char* usage_str; return usage_str; }$/;"	f	class:Minisat::Option	typeref:typename:const char * &
getVars	yosys/kernel/fstdata.h	/^	std::vector<FstVar>& getVars() { return vars; };$/;"	f	class:FstData	typeref:typename:std::vector<FstVar> &
get_activation	yosys/passes/sat/assertpmux.cc	/^	SigBit get_activation(SigSpec sig)$/;"	f	struct:AssertpmuxWorker	typeref:typename:SigBit	file:
get_all_cells	yosys/kernel/rtlil.cc	/^std::map<unsigned int, RTLIL::Cell*> *RTLIL::Cell::get_all_cells(void)$/;"	f	class:RTLIL::Cell	typeref:typename:std::map<unsigned int,RTLIL::Cell * > *
get_all_designs	yosys/kernel/rtlil.cc	/^std::map<unsigned int, RTLIL::Design*> *RTLIL::Design::get_all_designs(void)$/;"	f	class:RTLIL::Design	typeref:typename:std::map<unsigned int,RTLIL::Design * > *
get_all_memories	yosys/kernel/mem.cc	/^std::vector<Mem> Mem::get_all_memories(Module *module) {$/;"	f	class:Mem	typeref:typename:std::vector<Mem>
get_all_memorys	yosys/kernel/rtlil.cc	/^std::map<unsigned int, RTLIL::Memory*> *RTLIL::Memory::get_all_memorys(void)$/;"	f	class:RTLIL::Memory	typeref:typename:std::map<unsigned int,RTLIL::Memory * > *
get_all_modules	yosys/kernel/rtlil.cc	/^std::map<unsigned int, RTLIL::Module*> *RTLIL::Module::get_all_modules(void)$/;"	f	class:RTLIL::Module	typeref:typename:std::map<unsigned int,RTLIL::Module * > *
get_all_wires	yosys/kernel/rtlil.cc	/^std::map<unsigned int, RTLIL::Wire*> *RTLIL::Wire::get_all_wires(void)$/;"	f	class:RTLIL::Wire	typeref:typename:std::map<unsigned int,RTLIL::Wire * > *
get_ast_control	yosys/frontends/verific/verificsva.cc	/^	Instance *get_ast_control(Instance *inst) { return net_to_ast_driver(inst->GetControl()); }$/;"	f	struct:VerificSvaImporter	typeref:typename:Instance *	file:
get_ast_input	yosys/frontends/verific/verificsva.cc	/^	Instance *get_ast_input(Instance *inst) { return net_to_ast_driver(inst->GetInput()); }$/;"	f	struct:VerificSvaImporter	typeref:typename:Instance *	file:
get_ast_input1	yosys/frontends/verific/verificsva.cc	/^	Instance *get_ast_input1(Instance *inst) { return net_to_ast_driver(inst->GetInput1()); }$/;"	f	struct:VerificSvaImporter	typeref:typename:Instance *	file:
get_ast_input2	yosys/frontends/verific/verificsva.cc	/^	Instance *get_ast_input2(Instance *inst) { return net_to_ast_driver(inst->GetInput2()); }$/;"	f	struct:VerificSvaImporter	typeref:typename:Instance *	file:
get_ast_input3	yosys/frontends/verific/verificsva.cc	/^	Instance *get_ast_input3(Instance *inst) { return net_to_ast_driver(inst->GetInput3()); }$/;"	f	struct:VerificSvaImporter	typeref:typename:Instance *	file:
get_bit_activation	yosys/passes/sat/assertpmux.cc	/^	SigBit get_bit_activation(SigBit bit)$/;"	f	struct:AssertpmuxWorker	typeref:typename:SigBit	file:
get_bit_or_zero	yosys/techlibs/anlogic/anlogic_fixcarry.cc	/^static SigBit get_bit_or_zero(const SigSpec &sig)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN SigBit	file:
get_bit_or_zero	yosys/techlibs/efinix/efinix_fixcarry.cc	/^static SigBit get_bit_or_zero(const SigSpec &sig)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN SigBit	file:
get_bit_or_zero	yosys/techlibs/ice40/ice40_opt.cc	/^static SigBit get_bit_or_zero(const SigSpec &sig)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN SigBit	file:
get_bits	yosys/backends/json/json.cc	/^	string get_bits(SigSpec sig)$/;"	f	struct:JsonWriter	typeref:typename:string	file:
get_bits	yosys/backends/protobuf/protobuf.cc	/^	void get_bits(yosys::pb::BitVector *out, SigSpec sig)$/;"	f	struct:ProtobufDesignSerializer	typeref:typename:void	file:
get_bits	yosys/passes/sat/freduce.cc	/^	int get_bits(int val)$/;"	f	struct:FindReducedInputs	typeref:typename:int	file:
get_blackbox_attribute	yosys/kernel/rtlil.h	/^	bool get_blackbox_attribute(bool ignore_wb=false) const {$/;"	f	struct:RTLIL::AttrObject	typeref:typename:bool
get_bool	yosys/backends/smt2/smt2.cc	/^	std::string get_bool(RTLIL::SigBit bit, const char *state_name = "state")$/;"	f	struct:Smt2Worker	typeref:typename:std::string	file:
get_bool	yosys/backends/smt2/smt2.cc	/^	std::string get_bool(RTLIL::SigSpec sig, const char *state_name = "state")$/;"	f	struct:Smt2Worker	typeref:typename:std::string	file:
get_bool_attribute	yosys/frontends/ast/ast.cc	/^bool AstNode::get_bool_attribute(RTLIL::IdString id)$/;"	f	class:AstNode	typeref:typename:bool
get_bool_attribute	yosys/kernel/rtlil.cc	/^bool RTLIL::AttrObject::get_bool_attribute(RTLIL::IdString id) const$/;"	f	class:RTLIL::AttrObject	typeref:typename:bool
get_bv	yosys/backends/smt2/smt2.cc	/^	std::string get_bv(RTLIL::SigSpec sig, const char *state_name = "state")$/;"	f	struct:Smt2Worker	typeref:typename:std::string	file:
get_bv_sid	yosys/backends/btor/btor.cc	/^	int get_bv_sid(int width)$/;"	f	struct:BtorWorker	typeref:typename:int	file:
get_cf	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec get_cf() {$/;"	f	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
get_consumers	yosys/kernel/modtools.h	/^	bool get_consumers(pool<PortBit> &result, RTLIL::SigSpec signal) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_consumers	yosys/kernel/modtools.h	/^	inline bool get_consumers(pool<PortBit> &result, RTLIL::SigBit bit) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_consumers	yosys/kernel/modtools.h	/^	inline bool get_consumers(pool<PortBit> &result, const T &bits) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_corresponding_taint_signal	yosys/passes/cmds/glift.cc	/^	RTLIL::SigSpec get_corresponding_taint_signal(RTLIL::SigSpec sig) {$/;"	f	struct:GliftWorker	typeref:typename:RTLIL::SigSpec	file:
get_coverage_data	yosys/kernel/log.cc	/^dict<std::string, std::pair<std::string, int>> get_coverage_data()$/;"	f	typeref:typename:dict<std::string,std::pair<std::string,int>>
get_drivers	yosys/kernel/modtools.h	/^	bool get_drivers(pool<PortBit> &result, RTLIL::SigSpec signal) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_drivers	yosys/kernel/modtools.h	/^	inline bool get_drivers(pool<PortBit> &result, RTLIL::SigBit bit) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_drivers	yosys/kernel/modtools.h	/^	inline bool get_drivers(pool<PortBit> &result, const T &bits) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_eq	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec get_eq() {$/;"	f	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
get_ff_type	yosys/passes/techmap/dfflegalize.cc	/^	int get_ff_type(const FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:int	file:
get_fsm_accept_reject	yosys/frontends/verific/verificsva.cc	/^	void get_fsm_accept_reject(SvaFsm &fsm, SigBit *accept_p, SigBit *reject_p, bool swap_accept_re/;"	f	struct:VerificSvaImporter	typeref:typename:void	file:
get_full_case_bits	yosys/passes/proc/proc_mux.cc	/^const pool<SigBit> &get_full_case_bits(SnippetSwCache &swcache, RTLIL::SwitchRule *sw)$/;"	f	typeref:typename:const pool<SigBit> &
get_full_netlist_name	yosys/frontends/verific/verific.cc	/^string get_full_netlist_name(Netlist *nl)$/;"	f	typeref:typename:string
get_gt	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec get_gt() {$/;"	f	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
get_hash	yosys/kernel/rtlil.h	/^	size_t get_hash() const {$/;"	f	struct:RTLIL::SigSpec	typeref:typename:size_t
get_hdl_name	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^std::string get_hdl_name(T *object)$/;"	f	typeref:typename:std::string
get_hdlname_attribute	yosys/kernel/rtlil.cc	/^vector<string> RTLIL::AttrObject::get_hdlname_attribute() const$/;"	f	class:RTLIL::AttrObject	typeref:typename:vector<string>
get_highest_hot_index	yosys/passes/opt/opt_expr.cc	/^int get_highest_hot_index(RTLIL::SigSpec signal)$/;"	f	typeref:typename:int
get_hole_loc_idx_sigbit_map	yosys/passes/sat/qbfsat.h	/^	dict<std::pair<pool<std::string>, int>, RTLIL::SigBit> get_hole_loc_idx_sigbit_map(RTLIL::Modul/;"	f	struct:QbfSolutionType	typeref:typename:dict<std::pair<pool<std::string>,int>,RTLIL::SigBit>
get_id	yosys/backends/smt2/smt2.cc	/^	const char *get_id(Cell *c)$/;"	f	struct:Smt2Worker	typeref:typename:const char *	file:
get_id	yosys/backends/smt2/smt2.cc	/^	const char *get_id(IdString n)$/;"	f	struct:Smt2Worker	typeref:typename:const char *	file:
get_id	yosys/backends/smt2/smt2.cc	/^	const char *get_id(Module *m)$/;"	f	struct:Smt2Worker	typeref:typename:const char *	file:
get_id	yosys/backends/smt2/smt2.cc	/^	const char *get_id(T *obj) {$/;"	f	struct:Smt2Worker	typeref:typename:const char *	file:
get_id	yosys/backends/smt2/smt2.cc	/^	const char *get_id(Wire *w)$/;"	f	struct:Smt2Worker	typeref:typename:const char *	file:
get_indent_str	yosys/passes/cmds/printattrs.cc	/^	static std::string get_indent_str(const unsigned int indent) {$/;"	f	struct:PrintAttrsPass	typeref:typename:std::string	file:
get_init_data	yosys/kernel/mem.cc	/^Const Mem::get_init_data() const {$/;"	f	class:Mem	typeref:typename:Const
get_initmask	yosys/passes/techmap/dfflegalize.cc	/^	int get_initmask(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:int	file:
get_inputs	yosys/kernel/modtools.h	/^	bool get_inputs(pool<RTLIL::SigBit> &result, RTLIL::SigSpec signal) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_inputs	yosys/kernel/modtools.h	/^	inline bool get_inputs(pool<RTLIL::SigBit> &result, RTLIL::SigBit bit) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_inputs	yosys/kernel/modtools.h	/^	inline bool get_inputs(pool<RTLIL::SigBit> &result, const T &bits) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_intvec_attribute	yosys/kernel/rtlil.cc	/^vector<int> RTLIL::AttrObject::get_intvec_attribute(RTLIL::IdString id) const$/;"	f	class:RTLIL::AttrObject	typeref:typename:vector<int>
get_last_error_str	yosys/frontends/rpc/rpc_frontend.cc	/^static std::string get_last_error_str() {$/;"	f	typeref:typename:std::string	file:
get_line_num	yosys/frontends/ast/ast.cc	/^	int (*get_line_num)() = NULL;$/;"	v	namespace:AST	typeref:typename:int (*)()
get_lt	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec get_lt() {$/;"	f	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
get_max_offset	yosys/frontends/ast/simplify.cc	/^static int get_max_offset(AstNode *node)$/;"	f	typeref:typename:int	file:
get_mem_sid	yosys/backends/btor/btor.cc	/^	int get_mem_sid(int abits, int dbits)$/;"	f	struct:BtorWorker	typeref:typename:int	file:
get_module	yosys/passes/hierarchy/hierarchy.cc	/^RTLIL::Module *get_module(RTLIL::Design                  &design,$/;"	f	typeref:typename:RTLIL::Module *
get_module_names	yosys/frontends/rpc/rpc_frontend.cc	/^	std::vector<std::string> get_module_names() {$/;"	f	struct:RpcServer	typeref:typename:std::vector<std::string>	file:
get_name	yosys/backends/json/json.cc	/^	string get_name(IdString name)$/;"	f	struct:JsonWriter	typeref:typename:string	file:
get_name	yosys/backends/protobuf/protobuf.cc	/^	string get_name(IdString name)$/;"	f	struct:ProtobufDesignSerializer	typeref:typename:string	file:
get_ne	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec get_ne() {$/;"	f	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
get_next_token	yosys/libs/json11/json11.cpp	/^    char get_next_token() {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:char	file:
get_of	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec get_of() {$/;"	f	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
get_other_cells	yosys/passes/techmap/extract_counter.cc	/^pool<Cell*> get_other_cells(const RTLIL::SigSpec& port, ModIndex& index, Cell* src)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN pool<Cell * >
get_outputs	yosys/kernel/modtools.h	/^	bool get_outputs(pool<RTLIL::SigBit> &result, RTLIL::SigSpec signal) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_outputs	yosys/kernel/modtools.h	/^	inline bool get_outputs(pool<RTLIL::SigBit> &result, RTLIL::SigBit bit) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_outputs	yosys/kernel/modtools.h	/^	inline bool get_outputs(pool<RTLIL::SigBit> &result, const T &bits) const$/;"	f	struct:ModWalker	typeref:typename:bool
get_reference	yosys/kernel/rtlil.h	/^		static inline int get_reference(int idx)$/;"	f	struct:RTLIL::IdString	typeref:typename:int
get_reference	yosys/kernel/rtlil.h	/^		static int get_reference(const char *p)$/;"	f	struct:RTLIL::IdString	typeref:typename:int
get_selected_memories	yosys/kernel/mem.cc	/^std::vector<Mem> Mem::get_selected_memories(Module *module) {$/;"	f	class:Mem	typeref:typename:std::vector<Mem>
get_selection	yosys/passes/techmap/nlutmap.cc	/^	RTLIL::Selection get_selection()$/;"	f	struct:NlutmapWorker	typeref:typename:RTLIL::Selection	file:
get_sf	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec get_sf() {$/;"	f	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
get_sig_nid	yosys/backends/btor/btor.cc	/^	int get_sig_nid(SigSpec sig, int to_width = -1, bool is_signed = false, bool is_init = false)$/;"	f	struct:BtorWorker	typeref:typename:int	file:
get_sliced_signal	yosys/passes/cmds/splice.cc	/^	RTLIL::SigSpec get_sliced_signal(RTLIL::SigSpec sig)$/;"	f	struct:SpliceWorker	typeref:typename:RTLIL::SigSpec	file:
get_solver_name	yosys/passes/sat/qbfsat.h	/^	std::string get_solver_name() const {$/;"	f	struct:QbfSolveOptions	typeref:typename:std::string
get_spliced_signal	yosys/passes/cmds/splice.cc	/^	RTLIL::SigSpec get_spliced_signal(RTLIL::SigSpec sig)$/;"	f	struct:SpliceWorker	typeref:typename:RTLIL::SigSpec	file:
get_src_attribute	yosys/kernel/rtlil.h	/^	std::string get_src_attribute() const {$/;"	f	struct:RTLIL::AttrObject	typeref:typename:std::string
get_state	yosys/passes/sat/sim.cc	/^	Const get_state(SigSpec sig)$/;"	f	struct:SimInstance	typeref:typename:Const	file:
get_string	yosys/backends/json/json.cc	/^	string get_string(string str)$/;"	f	struct:JsonWriter	typeref:typename:string	file:
get_string_attribute	yosys/kernel/rtlil.cc	/^string RTLIL::AttrObject::get_string_attribute(RTLIL::IdString id) const$/;"	f	class:RTLIL::AttrObject	typeref:typename:string
get_strpool_attribute	yosys/kernel/rtlil.cc	/^pool<string> RTLIL::AttrObject::get_strpool_attribute(RTLIL::IdString id) const$/;"	f	class:RTLIL::AttrObject	typeref:typename:pool<string>
get_struct_array_width	yosys/frontends/ast/simplify.cc	/^static int get_struct_array_width(AstNode *node)$/;"	f	typeref:typename:int	file:
get_tern_choice	yosys/frontends/ast/simplify.cc	/^std::pair<AstNode*, AstNode*> AstNode::get_tern_choice()$/;"	f	class:AstNode	typeref:typename:std::pair<AstNode *,AstNode * >
get_vals	yosys/frontends/verilog/preproc.cc	/^	get_vals(const std::string &macro_name, const std::vector<std::string> &arg_vals) const$/;"	f	struct:arg_map_t	typeref:typename:std::vector<std::pair<std::string,std::string>>	file:
getcwd	yosys/kernel/yosys.h	/^#  define getcwd /;"	d
getinfo	yosys/backends/btor/btor.cc	/^	string getinfo(T *obj, bool srcsym = false)$/;"	f	struct:BtorWorker	typeref:typename:string	file:
getopt	yosys/kernel/driver.cc	/^int getopt(int argc, char **argv, const char *optstring)$/;"	f	typeref:typename:int
gettimeofday	yosys/kernel/log.cc	/^int gettimeofday(struct timeval *tv, struct timezone *tz)$/;"	f	typeref:typename:int
getw	yosys/passes/tests/test_abcloop.cc	/^static RTLIL::Wire *getw(std::vector<RTLIL::Wire*> &wires, RTLIL::Wire *w)$/;"	f	typeref:typename:RTLIL::Wire *	file:
glift_attribute_name	yosys/passes/cmds/glift.cc	/^	const RTLIL::IdString glift_attribute_name = ID(glift);$/;"	m	struct:GliftWorker	typeref:typename:const RTLIL::IdString	file:
glift_mux	yosys/examples/smtbmc/Makefile	/^glift_mux:$/;"	t
glob_abort_cnt	yosys/passes/opt/opt_muxtree.cc	/^	int glob_abort_cnt = 100000;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:int	file:
glob_filename	yosys/kernel/yosys.cc	/^std::vector<std::string> glob_filename(const std::string &filename_pattern)$/;"	f	typeref:typename:std::vector<std::string>
global_free_idx_list_	yosys/kernel/rtlil.cc	/^std::vector<int> RTLIL::IdString::global_free_idx_list_;$/;"	m	class:RTLIL::IdString	typeref:typename:std::vector<int>
global_free_idx_list_	yosys/kernel/rtlil.h	/^		static std::vector<int> global_free_idx_list_;$/;"	m	struct:RTLIL::IdString	typeref:typename:std::vector<int>
global_id_index_	yosys/kernel/rtlil.cc	/^dict<char*, int, hash_cstr_ops> RTLIL::IdString::global_id_index_;$/;"	m	class:RTLIL::IdString	typeref:typename:dict<char *,int,hash_cstr_ops>
global_id_index_	yosys/kernel/rtlil.h	/^		static dict<char*, int, hash_cstr_ops> global_id_index_;$/;"	m	struct:RTLIL::IdString	typeref:typename:dict<char *,int,hash_cstr_ops>
global_id_storage_	yosys/kernel/rtlil.cc	/^std::vector<char*> RTLIL::IdString::global_id_storage_;$/;"	m	class:RTLIL::IdString	typeref:typename:std::vector<char * >
global_id_storage_	yosys/kernel/rtlil.h	/^		static std::vector<char*> global_id_storage_;$/;"	m	struct:RTLIL::IdString	typeref:typename:std::vector<char * >
global_refcount_storage_	yosys/kernel/rtlil.cc	/^std::vector<int> RTLIL::IdString::global_refcount_storage_;$/;"	m	class:RTLIL::IdString	typeref:typename:std::vector<int>
global_refcount_storage_	yosys/kernel/rtlil.h	/^		static std::vector<int> global_refcount_storage_;$/;"	m	struct:RTLIL::IdString	typeref:typename:std::vector<int>
gold	yosys/passes/sat/sim.cc	/^	gold,$/;"	e	enum:SimulationMode	file:
gold_mod	yosys/passes/equiv/equiv_make.cc	/^	Module *gold_mod, *gate_mod, *equiv_mod;$/;"	m	struct:EquivMakeWorker	typeref:typename:Module *	file:
gotTimeout	yosys/passes/sat/sat.cc	/^	bool gotTimeout;$/;"	m	struct:SatHelper	typeref:typename:bool	file:
got_cr	yosys/passes/techmap/abc.cc	/^	bool got_cr;$/;"	m	struct:abc_output_filter	typeref:typename:bool	file:
got_cr	yosys/passes/techmap/abc9_exe.cc	/^	bool got_cr;$/;"	m	struct:abc9_output_filter	typeref:typename:bool	file:
graph	yosys/libs/subcircuit/subcircuit.cc	/^		Graph graph;$/;"	m	struct:SubCircuit::SolverWorker::GraphData	typeref:typename:Graph	file:
graphData	yosys/libs/subcircuit/subcircuit.cc	/^	std::map<std::string, GraphData> graphData;$/;"	m	class:SubCircuit::SolverWorker	typeref:typename:std::map<std::string,GraphData>	file:
graphId	yosys/libs/subcircuit/subcircuit.cc	/^		std::string graphId;$/;"	m	struct:SubCircuit::SolverWorker::GraphData	typeref:typename:std::string	file:
graphId	yosys/libs/subcircuit/subcircuit.cc	/^		std::string graphId;$/;"	m	struct:SubCircuit::SolverWorker::NodeSet	typeref:typename:std::string	file:
graphId	yosys/libs/subcircuit/subcircuit.h	/^			std::string graphId;$/;"	m	struct:SubCircuit::Solver::MineResult	typeref:typename:std::string
greater	yosys/libs/bigint/BigInteger.hh	/^		greater = BigUnsigned::greater;$/;"	m	class:BigInteger	typeref:typename:const CmpRes
greater	yosys/libs/bigint/BigUnsigned.hh	/^	enum CmpRes { less = -1, equal = 0, greater = 1 };$/;"	e	enum:BigUnsigned::CmpRes
grid	yosys/libs/ezsat/puzzle3d.cc	/^std::vector<int> grid[DIM_X][DIM_Y][DIM_Z];$/;"	v	typeref:typename:std::vector<int>[][][]
grid	yosys/passes/cmds/qwp.cc	/^	double grid;$/;"	m	struct:QwpConfig	typeref:typename:double	file:
group	yosys/passes/memory/memory_bram.cc	/^		int group, index, dupidx;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:int	file:
group_cell_inputs	yosys/passes/opt/opt_expr.cc	/^bool group_cell_inputs(RTLIL::Module *module, RTLIL::Cell *cell, bool commutative, SigMap &sigma/;"	f	typeref:typename:bool
group_t	yosys/passes/fsm/fsm_opt.cc	/^		typedef std::pair<std::pair<int, int>, RTLIL::Const> group_t;$/;"	t	function:FsmOpt::opt_find_dont_care	typeref:typename:std::pair<std::pair<int,int>,RTLIL::Const>	file:
groups	yosys/passes/memory/memory_bram.cc	/^		int groups, abits, dbits, init;$/;"	m	struct:rules_t::bram_t	typeref:typename:int	file:
grow	yosys/libs/minisat/SimpSolver.h	/^    int     grow;              \/\/ Allow a variable elimination step to grow by a number of cla/;"	m	class:Minisat::SimpSolver	typeref:typename:int
growTo	yosys/libs/minisat/SolverTypes.h	/^    void     growTo      (CRef cr, const T& t){ map.insert(cr, t); } \/\/ NOTE: for compatibilit/;"	f	class:Minisat::CMap	typeref:typename:void
growTo	yosys/libs/minisat/Vec.h	/^void vec<T,_Size>::growTo(Size size) {$/;"	f	class:Minisat::vec	typeref:typename:void
growTo	yosys/libs/minisat/Vec.h	/^void vec<T,_Size>::growTo(Size size, const T& pad) {$/;"	f	class:Minisat::vec	typeref:typename:void
gt_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> gt_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
gt_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> gt_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
gzf	yosys/kernel/register.cc	/^		gzFile gzf = nullptr;$/;"	m	class:gzip_ostream::gzip_streambuf	typeref:typename:gzFile	file:
gzip_ostream	yosys/kernel/register.cc	/^	gzip_ostream() : std::ostream(nullptr)$/;"	f	class:gzip_ostream	file:
gzip_ostream	yosys/kernel/register.cc	/^class gzip_ostream : public std::ostream  {$/;"	c	file:
gzip_streambuf	yosys/kernel/register.cc	/^		gzip_streambuf() { };$/;"	f	class:gzip_ostream::gzip_streambuf	file:
gzip_streambuf	yosys/kernel/register.cc	/^	class gzip_streambuf : public std::stringbuf {$/;"	c	class:gzip_ostream	file:
had_init	yosys/passes/techmap/abc.cc	/^bool had_init;$/;"	v	typeref:typename:bool
halfadder	yosys/libs/ezsat/ezsat.cc	/^static void halfadder(ezSAT *that, int a, int b, int &y, int &x)$/;"	f	typeref:typename:void	file:
handle	yosys/libs/fst/fstapi.cc	/^    FILE *handle;$/;"	m	struct:fstWriterContext	typeref:typename:FILE *	file:
handle	yosys/libs/fst/fstapi.h	/^            fstHandle handle;$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierVar	typeref:typename:fstHandle
handle_clkpol_celltype_swap	yosys/passes/opt/opt_expr.cc	/^void handle_clkpol_celltype_swap(Cell *cell, string type1, string type2, IdString port, const Si/;"	f	typeref:typename:void
handle_extra_select_args	yosys/passes/cmds/select.cc	/^void handle_extra_select_args(Pass *pass, const vector<string> &args, size_t argidx, size_t args/;"	f	typeref:typename:PRIVATE_NAMESPACE_END YOSYS_NAMESPACE_BEGIN void
handle_label	yosys/kernel/yosys.cc	/^static void handle_label(std::string &command, bool &from_to_active, const std::string &run_from/;"	f	typeref:typename:void	file:
handle_loops	yosys/passes/techmap/abc.cc	/^void handle_loops()$/;"	f	typeref:typename:void
handle_memory	yosys/passes/memory/memory_bram.cc	/^void handle_memory(Mem &mem, const rules_t &rules, FfInitVals *initvals)$/;"	f	typeref:typename:void
handle_memory	yosys/passes/memory/memory_map.cc	/^	void handle_memory(Mem &mem)$/;"	f	struct:MemoryMapWorker	typeref:typename:void	file:
handle_module	yosys/passes/cmds/show.cc	/^	void handle_module()$/;"	f	struct:ShowWorker	typeref:typename:void	file:
handle_polarity_inv	yosys/passes/opt/opt_expr.cc	/^void handle_polarity_inv(Cell *cell, IdString port, IdString param, const SigMap &assign_map, co/;"	f	typeref:typename:void
handle_rd_port	yosys/passes/memory/memory_dff.cc	/^	void handle_rd_port(Mem &mem, QuickConeSat &qcsat, int idx)$/;"	f	struct:MemoryDffWorker	typeref:typename:void	file:
handle_rd_port_addr	yosys/passes/memory/memory_dff.cc	/^	void handle_rd_port_addr(Mem &mem, int idx)$/;"	f	struct:MemoryDffWorker	typeref:typename:void	file:
handle_submodule	yosys/passes/hierarchy/submod.cc	/^	void handle_submodule(SubModule &submod)$/;"	f	struct:SubmodWorker	typeref:typename:void	file:
handle_to_var	yosys/kernel/fstdata.h	/^	std::map<fstHandle, FstVar> handle_to_var;$/;"	m	class:FstData	typeref:typename:std::map<fstHandle,FstVar>
handled_bits	yosys/passes/techmap/extract_fa.cc	/^	pool<SigBit> handled_bits;$/;"	m	struct:ExtractFaWorker	typeref:typename:pool<SigBit>	file:
has	yosys/kernel/rtlil.h	/^	bool has(RTLIL::IdString id) const {$/;"	f	struct:RTLIL::Design	typeref:typename:bool
has	yosys/kernel/sigtools.h	/^	bool has(const RTLIL::SigSpec &sig)$/;"	f	struct:SigSet	typeref:typename:bool
has	yosys/kernel/utils.h	/^	bool has(const Key &k)$/;"	f	struct:stackmap	typeref:typename:bool
has	yosys/libs/minisat/IntMap.h	/^        bool     has         (K k) { in_set.reserve(k, 0); return in_set[k]; }$/;"	f	class:Minisat::IntSet	typeref:typename:bool
has	yosys/libs/minisat/IntMap.h	/^        bool     has       (K k) const { return index(k) < map.size(); }$/;"	f	class:Minisat::IntMap	typeref:typename:bool
has	yosys/libs/minisat/Map.h	/^    bool has   (const K& k) const {$/;"	f	class:Minisat::Map	typeref:typename:bool
has	yosys/libs/minisat/SolverTypes.h	/^    bool     has         (CRef cr, T& t)      { return map.peek(cr, t); }$/;"	f	class:Minisat::CMap	typeref:typename:bool
hasParam	yosys/kernel/rtlil.cc	/^bool RTLIL::Cell::hasParam(RTLIL::IdString paramname) const$/;"	f	class:RTLIL::Cell	typeref:typename:bool
hasPort	yosys/kernel/rtlil.cc	/^bool RTLIL::Cell::hasPort(RTLIL::IdString portname) const$/;"	f	class:RTLIL::Cell	typeref:typename:bool
has_all	yosys/kernel/bitpattern.h	/^	bool has_all(RTLIL::SigSpec sig)$/;"	f	struct:BitPatternPool	typeref:typename:bool
has_aload	yosys/kernel/ff.h	/^	bool has_aload;$/;"	m	struct:FfData	typeref:typename:bool
has_any	yosys/kernel/bitpattern.h	/^	bool has_any(RTLIL::SigSpec sig)$/;"	f	struct:BitPatternPool	typeref:typename:bool
has_args	yosys/frontends/verilog/preproc.cc	/^	bool        has_args;$/;"	m	struct:define_body_t	typeref:typename:bool	file:
has_arst	yosys/kernel/ff.h	/^	bool has_arst;$/;"	m	struct:FfData	typeref:typename:bool
has_attribute	yosys/kernel/rtlil.cc	/^bool RTLIL::AttrObject::has_attribute(RTLIL::IdString id) const$/;"	f	class:RTLIL::AttrObject	typeref:typename:bool
has_ce	yosys/kernel/ff.h	/^	bool has_ce;$/;"	m	struct:FfData	typeref:typename:bool
has_ce	yosys/passes/techmap/extract_counter.cc	/^	bool has_ce;					\/\/true if we have a clock enable$/;"	m	struct:CounterExtraction	typeref:typename:bool	file:
has_clk	yosys/kernel/ff.h	/^	bool has_clk;$/;"	m	struct:FfData	typeref:typename:bool
has_const	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::has_const() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
has_const_only_constructs	yosys/frontends/ast/simplify.cc	/^bool AstNode::has_const_only_constructs()$/;"	f	class:AstNode	typeref:typename:bool
has_consumers	yosys/kernel/modtools.h	/^	inline bool has_consumers(RTLIL::SigSpec sig) const {$/;"	f	struct:ModWalker	typeref:typename:bool
has_consumers	yosys/kernel/modtools.h	/^	inline bool has_consumers(const T &sig) const {$/;"	f	struct:ModWalker	typeref:typename:bool
has_default	yosys/frontends/verilog/preproc.cc	/^	bool        has_default;$/;"	m	struct:macro_arg_t	typeref:typename:bool	file:
has_dont_care_initval	yosys/passes/opt/opt_merge.cc	/^	bool has_dont_care_initval(const RTLIL::Cell *cell)$/;"	f	struct:OptMergeWorker	typeref:typename:bool	file:
has_drivers	yosys/kernel/modtools.h	/^	inline bool has_drivers(RTLIL::SigSpec sig) const {$/;"	f	struct:ModWalker	typeref:typename:bool
has_drivers	yosys/kernel/modtools.h	/^	inline bool has_drivers(const T &sig) const {$/;"	f	struct:ModWalker	typeref:typename:bool
has_extra	yosys/libs/minisat/SolverTypes.h	/^        unsigned has_extra : 1;$/;"	m	struct:Minisat::Clause::__anonb7535e3e0108	typeref:typename:unsigned:1
has_extra	yosys/libs/minisat/SolverTypes.h	/^    bool         has_extra   ()      const   { return header.has_extra; }$/;"	f	class:Minisat::Clause	typeref:typename:bool
has_gclk	yosys/kernel/ff.h	/^	bool has_gclk;$/;"	m	struct:FfData	typeref:typename:bool
has_inputs	yosys/kernel/modtools.h	/^	inline bool has_inputs(RTLIL::SigSpec sig) const {$/;"	f	struct:ModWalker	typeref:typename:bool
has_inputs	yosys/kernel/modtools.h	/^	inline bool has_inputs(const T &sig) const {$/;"	f	struct:ModWalker	typeref:typename:bool
has_inputs	yosys/kernel/timinginfo.h	/^		bool has_inputs;$/;"	m	struct:TimingInfo::ModuleTiming	typeref:typename:bool
has_interfaces_not_found	yosys/passes/hierarchy/hierarchy.cc	/^	bool                                    has_interfaces_not_found;$/;"	m	struct:IFExpander	typeref:typename:bool	file:
has_keep_attr	yosys/kernel/rtlil.h	/^	bool has_keep_attr() const {$/;"	f	struct:RTLIL::Cell	typeref:typename:bool
has_lookaheadids	yosys/frontends/ast/genrtlil.cc	/^	bool has_lookaheadids(AstNode *node)$/;"	f	struct:AST_INTERNAL::LookaheadRewriter	typeref:typename:bool	file:
has_marked_bits	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::has_marked_bits() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
has_memid	yosys/kernel/rtlil.cc	/^bool RTLIL::Cell::has_memid() const$/;"	f	class:RTLIL::Cell	typeref:typename:bool
has_memories	yosys/kernel/rtlil.cc	/^bool RTLIL::Module::has_memories() const$/;"	f	class:RTLIL::Module	typeref:typename:bool
has_memories_warn	yosys/kernel/rtlil.cc	/^bool RTLIL::Module::has_memories_warn() const$/;"	f	class:RTLIL::Module	typeref:typename:bool
has_nonlookaheadids	yosys/frontends/ast/genrtlil.cc	/^	bool has_nonlookaheadids(AstNode *node)$/;"	f	struct:AST_INTERNAL::LookaheadRewriter	typeref:typename:bool	file:
has_outputs	yosys/kernel/modtools.h	/^	inline bool has_outputs(RTLIL::SigSpec sig) const {$/;"	f	struct:ModWalker	typeref:typename:bool
has_outputs	yosys/kernel/modtools.h	/^	inline bool has_outputs(const T &sig) const {$/;"	f	struct:ModWalker	typeref:typename:bool
has_pout	yosys/passes/techmap/extract_counter.cc	/^	bool has_pout;					\/\/whether parallel output is used$/;"	m	struct:CounterExtraction	typeref:typename:bool	file:
has_processes	yosys/kernel/rtlil.cc	/^bool RTLIL::Module::has_processes() const$/;"	f	class:RTLIL::Module	typeref:typename:bool
has_processes_warn	yosys/kernel/rtlil.cc	/^bool RTLIL::Module::has_processes_warn() const$/;"	f	class:RTLIL::Module	typeref:typename:bool
has_reset	yosys/passes/techmap/extract_counter.cc	/^	bool has_reset;					\/\/true if we have a reset$/;"	m	struct:CounterExtraction	typeref:typename:bool	file:
has_shape	yosys/libs/json11/json11.cpp	/^bool Json::has_shape(const shape & types, string & err) const {$/;"	f	class:json11::Json	typeref:typename:bool
has_sr	yosys/kernel/ff.h	/^	bool has_sr;$/;"	m	struct:FfData	typeref:typename:bool
has_srst	yosys/kernel/ff.h	/^	bool has_srst;$/;"	m	struct:FfData	typeref:typename:bool
has_value	yosys/passes/techmap/attrmap.cc	/^	bool has_value;$/;"	m	struct:AttrmapRemove	typeref:typename:bool	file:
hash	yosys/frontends/ast/ast.h	/^		unsigned int hash() const { return hashidx_; }$/;"	f	struct:AST::AstNode	typeref:typename:unsigned int
hash	yosys/kernel/bitpattern.h	/^		unsigned int hash() const {$/;"	f	struct:BitPatternPool::bits_t	typeref:typename:unsigned int
hash	yosys/kernel/cellaigs.cc	/^unsigned int Aig::hash() const$/;"	f	class:Aig	typeref:typename:unsigned int
hash	yosys/kernel/cellaigs.cc	/^unsigned int AigNode::hash() const$/;"	f	class:AigNode	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	bool hash() const {$/;"	f	class:hashlib::pool	typeref:typename:bool
hash	yosys/kernel/hashlib.h	/^	static inline typename std::enable_if<I != sizeof...(T), unsigned int>::type hash(std::tuple<T./;"	f	struct:hashlib::hash_ops	typeref:typename:std::enable_if<I!=sizeof...(T),unsigned int>::type
hash	yosys/kernel/hashlib.h	/^	static inline typename std::enable_if<I == sizeof...(T), unsigned int>::type hash(std::tuple<T./;"	f	struct:hashlib::hash_ops	typeref:typename:std::enable_if<I==sizeof...(T),unsigned int>::type
hash	yosys/kernel/hashlib.h	/^	static inline unsigned int hash(bool a) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	static inline unsigned int hash(const T &a) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	static inline unsigned int hash(const T *a) {$/;"	f	struct:hashlib::hash_obj_ops	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	static inline unsigned int hash(const char *a) {$/;"	f	struct:hashlib::hash_cstr_ops	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	static inline unsigned int hash(const std::string &a) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	static inline unsigned int hash(const void *a) {$/;"	f	struct:hashlib::hash_ptr_ops	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	static inline unsigned int hash(int32_t a) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	static inline unsigned int hash(int64_t a) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	static inline unsigned int hash(std::pair<P, Q> a) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	static inline unsigned int hash(std::vector<T> a) {$/;"	f	struct:hashlib::hash_ops	typeref:typename:unsigned int
hash	yosys/kernel/hashlib.h	/^	unsigned int hash() const {$/;"	f	class:hashlib::dict	typeref:typename:unsigned int
hash	yosys/kernel/modtools.h	/^		unsigned int hash() const {$/;"	f	struct:ModIndex::PortInfo	typeref:typename:unsigned int
hash	yosys/kernel/modtools.h	/^		unsigned int hash() const {$/;"	f	struct:ModWalker::PortBit	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^		unsigned int hash() const {$/;"	f	struct:RTLIL::IdString	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^	inline unsigned int hash() const {$/;"	f	struct:RTLIL::Const	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^	unsigned int hash() const { if (!hash_) updhash(); return hash_; };$/;"	f	struct:RTLIL::SigSpec	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^	unsigned int hash() const { return hashidx_; }$/;"	f	struct:RTLIL::Cell	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^	unsigned int hash() const { return hashidx_; }$/;"	f	struct:RTLIL::Design	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^	unsigned int hash() const { return hashidx_; }$/;"	f	struct:RTLIL::Memory	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^	unsigned int hash() const { return hashidx_; }$/;"	f	struct:RTLIL::Module	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^	unsigned int hash() const { return hashidx_; }$/;"	f	struct:RTLIL::Monitor	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^	unsigned int hash() const { return hashidx_; }$/;"	f	struct:RTLIL::Process	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^	unsigned int hash() const { return hashidx_; }$/;"	f	struct:RTLIL::Wire	typeref:typename:unsigned int
hash	yosys/kernel/rtlil.h	/^inline unsigned int RTLIL::SigBit::hash() const {$/;"	f	class:RTLIL::SigBit	typeref:typename:unsigned int
hash	yosys/kernel/sigtools.h	/^		unsigned int hash() const { return first->name.hash() + second; }$/;"	f	struct:SigPool::bitDef_t	typeref:typename:unsigned int
hash	yosys/kernel/sigtools.h	/^		unsigned int hash() const { return first->name.hash() + second; }$/;"	f	struct:SigSet::bitDef_t	typeref:typename:unsigned int
hash	yosys/kernel/timinginfo.h	/^		unsigned int hash() const { return mkhash_add(first.hash(), second.hash()); }$/;"	f	struct:TimingInfo::BitBit	typeref:typename:unsigned int
hash	yosys/kernel/timinginfo.h	/^		unsigned int hash() const { return mkhash_add(name.hash(), offset); }$/;"	f	struct:TimingInfo::NameBit	typeref:typename:unsigned int
hash	yosys/kernel/yosys.h	/^	unsigned int hash() const { return hashlib::hash_ops<std::string>::hash(*content); }$/;"	f	struct:shared_str	typeref:typename:unsigned int
hash	yosys/libs/minisat/Map.h	/^    H          hash;$/;"	m	class:Minisat::Map	typeref:typename:H
hash	yosys/libs/minisat/Map.h	/^static inline uint32_t hash(int32_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat	typeref:typename:uint32_t
hash	yosys/libs/minisat/Map.h	/^static inline uint32_t hash(int64_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat	typeref:typename:uint32_t
hash	yosys/libs/minisat/Map.h	/^static inline uint32_t hash(uint32_t x){ return x; }$/;"	f	namespace:Minisat	typeref:typename:uint32_t
hash	yosys/libs/minisat/Map.h	/^static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }$/;"	f	namespace:Minisat	typeref:typename:uint32_t
hash	yosys/passes/equiv/equiv_struct.cc	/^		unsigned int hash() const {$/;"	f	struct:EquivStructWorker::merge_key_t	typeref:typename:unsigned int	file:
hash	yosys/passes/proc/proc_dlatch.cc	/^		unsigned int hash() const {$/;"	f	struct:proc_dlatch_db_t::rule_node_t	typeref:typename:unsigned int	file:
hash	yosys/passes/techmap/flowmap.cc	/^		unsigned int hash() const$/;"	f	struct:FlowGraph::NodePrime	typeref:typename:unsigned int	file:
hashTable	yosys/libs/fst/lz4.cc	/^    U32 hashTable[HASH_SIZE_U32];$/;"	m	struct:__anon9390dffe0208	typeref:typename:U32[]	file:
hash_	yosys/kernel/rtlil.h	/^	unsigned long hash_;$/;"	m	struct:RTLIL::SigSpec	typeref:typename:unsigned long
hash_cell_parameters_and_connections	yosys/passes/opt/opt_merge.cc	/^	std::string hash_cell_parameters_and_connections(const RTLIL::Cell *cell)$/;"	f	struct:OptMergeWorker	typeref:typename:std::string	file:
hash_cstr_ops	yosys/kernel/hashlib.h	/^struct hash_cstr_ops {$/;"	s	namespace:hashlib
hash_int_ops	yosys/kernel/hashlib.h	/^struct hash_int_ops {$/;"	s	namespace:hashlib
hash_obj_ops	yosys/kernel/hashlib.h	/^struct hash_obj_ops {$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/hashlib.h	/^template<> struct hash_ops<bool> : hash_int_ops$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/hashlib.h	/^template<> struct hash_ops<int32_t> : hash_int_ops$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/hashlib.h	/^template<> struct hash_ops<int64_t> : hash_int_ops$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/hashlib.h	/^template<> struct hash_ops<std::string> {$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/hashlib.h	/^template<typename P, typename Q> struct hash_ops<std::pair<P, Q>> {$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/hashlib.h	/^template<typename T> struct hash_ops {$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/hashlib.h	/^template<typename T> struct hash_ops<std::vector<T>> {$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/hashlib.h	/^template<typename... T> struct hash_ops<std::tuple<T...>> {$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<AST::AstNode*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<RTLIL::Cell*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<RTLIL::Design*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<RTLIL::Memory*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<RTLIL::Module*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<RTLIL::Monitor*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<RTLIL::Process*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<RTLIL::State> : hash_ops<int> {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<RTLIL::Wire*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<const AST::AstNode*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<const RTLIL::Cell*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<const RTLIL::Design*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<const RTLIL::Memory*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<const RTLIL::Module*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<const RTLIL::Monitor*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<const RTLIL::Process*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ops	yosys/kernel/yosys.h	/^	template<> struct hash_ops<const RTLIL::Wire*> : hash_obj_ops {};$/;"	s	namespace:hashlib
hash_ptr_ops	yosys/kernel/hashlib.h	/^struct hash_ptr_ops {$/;"	s	namespace:hashlib
hashidx_	yosys/frontends/ast/ast.h	/^		unsigned int hashidx_;$/;"	m	struct:AST::AstNode	typeref:typename:unsigned int
hashidx_	yosys/kernel/rtlil.h	/^	unsigned int hashidx_;$/;"	m	struct:RTLIL::Cell	typeref:typename:unsigned int
hashidx_	yosys/kernel/rtlil.h	/^	unsigned int hashidx_;$/;"	m	struct:RTLIL::Design	typeref:typename:unsigned int
hashidx_	yosys/kernel/rtlil.h	/^	unsigned int hashidx_;$/;"	m	struct:RTLIL::Memory	typeref:typename:unsigned int
hashidx_	yosys/kernel/rtlil.h	/^	unsigned int hashidx_;$/;"	m	struct:RTLIL::Module	typeref:typename:unsigned int
hashidx_	yosys/kernel/rtlil.h	/^	unsigned int hashidx_;$/;"	m	struct:RTLIL::Monitor	typeref:typename:unsigned int
hashidx_	yosys/kernel/rtlil.h	/^	unsigned int hashidx_;$/;"	m	struct:RTLIL::Process	typeref:typename:unsigned int
hashidx_	yosys/kernel/rtlil.h	/^	unsigned int hashidx_;$/;"	m	struct:RTLIL::Wire	typeref:typename:unsigned int
hashlib	yosys/kernel/hashlib.h	/^namespace hashlib {$/;"	n
hashlib	yosys/kernel/yosys.h	/^namespace hashlib {$/;"	n
hashtable	yosys/kernel/hashlib.h	/^	std::vector<int> hashtable;$/;"	m	class:hashlib::dict	typeref:typename:std::vector<int>
hashtable	yosys/kernel/hashlib.h	/^	std::vector<int> hashtable;$/;"	m	class:hashlib::pool	typeref:typename:std::vector<int>
hashtable_size	yosys/kernel/hashlib.h	/^inline int hashtable_size(int min_size)$/;"	f	namespace:hashlib	typeref:typename:int
hashtable_size_factor	yosys/kernel/hashlib.h	/^const int hashtable_size_factor = 3;$/;"	v	namespace:hashlib	typeref:typename:const int
hashtable_size_trigger	yosys/kernel/hashlib.h	/^const int hashtable_size_trigger = 2;$/;"	v	namespace:hashlib	typeref:typename:const int
haystackGraphId	yosys/libs/subcircuit/subcircuit.h	/^			std::string needleGraphId, haystackGraphId;$/;"	m	struct:SubCircuit::Solver::Result	typeref:typename:std::string
haystackNodeId	yosys/libs/subcircuit/subcircuit.h	/^			std::string needleNodeId, haystackNodeId;$/;"	m	struct:SubCircuit::Solver::ResultNodeMapping	typeref:typename:std::string
haystackUserData	yosys/libs/subcircuit/subcircuit.h	/^			void *needleUserData, *haystackUserData;$/;"	m	struct:SubCircuit::Solver::ResultNodeMapping	typeref:typename:void *
header	yosys/libs/minisat/SolverTypes.h	/^        unsigned size      : 27; }                        header;$/;"	m	class:Minisat::Clause	typeref:struct:Minisat::Clause::__anonb7535e3e0108
header_count	yosys/kernel/log.cc	/^vector<int> header_count;$/;"	v	typeref:typename:vector<int>
heap	yosys/libs/minisat/Heap.h	/^    vec<K>                heap;     \/\/ Heap of Keys$/;"	m	class:Minisat::Heap	typeref:typename:vec<K>
help	yosys/backends/aiger/aiger.cc	/^	void help() override$/;"	f	struct:AigerBackend	typeref:typename:void	file:
help	yosys/backends/aiger/xaiger.cc	/^	void help() override$/;"	f	struct:XAigerBackend	typeref:typename:void	file:
help	yosys/backends/blif/blif.cc	/^	void help() override$/;"	f	struct:BlifBackend	typeref:typename:void	file:
help	yosys/backends/btor/btor.cc	/^	void help() override$/;"	f	struct:BtorBackend	typeref:typename:void	file:
help	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void help() override$/;"	f	struct:CxxrtlBackend	typeref:typename:void	file:
help	yosys/backends/edif/edif.cc	/^	void help() override$/;"	f	struct:EdifBackend	typeref:typename:void	file:
help	yosys/backends/firrtl/firrtl.cc	/^	void help() override$/;"	f	struct:FirrtlBackend	typeref:typename:void	file:
help	yosys/backends/intersynth/intersynth.cc	/^	void help() override$/;"	f	struct:IntersynthBackend	typeref:typename:void	file:
help	yosys/backends/jny/jny.cc	/^    void help() override {$/;"	f	struct:JnyBackend	typeref:typename:void	file:
help	yosys/backends/jny/jny.cc	/^    void help() override {$/;"	f	struct:JnyPass	typeref:typename:void	file:
help	yosys/backends/json/json.cc	/^	void help() override$/;"	f	struct:JsonBackend	typeref:typename:void	file:
help	yosys/backends/json/json.cc	/^	void help() override$/;"	f	struct:JsonPass	typeref:typename:void	file:
help	yosys/backends/protobuf/protobuf.cc	/^	void help() override$/;"	f	struct:ProtobufBackend	typeref:typename:void	file:
help	yosys/backends/protobuf/protobuf.cc	/^	void help() override$/;"	f	struct:ProtobufPass	typeref:typename:void	file:
help	yosys/backends/rtlil/rtlil_backend.cc	/^	void help() override$/;"	f	struct:DumpPass	typeref:typename:void	file:
help	yosys/backends/rtlil/rtlil_backend.cc	/^	void help() override$/;"	f	struct:IlangBackend	typeref:typename:void	file:
help	yosys/backends/rtlil/rtlil_backend.cc	/^	void help() override$/;"	f	struct:RTLILBackend	typeref:typename:void	file:
help	yosys/backends/simplec/simplec.cc	/^	void help() override$/;"	f	struct:SimplecBackend	typeref:typename:void	file:
help	yosys/backends/smt2/smt2.cc	/^	void help() override$/;"	f	struct:Smt2Backend	typeref:typename:void	file:
help	yosys/backends/smv/smv.cc	/^	void help() override$/;"	f	struct:SmvBackend	typeref:typename:void	file:
help	yosys/backends/spice/spice.cc	/^	void help() override$/;"	f	struct:SpiceBackend	typeref:typename:void	file:
help	yosys/backends/table/table.cc	/^	void help() override$/;"	f	struct:TableBackend	typeref:typename:void	file:
help	yosys/backends/verilog/verilog_backend.cc	/^	void help() override$/;"	f	struct:VerilogBackend	typeref:typename:void	file:
help	yosys/frontends/aiger/aigerparse.cc	/^	void help() override$/;"	f	struct:AigerFrontend	typeref:typename:void	file:
help	yosys/frontends/blif/blifparse.cc	/^	void help() override$/;"	f	struct:BlifFrontend	typeref:typename:void	file:
help	yosys/frontends/json/jsonparse.cc	/^	void help() override$/;"	f	struct:JsonFrontend	typeref:typename:void	file:
help	yosys/frontends/liberty/liberty.cc	/^	void help() override$/;"	f	struct:LibertyFrontend	typeref:typename:void	file:
help	yosys/frontends/rpc/rpc_frontend.cc	/^	void help() override$/;"	f	struct:RpcFrontend	typeref:typename:void	file:
help	yosys/frontends/rtlil/rtlil_frontend.cc	/^	void help() override$/;"	f	struct:IlangFrontend	typeref:typename:void	file:
help	yosys/frontends/rtlil/rtlil_frontend.cc	/^	void help() override$/;"	f	struct:RTLILFrontend	typeref:typename:void	file:
help	yosys/frontends/verific/verific.cc	/^	void help() override$/;"	f	struct:ReadPass	typeref:typename:void	file:
help	yosys/frontends/verific/verific.cc	/^	void help() override$/;"	f	struct:VerificPass	typeref:typename:void	file:
help	yosys/frontends/verilog/verilog_frontend.cc	/^	void help() override$/;"	f	struct:VerilogDefaults	typeref:typename:void	file:
help	yosys/frontends/verilog/verilog_frontend.cc	/^	void help() override$/;"	f	struct:VerilogDefines	typeref:typename:void	file:
help	yosys/frontends/verilog/verilog_frontend.cc	/^	void help() override$/;"	f	struct:VerilogFrontend	typeref:typename:void	file:
help	yosys/kernel/register.cc	/^	void help() override$/;"	f	struct:EchoPass	typeref:typename:void	file:
help	yosys/kernel/register.cc	/^	void help() override$/;"	f	struct:HelpPass	typeref:typename:void	file:
help	yosys/kernel/register.cc	/^void Pass::help()$/;"	f	class:Pass	typeref:typename:void
help	yosys/kernel/yosys.cc	/^	void help() override {$/;"	f	struct:HistoryPass	typeref:typename:void	file:
help	yosys/kernel/yosys.cc	/^	void help() override {$/;"	f	struct:ScriptCmdPass	typeref:typename:void	file:
help	yosys/kernel/yosys.cc	/^	void help() override {$/;"	f	struct:ShellPass	typeref:typename:void	file:
help	yosys/kernel/yosys.cc	/^	void help() override {$/;"	f	struct:TclPass	typeref:typename:void	file:
help	yosys/libs/minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::BoolOption	typeref:typename:void
help	yosys/libs/minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::DoubleOption	typeref:typename:void
help	yosys/libs/minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::Int64Option	typeref:typename:void
help	yosys/libs/minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::IntOption	typeref:typename:void
help	yosys/libs/minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::StringOption	typeref:typename:void
help	yosys/passes/cmds/add.cc	/^	void help() override$/;"	f	struct:AddPass	typeref:typename:void	file:
help	yosys/passes/cmds/autoname.cc	/^	void help() override$/;"	f	struct:AutonamePass	typeref:typename:void	file:
help	yosys/passes/cmds/blackbox.cc	/^	void help() override$/;"	f	struct:BlackboxPass	typeref:typename:void	file:
help	yosys/passes/cmds/bugpoint.cc	/^	void help() override$/;"	f	struct:BugpointPass	typeref:typename:void	file:
help	yosys/passes/cmds/check.cc	/^	void help() override$/;"	f	struct:CheckPass	typeref:typename:void	file:
help	yosys/passes/cmds/chformal.cc	/^	void help() override$/;"	f	struct:ChformalPass	typeref:typename:void	file:
help	yosys/passes/cmds/chtype.cc	/^	void help() override$/;"	f	struct:ChtypePass	typeref:typename:void	file:
help	yosys/passes/cmds/clean_zerowidth.cc	/^	void help() override$/;"	f	struct:CleanZeroWidthPass	typeref:typename:void	file:
help	yosys/passes/cmds/connect.cc	/^	void help() override$/;"	f	struct:ConnectPass	typeref:typename:void	file:
help	yosys/passes/cmds/connwrappers.cc	/^	void help() override$/;"	f	struct:ConnwrappersPass	typeref:typename:void	file:
help	yosys/passes/cmds/copy.cc	/^	void help() override$/;"	f	struct:CopyPass	typeref:typename:void	file:
help	yosys/passes/cmds/cover.cc	/^	void help() override$/;"	f	struct:CoverPass	typeref:typename:void	file:
help	yosys/passes/cmds/delete.cc	/^	void help() override$/;"	f	struct:DeletePass	typeref:typename:void	file:
help	yosys/passes/cmds/design.cc	/^	void help() override$/;"	f	struct:DesignPass	typeref:typename:void	file:
help	yosys/passes/cmds/edgetypes.cc	/^	void help() override$/;"	f	struct:EdgetypePass	typeref:typename:void	file:
help	yosys/passes/cmds/exec.cc	/^	void help() override$/;"	f	struct:ExecPass	typeref:typename:void	file:
help	yosys/passes/cmds/glift.cc	/^	void help() override$/;"	f	struct:GliftPass	typeref:typename:void	file:
help	yosys/passes/cmds/logcmd.cc	/^	void help() override$/;"	f	struct:LogPass	typeref:typename:void	file:
help	yosys/passes/cmds/logger.cc	/^	void help() override$/;"	f	struct:LoggerPass	typeref:typename:void	file:
help	yosys/passes/cmds/ltp.cc	/^	void help() override$/;"	f	struct:LtpPass	typeref:typename:void	file:
help	yosys/passes/cmds/plugin.cc	/^	void help() override$/;"	f	struct:PluginPass	typeref:typename:void	file:
help	yosys/passes/cmds/portlist.cc	/^	void help() override$/;"	f	struct:PortlistPass	typeref:typename:void	file:
help	yosys/passes/cmds/printattrs.cc	/^	void help() override$/;"	f	struct:PrintAttrsPass	typeref:typename:void	file:
help	yosys/passes/cmds/qwp.cc	/^	void help() override$/;"	f	struct:QwpPass	typeref:typename:void	file:
help	yosys/passes/cmds/rename.cc	/^	void help() override$/;"	f	struct:RenamePass	typeref:typename:void	file:
help	yosys/passes/cmds/scatter.cc	/^	void help() override$/;"	f	struct:ScatterPass	typeref:typename:void	file:
help	yosys/passes/cmds/scc.cc	/^	void help() override$/;"	f	struct:SccPass	typeref:typename:void	file:
help	yosys/passes/cmds/scratchpad.cc	/^	void help() override$/;"	f	struct:ScratchpadPass	typeref:typename:void	file:
help	yosys/passes/cmds/select.cc	/^	void help() override$/;"	f	struct:CdPass	typeref:typename:void	file:
help	yosys/passes/cmds/select.cc	/^	void help() override$/;"	f	struct:LsPass	typeref:typename:void	file:
help	yosys/passes/cmds/select.cc	/^	void help() override$/;"	f	struct:SelectPass	typeref:typename:void	file:
help	yosys/passes/cmds/setattr.cc	/^	void help() override$/;"	f	struct:ChparamPass	typeref:typename:void	file:
help	yosys/passes/cmds/setattr.cc	/^	void help() override$/;"	f	struct:SetattrPass	typeref:typename:void	file:
help	yosys/passes/cmds/setattr.cc	/^	void help() override$/;"	f	struct:SetparamPass	typeref:typename:void	file:
help	yosys/passes/cmds/setattr.cc	/^	void help() override$/;"	f	struct:WbflipPass	typeref:typename:void	file:
help	yosys/passes/cmds/setundef.cc	/^	void help() override$/;"	f	struct:SetundefPass	typeref:typename:void	file:
help	yosys/passes/cmds/show.cc	/^	void help() override$/;"	f	struct:ShowPass	typeref:typename:void	file:
help	yosys/passes/cmds/splice.cc	/^	void help() override$/;"	f	struct:SplicePass	typeref:typename:void	file:
help	yosys/passes/cmds/splitnets.cc	/^	void help() override$/;"	f	struct:SplitnetsPass	typeref:typename:void	file:
help	yosys/passes/cmds/sta.cc	/^	void help() override$/;"	f	struct:StaPass	typeref:typename:void	file:
help	yosys/passes/cmds/stat.cc	/^	void help() override$/;"	f	struct:StatPass	typeref:typename:void	file:
help	yosys/passes/cmds/tee.cc	/^	void help() override$/;"	f	struct:TeePass	typeref:typename:void	file:
help	yosys/passes/cmds/torder.cc	/^	void help() override$/;"	f	struct:TorderPass	typeref:typename:void	file:
help	yosys/passes/cmds/trace.cc	/^	void help() override$/;"	f	struct:DebugPass	typeref:typename:void	file:
help	yosys/passes/cmds/trace.cc	/^	void help() override$/;"	f	struct:TracePass	typeref:typename:void	file:
help	yosys/passes/cmds/write_file.cc	/^	void help() override$/;"	f	struct:WriteFileFrontend	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_add.cc	/^	void help() override$/;"	f	struct:EquivAddPass	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_induct.cc	/^	void help() override$/;"	f	struct:EquivInductPass	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_make.cc	/^	void help() override$/;"	f	struct:EquivMakePass	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_mark.cc	/^	void help() override$/;"	f	struct:EquivMarkPass	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_miter.cc	/^	void help() override$/;"	f	struct:EquivMiterPass	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_opt.cc	/^	void help() override$/;"	f	struct:EquivOptPass	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_purge.cc	/^	void help() override$/;"	f	struct:EquivPurgePass	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_remove.cc	/^	void help() override$/;"	f	struct:EquivRemovePass	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_simple.cc	/^	void help() override$/;"	f	struct:EquivSimplePass	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_status.cc	/^	void help() override$/;"	f	struct:EquivStatusPass	typeref:typename:void	file:
help	yosys/passes/equiv/equiv_struct.cc	/^	void help() override$/;"	f	struct:EquivStructPass	typeref:typename:void	file:
help	yosys/passes/fsm/fsm.cc	/^	void help() override$/;"	f	struct:FsmPass	typeref:typename:void	file:
help	yosys/passes/fsm/fsm_detect.cc	/^	void help() override$/;"	f	struct:FsmDetectPass	typeref:typename:void	file:
help	yosys/passes/fsm/fsm_expand.cc	/^	void help() override$/;"	f	struct:FsmExpandPass	typeref:typename:void	file:
help	yosys/passes/fsm/fsm_export.cc	/^	void help() override$/;"	f	struct:FsmExportPass	typeref:typename:void	file:
help	yosys/passes/fsm/fsm_extract.cc	/^	void help() override$/;"	f	struct:FsmExtractPass	typeref:typename:void	file:
help	yosys/passes/fsm/fsm_info.cc	/^	void help() override$/;"	f	struct:FsmInfoPass	typeref:typename:void	file:
help	yosys/passes/fsm/fsm_map.cc	/^	void help() override$/;"	f	struct:FsmMapPass	typeref:typename:void	file:
help	yosys/passes/fsm/fsm_opt.cc	/^	void help() override$/;"	f	struct:FsmOptPass	typeref:typename:void	file:
help	yosys/passes/fsm/fsm_recode.cc	/^	void help() override$/;"	f	struct:FsmRecodePass	typeref:typename:void	file:
help	yosys/passes/hierarchy/hierarchy.cc	/^	void help() override$/;"	f	struct:HierarchyPass	typeref:typename:void	file:
help	yosys/passes/hierarchy/submod.cc	/^	void help() override$/;"	f	struct:SubmodPass	typeref:typename:void	file:
help	yosys/passes/hierarchy/uniquify.cc	/^	void help() override$/;"	f	struct:UniquifyPass	typeref:typename:void	file:
help	yosys/passes/memory/memory.cc	/^	void help() override$/;"	f	struct:MemoryPass	typeref:typename:void	file:
help	yosys/passes/memory/memory_bram.cc	/^	void help() override$/;"	f	struct:MemoryBramPass	typeref:typename:void	file:
help	yosys/passes/memory/memory_collect.cc	/^	void help() override$/;"	f	struct:MemoryCollectPass	typeref:typename:void	file:
help	yosys/passes/memory/memory_dff.cc	/^	void help() override$/;"	f	struct:MemoryDffPass	typeref:typename:void	file:
help	yosys/passes/memory/memory_map.cc	/^	void help() override$/;"	f	struct:MemoryMapPass	typeref:typename:void	file:
help	yosys/passes/memory/memory_memx.cc	/^	void help() override$/;"	f	struct:MemoryMemxPass	typeref:typename:void	file:
help	yosys/passes/memory/memory_narrow.cc	/^	void help() override$/;"	f	struct:MemoryNarrowPass	typeref:typename:void	file:
help	yosys/passes/memory/memory_nordff.cc	/^	void help() override$/;"	f	struct:MemoryNordffPass	typeref:typename:void	file:
help	yosys/passes/memory/memory_share.cc	/^	void help() override$/;"	f	struct:MemorySharePass	typeref:typename:void	file:
help	yosys/passes/memory/memory_unpack.cc	/^	void help() override$/;"	f	struct:MemoryUnpackPass	typeref:typename:void	file:
help	yosys/passes/opt/muxpack.cc	/^	void help() override$/;"	f	struct:MuxpackPass	typeref:typename:void	file:
help	yosys/passes/opt/opt.cc	/^	void help() override$/;"	f	struct:OptPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_clean.cc	/^	void help() override$/;"	f	struct:CleanPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_clean.cc	/^	void help() override$/;"	f	struct:OptCleanPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_demorgan.cc	/^	void help() override$/;"	f	struct:OptDemorganPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_dff.cc	/^	void help() override$/;"	f	struct:OptDffPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_expr.cc	/^	void help() override$/;"	f	struct:OptExprPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_lut.cc	/^	void help() override$/;"	f	struct:OptLutPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_lut_ins.cc	/^	void help() override$/;"	f	struct:OptLutInsPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_mem.cc	/^	void help() override$/;"	f	struct:OptMemPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_mem_feedback.cc	/^	void help() override$/;"	f	struct:OptMemFeedbackPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_mem_priority.cc	/^	void help() override$/;"	f	struct:OptMemPriorityPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_mem_widen.cc	/^	void help() override$/;"	f	struct:OptMemWidenPass	typeref:typename:void	file:
help	yosys/passes/opt/opt_merge.cc	/^	void help() override$/;"	f	struct:OptMergePass	typeref:typename:void	file:
help	yosys/passes/opt/opt_muxtree.cc	/^	void help() override$/;"	f	struct:OptMuxtreePass	typeref:typename:void	file:
help	yosys/passes/opt/opt_reduce.cc	/^	void help() override$/;"	f	struct:OptReducePass	typeref:typename:void	file:
help	yosys/passes/opt/opt_share.cc	/^	void help() override$/;"	f	struct:OptSharePass	typeref:typename:void	file:
help	yosys/passes/opt/pmux2shiftx.cc	/^	void help() override$/;"	f	struct:OnehotPass	typeref:typename:void	file:
help	yosys/passes/opt/pmux2shiftx.cc	/^	void help() override$/;"	f	struct:Pmux2ShiftxPass	typeref:typename:void	file:
help	yosys/passes/opt/rmports.cc	/^	void help() override$/;"	f	struct:RmportsPassPass	typeref:typename:void	file:
help	yosys/passes/opt/share.cc	/^	void help() override$/;"	f	struct:SharePass	typeref:typename:void	file:
help	yosys/passes/opt/wreduce.cc	/^	void help() override$/;"	f	struct:WreducePass	typeref:typename:void	file:
help	yosys/passes/pmgen/ice40_dsp.cc	/^	void help() override$/;"	f	struct:Ice40DspPass	typeref:typename:void	file:
help	yosys/passes/pmgen/ice40_wrapcarry.cc	/^	void help() override$/;"	f	struct:Ice40WrapCarryPass	typeref:typename:void	file:
help	yosys/passes/pmgen/peepopt.cc	/^	void help() override$/;"	f	struct:PeepoptPass	typeref:typename:void	file:
help	yosys/passes/pmgen/test_pmgen.cc	/^	void help() override$/;"	f	struct:TestPmgenPass	typeref:typename:void	file:
help	yosys/passes/pmgen/xilinx_dsp.cc	/^	void help() override$/;"	f	struct:XilinxDspPass	typeref:typename:void	file:
help	yosys/passes/pmgen/xilinx_srl.cc	/^	void help() override$/;"	f	struct:XilinxSrlPass	typeref:typename:void	file:
help	yosys/passes/proc/proc.cc	/^	void help() override$/;"	f	struct:ProcPass	typeref:typename:void	file:
help	yosys/passes/proc/proc_arst.cc	/^	void help() override$/;"	f	struct:ProcArstPass	typeref:typename:void	file:
help	yosys/passes/proc/proc_clean.cc	/^	void help() override$/;"	f	struct:ProcCleanPass	typeref:typename:void	file:
help	yosys/passes/proc/proc_dff.cc	/^	void help() override$/;"	f	struct:ProcDffPass	typeref:typename:void	file:
help	yosys/passes/proc/proc_dlatch.cc	/^	void help() override$/;"	f	struct:ProcDlatchPass	typeref:typename:void	file:
help	yosys/passes/proc/proc_init.cc	/^	void help() override$/;"	f	struct:ProcInitPass	typeref:typename:void	file:
help	yosys/passes/proc/proc_memwr.cc	/^	void help() override$/;"	f	struct:ProcMemWrPass	typeref:typename:void	file:
help	yosys/passes/proc/proc_mux.cc	/^	void help() override$/;"	f	struct:ProcMuxPass	typeref:typename:void	file:
help	yosys/passes/proc/proc_prune.cc	/^	void help() override$/;"	f	struct:ProcPrunePass	typeref:typename:void	file:
help	yosys/passes/proc/proc_rmdead.cc	/^	void help() override$/;"	f	struct:ProcRmdeadPass	typeref:typename:void	file:
help	yosys/passes/sat/assertpmux.cc	/^	void help() override$/;"	f	struct:AssertpmuxPass	typeref:typename:void	file:
help	yosys/passes/sat/async2sync.cc	/^	void help() override$/;"	f	struct:Async2syncPass	typeref:typename:void	file:
help	yosys/passes/sat/clk2fflogic.cc	/^	void help() override$/;"	f	struct:Clk2fflogicPass	typeref:typename:void	file:
help	yosys/passes/sat/cutpoint.cc	/^	void help() override$/;"	f	struct:CutpointPass	typeref:typename:void	file:
help	yosys/passes/sat/eval.cc	/^	void help() override$/;"	f	struct:EvalPass	typeref:typename:void	file:
help	yosys/passes/sat/expose.cc	/^	void help() override$/;"	f	struct:ExposePass	typeref:typename:void	file:
help	yosys/passes/sat/fmcombine.cc	/^	void help() override$/;"	f	struct:FmcombinePass	typeref:typename:void	file:
help	yosys/passes/sat/fminit.cc	/^	void help() override$/;"	f	struct:FminitPass	typeref:typename:void	file:
help	yosys/passes/sat/freduce.cc	/^	void help() override$/;"	f	struct:FreducePass	typeref:typename:void	file:
help	yosys/passes/sat/miter.cc	/^	void help() override$/;"	f	struct:MiterPass	typeref:typename:void	file:
help	yosys/passes/sat/mutate.cc	/^	void help() override$/;"	f	struct:MutatePass	typeref:typename:void	file:
help	yosys/passes/sat/qbfsat.cc	/^	void help() override$/;"	f	struct:QbfSatPass	typeref:typename:void	file:
help	yosys/passes/sat/sat.cc	/^	void help() override$/;"	f	struct:SatPass	typeref:typename:void	file:
help	yosys/passes/sat/sim.cc	/^	void help() override$/;"	f	struct:Fst2TbPass	typeref:typename:void	file:
help	yosys/passes/sat/sim.cc	/^	void help() override$/;"	f	struct:SimPass	typeref:typename:void	file:
help	yosys/passes/sat/supercover.cc	/^	void help() override$/;"	f	struct:SupercoverPass	typeref:typename:void	file:
help	yosys/passes/techmap/abc.cc	/^	void help() override$/;"	f	struct:AbcPass	typeref:typename:void	file:
help	yosys/passes/techmap/abc9.cc	/^	void help() override$/;"	f	struct:Abc9Pass	typeref:typename:void	file:
help	yosys/passes/techmap/abc9_exe.cc	/^	void help() override$/;"	f	struct:Abc9ExePass	typeref:typename:void	file:
help	yosys/passes/techmap/abc9_ops.cc	/^	void help() override$/;"	f	struct:Abc9OpsPass	typeref:typename:void	file:
help	yosys/passes/techmap/aigmap.cc	/^	void help() override$/;"	f	struct:AigmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/alumacc.cc	/^	void help() override$/;"	f	struct:AlumaccPass	typeref:typename:void	file:
help	yosys/passes/techmap/attrmap.cc	/^	void help() override$/;"	f	struct:AttrmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/attrmap.cc	/^	void help() override$/;"	f	struct:ParamapPass	typeref:typename:void	file:
help	yosys/passes/techmap/attrmvcp.cc	/^	void help() override$/;"	f	struct:AttrmvcpPass	typeref:typename:void	file:
help	yosys/passes/techmap/bmuxmap.cc	/^	void help() override$/;"	f	struct:BmuxmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/clkbufmap.cc	/^	void help() override$/;"	f	struct:ClkbufmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/deminout.cc	/^	void help() override$/;"	f	struct:DeminoutPass	typeref:typename:void	file:
help	yosys/passes/techmap/demuxmap.cc	/^	void help() override$/;"	f	struct:DemuxmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/dffinit.cc	/^	void help() override$/;"	f	struct:DffinitPass	typeref:typename:void	file:
help	yosys/passes/techmap/dfflegalize.cc	/^	void help() override$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
help	yosys/passes/techmap/dfflibmap.cc	/^	void help() override$/;"	f	struct:DfflibmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/dffunmap.cc	/^	void help() override$/;"	f	struct:DffunmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/extract.cc	/^	void help() override$/;"	f	struct:ExtractPass	typeref:typename:void	file:
help	yosys/passes/techmap/extract_counter.cc	/^	void help() override$/;"	f	struct:ExtractCounterPass	typeref:typename:void	file:
help	yosys/passes/techmap/extract_fa.cc	/^	void help() override$/;"	f	struct:ExtractFaPass	typeref:typename:void	file:
help	yosys/passes/techmap/extract_reduce.cc	/^	void help() override$/;"	f	struct:ExtractReducePass	typeref:typename:void	file:
help	yosys/passes/techmap/extractinv.cc	/^	void help() override$/;"	f	struct:ExtractinvPass	typeref:typename:void	file:
help	yosys/passes/techmap/flatten.cc	/^	void help() override$/;"	f	struct:FlattenPass	typeref:typename:void	file:
help	yosys/passes/techmap/flowmap.cc	/^	void help() override$/;"	f	struct:FlowmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/hilomap.cc	/^	void help() override$/;"	f	struct:HilomapPass	typeref:typename:void	file:
help	yosys/passes/techmap/insbuf.cc	/^	void help() override$/;"	f	struct:InsbufPass	typeref:typename:void	file:
help	yosys/passes/techmap/iopadmap.cc	/^	void help() override$/;"	f	struct:IopadmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/lut2mux.cc	/^	void help() override$/;"	f	struct:Lut2muxPass	typeref:typename:void	file:
help	yosys/passes/techmap/maccmap.cc	/^	void help() override$/;"	f	struct:MaccmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/muxcover.cc	/^	void help() override$/;"	f	struct:MuxcoverPass	typeref:typename:void	file:
help	yosys/passes/techmap/nlutmap.cc	/^	void help() override$/;"	f	struct:NlutmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/pmuxtree.cc	/^	void help() override$/;"	f	struct:PmuxtreePass	typeref:typename:void	file:
help	yosys/passes/techmap/shregmap.cc	/^	void help() override$/;"	f	struct:ShregmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/simplemap.cc	/^	void help() override$/;"	f	struct:SimplemapPass	typeref:typename:void	file:
help	yosys/passes/techmap/techmap.cc	/^	void help() override$/;"	f	struct:TechmapPass	typeref:typename:void	file:
help	yosys/passes/techmap/tribuf.cc	/^	void help() override$/;"	f	struct:TribufPass	typeref:typename:void	file:
help	yosys/passes/techmap/zinit.cc	/^	void help() override$/;"	f	struct:ZinitPass	typeref:typename:void	file:
help	yosys/passes/tests/test_abcloop.cc	/^	void help() override$/;"	f	struct:TestAbcloopPass	typeref:typename:void	file:
help	yosys/passes/tests/test_autotb.cc	/^	void help() override$/;"	f	struct:TestAutotbBackend	typeref:typename:void	file:
help	yosys/passes/tests/test_cell.cc	/^	void help() override$/;"	f	struct:TestCellPass	typeref:typename:void	file:
help	yosys/techlibs/achronix/synth_achronix.cc	/^  void help() override$/;"	f	struct:SynthAchronixPass	typeref:typename:void	file:
help	yosys/techlibs/anlogic/anlogic_eqn.cc	/^	void help() override$/;"	f	struct:AnlogicEqnPass	typeref:typename:void	file:
help	yosys/techlibs/anlogic/anlogic_fixcarry.cc	/^	void help() override$/;"	f	struct:AnlogicCarryFixPass	typeref:typename:void	file:
help	yosys/techlibs/anlogic/synth_anlogic.cc	/^	void help() override$/;"	f	struct:SynthAnlogicPass	typeref:typename:void	file:
help	yosys/techlibs/common/prep.cc	/^	void help() override$/;"	f	struct:PrepPass	typeref:typename:void	file:
help	yosys/techlibs/common/synth.cc	/^	void help() override$/;"	f	struct:SynthPass	typeref:typename:void	file:
help	yosys/techlibs/coolrunner2/coolrunner2_fixup.cc	/^	void help() override$/;"	f	struct:Coolrunner2FixupPass	typeref:typename:void	file:
help	yosys/techlibs/coolrunner2/coolrunner2_sop.cc	/^	void help() override$/;"	f	struct:Coolrunner2SopPass	typeref:typename:void	file:
help	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^	void help() override$/;"	f	struct:SynthCoolrunner2Pass	typeref:typename:void	file:
help	yosys/techlibs/easic/synth_easic.cc	/^	void help() override$/;"	f	struct:SynthEasicPass	typeref:typename:void	file:
help	yosys/techlibs/ecp5/ecp5_gsr.cc	/^	void help() override$/;"	f	struct:Ecp5GsrPass	typeref:typename:void	file:
help	yosys/techlibs/ecp5/synth_ecp5.cc	/^	void help() override$/;"	f	struct:SynthEcp5Pass	typeref:typename:void	file:
help	yosys/techlibs/efinix/efinix_fixcarry.cc	/^	void help() override$/;"	f	struct:EfinixCarryFixPass	typeref:typename:void	file:
help	yosys/techlibs/efinix/synth_efinix.cc	/^	void help() override$/;"	f	struct:SynthEfinixPass	typeref:typename:void	file:
help	yosys/techlibs/gatemate/synth_gatemate.cc	/^	void help() override$/;"	f	struct:SynthGateMatePass	typeref:typename:void	file:
help	yosys/techlibs/gowin/synth_gowin.cc	/^	void help() override$/;"	f	struct:SynthGowinPass	typeref:typename:void	file:
help	yosys/techlibs/greenpak4/greenpak4_dffinv.cc	/^	void help() override$/;"	f	struct:Greenpak4DffInvPass	typeref:typename:void	file:
help	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^	void help() override$/;"	f	struct:SynthGreenPAK4Pass	typeref:typename:void	file:
help	yosys/techlibs/ice40/ice40_braminit.cc	/^	void help() override$/;"	f	struct:Ice40BRAMInitPass	typeref:typename:void	file:
help	yosys/techlibs/ice40/ice40_opt.cc	/^	void help() override$/;"	f	struct:Ice40OptPass	typeref:typename:void	file:
help	yosys/techlibs/ice40/synth_ice40.cc	/^	void help() override$/;"	f	struct:SynthIce40Pass	typeref:typename:void	file:
help	yosys/techlibs/intel/synth_intel.cc	/^	void help() override$/;"	f	struct:SynthIntelPass	typeref:typename:void	file:
help	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	void help() override$/;"	f	struct:SynthIntelALMPass	typeref:typename:void	file:
help	yosys/techlibs/machxo2/synth_machxo2.cc	/^	void help() override$/;"	f	struct:SynthMachXO2Pass	typeref:typename:void	file:
help	yosys/techlibs/nexus/synth_nexus.cc	/^	void help() override$/;"	f	struct:SynthNexusPass	typeref:typename:void	file:
help	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	void help() override$/;"	f	struct:SynthQuickLogicPass	typeref:typename:void	file:
help	yosys/techlibs/sf2/synth_sf2.cc	/^	void help() override$/;"	f	struct:SynthSf2Pass	typeref:typename:void	file:
help	yosys/techlibs/xilinx/synth_xilinx.cc	/^	void help() override$/;"	f	struct:SynthXilinxPass	typeref:typename:void	file:
help	yosys/techlibs/xilinx/xilinx_dffopt.cc	/^	void help() override$/;"	f	struct:XilinxDffOptPass	typeref:typename:void	file:
help_mode	yosys/kernel/register.h	/^	bool block_active, help_mode;$/;"	m	struct:ScriptPass	typeref:typename:bool
help_script	yosys/kernel/register.cc	/^void ScriptPass::help_script()$/;"	f	class:ScriptPass	typeref:typename:void
hicell_celltype	yosys/passes/techmap/hilomap.cc	/^static std::string hicell_celltype, hicell_portname;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN std::string	file:
hicell_portname	yosys/passes/techmap/hilomap.cc	/^static std::string hicell_celltype, hicell_portname;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN std::string	file:
hidden_mode	yosys/passes/hierarchy/submod.cc	/^	bool hidden_mode;$/;"	m	struct:SubmodWorker	typeref:typename:bool	file:
hide_internal	yosys/passes/sat/sim.cc	/^	bool hide_internal = true;$/;"	m	struct:SimShared	typeref:typename:bool	file:
hier	yosys/backends/smt2/smt2.cc	/^	std::vector<std::string> decls, trans, hier, dtmembers;$/;"	m	struct:Smt2Worker	typeref:typename:std::vector<std::string>	file:
hier	yosys/libs/fst/fstapi.cc	/^    struct fstHier hier;$/;"	m	struct:fstReaderContext	typeref:struct:fstHier	file:
hier_file_len	yosys/libs/fst/fstapi.cc	/^    fst_off_t hier_file_len;$/;"	m	struct:fstWriterContext	typeref:typename:fst_off_t	file:
hier_handle	yosys/libs/fst/fstapi.cc	/^    FILE *hier_handle;$/;"	m	struct:fstWriterContext	typeref:typename:FILE *	file:
hier_pos	yosys/libs/fst/fstapi.cc	/^    fst_off_t hier_pos;$/;"	m	struct:fstReaderContext	typeref:typename:fst_off_t	file:
hierarchy_clean	yosys/passes/hierarchy/hierarchy.cc	/^void hierarchy_clean(RTLIL::Design *design, RTLIL::Module *top, bool purge_lib)$/;"	f	typeref:typename:void
hierarchy_worker	yosys/passes/cmds/stat.cc	/^statdata_t hierarchy_worker(std::map<RTLIL::IdString, statdata_t> &mod_stat, RTLIL::IdString mod/;"	f	typeref:typename:statdata_t
hierarchy_worker	yosys/passes/hierarchy/hierarchy.cc	/^void hierarchy_worker(RTLIL::Design *design, std::set<RTLIL::Module*, IdString::compare_ptr_by_n/;"	f	typeref:typename:void
hiercells	yosys/backends/smt2/smt2.cc	/^	std::set<RTLIL::Cell*> exported_cells, hiercells, hiercells_queue;$/;"	m	struct:Smt2Worker	typeref:typename:std::set<RTLIL::Cell * >	file:
hiercells_queue	yosys/backends/smt2/smt2.cc	/^	std::set<RTLIL::Cell*> exported_cells, hiercells, hiercells_queue;$/;"	m	struct:Smt2Worker	typeref:typename:std::set<RTLIL::Cell * >	file:
hiername	yosys/backends/simplec/simplec.cc	/^	IdString hiername;$/;"	m	struct:HierDirtyFlags	typeref:typename:IdString	file:
hiername	yosys/passes/sat/sim.cc	/^	std::string hiername() const$/;"	f	struct:SimInstance	typeref:typename:std::string	file:
hilomap_worker	yosys/passes/techmap/hilomap.cc	/^void hilomap_worker(RTLIL::SigSpec &sig)$/;"	f	typeref:typename:void
histogram	yosys/passes/cmds/qwp.cc	/^	void histogram(const vector<double> &values)$/;"	f	struct:QwpWorker	typeref:typename:void	file:
hole_to_value	yosys/passes/sat/qbfsat.h	/^	dict<pool<std::string>, std::string> hole_to_value = {};$/;"	m	struct:QbfSolutionType	typeref:typename:dict<pool<std::string>,std::string>
hrecv	yosys/frontends/rpc/rpc_frontend.cc	/^	HANDLE hsend, hrecv;$/;"	m	struct:HandleRpcServer	typeref:typename:HANDLE	file:
hsend	yosys/frontends/rpc/rpc_frontend.cc	/^	HANDLE hsend, hrecv;$/;"	m	struct:HandleRpcServer	typeref:typename:HANDLE	file:
htyp	yosys/libs/fst/fstapi.h	/^    unsigned char htyp;$/;"	m	struct:fstHier	typeref:typename:unsigned char
i	yosys/libs/fst/lz4.cc	/^        U32 i;$/;"	m	union:LZ4_isLittleEndian::__anon9390dffe010a	typeref:typename:U32	file:
i	yosys/libs/json11/json11.cpp	/^    size_t i;$/;"	m	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:size_t	file:
i	yosys/libs/minisat/Solver.h	/^        uint32_t i;$/;"	m	struct:Minisat::Solver::ShrinkStackElem	typeref:typename:uint32_t
i32	yosys/frontends/ast/dpicall.cc	/^	union { double f64; float f32; int32_t i32; void *ptr; } value_store [args.size() + 1];$/;"	m	union:AST::dpi_call::__anonad5aa9e1010a	typeref:typename:int32_t	file:
iattr_mode	yosys/backends/blif/blif.cc	/^	bool iattr_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
icells	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
icells_mode	yosys/backends/blif/blif.cc	/^	bool icells_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
id	yosys/backends/verilog/verilog_backend.cc	/^std::string id(RTLIL::IdString internal_id, bool may_rename = true)$/;"	f	typeref:typename:std::string
id	yosys/kernel/fstdata.h	/^	fstHandle id;$/;"	m	struct:FstVar	typeref:typename:fstHandle
id	yosys/kernel/log.h	/^	const char *file, *func, *id;$/;"	m	struct:CoverData	typeref:typename:const char *
id	yosys/libs/ezsat/ezsat.h	/^		int id;$/;"	m	struct:ezSAT::_V	typeref:typename:int
id	yosys/libs/ezsat/ezsat.h	/^	int id;$/;"	m	struct:ezSATbit	typeref:typename:int
id	yosys/passes/techmap/abc.cc	/^	int id;$/;"	m	struct:gate_t	typeref:typename:int	file:
id	yosys/passes/techmap/libparse.h	/^		std::string id, value;$/;"	m	struct:Yosys::LibertyAst	typeref:typename:std::string
id	yosys/passes/tests/test_autotb.cc	/^static std::string id(std::string internal_id)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN std::string	file:
id2ast	yosys/frontends/ast/ast.h	/^		AstNode *id2ast;$/;"	m	struct:AST::AstNode	typeref:typename:AstNode *
id2cid	yosys/backends/simplec/simplec.cc	/^static dict<IdString, string> id2cid;$/;"	v	typeref:typename:dict<IdString,string>	file:
id2cstr	yosys/kernel/rtlil.h	/^	static inline const char *id2cstr(RTLIL::IdString str) {$/;"	f	namespace:RTLIL	typeref:typename:const char *
id2num	yosys/passes/cmds/show.cc	/^	int id2num(RTLIL::IdString id)$/;"	f	struct:ShowWorker	typeref:typename:int	file:
id2vl	yosys/frontends/ast/ast.cc	/^static std::string id2vl(std::string txt)$/;"	f	typeref:typename:std::string	file:
idcache	yosys/backends/smv/smv.cc	/^	dict<IdString, shared_str> idcache;$/;"	m	struct:SmvWorker	typeref:typename:dict<IdString,shared_str>	file:
idcounter	yosys/backends/smt2/smt2.cc	/^	int idcounter = 0, statebv_width = 0;$/;"	m	struct:Smt2Worker	typeref:typename:int	file:
idcounter	yosys/backends/smv/smv.cc	/^	int idcounter;$/;"	m	struct:SmvWorker	typeref:typename:int	file:
ident	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^		size_t ident;$/;"	m	struct:cxxrtl::vcd_writer::variable	typeref:typename:size_t
idict	yosys/kernel/hashlib.h	/^class idict$/;"	c	namespace:hashlib
ids	yosys/backends/smt2/smt2.cc	/^	dict<IdString, char*> ids;$/;"	m	struct:Smt2Worker	typeref:typename:dict<IdString,char * >	file:
idx	yosys/passes/tests/test_autotb.cc	/^static std::string idx(std::string str)$/;"	f	typeref:typename:std::string	file:
idy	yosys/passes/tests/test_autotb.cc	/^static std::string idy(std::string str1, std::string str2 = std::string(), std::string str3 = st/;"	f	typeref:typename:std::string	file:
ifind	yosys/kernel/hashlib.h	/^	int ifind(int i) const$/;"	f	class:hashlib::mfp	typeref:typename:int
ifxmode	yosys/techlibs/common/prep.cc	/^	bool autotop, flatten, ifxmode, memxmode, nomemmode, nokeepdc, rdff;$/;"	m	struct:PrepPass	typeref:typename:bool	file:
ignoreThisSignalsInInitial	yosys/frontends/ast/ast.cc	/^	RTLIL::SigSpec ignoreThisSignalsInInitial;$/;"	v	namespace:AST_INTERNAL	typeref:typename:RTLIL::SigSpec
ignore_div_by_zero	yosys/kernel/satgen.h	/^	bool ignore_div_by_zero;$/;"	m	struct:SatGen	typeref:typename:bool
ignore_parameters	yosys/passes/techmap/extract.cc	/^	bool ignore_parameters;$/;"	m	class:SubCircuitSolver	typeref:typename:bool	file:
ignore_unknown_cells	yosys/passes/sat/sat.cc	/^	bool enable_undef, set_init_def, set_init_undef, set_init_zero, ignore_unknown_cells;$/;"	m	struct:SatHelper	typeref:typename:bool	file:
ignore_wb	yosys/passes/techmap/flatten.cc	/^	bool ignore_wb = false;$/;"	m	struct:FlattenWorker	typeref:typename:bool	file:
ignore_wb	yosys/passes/techmap/techmap.cc	/^	bool ignore_wb = false;$/;"	m	struct:TechmapWorker	typeref:typename:bool	file:
ignore_x	yosys/passes/sat/sim.cc	/^	bool ignore_x = false;$/;"	m	struct:SimShared	typeref:typename:bool	file:
ignore_x_mod1	yosys/passes/sat/eval.cc	/^	bool ignore_x_mod1;$/;"	m	struct:BruteForceEquivChecker	typeref:typename:bool	file:
ignored_parameters	yosys/passes/techmap/extract.cc	/^	std::set<std::pair<RTLIL::IdString, RTLIL::IdString>> ignored_parameters;$/;"	m	class:SubCircuitSolver	typeref:typename:std::set<std::pair<RTLIL::IdString,RTLIL::IdString>>	file:
imap	yosys/passes/techmap/attrmap.cc	/^	bool imap;$/;"	m	struct:AttrmapMap	typeref:typename:bool	file:
imerge	yosys/kernel/hashlib.h	/^	void imerge(int i, int j)$/;"	f	class:hashlib::mfp	typeref:typename:void
impl_f	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::ostream *impl_f = nullptr;$/;"	m	struct:CxxrtlWorker	typeref:typename:std::ostream *	file:
implement_best_cover	yosys/passes/techmap/muxcover.cc	/^	void implement_best_cover(tree_t &tree, SigBit bit, int count_muxes_by_type[4])$/;"	f	struct:MuxcoverWorker	typeref:typename:void	file:
implement_decode_mux	yosys/passes/techmap/muxcover.cc	/^	void implement_decode_mux(SigBit ctrl_bit)$/;"	f	struct:MuxcoverWorker	typeref:typename:void	file:
implement_pattern_cache	yosys/passes/fsm/fsm_map.cc	/^static void implement_pattern_cache(RTLIL::Module *module, std::map<RTLIL::Const, std::set<int>>/;"	f	typeref:typename:void	file:
implied	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::implied(const vec<Lit>& c)$/;"	f	class:SimpSolver	typeref:typename:bool
implies	yosys/libs/minisat/Solver.cc	/^bool Solver::implies(const vec<Lit>& assumps, vec<Lit>& out)$/;"	f	class:Solver	typeref:typename:bool
impltf_mode	yosys/backends/blif/blif.cc	/^	bool impltf_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
import	yosys/frontends/verific/verificsva.cc	/^	void import()$/;"	f	struct:VerificSvaImporter	typeref:typename:void	file:
importAsserts	yosys/kernel/satgen.h	/^	int importAsserts(int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:int
importAssumes	yosys/kernel/satgen.h	/^	int importAssumes(int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:int
importCell	yosys/kernel/satgen.cc	/^bool SatGen::importCell(RTLIL::Cell *cell, int timestep)$/;"	f	class:SatGen	typeref:typename:USING_YOSYS_NAMESPACE bool
importDefSigBit	yosys/kernel/satgen.h	/^	int importDefSigBit(RTLIL::SigBit bit, int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:int
importDefSigSpec	yosys/kernel/satgen.h	/^	std::vector<int> importDefSigSpec(RTLIL::SigSpec sig, int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:std::vector<int>
importSig	yosys/kernel/qcsat.cc	/^std::vector<int> QuickConeSat::importSig(SigSpec sig)$/;"	f	class:QuickConeSat	typeref:typename:USING_YOSYS_NAMESPACE std::vector<int>
importSigBit	yosys/kernel/qcsat.cc	/^int QuickConeSat::importSigBit(SigBit bit)$/;"	f	class:QuickConeSat	typeref:typename:int
importSigBit	yosys/kernel/satgen.h	/^	int importSigBit(RTLIL::SigBit bit, int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:int
importSigSpec	yosys/kernel/satgen.h	/^	std::vector<int> importSigSpec(RTLIL::SigSpec sig, int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:std::vector<int>
importSigSpecWorker	yosys/kernel/satgen.h	/^	std::vector<int> importSigSpecWorker(RTLIL::SigSpec sig, std::string &pf, bool undef_mode, bool/;"	f	struct:SatGen	typeref:typename:std::vector<int>
importUndefSigBit	yosys/kernel/satgen.h	/^	int importUndefSigBit(RTLIL::SigBit bit, int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:int
importUndefSigSpec	yosys/kernel/satgen.h	/^	std::vector<int> importUndefSigSpec(RTLIL::SigSpec sig, int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:std::vector<int>
import_attributes	yosys/frontends/verific/verific.cc	/^void VerificImporter::import_attributes(dict<RTLIL::IdString, RTLIL::Const> &attributes, DesignO/;"	f	class:VerificImporter	typeref:typename:void
import_hier_cell	yosys/passes/sat/fmcombine.cc	/^	void import_hier_cell(Cell *cell)$/;"	f	struct:FmcombineWorker	typeref:typename:void	file:
import_netlist	yosys/frontends/verific/verific.cc	/^void VerificImporter::import_netlist(RTLIL::Design *design, Netlist *nl, std::map<std::string,Ne/;"	f	class:VerificImporter	typeref:typename:void
import_netlist_instance_cells	yosys/frontends/verific/verific.cc	/^bool VerificImporter::import_netlist_instance_cells(Instance *inst, RTLIL::IdString inst_name)$/;"	f	class:VerificImporter	typeref:typename:bool
import_netlist_instance_gates	yosys/frontends/verific/verific.cc	/^bool VerificImporter::import_netlist_instance_gates(Instance *inst, RTLIL::IdString inst_name)$/;"	f	class:VerificImporter	typeref:typename:bool
import_prim_cell	yosys/passes/sat/fmcombine.cc	/^	Cell *import_prim_cell(Cell *cell, const string &suffix)$/;"	f	struct:FmcombineWorker	typeref:typename:Cell *	file:
import_sig	yosys/passes/sat/fmcombine.cc	/^	SigSpec import_sig(SigSpec sig, const string &suffix)$/;"	f	struct:FmcombineWorker	typeref:typename:SigSpec	file:
importedSigBit	yosys/kernel/satgen.h	/^	bool importedSigBit(RTLIL::SigBit bit, int timestep = -1)$/;"	f	struct:SatGen	typeref:typename:bool
imported_cells	yosys/kernel/qcsat.h	/^	pool<RTLIL::Cell*> imported_cells;$/;"	m	struct:QuickConeSat	typeref:typename:pool<RTLIL::Cell * >
imported_cells_cache	yosys/passes/equiv/equiv_simple.cc	/^	pool<pair<Cell*, int>> imported_cells_cache;$/;"	m	struct:EquivSimpleWorker	typeref:typename:pool<pair<Cell *,int>>	file:
imported_onehot	yosys/kernel/qcsat.h	/^	pool<RTLIL::Wire*> imported_onehot;$/;"	m	struct:QuickConeSat	typeref:typename:pool<RTLIL::Wire * >
imported_signals	yosys/kernel/satgen.h	/^	std::map<std::string, std::map<RTLIL::SigBit, int>> imported_signals;$/;"	m	struct:SatGen	typeref:typename:std::map<std::string,std::map<RTLIL::SigBit,int>>
importer	yosys/frontends/verific/verificsva.cc	/^	VerificImporter *importer = nullptr;$/;"	m	struct:VerificSvaImporter	typeref:typename:VerificImporter *	file:
impossible_with_ren	yosys/passes/memory/memory_dff.cc	/^	bool impossible_with_ren(SigBit sel, bool neg_sel) {$/;"	f	struct:MemQueryCache	typeref:typename:bool	file:
in	yosys/kernel/rtlil.h	/^		bool in(Args... args) const {$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
in	yosys/kernel/rtlil.h	/^		bool in(const IdString &rhs) const { return *this == rhs; }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
in	yosys/kernel/rtlil.h	/^		bool in(const char *rhs) const { return *this == rhs; }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
in	yosys/kernel/rtlil.h	/^		bool in(const pool<IdString> &rhs) const { return rhs.count(*this) != 0; }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
in	yosys/kernel/rtlil.h	/^		bool in(const std::string &rhs) const { return *this == rhs; }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
in	yosys/passes/cmds/show.cc	/^	struct net_conn { std::set<std::pair<std::string, int>> in, out; std::string color; };$/;"	m	struct:ShowWorker::net_conn	typeref:typename:std::set<std::pair<std::string,int>>	file:
in1	yosys/passes/techmap/abc.cc	/^	int in1, in2, in3, in4;$/;"	m	struct:gate_t	typeref:typename:int	file:
in2	yosys/passes/techmap/abc.cc	/^	int in1, in2, in3, in4;$/;"	m	struct:gate_t	typeref:typename:int	file:
in3	yosys/passes/techmap/abc.cc	/^	int in1, in2, in3, in4;$/;"	m	struct:gate_t	typeref:typename:int	file:
in4	yosys/passes/techmap/abc.cc	/^	int in1, in2, in3, in4;$/;"	m	struct:gate_t	typeref:typename:int	file:
inHeap	yosys/libs/minisat/Heap.h	/^    bool inHeap    (K k)       const { return indices.has(k) && indices[k] >= 0; }$/;"	f	class:Minisat::Heap	typeref:typename:bool
in_a	yosys/kernel/macc.h	/^		RTLIL::SigSpec in_a, in_b;$/;"	m	struct:Macc::port_t	typeref:typename:RTLIL::SigSpec
in_b	yosys/kernel/macc.h	/^		RTLIL::SigSpec in_a, in_b;$/;"	m	struct:Macc::port_t	typeref:typename:RTLIL::SigSpec
in_cond_mode	yosys/frontends/verific/verificsva.cc	/^	bool in_cond_mode = false;$/;"	m	struct:SvaFsm	typeref:typename:bool	file:
in_pthread	yosys/libs/fst/fstapi.cc	/^    unsigned in_pthread : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
in_range	yosys/libs/json11/json11.cpp	/^static inline bool in_range(long x, long lower, long upper) {$/;"	f	namespace:json11	typeref:typename:bool	file:
in_set	yosys/libs/minisat/IntMap.h	/^        IntMap<K, char, MkIndex> in_set;$/;"	m	class:Minisat::IntSet	typeref:typename:IntMap<K,char,MkIndex>
iname_mode	yosys/backends/blif/blif.cc	/^	bool iname_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
inames	yosys/passes/equiv/equiv_make.cc	/^	bool inames;$/;"	m	struct:EquivMakeWorker	typeref:typename:bool	file:
inc_indent	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void inc_indent() {$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
increase	yosys/libs/minisat/Heap.h	/^    void increase  (K k) { assert(inHeap(k)); percolateDown(indices[k]); }$/;"	f	class:Minisat::Heap	typeref:typename:void
indent	yosys/backends/btor/btor.cc	/^	string indent, info_filename;$/;"	m	struct:BtorWorker	typeref:typename:string	file:
indent	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string indent;$/;"	m	struct:CxxrtlWorker	typeref:typename:std::string	file:
indent	yosys/backends/firrtl/firrtl.cc	/^	std::string indent;$/;"	m	struct:FirrtlWorker	typeref:typename:std::string	file:
index	yosys/backends/cxxrtl/cxxrtl.h	/^		size_t index;$/;"	m	struct:cxxrtl::memory::write	typeref:typename:size_t
index	yosys/backends/cxxrtl/cxxrtl.h	/^	size_t index;$/;"	m	struct:cxxrtl_yosys::memory_index	typeref:typename:size_t
index	yosys/kernel/hashlib.h	/^		int index;$/;"	m	class:hashlib::dict::const_iterator	typeref:typename:int
index	yosys/kernel/hashlib.h	/^		int index;$/;"	m	class:hashlib::dict::iterator	typeref:typename:int
index	yosys/kernel/hashlib.h	/^		int index;$/;"	m	class:hashlib::idict::const_iterator	typeref:typename:int
index	yosys/kernel/hashlib.h	/^		int index;$/;"	m	class:hashlib::pool::const_iterator	typeref:typename:int
index	yosys/kernel/hashlib.h	/^		int index;$/;"	m	class:hashlib::pool::iterator	typeref:typename:int
index	yosys/kernel/rtlil.h	/^	int index;$/;"	m	struct:RTLIL::SigSpecConstIterator	typeref:typename:int
index	yosys/kernel/rtlil.h	/^	int index;$/;"	m	struct:RTLIL::SigSpecIterator	typeref:typename:int
index	yosys/libs/minisat/IntMap.h	/^        MkIndex  index;$/;"	m	class:Minisat::IntMap	typeref:typename:MkIndex
index	yosys/libs/minisat/Map.h	/^    int32_t index  (const K& k) const { return hash(k) % cap; }$/;"	f	class:Minisat::Map	typeref:typename:int32_t
index	yosys/passes/hierarchy/hierarchy.cc	/^	int index;$/;"	m	struct:generate_port_decl_t	typeref:typename:int	file:
index	yosys/passes/memory/memory_bram.cc	/^		int group, index, dupidx;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:int	file:
index	yosys/passes/opt/opt_lut.cc	/^	ModIndex index;$/;"	m	struct:OptLutWorker	typeref:typename:ModIndex	file:
index	yosys/passes/techmap/flowmap.cc	/^	ModIndex index;$/;"	m	struct:FlowmapWorker	typeref:typename:ModIndex	file:
index_	yosys/kernel/rtlil.h	/^		int index_;$/;"	m	struct:RTLIL::IdString	typeref:typename:int
indices	yosys/libs/minisat/Heap.h	/^    IntMap<K,int,MkIndex> indices;  \/\/ Each Key's position (index) in the Heap$/;"	m	class:Minisat::Heap	typeref:typename:IntMap<K,int,MkIndex>
infile	yosys/passes/memory/memory_bram.cc	/^	std::ifstream infile;$/;"	m	struct:rules_t	typeref:typename:std::ifstream	file:
info	yosys/kernel/modtools.h	/^	const SigBitInfo &info(RTLIL::SigBit bit)$/;"	f	struct:ModIndex	typeref:typename:const SigBitInfo &
info_clocks	yosys/backends/btor/btor.cc	/^	dict<int, int> info_clocks;$/;"	m	struct:BtorWorker	typeref:typename:dict<int,int>	file:
info_filename	yosys/backends/btor/btor.cc	/^	string indent, info_filename;$/;"	m	struct:BtorWorker	typeref:typename:string	file:
info_lines	yosys/backends/btor/btor.cc	/^	vector<string> info_lines;$/;"	m	struct:BtorWorker	typeref:typename:vector<string>	file:
infof	yosys/backends/btor/btor.cc	/^	void infof(const char *fmt, ...) YS_ATTRIBUTE(format(printf, 2, 3))$/;"	f	struct:BtorWorker	typeref:typename:void	file:
init	yosys/libs/minisat/SolverTypes.h	/^    void  init      (const K& idx){ occs.reserve(idx); occs[idx].clear(); dirty.reserve(idx, 0);/;"	f	class:Minisat::OccLists	typeref:typename:void
init	yosys/passes/memory/memory_bram.cc	/^		int groups, abits, dbits, init;$/;"	m	struct:rules_t::bram_t	typeref:typename:int	file:
init	yosys/passes/techmap/abc.cc	/^	RTLIL::State init;$/;"	m	struct:gate_t	typeref:typename:RTLIL::State	file:
init	yosys/passes/techmap/shregmap.cc	/^	bool zinit, init, params, ffe;$/;"	m	struct:ShregmapOptions	typeref:typename:bool	file:
init2eqn	yosys/techlibs/anlogic/anlogic_eqn.cc	/^	Const init2eqn(Const init, int inputs)$/;"	f	struct:AnlogicEqnPass	typeref:typename:Const	file:
initCheck	yosys/libs/fst/lz4.cc	/^    U32 initCheck;$/;"	m	struct:__anon9390dffe0208	typeref:typename:U32	file:
initFromPrimitive	yosys/libs/bigint/BigUnsigned.hh	/^void BigUnsigned::initFromPrimitive(X x) {$/;"	f	class:BigUnsigned	typeref:typename:void
initFromSignedPrimitive	yosys/libs/bigint/BigUnsigned.hh	/^void BigUnsigned::initFromSignedPrimitive(X x) {$/;"	f	class:BigUnsigned	typeref:typename:void
initSyncSignals	yosys/frontends/ast/genrtlil.cc	/^	RTLIL::SigSpec initSyncSignals;$/;"	m	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:RTLIL::SigSpec	file:
init_abc_executable_name	yosys/kernel/yosys.cc	/^void init_abc_executable_name()$/;"	f	typeref:typename:void
init_bit2driven	yosys/passes/equiv/equiv_make.cc	/^	void init_bit2driven()$/;"	f	struct:EquivMakeWorker	typeref:typename:void	file:
init_bits	yosys/backends/blif/blif.cc	/^	dict<SigBit, int> init_bits;$/;"	m	struct:BlifDumper	typeref:typename:dict<SigBit,int>	file:
init_inputs	yosys/backends/aiger/aiger.cc	/^	dict<SigBit, int> init_inputs;$/;"	m	struct:AigerWriter	typeref:typename:dict<SigBit,int>	file:
init_lvalue	yosys/frontends/ast/genrtlil.cc	/^	RTLIL::SigSpec init_lvalue, init_rvalue;$/;"	m	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:RTLIL::SigSpec	file:
init_map	yosys/backends/aiger/aiger.cc	/^	dict<SigBit, bool> init_map;$/;"	m	struct:AigerWriter	typeref:typename:dict<SigBit,bool>	file:
init_map	yosys/backends/aiger/xaiger.cc	/^	dict<SigBit, State> init_map;$/;"	m	struct:XAigerWriter	typeref:typename:dict<SigBit,State>	file:
init_register	yosys/kernel/register.cc	/^void Pass::init_register()$/;"	f	class:Pass	typeref:typename:void
init_rvalue	yosys/frontends/ast/genrtlil.cc	/^	RTLIL::SigSpec init_lvalue, init_rvalue;$/;"	m	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:RTLIL::SigSpec	file:
init_share_dirname	yosys/kernel/yosys.cc	/^void init_share_dirname()$/;"	f	typeref:typename:void
init_value	yosys/kernel/mem.h	/^	Const arst_value, srst_value, init_value;$/;"	m	struct:MemRd	typeref:typename:Const
initbits	yosys/backends/btor/btor.cc	/^	dict<SigBit, bool> initbits;$/;"	m	struct:BtorWorker	typeref:typename:dict<SigBit,bool>	file:
initbits	yosys/kernel/ffinit.h	/^	dict<SigBit, std::pair<State,SigBit>> initbits;$/;"	m	struct:FfInitVals	typeref:typename:dict<SigBit,std::pair<State,SigBit>>
initbits	yosys/passes/pmgen/peepopt.cc	/^dict<SigBit, State> initbits;$/;"	v	typeref:typename:dict<SigBit,State>
initeq	yosys/passes/sat/fmcombine.cc	/^	bool initeq = false;$/;"	m	struct:opts_t	typeref:typename:bool	file:
initial_id	yosys/backends/verilog/verilog_backend.cc	/^IdString initial_id;$/;"	v	typeref:typename:IdString
initial_state	yosys/frontends/aiger/aigerparse.h	/^    std::vector<int> mergeability, initial_state;$/;"	m	struct:AigerReader	typeref:typename:std::vector<int>
initial_state	yosys/kernel/satgen.h	/^	SigPool initial_state;$/;"	m	struct:SatGen	typeref:typename:SigPool
initial_tv	yosys/kernel/log.cc	/^static struct timeval initial_tv = { 0, 0 };$/;"	v	typeref:struct:timeval	file:
initialize	yosys/passes/opt/pmux2shiftx.cc	/^	void initialize()$/;"	f	struct:OnehotDatabase	typeref:typename:void	file:
initialized	yosys/passes/opt/pmux2shiftx.cc	/^	bool initialized = false;$/;"	m	struct:OnehotDatabase	typeref:typename:bool	file:
inits	yosys/kernel/mem.cc	/^		dict<IdString, pool<Cell *>> inits;$/;"	m	struct:__anon62474a9e0111::MemIndex	typeref:typename:dict<IdString,pool<Cell * >>	file:
inits	yosys/kernel/mem.h	/^	std::vector<MemInit> inits;$/;"	m	struct:Mem	typeref:typename:std::vector<MemInit>
initstate_bits	yosys/backends/aiger/aiger.cc	/^	pool<SigBit> initstate_bits;$/;"	m	struct:AigerWriter	typeref:typename:pool<SigBit>	file:
initstate_ff	yosys/backends/aiger/aiger.cc	/^	int initstate_ff = 0;$/;"	m	struct:AigerWriter	typeref:typename:int	file:
initstate_nid	yosys/backends/btor/btor.cc	/^	int initstate_nid = -1;$/;"	m	struct:BtorWorker	typeref:typename:int	file:
initstates	yosys/kernel/satgen.h	/^	std::map<std::pair<std::string, int>, bool> initstates;$/;"	m	struct:SatGen	typeref:typename:std::map<std::pair<std::string,int>,bool>
initvals	yosys/kernel/ff.h	/^	FfInitVals *initvals;$/;"	m	struct:FfData	typeref:typename:FfInitVals *
initvals	yosys/kernel/ffmerge.h	/^	FfInitVals *initvals;$/;"	m	struct:FfMergeHelper	typeref:typename:FfInitVals *
initvals	yosys/passes/memory/memory_dff.cc	/^	FfInitVals initvals;$/;"	m	struct:MemoryDffWorker	typeref:typename:FfInitVals	file:
initvals	yosys/passes/memory/memory_map.cc	/^	FfInitVals initvals;$/;"	m	struct:MemoryMapWorker	typeref:typename:FfInitVals	file:
initvals	yosys/passes/memory/memory_share.cc	/^	FfInitVals initvals;$/;"	m	struct:MemoryShareWorker	typeref:typename:FfInitVals	file:
initvals	yosys/passes/opt/opt_dff.cc	/^	FfInitVals initvals;$/;"	m	struct:OptDffWorker	typeref:typename:FfInitVals	file:
initvals	yosys/passes/opt/opt_mem_feedback.cc	/^	FfInitVals initvals;$/;"	m	struct:OptMemFeedbackWorker	typeref:typename:FfInitVals	file:
initvals	yosys/passes/opt/opt_merge.cc	/^	FfInitVals initvals;$/;"	m	struct:OptMergeWorker	typeref:typename:FfInitVals	file:
initvals	yosys/passes/opt/pmux2shiftx.cc	/^	FfInitVals initvals;$/;"	m	struct:OnehotDatabase	typeref:typename:FfInitVals	file:
initvals	yosys/passes/opt/wreduce.cc	/^	FfInitVals initvals;$/;"	m	struct:WreduceWorker	typeref:typename:FfInitVals	file:
initvals	yosys/passes/proc/proc_dlatch.cc	/^	FfInitVals initvals;$/;"	m	struct:proc_dlatch_db_t	typeref:typename:FfInitVals	file:
initvals	yosys/passes/techmap/abc.cc	/^FfInitVals initvals;$/;"	v	typeref:typename:FfInitVals
initvals	yosys/passes/techmap/dfflegalize.cc	/^	FfInitVals initvals;$/;"	m	struct:DffLegalizePass	typeref:typename:FfInitVals	file:
initvals	yosys/passes/techmap/shregmap.cc	/^	FfInitVals initvals;$/;"	m	struct:ShregmapWorker	typeref:typename:FfInitVals	file:
inline_internal	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool inline_internal = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
inline_public	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool inline_public = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
inline_unpack	yosys/kernel/rtlil.h	/^	inline void inline_unpack() const {$/;"	f	struct:RTLIL::SigSpec	typeref:typename:void
inport	yosys/kernel/cellaigs.cc	/^	int inport(IdString portname, int portbit = 0, bool inverter = false)$/;"	f	struct:AigMaker	typeref:typename:int	file:
inport_vec	yosys/kernel/cellaigs.cc	/^	vector<int> inport_vec(IdString portname, int width)$/;"	f	struct:AigMaker	typeref:typename:vector<int>	file:
input	yosys/kernel/rtlil.cc	/^bool RTLIL::Cell::input(RTLIL::IdString portname) const$/;"	f	class:RTLIL::Cell	typeref:typename:bool
input	yosys/passes/hierarchy/hierarchy.cc	/^	bool input, output;$/;"	m	struct:generate_port_decl_t	typeref:typename:bool	file:
input_bits	yosys/backends/aiger/aiger.cc	/^	pool<SigBit> input_bits, output_bits;$/;"	m	struct:AigerWriter	typeref:typename:pool<SigBit>	file:
input_bits	yosys/backends/aiger/xaiger.cc	/^	pool<SigBit> input_bits, output_bits;$/;"	m	struct:XAigerWriter	typeref:typename:pool<SigBit>	file:
input_buffer	yosys/frontends/verilog/preproc.cc	/^static std::list<std::string> input_buffer;$/;"	v	typeref:typename:std::list<std::string>	file:
input_buffer_charp	yosys/frontends/verilog/preproc.cc	/^static size_t input_buffer_charp;$/;"	v	typeref:typename:size_t	file:
input_file	yosys/frontends/verilog/preproc.cc	/^static void input_file(std::istream &f, std::string filename)$/;"	f	typeref:typename:void	file:
input_muxes	yosys/passes/opt/opt_muxtree.cc	/^		pool<int> input_muxes;$/;"	m	struct:OptMuxtreeWorker::portinfo_t	typeref:typename:pool<int>	file:
input_sigs	yosys/passes/opt/opt_muxtree.cc	/^		pool<int> input_sigs;$/;"	m	struct:OptMuxtreeWorker::portinfo_t	typeref:typename:pool<int>	file:
input_widths	yosys/passes/sat/eval.cc	/^	std::vector<int> input_widths;$/;"	m	struct:VlogHammerReporter	typeref:typename:std::vector<int>	file:
inputs	yosys/frontends/aiger/aigerparse.h	/^    std::vector<RTLIL::Wire*> inputs;$/;"	m	struct:AigerReader	typeref:typename:std::vector<RTLIL::Wire * >
inputs	yosys/kernel/celltypes.h	/^	pool<RTLIL::IdString> inputs, outputs;$/;"	m	struct:CellType	typeref:typename:pool<RTLIL::IdString>
inputs	yosys/passes/sat/eval.cc	/^	std::vector<RTLIL::IdString> inputs;$/;"	m	struct:VlogHammerReporter	typeref:typename:std::vector<RTLIL::IdString>	file:
inputs	yosys/passes/techmap/flowmap.cc	/^	pool<RTLIL::SigBit> nodes, inputs, outputs;$/;"	m	struct:FlowmapWorker	typeref:typename:pool<RTLIL::SigBit>	file:
inputs	yosys/passes/techmap/muxcover.cc	/^		vector<SigBit> inputs, selects;$/;"	m	struct:MuxcoverWorker::newmux_t	typeref:typename:vector<SigBit>	file:
inputvars	yosys/backends/smv/smv.cc	/^	vector<string> inputvars, vars, definitions, assignments, invarspecs;$/;"	m	struct:SmvWorker	typeref:typename:vector<string>	file:
insert	yosys/kernel/hashlib.h	/^	std::pair<iterator, bool> insert(K &&rvalue)$/;"	f	class:hashlib::pool	typeref:typename:std::pair<iterator,bool>
insert	yosys/kernel/hashlib.h	/^	std::pair<iterator, bool> insert(const K &key)$/;"	f	class:hashlib::dict	typeref:typename:std::pair<iterator,bool>
insert	yosys/kernel/hashlib.h	/^	std::pair<iterator, bool> insert(const K &value)$/;"	f	class:hashlib::pool	typeref:typename:std::pair<iterator,bool>
insert	yosys/kernel/hashlib.h	/^	std::pair<iterator, bool> insert(const std::pair<K, T> &value)$/;"	f	class:hashlib::dict	typeref:typename:std::pair<iterator,bool>
insert	yosys/kernel/hashlib.h	/^	std::pair<iterator, bool> insert(std::pair<K, T> &&rvalue)$/;"	f	class:hashlib::dict	typeref:typename:std::pair<iterator,bool>
insert	yosys/kernel/hashlib.h	/^	void insert(InputIterator first, InputIterator last)$/;"	f	class:hashlib::dict	typeref:typename:void
insert	yosys/kernel/hashlib.h	/^	void insert(InputIterator first, InputIterator last)$/;"	f	class:hashlib::pool	typeref:typename:void
insert	yosys/kernel/sigtools.h	/^	void insert(const RTLIL::SigSpec &sig, T data)$/;"	f	struct:SigSet	typeref:typename:void
insert	yosys/kernel/sigtools.h	/^	void insert(const RTLIL::SigSpec& sig, const std::set<T> &data)$/;"	f	struct:SigSet	typeref:typename:void
insert	yosys/libs/minisat/Heap.h	/^    void insert(K k)$/;"	f	class:Minisat::Heap	typeref:typename:void
insert	yosys/libs/minisat/IntMap.h	/^        void     insert      (K k) { in_set.reserve(k, 0); if (!in_set[k]) { in_set[k] = 1; xs.p/;"	f	class:Minisat::IntSet	typeref:typename:void
insert	yosys/libs/minisat/IntMap.h	/^        void     insert (K key, V val)       { reserve(key); operator[](key) = val; }$/;"	f	class:Minisat::IntMap	typeref:typename:void
insert	yosys/libs/minisat/IntMap.h	/^        void     insert (K key, V val, V pad){ reserve(key, pad); operator[](key) = val; }$/;"	f	class:Minisat::IntMap	typeref:typename:void
insert	yosys/libs/minisat/Map.h	/^    void insert (const K& k, const D& d) { if (checkCap(size+1)) rehash(); _insert(k, d); size++/;"	f	class:Minisat::Map	typeref:typename:void
insert	yosys/libs/minisat/Queue.h	/^    void insert(T elem) {   \/\/ INVARIANT: buf[end] is always unused$/;"	f	class:Minisat::Queue	typeref:typename:void
insert	yosys/libs/minisat/SolverTypes.h	/^    void     insert      (CRef cr, const T& t){ map.insert(cr, t); }$/;"	f	class:Minisat::CMap	typeref:typename:void
insert	yosys/passes/proc/proc_mux.cc	/^	void insert(SigSpec sig)$/;"	f	struct:SigSnippets	typeref:typename:void	file:
insert	yosys/passes/proc/proc_mux.cc	/^	void insert(const RTLIL::CaseRule *cs)$/;"	f	struct:SigSnippets	typeref:typename:void	file:
insert	yosys/passes/proc/proc_mux.cc	/^	void insert(const RTLIL::CaseRule *cs)$/;"	f	struct:SnippetSwCache	typeref:typename:void	file:
insert	yosys/passes/proc/proc_mux.cc	/^	void insert(const RTLIL::CaseRule *cs, vector<RTLIL::SwitchRule*> &sw_stack)$/;"	f	struct:SnippetSwCache	typeref:typename:void	file:
insert	yosys/passes/sat/mutate.cc	/^	void insert(const mutate_t &m) {$/;"	f	struct:coverdb_t	typeref:typename:void	file:
insertVarOrder	yosys/libs/minisat/Solver.h	/^inline void Solver::insertVarOrder(Var x) {$/;"	f	class:Minisat::Solver	typeref:typename:void
insert_input	yosys/frontends/verilog/preproc.cc	/^static void insert_input(std::string str)$/;"	f	typeref:typename:void	file:
install	yosys/Makefile	/^install: $(TARGETS) $(EXTRA_TARGETS)$/;"	t
instance	yosys/passes/sat/sim.cc	/^	Cell *instance;$/;"	m	struct:SimInstance	typeref:typename:Cell *	file:
int_to_hash_string	yosys/passes/opt/opt_merge.cc	/^	std::string int_to_hash_string(unsigned int v)$/;"	f	struct:OptMergeWorker	typeref:typename:std::string	file:
int_value	yosys/libs/json11/json11.cpp	/^    int int_value() const override { return m_value; }$/;"	f	class:json11::JsonInt	typeref:typename:int	file:
int_value	yosys/libs/json11/json11.cpp	/^    int int_value() const override { return static_cast<int>(m_value); }$/;"	f	class:json11::JsonDouble	typeref:typename:int	file:
int_value	yosys/libs/json11/json11.cpp	/^int                       JsonValue::int_value()                 const { return 0; }$/;"	f	class:json11::JsonValue	typeref:typename:int
int_value	yosys/libs/json11/json11.cpp	/^int Json::int_value()                             const { return m_ptr->int_value();    }$/;"	f	class:json11::Json	typeref:typename:int
integer	yosys/frontends/ast/ast.h	/^		uint32_t integer;$/;"	m	struct:AST::AstNode	typeref:typename:uint32_t
interfaces_in_module	yosys/passes/hierarchy/hierarchy.cc	/^	dict<RTLIL::IdString, RTLIL::Module*>   interfaces_in_module;$/;"	m	struct:IFExpander	typeref:typename:dict<RTLIL::IdString,RTLIL::Module * >	file:
interfaces_to_add_to_submodule	yosys/passes/hierarchy/hierarchy.cc	/^	dict<RTLIL::IdString, RTLIL::Module*>   interfaces_to_add_to_submodule;$/;"	m	struct:IFExpander	typeref:typename:dict<RTLIL::IdString,RTLIL::Module * >	file:
interior	yosys/backends/cxxrtl/cxxrtl.h	/^struct interior {};$/;"	s	namespace:cxxrtl
interrupt	yosys/libs/minisat/Solver.h	/^inline void     Solver::interrupt(){ asynch_interrupt = true; }$/;"	f	class:Minisat::Solver	typeref:typename:void
intf_f	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::ostream *intf_f = nullptr;$/;"	m	struct:CxxrtlWorker	typeref:typename:std::ostream *	file:
intf_filename	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string intf_filename;$/;"	m	struct:CxxrtlWorker	typeref:typename:std::string	file:
inv_a	yosys/passes/techmap/extract_fa.cc	/^		bool inv_a, inv_b, inv_c, inv_y;$/;"	m	struct:ExtractFaWorker::func3_maj_info_t	typeref:typename:bool	file:
inv_a	yosys/passes/techmap/extract_fa.cc	/^		bool inv_a, inv_b, inv_y;$/;"	m	struct:ExtractFaWorker::func2_and_info_t	typeref:typename:bool	file:
inv_b	yosys/passes/techmap/extract_fa.cc	/^		bool inv_a, inv_b, inv_c, inv_y;$/;"	m	struct:ExtractFaWorker::func3_maj_info_t	typeref:typename:bool	file:
inv_b	yosys/passes/techmap/extract_fa.cc	/^		bool inv_a, inv_b, inv_y;$/;"	m	struct:ExtractFaWorker::func2_and_info_t	typeref:typename:bool	file:
inv_c	yosys/passes/techmap/extract_fa.cc	/^		bool inv_a, inv_b, inv_c, inv_y;$/;"	m	struct:ExtractFaWorker::func3_maj_info_t	typeref:typename:bool	file:
inv_mode	yosys/passes/sat/freduce.cc	/^bool inv_mode;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
inv_pairs	yosys/passes/sat/freduce.cc	/^	std::set<std::pair<RTLIL::SigBit, RTLIL::SigBit>> &inv_pairs;$/;"	m	struct:PerformReduction	typeref:typename:std::set<std::pair<RTLIL::SigBit,RTLIL::SigBit>> &	file:
inv_pairs	yosys/passes/sat/freduce.cc	/^	std::set<std::pair<RTLIL::SigBit, RTLIL::SigBit>> inv_pairs;$/;"	m	struct:FreduceWorker	typeref:typename:std::set<std::pair<RTLIL::SigBit,RTLIL::SigBit>>	file:
inv_y	yosys/passes/techmap/extract_fa.cc	/^		bool inv_a, inv_b, inv_c, inv_y;$/;"	m	struct:ExtractFaWorker::func3_maj_info_t	typeref:typename:bool	file:
inv_y	yosys/passes/techmap/extract_fa.cc	/^		bool inv_a, inv_b, inv_y;$/;"	m	struct:ExtractFaWorker::func2_and_info_t	typeref:typename:bool	file:
invalidate_lut_critical_outputs	yosys/passes/techmap/flowmap.cc	/^	pool<RTLIL::SigBit> invalidate_lut_critical_outputs(dict<RTLIL::SigBit, pool<RTLIL::SigBit>> &l/;"	f	struct:FlowmapWorker	typeref:typename:pool<RTLIL::SigBit>	file:
invalidate_model	yosys/passes/sat/sat.cc	/^	void invalidate_model(bool max_undef)$/;"	f	struct:SatHelper	typeref:typename:void	file:
invarspecs	yosys/backends/smv/smv.cc	/^	vector<string> inputvars, vars, definitions, assignments, invarspecs;$/;"	m	struct:SmvWorker	typeref:typename:vector<string>	file:
invert	yosys/kernel/ff.cc	/^	State invert(State s) {$/;"	f	namespace:__anon7e9a4a8b0111	typeref:typename:State
invert_b	yosys/passes/techmap/alumacc.cc	/^		bool is_signed, invert_b;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:bool	file:
invert_gp_dff	yosys/techlibs/greenpak4/greenpak4_dffinv.cc	/^void invert_gp_dff(Cell *cell, bool invert_input)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
inverted	yosys/passes/sat/freduce.cc	/^	bool inverted;$/;"	m	struct:equiv_bit_t	typeref:typename:bool	file:
inverter	yosys/kernel/cellaigs.h	/^	bool inverter;$/;"	m	struct:AigNode	typeref:typename:bool
iobs	yosys/techlibs/sf2/synth_sf2.cc	/^	bool flatten, retime, iobs, clkbuf;$/;"	m	struct:SynthSf2Pass	typeref:typename:bool	file:
iopads	yosys/techlibs/intel/synth_intel.cc	/^	bool retime, flatten, nobram, iopads;$/;"	m	struct:SynthIntelPass	typeref:typename:bool	file:
ipromote	yosys/kernel/hashlib.h	/^	void ipromote(int i)$/;"	f	class:hashlib::mfp	typeref:typename:void
irand	yosys/libs/minisat/Rnd.h	/^static inline int irand(double& seed, int size) { return (int)(drand(seed) * size); }$/;"	f	namespace:Minisat	typeref:typename:int
irand	yosys/libs/minisat/Solver.h	/^    static inline int irand(double& seed, int size) {$/;"	f	class:Minisat::Solver	typeref:typename:int
isConst	yosys/frontends/ast/ast.cc	/^int AstNode::isConst() const$/;"	f	class:AstNode	typeref:typename:int
isEliminated	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::isEliminated (Var v) const { return eliminated[v]; }$/;"	f	class:Minisat::SimpSolver	typeref:typename:bool
isEmpty	yosys/libs/bigint/NumberlikeArray.hh	/^	bool  isEmpty()         const { return len == 0; }$/;"	f	class:NumberlikeArray	typeref:typename:bool
isEof	yosys/libs/minisat/ParseUtils.h	/^static inline bool isEof(StreamBuffer& in) { return *in == EOF;  }$/;"	f	namespace:Minisat	typeref:typename:bool
isEof	yosys/libs/minisat/ParseUtils.h	/^static inline bool isEof(const char*   in) { return *in == '\\0'; }$/;"	f	namespace:Minisat	typeref:typename:bool
isExtern	yosys/libs/subcircuit/subcircuit.h	/^			bool isExtern;$/;"	m	struct:SubCircuit::Graph::Edge	typeref:typename:bool
isPublic	yosys/kernel/rtlil.h	/^		bool isPublic() const { return begins_with("\\\\"); }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
isRemoved	yosys/libs/minisat/Solver.h	/^inline bool     Solver::isRemoved       (CRef cr)         const { return ca[cr].mark() == 1; }$/;"	f	class:Minisat::Solver	typeref:typename:bool
isZero	yosys/libs/bigint/BigInteger.hh	/^	bool isZero() const { return sign == zero; } \/\/ A bit special$/;"	f	class:BigInteger	typeref:typename:bool
isZero	yosys/libs/bigint/BigUnsigned.hh	/^	bool isZero() const { return NumberlikeArray<Blk>::isEmpty(); }$/;"	f	class:BigUnsigned	typeref:typename:bool
isZero	yosys/libs/bigint/BigUnsignedInABase.hh	/^	bool isZero() const { return NumberlikeArray<Digit>::isEmpty(); }$/;"	f	class:BigUnsignedInABase	typeref:typename:bool
is_absolute_path	yosys/kernel/yosys.cc	/^bool is_absolute_path(std::string filename)$/;"	f	typeref:typename:bool
is_alias	yosys/kernel/fstdata.h	/^	bool is_alias;$/;"	m	struct:FstVar	typeref:typename:bool
is_alias	yosys/libs/fst/fstapi.h	/^            unsigned is_alias : 1;$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierVar	typeref:typename:unsigned:1
is_all_z	yosys/passes/techmap/tribuf.cc	/^	static bool is_all_z(SigSpec sig)$/;"	f	struct:TribufWorker	typeref:typename:bool	file:
is_array	yosys/libs/json11/json11.hpp	/^    bool is_array()  const { return type() == ARRAY; }$/;"	f	class:json11::Json	typeref:typename:bool
is_autonamed_block	yosys/frontends/ast/simplify.cc	/^static bool is_autonamed_block(const std::string &str) {$/;"	f	typeref:typename:bool	file:
is_b	yosys/passes/memory/memory_dff.cc	/^	bool is_b;$/;"	m	struct:MuxData	typeref:typename:bool	file:
is_binary_cell	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_binary_cell(RTLIL::IdString type)$/;"	f	typeref:typename:bool
is_bit	yosys/kernel/rtlil.h	/^	inline bool is_bit() const { return width_ == 1; }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:bool
is_blackbox	yosys/frontends/verific/verific.cc	/^bool is_blackbox(Netlist *nl)$/;"	f	typeref:typename:bool
is_bool	yosys/libs/json11/json11.hpp	/^    bool is_bool()   const { return type() == BOOL; }$/;"	f	class:json11::Json	typeref:typename:bool
is_bottom	yosys/passes/techmap/flowmap.cc	/^		bool is_bottom;$/;"	m	struct:FlowGraph::NodePrime	typeref:typename:bool	file:
is_buffered	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool is_buffered() const { return type == BUFFERED; }$/;"	f	struct:WireType	typeref:typename:bool	file:
is_cell_merge_candidate	yosys/passes/fsm/fsm_expand.cc	/^	bool is_cell_merge_candidate(RTLIL::Cell *cell)$/;"	f	struct:FsmExpand	typeref:typename:bool	file:
is_chunk	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::is_chunk() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
is_cond_node	yosys/frontends/verific/verificsva.cc	/^	bool is_cond_node;$/;"	m	struct:SvaNFsmNode	typeref:typename:bool	file:
is_custom_type	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
is_cxxrtl_blackbox_cell	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_cxxrtl_blackbox_cell(const RTLIL::Cell *cell)$/;"	f	typeref:typename:bool
is_cxxrtl_comb_port	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_cxxrtl_comb_port(const RTLIL::Cell *cell, RTLIL::IdString port)$/;"	f	typeref:typename:bool
is_cxxrtl_sync_port	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_cxxrtl_sync_port(const RTLIL::Cell *cell, RTLIL::IdString port)$/;"	f	typeref:typename:bool
is_effectful_cell	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_effectful_cell(RTLIL::IdString type)$/;"	f	typeref:typename:bool
is_enum	yosys/frontends/ast/ast.h	/^		bool is_enum;$/;"	m	struct:AST::AstNode	typeref:typename:bool
is_evaluable	yosys/kernel/celltypes.h	/^	bool is_evaluable;$/;"	m	struct:CellType	typeref:typename:bool
is_exact	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool is_exact() const { return type == ALIAS || type == CONST; }$/;"	f	struct:WireType	typeref:typename:bool	file:
is_ext_driven	yosys/passes/hierarchy/submod.cc	/^		bool is_int_used, is_ext_driven, is_ext_used;$/;"	m	struct:SubmodWorker::wire_flags_t	typeref:typename:bool	file:
is_ext_used	yosys/passes/hierarchy/submod.cc	/^		bool is_int_used, is_ext_driven, is_ext_used;$/;"	m	struct:SubmodWorker::wire_flags_t	typeref:typename:bool	file:
is_extending_cell	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_extending_cell(RTLIL::IdString type)$/;"	f	typeref:typename:bool
is_ff_cell	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_ff_cell(RTLIL::IdString type)$/;"	f	typeref:typename:bool
is_fine	yosys/kernel/ff.h	/^	bool is_fine;$/;"	m	struct:FfData	typeref:typename:bool
is_formal_celltype	yosys/passes/cmds/add.cc	/^static bool is_formal_celltype(const std::string &celltype)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool	file:
is_full_bus	yosys/passes/techmap/extract_counter.cc	/^bool is_full_bus($/;"	f	typeref:typename:bool
is_fully_const	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::is_fully_const() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
is_fully_def	yosys/kernel/rtlil.cc	/^bool RTLIL::Const::is_fully_def() const$/;"	f	class:RTLIL::Const	typeref:typename:bool
is_fully_def	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::is_fully_def() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
is_fully_ones	yosys/kernel/rtlil.cc	/^bool RTLIL::Const::is_fully_ones() const$/;"	f	class:RTLIL::Const	typeref:typename:bool
is_fully_ones	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::is_fully_ones() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
is_fully_undef	yosys/kernel/rtlil.cc	/^bool RTLIL::Const::is_fully_undef() const$/;"	f	class:RTLIL::Const	typeref:typename:bool
is_fully_undef	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::is_fully_undef() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
is_fully_zero	yosys/kernel/rtlil.cc	/^bool RTLIL::Const::is_fully_zero() const$/;"	f	class:RTLIL::Const	typeref:typename:bool
is_fully_zero	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::is_fully_zero() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
is_initial_time	yosys/libs/fst/fstapi.cc	/^    unsigned is_initial_time : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
is_inlinable	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool is_inlinable(const RTLIL::Wire *wire) const$/;"	f	struct:FlowGraph	typeref:typename:bool	file:
is_inlinable	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool is_inlinable(const RTLIL::Wire *wire, const pool<Node*, hash_ptr_ops> &nodes) const$/;"	f	struct:FlowGraph	typeref:typename:bool	file:
is_inlinable_cell	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_inlinable_cell(RTLIL::IdString type)$/;"	f	typeref:typename:bool
is_input	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
is_input	yosys/kernel/modtools.h	/^		bool is_input, is_output;$/;"	m	struct:ModIndex::SigBitInfo	typeref:typename:bool
is_int_driven	yosys/passes/hierarchy/submod.cc	/^		RTLIL::Const is_int_driven;$/;"	m	struct:SubmodWorker::wire_flags_t	typeref:typename:RTLIL::Const	file:
is_int_used	yosys/passes/hierarchy/submod.cc	/^		bool is_int_used, is_ext_driven, is_ext_used;$/;"	m	struct:SubmodWorker::wire_flags_t	typeref:typename:bool	file:
is_internal_cell	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_internal_cell(RTLIL::IdString type)$/;"	f	typeref:typename:bool
is_local	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool is_local() const { return type == LOCAL || type == INLINE; }$/;"	f	struct:WireType	typeref:typename:bool	file:
is_logic	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
is_mem_cell	yosys/kernel/rtlil.cc	/^bool RTLIL::Cell::is_mem_cell() const$/;"	f	class:RTLIL::Cell	typeref:typename:bool
is_member	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool is_member() const { return type == BUFFERED || type == MEMBER || type == OUTLINE; }$/;"	f	struct:WireType	typeref:typename:bool	file:
is_memwr_process	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_memwr_process(const RTLIL::Process *process)$/;"	f	typeref:typename:bool
is_named	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool is_named() const { return is_member() || type == LOCAL; }$/;"	f	struct:WireType	typeref:typename:bool	file:
is_neg	yosys/backends/cxxrtl/cxxrtl.h	/^	bool is_neg() const {$/;"	f	struct:cxxrtl::value	typeref:typename:bool
is_null	yosys/libs/json11/json11.hpp	/^    bool is_null()   const { return type() == NUL; }$/;"	f	class:json11::Json	typeref:typename:bool
is_number	yosys/libs/json11/json11.hpp	/^    bool is_number() const { return type() == NUMBER; }$/;"	f	class:json11::Json	typeref:typename:bool
is_object	yosys/libs/json11/json11.hpp	/^    bool is_object() const { return type() == OBJECT; }$/;"	f	class:json11::Json	typeref:typename:bool
is_one_or_minus_one	yosys/passes/opt/opt_expr.cc	/^bool is_one_or_minus_one(const Const &value, bool is_signed, bool &is_negative)$/;"	f	typeref:typename:bool
is_onehot	yosys/kernel/rtlil.cc	/^bool RTLIL::Const::is_onehot(int *pos) const$/;"	f	class:RTLIL::Const	typeref:typename:bool
is_onehot	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::is_onehot(int *pos) const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
is_outline	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool is_outline() const { return type == OUTLINE; }$/;"	f	struct:WireType	typeref:typename:bool	file:
is_output	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
is_output	yosys/kernel/modtools.h	/^		bool is_input, is_output;$/;"	m	struct:ModIndex::SigBitInfo	typeref:typename:bool
is_output_unused	yosys/kernel/ffmerge.cc	/^bool FfMergeHelper::is_output_unused(RTLIL::SigSpec sig) {$/;"	f	class:FfMergeHelper	typeref:typename:USING_YOSYS_NAMESPACE bool
is_part_of_scc	yosys/passes/opt/share.cc	/^	bool is_part_of_scc(RTLIL::Cell *cell)$/;"	f	struct:ShareWorker	typeref:typename:bool	file:
is_port	yosys/passes/techmap/abc.cc	/^	bool is_port;$/;"	m	struct:gate_t	typeref:typename:bool	file:
is_recursive_function	yosys/frontends/ast/simplify.cc	/^bool AstNode::is_recursive_function() const$/;"	f	class:AstNode	typeref:typename:bool
is_reg	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
is_reg	yosys/kernel/fstdata.h	/^	bool is_reg;$/;"	m	struct:FstVar	typeref:typename:bool
is_reg_wire	yosys/backends/verilog/verilog_backend.cc	/^bool is_reg_wire(RTLIL::SigSpec sig, std::string &reg_name)$/;"	f	typeref:typename:bool
is_shareable_pair	yosys/passes/opt/share.cc	/^	bool is_shareable_pair(RTLIL::Cell *c1, RTLIL::Cell *c2)$/;"	f	struct:ShareWorker	typeref:typename:bool	file:
is_signed	yosys/frontends/ast/ast.h	/^			bool is_signed;$/;"	m	struct:AST::AstNode::varinfo_t	typeref:typename:bool
is_signed	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
is_signed	yosys/kernel/macc.h	/^		bool is_signed, do_subtract;$/;"	m	struct:Macc::port_t	typeref:typename:bool
is_signed	yosys/kernel/rtlil.h	/^	bool port_input, port_output, upto, is_signed;$/;"	m	struct:RTLIL::Wire	typeref:typename:bool
is_signed	yosys/passes/cmds/connwrappers.cc	/^		bool is_signed;$/;"	m	struct:ConnwrappersWorker::portdecl_t	typeref:typename:bool	file:
is_signed	yosys/passes/opt/opt_share.cc	/^	bool is_signed;$/;"	m	struct:ExtSigSpec	typeref:typename:bool	file:
is_signed	yosys/passes/techmap/alumacc.cc	/^		bool is_signed, invert_b;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:bool	file:
is_simple_const_expr	yosys/frontends/ast/simplify.cc	/^bool AstNode::is_simple_const_expr()$/;"	f	class:AstNode	typeref:typename:bool
is_string	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
is_string	yosys/libs/json11/json11.hpp	/^    bool is_string() const { return type() == STRING; }$/;"	f	class:json11::Json	typeref:typename:bool
is_top_module	yosys/passes/cmds/glift.cc	/^	bool is_top_module = false;$/;"	m	struct:GliftWorker	typeref:typename:bool	file:
is_unary_cell	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_unary_cell(RTLIL::IdString type)$/;"	f	typeref:typename:bool
is_unconnected	yosys/passes/techmap/extract_counter.cc	/^bool is_unconnected(const RTLIL::SigSpec& port, ModIndex& index)$/;"	f	typeref:typename:bool
is_unsized	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
is_valid_clock	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^bool is_valid_clock(const RTLIL::SigSpec& sig) {$/;"	f	typeref:typename:bool
is_w2rbyp	yosys/passes/memory/memory_dff.cc	/^	bool is_w2rbyp(int widx, SigBit wen, SigBit sel, bool neg_sel) {$/;"	f	struct:MemQueryCache	typeref:typename:bool	file:
is_wand	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
is_wire	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::is_wire() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
is_wire	yosys/kernel/rtlil.h	/^	inline bool is_wire() const { return wire != NULL; }$/;"	f	struct:RTLIL::SigBit	typeref:typename:bool
is_wire	yosys/kernel/rtlil.h	/^	inline bool is_wire() const { return wire != NULL; }$/;"	f	struct:RTLIL::SigChunk	typeref:typename:bool
is_wor	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
is_zero	yosys/backends/cxxrtl/cxxrtl.h	/^	bool is_zero() const {$/;"	f	struct:cxxrtl::value	typeref:typename:bool
isatty	yosys/kernel/yosys.h	/^#    define isatty /;"	d
ise	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
it	yosys/kernel/rtlil.h	/^		typename dict<RTLIL::IdString, T>::iterator it;$/;"	m	struct:RTLIL::ObjIterator	typeref:typename:dict<RTLIL::IdString,T>::iterator
iterator	yosys/kernel/hashlib.h	/^		iterator() { }$/;"	f	class:hashlib::dict::iterator
iterator	yosys/kernel/hashlib.h	/^		iterator() { }$/;"	f	class:hashlib::pool::iterator
iterator	yosys/kernel/hashlib.h	/^		iterator(dict *ptr, int index) : ptr(ptr), index(index) { }$/;"	f	class:hashlib::dict::iterator
iterator	yosys/kernel/hashlib.h	/^		iterator(pool *ptr, int index) : ptr(ptr), index(index) { }$/;"	f	class:hashlib::pool::iterator
iterator	yosys/kernel/hashlib.h	/^	class iterator : public std::iterator<std::forward_iterator_tag, K>$/;"	c	class:hashlib::pool
iterator	yosys/kernel/hashlib.h	/^	class iterator : public std::iterator<std::forward_iterator_tag, std::pair<K, T>>$/;"	c	class:hashlib::dict
iterator_category	yosys/kernel/rtlil.h	/^		using iterator_category = std::forward_iterator_tag;$/;"	t	struct:RTLIL::ObjIterator	typeref:typename:std::forward_iterator_tag
j_hash	yosys/libs/fst/fstapi.cc	/^static uint32_t j_hash(const uint8_t *k, uint32_t length, uint32_t initval)$/;"	f	typeref:typename:uint32_t	file:
join_executable_and_args	yosys/misc/launcher.c	/^char* join_executable_and_args(char *executable, char **args, int argc)$/;"	f	typeref:typename:char *
json11	yosys/libs/json11/json11.cpp	/^namespace json11 {$/;"	n	file:
json11	yosys/libs/json11/json11.hpp	/^namespace json11 {$/;"	n
json_file	yosys/techlibs/anlogic/synth_anlogic.cc	/^	string top_opt, edif_file, json_file;$/;"	m	struct:SynthAnlogicPass	typeref:typename:string	file:
json_file	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^	string top_opt, json_file;$/;"	m	struct:SynthCoolrunner2Pass	typeref:typename:string	file:
json_file	yosys/techlibs/ecp5/synth_ecp5.cc	/^	string top_opt, blif_file, edif_file, json_file;$/;"	m	struct:SynthEcp5Pass	typeref:typename:string	file:
json_file	yosys/techlibs/efinix/synth_efinix.cc	/^	string top_opt, edif_file, json_file;$/;"	m	struct:SynthEfinixPass	typeref:typename:string	file:
json_file	yosys/techlibs/gatemate/synth_gatemate.cc	/^	string top_opt, vlog_file, json_file;$/;"	m	struct:SynthGateMatePass	typeref:typename:string	file:
json_file	yosys/techlibs/gowin/synth_gowin.cc	/^	string top_opt, vout_file, json_file;$/;"	m	struct:SynthGowinPass	typeref:typename:string	file:
json_file	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^	string top_opt, part, json_file;$/;"	m	struct:SynthGreenPAK4Pass	typeref:typename:string	file:
json_file	yosys/techlibs/ice40/synth_ice40.cc	/^	string top_opt, blif_file, edif_file, json_file, device_opt;$/;"	m	struct:SynthIce40Pass	typeref:typename:string	file:
json_file	yosys/techlibs/machxo2/synth_machxo2.cc	/^	string top_opt, blif_file, edif_file, json_file;$/;"	m	struct:SynthMachXO2Pass	typeref:typename:string	file:
json_file	yosys/techlibs/nexus/synth_nexus.cc	/^	string top_opt, json_file, vm_file, family;$/;"	m	struct:SynthNexusPass	typeref:typename:string	file:
json_file	yosys/techlibs/sf2/synth_sf2.cc	/^	string top_opt, edif_file, vlog_file, json_file;$/;"	m	struct:SynthSf2Pass	typeref:typename:string	file:
json_import	yosys/frontends/json/jsonparse.cc	/^void json_import(Design *design, string &modname, JsonNode *node)$/;"	f	typeref:typename:void
json_parse_attr_param	yosys/frontends/json/jsonparse.cc	/^void json_parse_attr_param(dict<IdString, Const> &results, JsonNode *node)$/;"	f	typeref:typename:void
json_parse_attr_param_value	yosys/frontends/json/jsonparse.cc	/^Const json_parse_attr_param_value(JsonNode *node)$/;"	f	typeref:typename:Const
keep_after	yosys/passes/techmap/shregmap.cc	/^	int keep_before, keep_after;$/;"	m	struct:ShregmapOptions	typeref:typename:int	file:
keep_before	yosys/passes/techmap/shregmap.cc	/^	int keep_before, keep_after;$/;"	m	struct:ShregmapOptions	typeref:typename:int	file:
keep_bits	yosys/passes/opt/wreduce.cc	/^	pool<SigBit> keep_bits;$/;"	m	struct:WreduceWorker	typeref:typename:pool<SigBit>	file:
keep_cache	yosys/passes/opt/opt_clean.cc	/^keep_cache_t keep_cache;$/;"	v	typeref:typename:keep_cache_t
keep_cache_t	yosys/passes/opt/opt_clean.cc	/^struct keep_cache_t$/;"	s	file:
keep_cnf	yosys/libs/ezsat/ezsat.h	/^	void keep_cnf() { flag_keep_cnf = true; }$/;"	f	class:ezSAT	typeref:typename:void
keepdc	yosys/passes/opt/opt_dff.cc	/^	bool keepdc;$/;"	m	struct:OptDffOptions	typeref:typename:bool	file:
keepdc	yosys/passes/opt/wreduce.cc	/^	bool keepdc = false;$/;"	m	struct:WreduceConfig	typeref:typename:bool	file:
kernel/log.o	yosys/Makefile	/^kernel\/log.o: CXXFLAGS += -DYOSYS_SRC='"$(YOSYS_SRC)"'$/;"	t
kernel/version_$(GIT_REV).cc	yosys/Makefile	/^kernel\/version_$(GIT_REV).cc: $(YOSYS_SRC)\/Makefile$/;"	t
kernel/yosys.o	yosys/Makefile	/^kernel\/yosys.o: CXXFLAGS += -DABCEXTERNAL='"$(ABCEXTERNAL)"'$/;"	t
kernel/yosys.o	yosys/Makefile	/^kernel\/yosys.o: CXXFLAGS += -DYOSYS_DATDIR='"$(DATDIR)"' -DYOSYS_PROGRAM_PREFIX='"$(PROGRAM_PRE/;"	t
key	yosys/libs/minisat/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair	typeref:typename:K
kiss_convert_signal	yosys/passes/fsm/fsm_export.cc	/^std::string kiss_convert_signal(const RTLIL::SigSpec &sig) {$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN std::string
knowledge_t	yosys/passes/opt/opt_muxtree.cc	/^	struct knowledge_t$/;"	s	struct:OptMuxtreeWorker	file:
known	yosys/kernel/rtlil.cc	/^bool RTLIL::Cell::known() const$/;"	f	class:RTLIL::Cell	typeref:typename:bool
known_active	yosys/passes/opt/opt_muxtree.cc	/^		vector<int> known_active;$/;"	m	struct:OptMuxtreeWorker::knowledge_t	typeref:typename:vector<int>	file:
known_inactive	yosys/passes/opt/opt_muxtree.cc	/^		vector<int> known_inactive;$/;"	m	struct:OptMuxtreeWorker::knowledge_t	typeref:typename:vector<int>	file:
l	yosys/libs/minisat/Solver.h	/^        Lit      l;$/;"	m	struct:Minisat::Solver::ShrinkStackElem	typeref:typename:Lit
l_False	yosys/libs/minisat/SolverTypes.h	/^  #define l_False /;"	d
l_False	yosys/libs/minisat/SolverTypes.h	/^  const lbool l_False((uint8_t)1);$/;"	v	namespace:Minisat	typeref:typename:const lbool
l_True	yosys/libs/minisat/SolverTypes.h	/^  #define l_True /;"	d
l_True	yosys/libs/minisat/SolverTypes.h	/^  const lbool l_True ((uint8_t)0);$/;"	v	namespace:Minisat	typeref:typename:const lbool
l_Undef	yosys/libs/minisat/SolverTypes.h	/^  #define l_Undef /;"	d
l_Undef	yosys/libs/minisat/SolverTypes.h	/^  const lbool l_Undef((uint8_t)2);$/;"	v	namespace:Minisat	typeref:typename:const lbool
label	yosys/passes/techmap/flowmap.cc	/^	string label;$/;"	m	struct:GraphStyle	typeref:typename:string	file:
labelCounter	yosys/passes/cmds/scc.cc	/^	int labelCounter;$/;"	m	struct:SccWorker	typeref:typename:int	file:
label_genblks	yosys/frontends/ast/simplify.cc	/^void AstNode::label_genblks(std::set<std::string>& existing, int &counter)$/;"	f	class:AstNode	typeref:typename:void
label_nodes	yosys/passes/techmap/flowmap.cc	/^	void label_nodes()$/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
label_selections	yosys/passes/cmds/show.cc	/^	const std::vector<std::pair<std::string, RTLIL::Selection>> &label_selections;$/;"	m	struct:ShowWorker	typeref:typename:const std::vector<std::pair<std::string,RTLIL::Selection>> &	file:
labels	yosys/passes/memory/memory_bram.cc	/^	vector<string> labels;$/;"	m	struct:rules_t	typeref:typename:vector<string>	file:
labels	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, int> labels;$/;"	m	struct:FlowmapWorker	typeref:typename:dict<RTLIL::SigBit,int>	file:
last	yosys/libs/minisat/SolverTypes.h	/^    const Lit&   last        ()      const   { return data[header.size-1].lit; }$/;"	f	class:Minisat::Clause	typeref:typename:const Lit &
last	yosys/libs/minisat/Vec.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:Minisat::vec	typeref:typename:T &
last	yosys/libs/minisat/Vec.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:Minisat::vec	typeref:typename:const T &
last_column	yosys/frontends/ast/ast.h	/^		unsigned int first_column, last_column;$/;"	m	struct:AST::AstSrcLocType	typeref:typename:unsigned int
last_created_idx_	yosys/kernel/rtlil.cc	/^int RTLIL::IdString::last_created_idx_[8];$/;"	m	class:RTLIL::IdString	typeref:typename:int[8]
last_created_idx_	yosys/kernel/rtlil.h	/^		static int last_created_idx_[8];$/;"	m	struct:RTLIL::IdString	typeref:typename:int[8]
last_created_idx_ptr_	yosys/kernel/rtlil.cc	/^int RTLIL::IdString::last_created_idx_ptr_;$/;"	m	class:RTLIL::IdString	typeref:typename:int
last_created_idx_ptr_	yosys/kernel/rtlil.h	/^		static int last_created_idx_ptr_;$/;"	m	struct:RTLIL::IdString	typeref:typename:int
last_data	yosys/kernel/fstdata.h	/^	std::map<fstHandle, std::string> last_data;$/;"	m	class:FstData	typeref:typename:std::map<fstHandle,std::string>
last_here_document	yosys/kernel/register.cc	/^std::string Frontend::last_here_document;$/;"	m	class:Frontend	typeref:typename:std::string
last_here_document	yosys/kernel/register.h	/^	static std::string last_here_document;$/;"	m	struct:Frontend	typeref:typename:std::string
last_hi	yosys/passes/techmap/hilomap.cc	/^static RTLIL::SigBit last_hi, last_lo;$/;"	v	typeref:typename:RTLIL::SigBit	file:
last_line	yosys/frontends/ast/ast.h	/^		unsigned int first_line, last_line;$/;"	m	struct:AST::AstSrcLocType	typeref:typename:unsigned int
last_lo	yosys/passes/techmap/hilomap.cc	/^static RTLIL::SigBit last_hi, last_lo;$/;"	v	typeref:typename:RTLIL::SigBit	file:
last_time	yosys/kernel/fstdata.h	/^	uint64_t last_time;$/;"	m	class:FstData	typeref:typename:uint64_t
latches	yosys/frontends/aiger/aigerparse.h	/^    std::vector<RTLIL::Wire*> latches;$/;"	m	struct:AigerReader	typeref:typename:std::vector<RTLIL::Wire * >
lbool	yosys/libs/minisat/SolverTypes.h	/^    explicit lbool(bool x) : value(!x) { }$/;"	f	class:Minisat::lbool
lbool	yosys/libs/minisat/SolverTypes.h	/^    explicit lbool(uint8_t v) : value(v) { }$/;"	f	class:Minisat::lbool
lbool	yosys/libs/minisat/SolverTypes.h	/^    lbool()       : value(0) { }$/;"	f	class:Minisat::lbool
lbool	yosys/libs/minisat/SolverTypes.h	/^class lbool {$/;"	c	namespace:Minisat
le_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> le_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
le_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> le_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
lea	yosys/libs/minisat/Alloc.h	/^    T*       lea       (Ref r)       { assert(r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator	typeref:typename:T *
lea	yosys/libs/minisat/Alloc.h	/^    const T* lea       (Ref r) const { assert(r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator	typeref:typename:const T *
lea	yosys/libs/minisat/SolverTypes.h	/^    Clause*       lea       (CRef r)         { return (Clause*)ra.lea(r); }$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:Clause *
lea	yosys/libs/minisat/SolverTypes.h	/^    const Clause* lea       (CRef r) const   { return (Clause*)ra.lea(r);; }$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:const Clause *
learnt	yosys/libs/minisat/SolverTypes.h	/^        unsigned learnt    : 1;$/;"	m	struct:Minisat::Clause::__anonb7535e3e0108	typeref:typename:unsigned:1
learnt	yosys/libs/minisat/SolverTypes.h	/^    bool         learnt      ()      const   { return header.learnt; }$/;"	f	class:Minisat::Clause	typeref:typename:bool
learnts	yosys/libs/minisat/Solver.h	/^    vec<CRef>           learnts;          \/\/ List of learnt clauses.$/;"	m	class:Minisat::Solver	typeref:typename:vec<CRef>
learnts_literals	yosys/libs/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literal/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
learntsize_adjust_cnt	yosys/libs/minisat/Solver.h	/^    int                 learntsize_adjust_cnt;$/;"	m	class:Minisat::Solver	typeref:typename:int
learntsize_adjust_confl	yosys/libs/minisat/Solver.h	/^    double              learntsize_adjust_confl;$/;"	m	class:Minisat::Solver	typeref:typename:double
learntsize_adjust_inc	yosys/libs/minisat/Solver.h	/^    double    learntsize_adjust_inc;$/;"	m	class:Minisat::Solver	typeref:typename:double
learntsize_adjust_start_confl	yosys/libs/minisat/Solver.h	/^    int       learntsize_adjust_start_confl;$/;"	m	class:Minisat::Solver	typeref:typename:int
learntsize_factor	yosys/libs/minisat/Solver.h	/^    double    learntsize_factor;  \/\/ The intitial limit for learnt clauses is a factor of the /;"	m	class:Minisat::Solver	typeref:typename:double
learntsize_inc	yosys/libs/minisat/Solver.h	/^    double    learntsize_inc;     \/\/ The limit for learnt clauses is multiplied with this fact/;"	m	class:Minisat::Solver	typeref:typename:double
left	yosys/libs/minisat/Heap.h	/^    static inline int left  (int i) { return i*2+1; }$/;"	f	class:Minisat::Heap	typeref:typename:int
left_parent	yosys/kernel/cellaigs.h	/^	int left_parent, right_parent;$/;"	m	struct:AigNode	typeref:typename:int
legalize_adff	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_adff(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_adlatch	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_adlatch(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_aldff	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_aldff(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_dff	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_dff(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_dffsr	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_dffsr(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_dlatch	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_dlatch(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_dlatchsr	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_dlatchsr(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_ff	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_ff(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_finish	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_finish(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_rlatch	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_rlatch(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_sdff	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_sdff(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_sdffce	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_sdffce(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
legalize_sr	yosys/passes/techmap/dfflegalize.cc	/^	void legalize_sr(FfData &ff) {$/;"	f	struct:DffLegalizePass	typeref:typename:void	file:
len	yosys/libs/bigint/NumberlikeArray.hh	/^	Index len;$/;"	m	class:NumberlikeArray	typeref:typename:Index
len	yosys/libs/fst/fstapi.cc	/^    int len;$/;"	m	struct:fstCurrHier	typeref:typename:int	file:
length	yosys/libs/fst/fstapi.cc	/^    uint32_t fullhash, length;$/;"	m	struct:collchain_t	typeref:typename:uint32_t	file:
length	yosys/libs/fst/fstapi.h	/^            uint32_t length;$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierVar	typeref:typename:uint32_t
less	yosys/libs/bigint/BigInteger.hh	/^		less    = BigUnsigned::less   ,$/;"	m	class:BigInteger	typeref:typename:const CmpRes
less	yosys/libs/bigint/BigUnsigned.hh	/^	enum CmpRes { less = -1, equal = 0, greater = 1 };$/;"	e	enum:BigUnsigned::CmpRes
less	yosys/libs/json11/json11.cpp	/^    bool less(const JsonValue * other)   const override { return m_value <  other->number_value(/;"	f	class:json11::JsonDouble	typeref:typename:bool	file:
less	yosys/libs/json11/json11.cpp	/^    bool less(const JsonValue * other)   const override { return m_value <  other->number_value(/;"	f	class:json11::JsonInt	typeref:typename:bool	file:
less	yosys/libs/json11/json11.cpp	/^    bool less(const JsonValue * other) const override {$/;"	f	class:json11::Value	typeref:typename:bool	file:
level	yosys/libs/minisat/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::Solver::VarData	typeref:typename:int
level	yosys/libs/minisat/Solver.h	/^inline int  Solver::level (Var x) const { return vardata[x].level; }$/;"	f	class:Minisat::Solver	typeref:typename:int
lexer	yosys/passes/techmap/libparse.cc	/^int LibertyParser::lexer(std::string &str)$/;"	f	class:LibertyParser	typeref:typename:int
lfsr_num	yosys/libs/ezsat/ezsat.cc	/^static int lfsr_num(int vec, int poly, int cnt = 1)$/;"	f	typeref:typename:int	file:
lfsr_sym	yosys/libs/ezsat/ezsat.cc	/^static std::vector<int> lfsr_sym(ezSAT *that, const std::vector<int> &vec, int poly)$/;"	f	typeref:typename:std::vector<int>	file:
lib	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
library	yosys/libs/bigint/Makefile	/^library: $(library-objects)$/;"	t
library-headers	yosys/libs/bigint/Makefile	/^library-headers = \\$/;"	m
library-objects	yosys/libs/bigint/Makefile	/^library-objects = \\$/;"	m
libyosys.so	yosys/Makefile	/^libyosys.so: $(filter-out kernel\/driver.o,$(OBJS))$/;"	t
likely	yosys/libs/fst/lz4.cc	/^#define likely(/;"	d	file:
limit	yosys/passes/opt/share.cc	/^	int limit;$/;"	m	struct:ShareWorker	typeref:typename:int	file:
limit	yosys/passes/opt/share.cc	/^	int limit;$/;"	m	struct:ShareWorkerConfig	typeref:typename:int	file:
limitMemory	yosys/libs/minisat/System.cc	/^void Minisat::limitMemory(uint64_t \/*max_mem_mb*\/)$/;"	f	class:Minisat	typeref:typename:void
limitMemory	yosys/libs/minisat/System.cc	/^void Minisat::limitMemory(uint64_t max_mem_mb)$/;"	f	class:Minisat	typeref:typename:void
limitTime	yosys/libs/minisat/System.cc	/^void Minisat::limitTime(uint32_t \/*max_cpu_time*\/)$/;"	f	class:Minisat	typeref:typename:void
limitTime	yosys/libs/minisat/System.cc	/^void Minisat::limitTime(uint32_t max_cpu_time)$/;"	f	class:Minisat	typeref:typename:void
limit_range_end	yosys/libs/fst/fstapi.cc	/^    uint64_t limit_range_start, limit_range_end;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
limit_range_start	yosys/libs/fst/fstapi.cc	/^    uint64_t limit_range_start, limit_range_end;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
limit_range_valid	yosys/libs/fst/fstapi.cc	/^    unsigned limit_range_valid : 1;            \/* valid for limit_range_start, limit_range_end /;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
limit_transitions	yosys/passes/fsm/fsm_expand.cc	/^	int limit_transitions;$/;"	m	struct:FsmExpand	typeref:typename:int	file:
limitedOutput	yosys/libs/fst/lz4.cc	/^    limitedOutput = 1$/;"	e	enum:__anon9390dffe0303	file:
limitedOutput_directive	yosys/libs/fst/lz4.cc	/^} limitedOutput_directive;$/;"	t	typeref:enum:__anon9390dffe0303	file:
line	yosys/kernel/log.h	/^	int line, counter;$/;"	m	struct:CoverData	typeref:typename:int
line	yosys/manual/CHAPTER_StateOfTheArt/cmp_tbdata.c	/^int line = 0;$/;"	v	typeref:typename:int
line	yosys/passes/techmap/libparse.h	/^		int line;$/;"	m	struct:Yosys::LibertyParser	typeref:typename:int
line	yosys/tests/tools/cmp_tbdata.c	/^int line = 0;$/;"	v	typeref:typename:int
line_count	yosys/frontends/aiger/aigerparse.h	/^    unsigned line_count;$/;"	m	struct:AigerReader	typeref:typename:unsigned
linebuf	yosys/passes/techmap/abc.cc	/^	std::string linebuf;$/;"	m	struct:abc_output_filter	typeref:typename:std::string	file:
linebuf	yosys/passes/techmap/abc9_exe.cc	/^	std::string linebuf;$/;"	m	struct:abc9_output_filter	typeref:typename:std::string	file:
linecount	yosys/passes/memory/memory_bram.cc	/^	int linecount;$/;"	m	struct:rules_t	typeref:typename:int	file:
link	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		void link(Vertex *list)$/;"	f	struct:Scheduler::Vertex	typeref:typename:void	file:
links	yosys/frontends/verific/verificsva.cc	/^	vector<pair<int, SigBit>> edges, links;$/;"	m	struct:SvaNFsmNode	typeref:typename:vector<pair<int,SigBit>>	file:
list_p	yosys/kernel/rtlil.h	/^		dict<RTLIL::IdString, T> *list_p;$/;"	m	struct:RTLIL::ObjIterator	typeref:typename:dict<RTLIL::IdString,T> *
list_p	yosys/kernel/rtlil.h	/^		dict<RTLIL::IdString, T> *list_p;$/;"	m	struct:RTLIL::ObjRange	typeref:typename:dict<RTLIL::IdString,T> *
lit	yosys/libs/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anonb7535e3e020a	typeref:typename:Lit
litRedundant	yosys/libs/minisat/Solver.cc	/^bool Solver::litRedundant(Lit p)$/;"	f	class:Solver	typeref:typename:bool
lit_Error	yosys/libs/minisat/SolverTypes.h	/^const Lit lit_Error = { -1 };  \/\/ }$/;"	v	namespace:Minisat	typeref:typename:const Lit
lit_Undef	yosys/libs/minisat/SolverTypes.h	/^const Lit lit_Undef = { -2 };  \/\/ }- Useful special constants.$/;"	v	namespace:Minisat	typeref:typename:const Lit
literal	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::literal()$/;"	f	class:ezSAT	typeref:typename:int
literal	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::literal(const std::string &name)$/;"	f	class:ezSAT	typeref:typename:int
literal_arr	yosys/libs/fst/fstapi.h	/^    char **literal_arr;$/;"	m	struct:fstETab	typeref:typename:char **
literals	yosys/libs/ezsat/ezsat.h	/^	std::vector<std::string> literals;$/;"	m	class:ezSAT	typeref:typename:std::vector<std::string>
literalsCache	yosys/libs/ezsat/ezsat.h	/^	std::map<std::string, int> literalsCache;$/;"	m	class:ezSAT	typeref:typename:std::map<std::string,int>
lits	yosys/libs/minisat/SolverTypes.h	/^    const Lit* lits;$/;"	m	class:Minisat::TrailIterator	typeref:typename:const Lit *
liveness	yosys/backends/aiger/aiger.cc	/^	vector<pair<SigBit, SigBit>> liveness, fairness;$/;"	m	struct:AigerWriter	typeref:typename:vector<pair<SigBit,SigBit>>	file:
load_module	yosys/passes/cmds/qwp.cc	/^	void load_module()$/;"	f	struct:QwpWorker	typeref:typename:void	file:
load_plugin	yosys/passes/cmds/plugin.cc	/^void load_plugin(std::string filename, std::vector<std::string> aliases)$/;"	f	typeref:typename:void
load_plugin	yosys/passes/cmds/plugin.cc	/^void load_plugin(std::string, std::vector<std::string>)$/;"	f	typeref:typename:void
loadable_exe	yosys/misc/launcher.c	/^char *loadable_exe(char *exename) {$/;"	f	typeref:typename:char *
loadconfig	yosys/frontends/ast/ast.cc	/^void AstModule::loadconfig() const$/;"	f	class:AstModule	typeref:typename:void
loaded_plugin_aliases	yosys/passes/cmds/plugin.cc	/^std::map<std::string, std::string> loaded_plugin_aliases;$/;"	v	typeref:typename:std::map<std::string,std::string>
loaded_plugins	yosys/passes/cmds/plugin.cc	/^std::map<std::string, void*> loaded_plugins;$/;"	v	typeref:typename:YOSYS_NAMESPACE_BEGIN std::map<std::string,void * >
loaded_python_plugins	yosys/passes/cmds/plugin.cc	/^std::map<std::string, void*> loaded_python_plugins;$/;"	v	typeref:typename:std::map<std::string,void * >
loc_string	yosys/frontends/ast/ast.cc	/^std::string AstNode::loc_string() const$/;"	f	class:AstNode	typeref:typename:std::string
localize_internal	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool localize_internal = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
localize_public	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool localize_public = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
location	yosys/frontends/ast/ast.h	/^		AstSrcLocType location;$/;"	m	struct:AST::AstNode	typeref:typename:AstSrcLocType
locell_celltype	yosys/passes/techmap/hilomap.cc	/^static std::string locell_celltype, locell_portname;$/;"	v	typeref:typename:std::string	file:
locell_portname	yosys/passes/techmap/hilomap.cc	/^static std::string locell_celltype, locell_portname;$/;"	v	typeref:typename:std::string	file:
locked	yosys/libs/minisat/Solver.h	/^inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True &/;"	f	class:Minisat::Solver	typeref:typename:bool
log	yosys/frontends/verilog/preproc.cc	/^void define_map_t::log() const$/;"	f	class:define_map_t	typeref:typename:void
log	yosys/kernel/log.cc	/^void log(const char *format, ...)$/;"	f	typeref:typename:void
log_abort	yosys/kernel/log.h	/^#define log_abort(/;"	d
log_assert	yosys/kernel/log.h	/^#  define log_assert(/;"	d
log_assert_worker	yosys/kernel/log.h	/^static inline void log_assert_worker(bool cond, const char *expr, const char *file, int line) {$/;"	f	typeref:typename:void
log_attrmap_paramap_options	yosys/passes/techmap/attrmap.cc	/^void log_attrmap_paramap_options()$/;"	f	typeref:typename:void
log_backtrace	yosys/kernel/log.cc	/^void log_backtrace(const char *prefix, int levels)$/;"	f	typeref:typename:void
log_backtrace	yosys/kernel/log.cc	/^void log_backtrace(const char*, int) { }$/;"	f	typeref:typename:void
log_cell	yosys/kernel/log.cc	/^void log_cell(RTLIL::Cell *cell, std::string indent)$/;"	f	typeref:typename:void
log_cell_coordinates	yosys/passes/cmds/qwp.cc	/^	void log_cell_coordinates(int indent, bool log_all_nodes = false)$/;"	f	struct:QwpWorker	typeref:typename:void	file:
log_check_expected	yosys/kernel/log.cc	/^void log_check_expected()$/;"	f	typeref:typename:void
log_cmd_error	yosys/kernel/log.cc	/^void log_cmd_error(const char *format, ...)$/;"	f	typeref:typename:void
log_cmd_error_exception	yosys/kernel/log.h	/^struct log_cmd_error_exception { };$/;"	s
log_cmd_error_throw	yosys/kernel/log.cc	/^bool log_cmd_error_throw = false;$/;"	v	typeref:typename:bool
log_const	yosys/kernel/log.cc	/^const char *log_const(const RTLIL::Const &value, bool autoint)$/;"	f	typeref:typename:const char *
log_const	yosys/passes/cmds/printattrs.cc	/^	static void log_const(const RTLIL::IdString &s, const RTLIL::Const &x, const unsigned int inden/;"	f	struct:PrintAttrsPass	typeref:typename:void	file:
log_data	yosys/passes/cmds/stat.cc	/^	void log_data(RTLIL::IdString mod_name, bool top_mod)$/;"	f	struct:statdata_t	typeref:typename:void	file:
log_debug	yosys/kernel/log.h	/^#  define log_debug(/;"	d
log_debug2	yosys/frontends/aiger/aigerparse.cc	/^#define log_debug2(/;"	d	file:
log_debug_suppressed	yosys/kernel/log.cc	/^int log_debug_suppressed = 0;$/;"	v	typeref:typename:int
log_dump	yosys/kernel/log.h	/^#define log_dump(/;"	d
log_dump_args_worker	yosys/kernel/log.h	/^static inline void log_dump_args_worker(const char *p) { log_assert(*p == 0); }$/;"	f	typeref:typename:void
log_dump_args_worker	yosys/kernel/log.h	/^void log_dump_args_worker(const char *p, T first, Args ... args)$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.cc	/^void log_dump_val_worker(RTLIL::IdString v) {$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.cc	/^void log_dump_val_worker(RTLIL::SigSpec v) {$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.cc	/^void log_dump_val_worker(RTLIL::State v) {$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(PerformanceTimer p) { log("%f seconds", p.sec()); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(T *ptr) { log("%p", ptr); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(bool v) { log("%s", v ? "true" : "false"); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(char *v) { log("%s", v); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(char c) { log(c >= 32 && c < 127 ? "'%c'" : "'\\\\x%02x'"/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(const char *v) { log("%s", v); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(dict<K, T, OPS> &v) {$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(double v) { log("%f", v); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(int v) { log("%d", v); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(long int v) { log("%ld", v); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(long long int v) { log("%lld", v); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(pool<K, OPS> &v) {$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(short v) { log("%d", v); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(std::string v) { log("%s", v.c_str()); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(unsigned char c) { log(c >= 32 && c < 127 ? "'%c'" : "'\\/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(unsigned int v) { log("%u", v); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(unsigned long int v) { log("%lu", v); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(unsigned long long int v) { log("%lld", v); }$/;"	f	typeref:typename:void
log_dump_val_worker	yosys/kernel/log.h	/^static inline void log_dump_val_worker(unsigned short v) { log("%u", v); }$/;"	f	typeref:typename:void
log_errfile	yosys/kernel/log.cc	/^FILE *log_errfile = NULL;$/;"	v	typeref:typename:FILE *
log_error	yosys/kernel/log.cc	/^void log_error(const char *format, ...)$/;"	f	typeref:typename:void
log_error_atexit	yosys/kernel/log.cc	/^void (*log_error_atexit)() = NULL;$/;"	v	typeref:typename:void (*)()
log_error_stderr	yosys/kernel/log.cc	/^bool log_error_stderr = false;$/;"	v	typeref:typename:bool
log_expect_error	yosys/kernel/log.cc	/^dict<std::string, LogExpectedItem> log_expect_log, log_expect_warning, log_expect_error;$/;"	v	typeref:typename:dict<std::string,LogExpectedItem>
log_expect_log	yosys/kernel/log.cc	/^dict<std::string, LogExpectedItem> log_expect_log, log_expect_warning, log_expect_error;$/;"	v	typeref:typename:dict<std::string,LogExpectedItem>
log_expect_no_warnings	yosys/kernel/log.cc	/^bool log_expect_no_warnings = false;$/;"	v	typeref:typename:bool
log_expect_warning	yosys/kernel/log.cc	/^dict<std::string, LogExpectedItem> log_expect_log, log_expect_warning, log_expect_error;$/;"	v	typeref:typename:dict<std::string,LogExpectedItem>
log_experimental	yosys/kernel/log.cc	/^void log_experimental(const char *format, ...)$/;"	f	typeref:typename:void
log_experimentals	yosys/kernel/log.cc	/^std::set<std::string> log_warnings, log_experimentals, log_experimentals_ignored;$/;"	v	typeref:typename:std::set<std::string>
log_experimentals_ignored	yosys/kernel/log.cc	/^std::set<std::string> log_warnings, log_experimentals, log_experimentals_ignored;$/;"	v	typeref:typename:std::set<std::string>
log_file_error	yosys/kernel/log.cc	/^void log_file_error(const string &filename, int lineno,$/;"	f	typeref:typename:void
log_file_info	yosys/kernel/log.cc	/^void log_file_info(const std::string &filename, int lineno,$/;"	f	typeref:typename:void
log_file_warning	yosys/kernel/log.cc	/^void log_file_warning(const std::string &filename, int lineno,$/;"	f	typeref:typename:void
log_files	yosys/kernel/log.cc	/^std::vector<FILE*> log_files;$/;"	v	typeref:typename:YOSYS_NAMESPACE_BEGIN std::vector<FILE * >
log_flush	yosys/kernel/log.cc	/^void log_flush()$/;"	f	typeref:typename:void
log_force_debug	yosys/kernel/log.cc	/^int log_force_debug = 0;$/;"	v	typeref:typename:int
log_hasher	yosys/kernel/log.cc	/^SHA1 *log_hasher = NULL;$/;"	v	typeref:typename:SHA1 *
log_hdump	yosys/kernel/log.cc	/^std::map<std::string, std::set<std::string>> log_hdump;$/;"	v	typeref:typename:std::map<std::string,std::set<std::string>>
log_hdump_all	yosys/kernel/log.cc	/^bool log_hdump_all = false;$/;"	v	typeref:typename:bool
log_header	yosys/kernel/log.cc	/^void log_header(RTLIL::Design *design, const char *format, ...)$/;"	f	typeref:typename:void
log_id	yosys/kernel/log.cc	/^const char *log_id(RTLIL::IdString str)$/;"	f	typeref:typename:const char *
log_id	yosys/kernel/log.h	/^template<typename T> static inline const char *log_id(T *obj, const char *nullstr = nullptr) {$/;"	f	typeref:typename:const char *
log_id_cache	yosys/kernel/log.cc	/^vector<char*> log_id_cache;$/;"	v	typeref:typename:vector<char * >
log_id_cache_clear	yosys/kernel/log.cc	/^static void log_id_cache_clear()$/;"	f	typeref:typename:void	file:
log_info	yosys/passes/fsm/fsmdata.h	/^	void log_info(RTLIL::Cell *cell)$/;"	f	struct:FsmData	typeref:typename:void
log_last_error	yosys/kernel/log.cc	/^string log_last_error;$/;"	v	typeref:typename:string
log_make_debug	yosys/kernel/log.cc	/^int log_make_debug = 0;$/;"	v	typeref:typename:int
log_matches	yosys/passes/cmds/select.cc	/^static void log_matches(const char *title, Module *module, const T &list)$/;"	f	typeref:typename:void	file:
log_module	yosys/kernel/log.cc	/^void log_module(RTLIL::Module *module, std::string indent)$/;"	f	typeref:typename:void
log_msg_cache	yosys/passes/techmap/techmap.cc	/^	pool<string> log_msg_cache;$/;"	m	struct:TechmapWorker	typeref:typename:pool<string>	file:
log_newline_count	yosys/kernel/log.cc	/^static int log_newline_count = 0;$/;"	v	typeref:typename:int	file:
log_nowarn_regexes	yosys/kernel/log.cc	/^std::vector<YS_REGEX_TYPE> log_warn_regexes, log_nowarn_regexes, log_werror_regexes;$/;"	v	typeref:typename:std::vector<YS_REGEX_TYPE>
log_ping	yosys/kernel/log.h	/^#define log_ping(/;"	d
log_pop	yosys/kernel/log.cc	/^void log_pop()$/;"	f	typeref:typename:void
log_prefix	yosys/backends/simplec/simplec.cc	/^	string prefix, log_prefix;$/;"	m	struct:HierDirtyFlags	typeref:typename:string	file:
log_push	yosys/kernel/log.cc	/^void log_push()$/;"	f	typeref:typename:void
log_quiet_warnings	yosys/kernel/log.cc	/^bool log_quiet_warnings = false;$/;"	v	typeref:typename:bool
log_reset_stack	yosys/kernel/log.cc	/^void log_reset_stack()$/;"	f	typeref:typename:void
log_signal	yosys/kernel/log.cc	/^const char *log_signal(const RTLIL::SigSpec &sig, bool autoint)$/;"	f	typeref:typename:const char *
log_spacer	yosys/kernel/log.cc	/^void log_spacer()$/;"	f	typeref:typename:void
log_streams	yosys/kernel/log.cc	/^std::vector<std::ostream*> log_streams;$/;"	v	typeref:typename:std::vector<std::ostream * >
log_suppressed	yosys/kernel/log.h	/^static inline void log_suppressed() {$/;"	f	typeref:typename:void
log_time	yosys/kernel/log.cc	/^bool log_time = false;$/;"	v	typeref:typename:bool
log_verbose_level	yosys/kernel/log.cc	/^int log_verbose_level;$/;"	v	typeref:typename:int
log_warn_regexes	yosys/kernel/log.cc	/^std::vector<YS_REGEX_TYPE> log_warn_regexes, log_nowarn_regexes, log_werror_regexes;$/;"	v	typeref:typename:std::vector<YS_REGEX_TYPE>
log_warning	yosys/kernel/log.cc	/^void log_warning(const char *format, ...)$/;"	f	typeref:typename:void
log_warning_noprefix	yosys/kernel/log.cc	/^void log_warning_noprefix(const char *format, ...)$/;"	f	typeref:typename:void
log_warnings	yosys/kernel/log.cc	/^std::set<std::string> log_warnings, log_experimentals, log_experimentals_ignored;$/;"	v	typeref:typename:std::set<std::string>
log_warnings_count	yosys/kernel/log.cc	/^int log_warnings_count = 0;$/;"	v	typeref:typename:int
log_warnings_count_noexpect	yosys/kernel/log.cc	/^int log_warnings_count_noexpect = 0;$/;"	v	typeref:typename:int
log_werror_regexes	yosys/kernel/log.cc	/^std::vector<YS_REGEX_TYPE> log_warn_regexes, log_nowarn_regexes, log_werror_regexes;$/;"	v	typeref:typename:std::vector<YS_REGEX_TYPE>
log_wire	yosys/kernel/log.cc	/^void log_wire(RTLIL::Wire *wire, std::string indent)$/;"	f	typeref:typename:void
logic_and	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> logic_and(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
logic_and	yosys/kernel/calc.cc	/^static RTLIL::State logic_and(RTLIL::State a, RTLIL::State b)$/;"	f	typeref:typename:RTLIL::State	file:
logic_mode	yosys/passes/techmap/tribuf.cc	/^	bool logic_mode;$/;"	m	struct:TribufConfig	typeref:typename:bool	file:
logic_not	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> logic_not(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
logic_or	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> logic_or(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
logic_or	yosys/kernel/calc.cc	/^static RTLIL::State logic_or(RTLIL::State a, RTLIL::State b)$/;"	f	typeref:typename:RTLIL::State	file:
logic_reduce	yosys/passes/techmap/simplemap.cc	/^static void logic_reduce(RTLIL::Module *module, RTLIL::SigSpec &sig, RTLIL::Cell *cell)$/;"	f	typeref:typename:void	file:
logic_reduce_wrapper	yosys/kernel/calc.cc	/^static RTLIL::Const logic_reduce_wrapper(RTLIL::State initial, RTLIL::State(*logic_func)(RTLIL::/;"	f	typeref:typename:RTLIL::Const	file:
logic_wrapper	yosys/kernel/calc.cc	/^static RTLIL::Const logic_wrapper(RTLIL::State(*logic_func)(RTLIL::State, RTLIL::State),$/;"	f	typeref:typename:RTLIL::Const	file:
logic_xnor	yosys/kernel/calc.cc	/^static RTLIL::State logic_xnor(RTLIL::State a, RTLIL::State b)$/;"	f	typeref:typename:RTLIL::State	file:
logic_xor	yosys/kernel/calc.cc	/^static RTLIL::State logic_xor(RTLIL::State a, RTLIL::State b)$/;"	f	typeref:typename:RTLIL::State	file:
logmap	yosys/passes/techmap/dfflibmap.cc	/^static void logmap(IdString dff)$/;"	f	typeref:typename:void	file:
logmap_all	yosys/passes/techmap/dfflibmap.cc	/^static void logmap_all()$/;"	f	typeref:typename:void	file:
logv	yosys/kernel/log.cc	/^void logv(const char *format, va_list ap)$/;"	f	typeref:typename:void
logv_error	yosys/kernel/log.cc	/^void logv_error(const char *format, va_list ap)$/;"	f	typeref:typename:void
logv_error_with_prefix	yosys/kernel/log.cc	/^static void logv_error_with_prefix(const char *prefix,$/;"	f	typeref:typename:void	file:
logv_header	yosys/kernel/log.cc	/^void logv_header(RTLIL::Design *design, const char *format, va_list ap)$/;"	f	typeref:typename:void
logv_warning	yosys/kernel/log.cc	/^void logv_warning(const char *format, va_list ap)$/;"	f	typeref:typename:void
logv_warning_noprefix	yosys/kernel/log.cc	/^void logv_warning_noprefix(const char *format, va_list ap)$/;"	f	typeref:typename:void
logv_warning_with_prefix	yosys/kernel/log.cc	/^static void logv_warning_with_prefix(const char *prefix,$/;"	f	typeref:typename:void	file:
longest_signal_value_len	yosys/libs/fst/fstapi.cc	/^    uint32_t longest_signal_value_len;    \/* longest len value encountered *\/$/;"	m	struct:fstReaderContext	typeref:typename:uint32_t	file:
lookahead	yosys/frontends/ast/ast.h	/^		bool lookahead;$/;"	m	struct:AST::AstNode	typeref:typename:bool
lookaheadids	yosys/frontends/ast/genrtlil.cc	/^	dict<IdString, pair<AstNode*, AstNode*>> lookaheadids;$/;"	m	struct:AST_INTERNAL::LookaheadRewriter	typeref:typename:dict<IdString,pair<AstNode *,AstNode * >>	file:
lookup	yosys/kernel/hashlib.h	/^	int lookup(const K &a) const$/;"	f	class:hashlib::mfp	typeref:typename:int
lookup	yosys/libs/minisat/SolverTypes.h	/^    Vec&  lookup    (const K& idx){ if (dirty[idx]) clean(idx); return occs[idx]; }$/;"	f	class:Minisat::OccLists	typeref:typename:Vec &
lookup_cell_module	yosys/frontends/ast/simplify.cc	/^const RTLIL::Module* AstNode::lookup_cell_module()$/;"	f	class:AstNode	typeref:typename:const RTLIL::Module *
lookup_expression	yosys/libs/ezsat/ezsat.cc	/^const std::vector<int> &ezSAT::lookup_expression(int id, OpId &op) const$/;"	f	class:ezSAT	typeref:typename:const std::vector<int> &
lookup_expression	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::lookup_expression(int id, OpId &op, std::vector<int> &args) const$/;"	f	class:ezSAT	typeref:typename:void
lookup_literal	yosys/libs/ezsat/ezsat.cc	/^const std::string &ezSAT::lookup_literal(int id) const$/;"	f	class:ezSAT	typeref:typename:const std::string &
lookup_literal	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::lookup_literal(int id, std::string &name) const$/;"	f	class:ezSAT	typeref:typename:void
lookup_module	yosys/frontends/ast/simplify.cc	/^static const RTLIL::Module* lookup_module(const std::string &name)$/;"	f	typeref:typename:const RTLIL::Module *	file:
loops	yosys/kernel/utils.h	/^	std::set<std::set<T, C>> loops;$/;"	m	struct:TopoSort	typeref:typename:std::set<std::set<T,C>>
ls_expr	yosys/backends/cxxrtl/cxxrtl.h	/^	U &ls_expr;$/;"	m	struct:cxxrtl::concat_expr	typeref:typename:U &
lsb_at	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	size_t lsb_at;$/;"	m	struct:cxxrtl_object	typeref:typename:size_t
lseek	yosys/libs/fst/fstapi.h	/^#define lseek /;"	d
lt	yosys/libs/minisat/Heap.h	/^    Comp                  lt;       \/\/ The heap is a minimum-heap with respect to this compara/;"	m	class:Minisat::Heap	typeref:typename:Comp
lt_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> lt_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
lt_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> lt_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
ltr	yosys/passes/cmds/qwp.cc	/^	bool ltr;$/;"	m	struct:QwpConfig	typeref:typename:bool	file:
luby	yosys/libs/minisat/Solver.cc	/^static double luby(double y, int x){$/;"	f	typeref:typename:double	file:
luby_restart	yosys/libs/minisat/Solver.h	/^    bool      luby_restart;$/;"	m	class:Minisat::Solver	typeref:typename:bool
lut	yosys/techlibs/common/synth.cc	/^	int lut;$/;"	m	struct:SynthPass	typeref:typename:int	file:
lut2mux	yosys/passes/techmap/lut2mux.cc	/^int lut2mux(Cell *cell)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN int
lut_altitudes	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, int> lut_depths, lut_altitudes, lut_slacks;$/;"	m	struct:FlowmapWorker	typeref:typename:dict<RTLIL::SigBit,int>	file:
lut_area	yosys/passes/techmap/flowmap.cc	/^	int gate_area = 0, lut_area = 0;$/;"	m	struct:FlowmapWorker	typeref:typename:int	file:
lut_count	yosys/passes/techmap/flowmap.cc	/^	int gate_count = 0, lut_count = 0, packed_count = 0;$/;"	m	struct:FlowmapWorker	typeref:typename:int	file:
lut_depths	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, int> lut_depths, lut_altitudes, lut_slacks;$/;"	m	struct:FlowmapWorker	typeref:typename:dict<RTLIL::SigBit,int>	file:
lut_edges_bw	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, pool<RTLIL::SigBit>> lut_edges_fw, lut_edges_bw;$/;"	m	struct:FlowmapWorker	typeref:typename:dict<RTLIL::SigBit,pool<RTLIL::SigBit>>	file:
lut_edges_fw	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, pool<RTLIL::SigBit>> lut_edges_fw, lut_edges_bw;$/;"	m	struct:FlowmapWorker	typeref:typename:dict<RTLIL::SigBit,pool<RTLIL::SigBit>>	file:
lut_gates	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, pool<RTLIL::SigBit>> lut_gates;$/;"	m	struct:FlowmapWorker	typeref:typename:dict<RTLIL::SigBit,pool<RTLIL::SigBit>>	file:
lut_input_port	yosys/passes/opt/opt_lut.cc	/^	dict<int, IdString> lut_input_port;$/;"	m	struct:dlogic_t	typeref:typename:dict<int,IdString>	file:
lut_mode	yosys/passes/techmap/abc9.cc	/^	bool lut_mode;$/;"	m	struct:Abc9Pass	typeref:typename:bool	file:
lut_nodes	yosys/passes/techmap/flowmap.cc	/^	pool<RTLIL::SigBit> lut_nodes;$/;"	m	struct:FlowmapWorker	typeref:typename:pool<RTLIL::SigBit>	file:
lut_size	yosys/techlibs/xilinx/synth_xilinx.cc	/^	int lut_size;$/;"	m	struct:SynthXilinxPass	typeref:typename:int	file:
lut_slacks	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, int> lut_depths, lut_altitudes, lut_slacks;$/;"	m	struct:FlowmapWorker	typeref:typename:dict<RTLIL::SigBit,int>	file:
luts	yosys/passes/opt/opt_lut.cc	/^	pool<RTLIL::Cell*> luts;$/;"	m	struct:OptLutWorker	typeref:typename:pool<RTLIL::Cell * >	file:
luts	yosys/passes/techmap/nlutmap.cc	/^	vector<int> luts;$/;"	m	struct:NlutmapConfig	typeref:typename:vector<int>	file:
luts_arity	yosys/passes/opt/opt_lut.cc	/^	dict<RTLIL::Cell*, int> luts_arity;$/;"	m	struct:OptLutWorker	typeref:typename:dict<RTLIL::Cell *,int>	file:
luts_dlogic_inputs	yosys/passes/opt/opt_lut.cc	/^	dict<RTLIL::Cell*, pool<int>> luts_dlogic_inputs;$/;"	m	struct:OptLutWorker	typeref:typename:dict<RTLIL::Cell *,pool<int>>	file:
luts_dlogics	yosys/passes/opt/opt_lut.cc	/^	dict<RTLIL::Cell*, pool<std::pair<int, RTLIL::Cell*>>> luts_dlogics;$/;"	m	struct:OptLutWorker	typeref:typename:dict<RTLIL::Cell *,pool<std::pair<int,RTLIL::Cell * >>>	file:
lvalue	yosys/backends/smv/smv.cc	/^	const char *lvalue(SigSpec sig)$/;"	f	struct:SmvWorker	typeref:typename:const char *	file:
m_ptr	yosys/libs/json11/json11.hpp	/^    std::shared_ptr<JsonValue> m_ptr;$/;"	m	class:json11::Json	typeref:typename:std::shared_ptr<JsonValue>
m_value	yosys/libs/json11/json11.cpp	/^    const T m_value;$/;"	m	class:json11::Value	typeref:typename:const T	file:
macc	yosys/passes/techmap/alumacc.cc	/^		Macc macc;$/;"	m	struct:AlumaccWorker::maccnode_t	typeref:typename:Macc	file:
macc_counter	yosys/passes/techmap/alumacc.cc	/^	int macc_counter, alu_counter;$/;"	m	struct:AlumaccWorker	typeref:typename:int	file:
macc_may_overflow	yosys/passes/techmap/alumacc.cc	/^	static bool macc_may_overflow(Macc &macc, int width, bool is_signed)$/;"	f	struct:AlumaccWorker	typeref:typename:bool	file:
macc_simple_xmap.pdf	yosys/manual/PRESENTATION_ExAdv/Makefile	/^macc_simple_xmap.pdf: macc_simple_*.v macc_simple_test.ys$/;"	t
macc_to_alu	yosys/passes/techmap/alumacc.cc	/^	void macc_to_alu()$/;"	f	struct:AlumaccWorker	typeref:typename:void	file:
macc_xilinx_xmap.pdf	yosys/manual/PRESENTATION_ExAdv/Makefile	/^macc_xilinx_xmap.pdf: macc_xilinx_*.v macc_xilinx_test.ys$/;"	t
maccmap	yosys/passes/techmap/maccmap.cc	/^void maccmap(RTLIL::Module *module, RTLIL::Cell *cell, bool unmap)$/;"	f	typeref:typename:void
maccnode_t	yosys/passes/techmap/alumacc.cc	/^	struct maccnode_t {$/;"	s	struct:AlumaccWorker	file:
macro_arg_stack_t	yosys/frontends/verilog/preproc.cc	/^using macro_arg_stack_t = std::stack<std::pair<std::string, define_body_t>>;$/;"	t	typeref:typename:std::stack<std::pair<std::string,define_body_t>>	file:
macro_arg_t	yosys/frontends/verilog/preproc.cc	/^	macro_arg_t(const std::string &name_, const char *default_value_)$/;"	f	struct:macro_arg_t	file:
macro_arg_t	yosys/frontends/verilog/preproc.cc	/^struct macro_arg_t$/;"	s	file:
mag	yosys/libs/bigint/BigInteger.hh	/^	BigUnsigned mag;$/;"	m	class:BigInteger	typeref:typename:BigUnsigned
magOf	yosys/libs/bigint/BigInteger.cc	/^	BigInteger::Blk magOf(X x) {$/;"	f	namespace:__anon944949140111	typeref:typename:BigInteger::Blk
main	yosys/backends/simplec/test00_tb.c	/^int main()$/;"	f	typeref:typename:int
main	yosys/examples/cxx-api/demomain.cc	/^int main()$/;"	f	typeref:typename:int
main	yosys/kernel/driver.cc	/^int main(int argc, char **argv)$/;"	f	typeref:typename:int
main	yosys/libs/bigint/sample.cc	/^int main() {$/;"	f	typeref:typename:int
main	yosys/libs/bigint/testsuite.cc	/^int main() {$/;"	f	typeref:typename:int
main	yosys/libs/ezsat/demo_bit.cc	/^int main()$/;"	f	typeref:typename:int
main	yosys/libs/ezsat/demo_cmp.cc	/^int main()$/;"	f	typeref:typename:int
main	yosys/libs/ezsat/demo_vec.cc	/^int main()$/;"	f	typeref:typename:int
main	yosys/libs/ezsat/puzzle3d.cc	/^int main()$/;"	f	typeref:typename:int
main	yosys/libs/ezsat/testbench.cc	/^int main()$/;"	f	typeref:typename:int
main	yosys/libs/subcircuit/demo.cc	/^int main()$/;"	f	typeref:typename:int
main	yosys/libs/subcircuit/scshell.cc	/^int main()$/;"	f	typeref:typename:int
main	yosys/manual/CHAPTER_StateOfTheArt/cmp_tbdata.c	/^int main(int argc, char **argv)$/;"	f	typeref:typename:int
main	yosys/misc/launcher.c	/^int main(int argc, char** argv) {$/;"	f	typeref:typename:int
main	yosys/passes/techmap/libparse.cc	/^int main(int argc, char **argv)$/;"	f	typeref:typename:int
main	yosys/tests/tools/cmp_tbdata.c	/^int main(int argc, char **argv)$/;"	f	typeref:typename:int
make_addr_check	yosys/passes/memory/memory_memx.cc	/^	SigSpec make_addr_check(Mem &mem, SigSpec addr) {$/;"	f	struct:MemoryMemxPass	typeref:typename:SigSpec	file:
make_cell_activation_logic	yosys/passes/opt/share.cc	/^	RTLIL::SigSpec make_cell_activation_logic(const pool<ssc_pair_t> &activation_patterns, pool<RTL/;"	f	struct:ShareWorker	typeref:typename:RTLIL::SigSpec	file:
make_cond_eq	yosys/frontends/verific/verificsva.cc	/^	SigBit make_cond_eq(const SigSpec &ctrl, const Const &value, SigBit enable = State::S1)$/;"	f	struct:SvaFsm	typeref:typename:SigBit	file:
make_eval_func	yosys/backends/simplec/simplec.cc	/^	void make_eval_func(HierDirtyFlags *work)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
make_expr	yosys/backends/firrtl/firrtl.cc	/^	static string make_expr(const SigSpec &sig)$/;"	f	struct:FirrtlWorker	typeref:typename:string	file:
make_func	yosys/backends/simplec/simplec.cc	/^	void make_func(HierDirtyFlags *work, const string &func_name, const vector<string> &preamble)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
make_hold	yosys/passes/proc/proc_dlatch.cc	/^	SigBit make_hold(int n, string &src)$/;"	f	struct:proc_dlatch_db_t	typeref:typename:SigBit	file:
make_id	yosys/backends/firrtl/firrtl.cc	/^const char *make_id(IdString id)$/;"	f	typeref:typename:const char *
make_init_func	yosys/backends/simplec/simplec.cc	/^	void make_init_func(HierDirtyFlags *work)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
make_inner	yosys/passes/proc/proc_dlatch.cc	/^	int make_inner(SigBit signal, SigBit match, int child)$/;"	f	struct:proc_dlatch_db_t	typeref:typename:int	file:
make_inner	yosys/passes/proc/proc_dlatch.cc	/^	int make_inner(const pool<int> &children)$/;"	f	struct:proc_dlatch_db_t	typeref:typename:int	file:
make_input	yosys/passes/equiv/equiv_purge.cc	/^	SigSpec make_input(SigSpec sig)$/;"	f	struct:EquivPurgeWorker	typeref:typename:SigSpec	file:
make_leaf	yosys/passes/proc/proc_dlatch.cc	/^	int make_leaf(SigBit signal, SigBit match)$/;"	f	struct:proc_dlatch_db_t	typeref:typename:int	file:
make_link_order	yosys/frontends/verific/verificsva.cc	/^	void make_link_order(vector<int> &order, int node, int min)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
make_opts	yosys/passes/equiv/equiv_opt.cc	/^	std::string command, techmap_opts, make_opts;$/;"	m	struct:EquivOptPass	typeref:typename:std::string	file:
make_output	yosys/passes/equiv/equiv_purge.cc	/^	SigSpec make_output(SigSpec sig, IdString cellname)$/;"	f	struct:EquivPurgeWorker	typeref:typename:SigSpec	file:
make_outreg	yosys/passes/memory/memory_bram.cc	/^		bool make_outreg;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:bool	file:
make_outreg	yosys/passes/memory/memory_bram.cc	/^		bool or_next_if_better, make_transp, make_outreg;$/;"	m	struct:rules_t::match_t	typeref:typename:bool	file:
make_packed_struct	yosys/frontends/ast/simplify.cc	/^static AstNode *make_packed_struct(AstNode *template_node, std::string &name)$/;"	f	typeref:typename:AstNode *	file:
make_patterns_logic	yosys/passes/opt/opt_dff.cc	/^	ctrl_t make_patterns_logic(const patterns_t &patterns, const ctrls_t &ctrls, bool make_gates)$/;"	f	struct:OptDffWorker	typeref:typename:ctrl_t	file:
make_pdf_template	yosys/manual/PRESENTATION_ExSyn/Makefile	/^define make_pdf_template$/;"	m
make_portinfos	yosys/passes/memory/memory_bram.cc	/^		vector<portinfo_t> make_portinfos() const$/;"	f	struct:rules_t::bram_t	typeref:typename:vector<portinfo_t>	file:
make_range	yosys/frontends/ast/simplify.cc	/^static AstNode *make_range(int left, int right, bool is_signed = false)$/;"	f	typeref:typename:AstNode *	file:
make_sig_chain_next_prev	yosys/passes/opt/muxpack.cc	/^	void make_sig_chain_next_prev()$/;"	f	struct:MuxpackWorker	typeref:typename:void	file:
make_sigbit_chain_next_prev	yosys/passes/techmap/shregmap.cc	/^	void make_sigbit_chain_next_prev()$/;"	f	struct:ShregmapWorker	typeref:typename:void	file:
make_struct_index_range	yosys/frontends/ast/simplify.cc	/^static AstNode *make_struct_index_range(AstNode *node, AstNode *rnode, int stride, int offset)$/;"	f	typeref:typename:AstNode *	file:
make_struct_member_range	yosys/frontends/ast/simplify.cc	/^AstNode *AST::make_struct_member_range(AstNode *node, AstNode *member_node)$/;"	f	class:AST	typeref:typename:AstNode *
make_stuff	yosys/passes/equiv/equiv_miter.cc	/^	void make_stuff()$/;"	f	struct:EquivMiterWorker	typeref:typename:void	file:
make_supercell	yosys/passes/opt/share.cc	/^	RTLIL::Cell *make_supercell(RTLIL::Cell *c1, RTLIL::Cell *c2, RTLIL::SigSpec act, pool<RTLIL::C/;"	f	struct:ShareWorker	typeref:typename:RTLIL::Cell *	file:
make_temp_dir	yosys/kernel/yosys.cc	/^std::string make_temp_dir(std::string template_str)$/;"	f	typeref:typename:std::string
make_temp_file	yosys/kernel/yosys.cc	/^std::string make_temp_file(std::string template_str)$/;"	f	typeref:typename:std::string
make_tick_func	yosys/backends/simplec/simplec.cc	/^	void make_tick_func(HierDirtyFlags* \/* work *\/)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
make_transp	yosys/passes/memory/memory_bram.cc	/^		bool make_transp;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:bool	file:
make_transp	yosys/passes/memory/memory_bram.cc	/^		bool or_next_if_better, make_transp, make_outreg;$/;"	m	struct:rules_t::match_t	typeref:typename:bool	file:
make_value	yosys/passes/techmap/attrmap.cc	/^Const make_value(string &value)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN Const
makebits	yosys/backends/smt2/smt2.cc	/^	void makebits(std::string name, int width = 0, std::string comment = std::string())$/;"	f	struct:Smt2Worker	typeref:typename:void	file:
makeblackbox	yosys/kernel/rtlil.cc	/^void RTLIL::Module::makeblackbox()$/;"	f	class:RTLIL::Module	typeref:typename:void
makeptermbuffer	yosys/techlibs/coolrunner2/coolrunner2_fixup.cc	/^RTLIL::Wire *makeptermbuffer(RTLIL::Module *module, SigBit inwire)$/;"	f	typeref:typename:RTLIL::Wire *
makexorbuffer	yosys/techlibs/coolrunner2/coolrunner2_fixup.cc	/^RTLIL::Wire *makexorbuffer(RTLIL::Module *module, SigBit inwire, const char *cellname)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN RTLIL::Wire *
mangle	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle(RTLIL::SigBit sigbit)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
mangle	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle(const Mem *mem)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
mangle	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle(const RTLIL::Cell *cell)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
mangle	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle(const RTLIL::Memory *memory)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
mangle	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle(const RTLIL::Module *module)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
mangle	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle(const RTLIL::Wire *wire)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
mangle_cell_name	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle_cell_name(const RTLIL::IdString &name)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
mangle_memory_name	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle_memory_name(const RTLIL::IdString &name)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
mangle_module_name	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle_module_name(const RTLIL::IdString &name, bool is_blackbox = false)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
mangle_name	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle_name(const RTLIL::IdString &name)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
mangle_wire_name	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string mangle_wire_name(const RTLIL::IdString &name)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
manual	yosys/Makefile	/^manual: $(TARGETS) $(EXTRA_TARGETS)$/;"	t
manyhot	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::manyhot(const std::vector<int> &vec, int min_hot, int max_hot)$/;"	f	class:ezSAT	typeref:typename:int
map	yosys/libs/minisat/IntMap.h	/^        vec<V>   map;$/;"	m	class:Minisat::IntMap	typeref:typename:vec<V>
map	yosys/libs/minisat/SolverTypes.h	/^    HashTable map;$/;"	m	class:Minisat::CMap	typeref:typename:HashTable
mapVar	yosys/libs/minisat/Solver.cc	/^static Var mapVar(Var x, vec<Var>& map, Var& max)$/;"	f	typeref:typename:Var	file:
map_attributes	yosys/passes/techmap/flatten.cc	/^void map_attributes(RTLIL::Cell *cell, T *object, IdString orig_object_name)$/;"	f	typeref:typename:void
map_autoidx	yosys/passes/techmap/abc.cc	/^int map_autoidx;$/;"	v	typeref:typename:int
map_autoidx	yosys/passes/techmap/abc9_ops.cc	/^int map_autoidx;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN int
map_case	yosys/passes/memory/memory_bram.cc	/^	RTLIL::Const map_case(RTLIL::Const value) const$/;"	f	struct:rules_t	typeref:typename:RTLIL::Const	file:
map_case	yosys/passes/memory/memory_bram.cc	/^	std::string map_case(std::string value) const$/;"	f	struct:rules_t	typeref:typename:std::string	file:
map_case	yosys/passes/memory/memory_map.cc	/^	RTLIL::Const map_case(RTLIL::Const value) const$/;"	f	struct:MemoryMapWorker	typeref:typename:RTLIL::Const	file:
map_case	yosys/passes/memory/memory_map.cc	/^	std::string map_case(std::string value) const$/;"	f	struct:MemoryMapWorker	typeref:typename:std::string	file:
map_filename	yosys/frontends/aiger/aigerparse.h	/^    std::string map_filename;$/;"	m	struct:AigerReader	typeref:typename:std::string
map_filename	yosys/passes/sat/sim.cc	/^	std::string map_filename;$/;"	m	struct:SimWorker	typeref:typename:std::string	file:
map_fsm	yosys/passes/fsm/fsm_map.cc	/^static void map_fsm(RTLIL::Cell *fsm_cell, RTLIL::Module *module)$/;"	f	typeref:typename:void	file:
map_luts	yosys/passes/techmap/flowmap.cc	/^	int map_luts()$/;"	f	struct:FlowmapWorker	typeref:typename:int	file:
map_mux16	yosys/passes/techmap/abc.cc	/^bool map_mux16;$/;"	v	typeref:typename:bool
map_mux4	yosys/passes/techmap/abc.cc	/^bool map_mux4;$/;"	v	typeref:typename:bool
map_mux8	yosys/passes/techmap/abc.cc	/^bool map_mux8;$/;"	v	typeref:typename:bool
map_name	yosys/passes/techmap/flatten.cc	/^IdString map_name(RTLIL::Cell *cell, T *object)$/;"	f	typeref:typename:IdString
map_signal	yosys/passes/techmap/abc.cc	/^int map_signal(RTLIL::SigBit bit, gate_type_t gate_type = G(NONE), int in1 = -1, int in2 = -1, i/;"	f	typeref:typename:int
map_sigspec	yosys/passes/techmap/flatten.cc	/^void map_sigspec(const dict<RTLIL::Wire*, RTLIL::Wire*> &map, RTLIL::SigSpec &sig, RTLIL::Module/;"	f	typeref:typename:void
mapped_cells	yosys/passes/techmap/nlutmap.cc	/^	pool<Cell*> mapped_cells;$/;"	m	struct:NlutmapWorker	typeref:typename:pool<Cell * >	file:
mapped_port	yosys/passes/memory/memory_bram.cc	/^		int mapped_port;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:int	file:
mapping	yosys/passes/sat/sim.cc	/^	std::map<Wire*,int> mapping;$/;"	m	struct:AIWWriter	typeref:typename:std::map<Wire *,int>	file:
mapping	yosys/passes/sat/sim.cc	/^	std::map<int,fstHandle> mapping;$/;"	m	struct:FSTWriter	typeref:typename:std::map<int,fstHandle>	file:
mappings	yosys/libs/subcircuit/subcircuit.h	/^			std::map<std::string, ResultNodeMapping> mappings;$/;"	m	struct:SubCircuit::Solver::Result	typeref:typename:std::map<std::string,ResultNodeMapping>
mark	yosys/libs/minisat/SolverTypes.h	/^        unsigned mark      : 2;$/;"	m	struct:Minisat::Clause::__anonb7535e3e0108	typeref:typename:unsigned:2
mark	yosys/libs/minisat/SolverTypes.h	/^    uint32_t     mark        ()      const   { return header.mark; }$/;"	f	class:Minisat::Clause	typeref:typename:uint32_t
mark	yosys/libs/minisat/SolverTypes.h	/^    void         mark        (uint32_t m)    { header.mark = m; }$/;"	f	class:Minisat::Clause	typeref:typename:void
mark	yosys/passes/equiv/equiv_mark.cc	/^	void mark()$/;"	f	struct:EquivMarkWorker	typeref:typename:void	file:
markAllExtern	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Graph::markAllExtern()$/;"	f	class:SubCircuit::Graph	typeref:typename:void
markExtern	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Graph::markExtern(std::string nodeId, std::string portId, int bit)$/;"	f	class:SubCircuit::Graph	typeref:typename:void
mark_auto_nosync	yosys/frontends/ast/simplify.cc	/^static void mark_auto_nosync(AstNode *block, const AstNode *wire)$/;"	f	typeref:typename:void	file:
mark_input_ff	yosys/kernel/ffmerge.cc	/^void FfMergeHelper::mark_input_ff(const pool<std::pair<Cell *, int>> &bits) {$/;"	f	class:FfMergeHelper	typeref:typename:void
mark_memories_assign_lhs_complex	yosys/frontends/ast/simplify.cc	/^static void mark_memories_assign_lhs_complex(dict<AstNode*, pool<std::string>> &mem2reg_places,$/;"	f	typeref:typename:void	file:
mark_port	yosys/passes/techmap/abc.cc	/^void mark_port(RTLIL::SigSpec sig)$/;"	f	typeref:typename:void
mark_reachable_unode	yosys/frontends/verific/verificsva.cc	/^	void mark_reachable_unode(int unode)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
markgroups	yosys/passes/techmap/abc.cc	/^bool markgroups;$/;"	v	typeref:typename:bool
mask	yosys/backends/cxxrtl/cxxrtl.h	/^		value<Width> mask;$/;"	m	struct:cxxrtl::memory::write	typeref:typename:value<Width>
mask	yosys/backends/cxxrtl/cxxrtl.h	/^	static constexpr T mask = std::numeric_limits<T>::max();$/;"	m	struct:cxxrtl::chunk_traits	typeref:typename:T
match	yosys/kernel/bitpattern.h	/^	bool match(bits_t a, bits_t b)$/;"	f	struct:BitPatternPool	typeref:typename:bool
match	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::match(const char* pattern) const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
match	yosys/libs/minisat/ParseUtils.h	/^static bool match(B& in, const char* str) {$/;"	f	namespace:Minisat	typeref:typename:bool
match	yosys/passes/proc/proc_dlatch.cc	/^		SigBit signal, match;$/;"	m	struct:proc_dlatch_db_t::rule_node_t	typeref:typename:SigBit	file:
matchNodePorts	yosys/libs/subcircuit/subcircuit.cc	/^	bool matchNodePorts(const Graph &needle, int needleNodeIdx, const Graph &haystack, int haystack/;"	f	class:SubCircuit::SolverWorker	typeref:typename:bool	file:
matchNodes	yosys/libs/subcircuit/subcircuit.cc	/^	bool matchNodes(const GraphData &needle, int needleNodeIdx, const GraphData &haystack, int hays/;"	f	class:SubCircuit::SolverWorker	typeref:typename:bool	file:
match_attr	yosys/passes/cmds/select.cc	/^static bool match_attr(const dict<RTLIL::IdString, RTLIL::Const> &attributes, const std::string /;"	f	typeref:typename:bool	file:
match_attr_val	yosys/passes/cmds/select.cc	/^static bool match_attr_val(const RTLIL::Const &value, const std::string &pattern, char match_op)$/;"	f	typeref:typename:bool	file:
match_ids	yosys/passes/cmds/select.cc	/^static bool match_ids(RTLIL::IdString id, const std::string &pattern)$/;"	f	typeref:typename:bool	file:
match_name	yosys/passes/techmap/attrmap.cc	/^bool match_name(string &name, IdString &id, bool ignore_case=false)$/;"	f	typeref:typename:bool
match_t	yosys/passes/memory/memory_bram.cc	/^	struct match_t {$/;"	s	struct:rules_t	file:
match_value	yosys/passes/techmap/attrmap.cc	/^bool match_value(string &value, Const &val, bool ignore_case=false)$/;"	f	typeref:typename:bool
matched	yosys/passes/cmds/exec.cc	/^			bool matched;$/;"	m	struct:ExecPass::execute::expect_stdout_elem	typeref:typename:bool	file:
matches	yosys/passes/memory/memory_bram.cc	/^	vector<match_t> matches;$/;"	m	struct:rules_t	typeref:typename:vector<match_t>	file:
matchesPerGraph	yosys/libs/subcircuit/subcircuit.h	/^			std::map<std::string, int> matchesPerGraph;$/;"	m	struct:SubCircuit::Solver::MineResult	typeref:typename:std::map<std::string,int>
materialized	yosys/frontends/verific/verificsva.cc	/^	bool materialized = false;$/;"	m	struct:SvaFsm	typeref:typename:bool	file:
max	yosys/backends/cxxrtl/cxxrtl.h	/^constexpr T max(const T &a, const T &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE T
max	yosys/libs/minisat/Vec.h	/^    static inline Size max(Size x, Size y){ return (x > y) ? x : y; }$/;"	f	class:Minisat::vec	typeref:typename:Size
maxPermutationsLimit	yosys/libs/subcircuit/subcircuit.cc	/^	static constexpr int maxPermutationsLimit = 1000000;$/;"	m	class:SubCircuit::SolverWorker	typeref:typename:int	file:
max_cell_complexity	yosys/kernel/qcsat.h	/^	int max_cell_complexity = 2;$/;"	m	struct:QuickConeSat	typeref:typename:int
max_cell_count	yosys/kernel/qcsat.h	/^	int max_cell_count = 0;$/;"	m	struct:QuickConeSat	typeref:typename:int
max_cell_outs	yosys/kernel/qcsat.h	/^	int max_cell_outs = 0;$/;"	m	struct:QuickConeSat	typeref:typename:int
max_depth	yosys/libs/json11/json11.cpp	/^static const int max_depth = 200;$/;"	v	namespace:json11	typeref:typename:const int	file:
max_enumhandle	yosys/libs/fst/fstapi.cc	/^    fstEnumHandle max_enumhandle;$/;"	m	struct:fstWriterContext	typeref:typename:fstEnumHandle	file:
max_learnts	yosys/libs/minisat/Solver.h	/^    double              max_learnts;$/;"	m	class:Minisat::Solver	typeref:typename:double
max_limits	yosys/passes/memory/memory_bram.cc	/^		dict<string, int> min_limits, max_limits;$/;"	m	struct:rules_t::match_t	typeref:typename:dict<string,int>	file:
max_literals	yosys/libs/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literal/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
max_patterns	yosys/passes/proc/proc_rmdead.cc	/^	size_t max_patterns;$/;"	m	struct:FullyDefinedPool	typeref:typename:size_t	file:
max_seq	yosys/passes/equiv/equiv_induct.cc	/^	int max_seq;$/;"	m	struct:EquivInductWorker	typeref:typename:int	file:
max_seq	yosys/passes/equiv/equiv_simple.cc	/^	int max_seq;$/;"	m	struct:EquivSimpleWorker	typeref:typename:int	file:
max_simp_var	yosys/libs/minisat/SimpSolver.h	/^    Var                 max_simp_var;        \/\/ Max variable at the point simplification was t/;"	m	class:Minisat::SimpSolver	typeref:typename:Var
max_timestep	yosys/passes/sat/sat.cc	/^	int max_timestep, timeout;$/;"	m	struct:SatHelper	typeref:typename:int	file:
max_uintsize	yosys/backends/simplec/simplec.cc	/^	int max_uintsize = 32;$/;"	m	struct:SimplecWorker	typeref:typename:int	file:
maxarrival	yosys/passes/cmds/sta.cc	/^	int maxarrival;$/;"	m	struct:StaWorker	typeref:typename:int	file:
maxbit	yosys/passes/cmds/ltp.cc	/^	SigBit maxbit;$/;"	m	struct:LtpWorker	typeref:typename:SigBit	file:
maxbit	yosys/passes/cmds/sta.cc	/^	SigBit maxbit;$/;"	m	struct:StaWorker	typeref:typename:SigBit	file:
maxbreadth	yosys/passes/techmap/extract_fa.cc	/^	int maxbreadth = 6;$/;"	m	struct:ExtractFaConfig	typeref:typename:int	file:
maxdepth	yosys/passes/techmap/extract_fa.cc	/^	int maxdepth = 20;$/;"	m	struct:ExtractFaConfig	typeref:typename:int	file:
maxhandle	yosys/libs/fst/fstapi.cc	/^    fstHandle maxhandle;$/;"	m	struct:fstReaderContext	typeref:typename:fstHandle	file:
maxhandle	yosys/libs/fst/fstapi.cc	/^    fstHandle maxhandle;$/;"	m	struct:fstWriterContext	typeref:typename:fstHandle	file:
maximize_undefs	yosys/passes/sat/sat.cc	/^	void maximize_undefs()$/;"	f	struct:SatHelper	typeref:typename:void	file:
maximum_flow	yosys/passes/techmap/flowmap.cc	/^	int maximum_flow(int order)$/;"	f	struct:FlowGraph	typeref:typename:int	file:
maxlen	yosys/passes/techmap/shregmap.cc	/^	int minlen, maxlen;$/;"	m	struct:ShregmapOptions	typeref:typename:int	file:
maxlut	yosys/passes/techmap/abc9.cc	/^	int maxlut;$/;"	m	struct:Abc9Pass	typeref:typename:int	file:
maxlvl	yosys/passes/cmds/ltp.cc	/^	int maxlvl;$/;"	m	struct:LtpWorker	typeref:typename:int	file:
maxvalpos	yosys/libs/fst/fstapi.cc	/^    uint32_t maxvalpos;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t	file:
maxwidth	yosys/passes/techmap/extract_counter.cc	/^	int maxwidth;$/;"	m	struct:CounterExtractionSettings	typeref:typename:int	file:
mem	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		const Mem *mem = nullptr;$/;"	m	struct:FlowGraph::Node	typeref:typename:const Mem *	file:
mem	yosys/kernel/mem.h	/^	RTLIL::Memory *mem;$/;"	m	struct:Mem	typeref:typename:RTLIL::Memory *
mem	yosys/libs/fst/fstapi.cc	/^    unsigned char mem[1];$/;"	m	struct:collchain_t	typeref:typename:unsigned char[1]	file:
mem	yosys/passes/memory/memory_dff.cc	/^	Mem &mem;$/;"	m	struct:MemQueryCache	typeref:typename:Mem &	file:
mem	yosys/passes/sat/sim.cc	/^		Mem *mem;$/;"	m	struct:SimInstance::mem_state_t	typeref:typename:Mem *	file:
mem2reg	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
mem2reg_as_needed_pass1	yosys/frontends/ast/simplify.cc	/^void AstNode::mem2reg_as_needed_pass1(dict<AstNode*, pool<std::string>> &mem2reg_places,$/;"	f	class:AstNode	typeref:typename:void
mem2reg_as_needed_pass2	yosys/frontends/ast/simplify.cc	/^bool AstNode::mem2reg_as_needed_pass2(pool<AstNode*> &mem2reg_set, AstNode *mod, AstNode *block,/;"	f	class:AstNode	typeref:typename:bool
mem2reg_check	yosys/frontends/ast/simplify.cc	/^bool AstNode::mem2reg_check(pool<AstNode*> &mem2reg_set)$/;"	f	class:AstNode	typeref:typename:bool
mem2reg_flags	yosys/frontends/ast/ast.h	/^		enum mem2reg_flags$/;"	g	struct:AST::AstNode
mem2reg_remove	yosys/frontends/ast/simplify.cc	/^void AstNode::mem2reg_remove(pool<AstNode*> &mem2reg_set, vector<AstNode*> &delnodes)$/;"	f	class:AstNode	typeref:typename:void
memReadPeak	yosys/libs/minisat/System.cc	/^static inline int memReadPeak(void)$/;"	f	typeref:typename:int	file:
memReadStat	yosys/libs/minisat/System.cc	/^static inline int memReadStat(int field)$/;"	f	typeref:typename:int	file:
memUsed	yosys/libs/minisat/System.cc	/^double Minisat::memUsed()     { return 0; }$/;"	f	class:Minisat	typeref:typename:double
memUsed	yosys/libs/minisat/System.cc	/^double Minisat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() \/ (1024*1024)/;"	f	class:Minisat	typeref:typename:double
memUsed	yosys/libs/minisat/System.cc	/^double Minisat::memUsed() {$/;"	f	class:Minisat	typeref:typename:double
memUsedPeak	yosys/libs/minisat/System.cc	/^double Minisat::memUsedPeak(bool strictlyPeak) { $/;"	f	class:Minisat	typeref:typename:double
memUsedPeak	yosys/libs/minisat/System.cc	/^double Minisat::memUsedPeak(bool) { return 0; }$/;"	f	class:Minisat	typeref:typename:double
memUsedPeak	yosys/libs/minisat/System.cc	/^double Minisat::memUsedPeak(bool) { return memUsed(); }$/;"	f	class:Minisat	typeref:typename:double
mem_cell_addr	yosys/passes/sat/sim.cc	/^	int mem_cell_addr(std::string const & name)$/;"	f	struct:SimWorker	typeref:typename:int	file:
mem_cells	yosys/backends/btor/btor.cc	/^	dict<Cell*, Mem*> mem_cells;$/;"	m	struct:BtorWorker	typeref:typename:dict<Cell *,Mem * >	file:
mem_cells	yosys/backends/smt2/smt2.cc	/^	dict<Cell*, Mem*> mem_cells;$/;"	m	struct:Smt2Worker	typeref:typename:dict<Cell *,Mem * >	file:
mem_cells	yosys/passes/sat/sim.cc	/^	dict<Cell*, IdString> mem_cells;$/;"	m	struct:SimInstance	typeref:typename:dict<Cell *,IdString>	file:
mem_database	yosys/passes/sat/sim.cc	/^	dict<IdString, mem_state_t> mem_database;$/;"	m	struct:SimInstance	typeref:typename:dict<IdString,mem_state_t>	file:
mem_from_cell	yosys/kernel/mem.cc	/^	Mem mem_from_cell(Cell *cell) {$/;"	f	namespace:__anon62474a9e0111	typeref:typename:Mem
mem_from_memory	yosys/kernel/mem.cc	/^	Mem mem_from_memory(Module *module, RTLIL::Memory *mem, const MemIndex &index) {$/;"	f	namespace:__anon62474a9e0111	typeref:typename:Mem
mem_state_t	yosys/passes/sat/sim.cc	/^	struct mem_state_t$/;"	s	struct:SimInstance	file:
mem_todo	yosys/backends/btor/btor.cc	/^	vector<pair<int, Mem*>> mem_todo;$/;"	m	struct:BtorWorker	typeref:typename:vector<pair<int,Mem * >>	file:
mem_used_by_writer	yosys/libs/fst/fstapi.cc	/^    uint64_t mem_used_by_writer;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
mem_write_actions	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::MemWriteAction> mem_write_actions;$/;"	m	struct:RTLIL::SyncRule	typeref:typename:std::vector<RTLIL::MemWriteAction>
memarrays	yosys/backends/smt2/smt2.cc	/^	std::map<Mem*, int> memarrays;$/;"	m	struct:Smt2Worker	typeref:typename:std::map<Mem *,int>	file:
memhasher	yosys/kernel/yosys.h	/^inline void memhasher() { if (memhasher_active) memhasher_do(); }$/;"	f	typeref:typename:void
memhasher_active	yosys/kernel/yosys.cc	/^bool memhasher_active = false;$/;"	v	typeref:typename:bool
memhasher_do	yosys/kernel/yosys.cc	/^void memhasher_do()$/;"	f	typeref:typename:void
memhasher_off	yosys/kernel/yosys.cc	/^void memhasher_off()$/;"	f	typeref:typename:void
memhasher_on	yosys/kernel/yosys.cc	/^void memhasher_on()$/;"	f	typeref:typename:void
memhasher_rng	yosys/kernel/yosys.cc	/^uint32_t memhasher_rng = 123456;$/;"	v	typeref:typename:uint32_t
memhasher_store	yosys/kernel/yosys.cc	/^std::vector<void*> memhasher_store;$/;"	v	typeref:typename:std::vector<void * >
memid	yosys/kernel/mem.h	/^	IdString memid;$/;"	m	struct:Mem	typeref:typename:IdString
memid	yosys/kernel/rtlil.h	/^	RTLIL::IdString memid;$/;"	m	struct:RTLIL::MemWriteAction	typeref:typename:RTLIL::IdString
meminfo	yosys/frontends/ast/simplify.cc	/^void AstNode::meminfo(int &mem_width, int &mem_size, int &addr_bits)$/;"	f	class:AstNode	typeref:typename:void
memmode	yosys/backends/smt2/smt2.cc	/^	bool bvmode, memmode, wiresmode, verbose, statebv, statedt, forallmode;$/;"	m	struct:Smt2Worker	typeref:typename:bool	file:
memories	yosys/backends/btor/btor.cc	/^	vector<Mem> memories;$/;"	m	struct:BtorWorker	typeref:typename:vector<Mem>	file:
memories	yosys/backends/smt2/smt2.cc	/^	std::vector<Mem> memories;$/;"	m	struct:Smt2Worker	typeref:typename:std::vector<Mem>	file:
memories	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, RTLIL::Memory*> memories;$/;"	m	struct:RTLIL::Module	typeref:typename:dict<RTLIL::IdString,RTLIL::Memory * >
memories	yosys/passes/sat/sim.cc	/^	std::vector<Mem> memories;$/;"	m	struct:SimInstance	typeref:typename:std::vector<Mem>	file:
memory	yosys/backends/cxxrtl/cxxrtl.h	/^	explicit memory(size_t depth) : depth(depth), data(new value<Width>[depth]) {}$/;"	f	struct:cxxrtl::memory
memory	yosys/backends/cxxrtl/cxxrtl.h	/^struct memory {$/;"	s	namespace:cxxrtl
memory	yosys/libs/minisat/Alloc.h	/^    T*        memory;$/;"	m	class:Minisat::RegionAllocator	typeref:typename:T *
memory_index	yosys/backends/cxxrtl/cxxrtl.h	/^	memory_index(const value<BitsAddr> &addr, size_t offset, size_t depth) {$/;"	f	struct:cxxrtl_yosys::memory_index
memory_index	yosys/backends/cxxrtl/cxxrtl.h	/^struct memory_index {$/;"	s	namespace:cxxrtl_yosys
memory_opts	yosys/techlibs/common/synth.cc	/^	string top_module, fsm_opts, memory_opts, abc;$/;"	m	struct:SynthPass	typeref:typename:string	file:
memory_queue	yosys/backends/smt2/smt2.cc	/^	std::set<Mem*> memory_queue;$/;"	m	struct:Smt2Worker	typeref:typename:std::set<Mem * >	file:
memxmode	yosys/techlibs/common/prep.cc	/^	bool autotop, flatten, ifxmode, memxmode, nomemmode, nokeepdc, rdff;$/;"	m	struct:PrepPass	typeref:typename:bool	file:
merge	yosys/frontends/verilog/preproc.cc	/^void define_map_t::merge(const define_map_t &map)$/;"	f	class:define_map_t	typeref:typename:void
merge	yosys/kernel/hashlib.h	/^	void merge(const K &a, const K &b)$/;"	f	class:hashlib::mfp	typeref:typename:void
merge	yosys/kernel/modtools.h	/^		void merge(const SigBitInfo &other)$/;"	f	struct:ModIndex::SigBitInfo	typeref:typename:void
merge	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, int& size)$/;"	f	class:SimpSolver	typeref:typename:bool
merge	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)$/;"	f	class:SimpSolver	typeref:typename:bool
merge_cache	yosys/passes/equiv/equiv_struct.cc	/^	dict<merge_key_t, pool<IdString>> merge_cache;$/;"	m	struct:EquivStructWorker	typeref:typename:dict<merge_key_t,pool<IdString>>	file:
merge_cell_into_fsm	yosys/passes/fsm/fsm_expand.cc	/^	void merge_cell_into_fsm(RTLIL::Cell *cell)$/;"	f	struct:FsmExpand	typeref:typename:void	file:
merge_cell_pair	yosys/passes/equiv/equiv_struct.cc	/^	void merge_cell_pair(Cell *cell_a, Cell *cell_b)$/;"	f	struct:EquivStructWorker	typeref:typename:void	file:
merge_count	yosys/passes/equiv/equiv_struct.cc	/^	int merge_count;$/;"	m	struct:EquivStructWorker	typeref:typename:int	file:
merge_key_t	yosys/passes/equiv/equiv_struct.cc	/^	struct merge_key_t$/;"	s	struct:EquivStructWorker	file:
merge_lut	yosys/techlibs/xilinx/xilinx_dffopt.cc	/^bool merge_lut(LutData &result, const LutData &data, const LutData select, bool select_inv, SigB/;"	f	typeref:typename:bool
merge_macc	yosys/passes/techmap/alumacc.cc	/^	void merge_macc()$/;"	f	struct:AlumaccWorker	typeref:typename:void	file:
merge_mode	yosys/passes/techmap/tribuf.cc	/^	bool merge_mode;$/;"	m	struct:TribufConfig	typeref:typename:bool	file:
merge_operators	yosys/passes/opt/opt_share.cc	/^void merge_operators(RTLIL::Module *module, RTLIL::Cell *mux, const std::vector<OpMuxConn> &port/;"	f	typeref:typename:void
merge_past_ffs	yosys/frontends/verific/verific.cc	/^void VerificImporter::merge_past_ffs(pool<RTLIL::Cell*> &candidates)$/;"	f	class:VerificImporter	typeref:typename:void
merge_past_ffs_clock	yosys/frontends/verific/verific.cc	/^void VerificImporter::merge_past_ffs_clock(pool<RTLIL::Cell*> &candidates, SigBit clock, bool cl/;"	f	class:VerificImporter	typeref:typename:void
merge_rst_value	yosys/passes/memory/memory_share.cc	/^	bool merge_rst_value(Mem &mem, Const &res, int wide_log2, const Const &src1, int sub1, const Co/;"	f	struct:MemoryShareWorker	typeref:typename:bool	file:
mergeability	yosys/frontends/aiger/aigerparse.h	/^    std::vector<int> mergeability, initial_state;$/;"	m	struct:AigerReader	typeref:typename:std::vector<int>
mergeable	yosys/passes/opt/opt_share.cc	/^bool mergeable(RTLIL::Cell *a, RTLIL::Cell *b)$/;"	f	typeref:typename:bool
mergeable_type_map	yosys/passes/opt/opt_share.cc	/^std::map<IdString, IdString> mergeable_type_map;$/;"	v	typeref:typename:std::map<IdString,IdString>
merged_op_t	yosys/passes/opt/opt_share.cc	/^} merged_op_t;$/;"	t	typeref:struct:__anonade320d40208	file:
merged_set	yosys/passes/fsm/fsm_expand.cc	/^	std::set<RTLIL::Cell*, RTLIL::sort_by_name_id<RTLIL::Cell>> merged_set;$/;"	m	struct:FsmExpand	typeref:typename:std::set<RTLIL::Cell *,RTLIL::sort_by_name_id<RTLIL::Cell>>	file:
merger	yosys/passes/memory/memory_dff.cc	/^	FfMergeHelper merger;$/;"	m	struct:MemoryDffWorker	typeref:typename:FfMergeHelper	file:
merges	yosys/libs/minisat/SimpSolver.h	/^    int     merges;$/;"	m	class:Minisat::SimpSolver	typeref:typename:int
meta_mux_selects	yosys/passes/cmds/glift.cc	/^	std::vector<std::pair<RTLIL::SigSpec, RTLIL::IdString>> meta_mux_selects;$/;"	m	struct:GliftWorker	typeref:typename:std::vector<std::pair<RTLIL::SigSpec,RTLIL::IdString>>	file:
metadata	yosys/backends/cxxrtl/cxxrtl.h	/^	metadata() : value_type(MISSING) {}$/;"	f	struct:cxxrtl::metadata
metadata	yosys/backends/cxxrtl/cxxrtl.h	/^	metadata(const char *value) : value_type(STRING), string_value(value) {}$/;"	f	struct:cxxrtl::metadata
metadata	yosys/backends/cxxrtl/cxxrtl.h	/^	metadata(const std::string &value) : value_type(STRING), string_value(value) {}$/;"	f	struct:cxxrtl::metadata
metadata	yosys/backends/cxxrtl/cxxrtl.h	/^	metadata(double value) : value_type(DOUBLE), double_value(value) {}$/;"	f	struct:cxxrtl::metadata
metadata	yosys/backends/cxxrtl/cxxrtl.h	/^	metadata(signed value) : value_type(SINT), sint_value(value) {}$/;"	f	struct:cxxrtl::metadata
metadata	yosys/backends/cxxrtl/cxxrtl.h	/^	metadata(unsigned value) : value_type(UINT), uint_value(value) {}$/;"	f	struct:cxxrtl::metadata
metadata	yosys/backends/cxxrtl/cxxrtl.h	/^struct metadata {$/;"	s	namespace:cxxrtl
metadata_map	yosys/backends/cxxrtl/cxxrtl.h	/^typedef std::map<std::string, metadata> metadata_map;$/;"	t	namespace:cxxrtl	typeref:typename:std::map<std::string,metadata>
mfp	yosys/kernel/hashlib.h	/^class mfp$/;"	c	namespace:hashlib
mi	yosys/passes/opt/wreduce.cc	/^	ModIndex mi;$/;"	m	struct:WreduceWorker	typeref:typename:ModIndex	file:
midpos	yosys/passes/cmds/qwp.cc	/^	double midpos;$/;"	m	struct:QwpWorker	typeref:typename:double	file:
minWidth	yosys/libs/subcircuit/subcircuit.h	/^			int minWidth;$/;"	m	struct:SubCircuit::Graph::Port	typeref:typename:int
min_ce_use	yosys/techlibs/ice40/synth_ice40.cc	/^	int min_ce_use;$/;"	m	struct:SynthIce40Pass	typeref:typename:int	file:
min_learnts_lim	yosys/libs/minisat/Solver.h	/^    int       min_learnts_lim;    \/\/ Minimum number to set the learnts limit to.$/;"	m	class:Minisat::Solver	typeref:typename:int
min_limits	yosys/passes/memory/memory_bram.cc	/^		dict<string, int> min_limits, max_limits;$/;"	m	struct:rules_t::match_t	typeref:typename:dict<string,int>	file:
mince	yosys/passes/techmap/dfflegalize.cc	/^	int mince;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
mine	yosys/libs/subcircuit/subcircuit.cc	/^	void mine(std::vector<Solver::MineResult> &results, int minNodes, int maxNodes, int minMatches,/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
mine	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::mine(std::vector<MineResult> &results, int minNodes, int maxNodes, int /;"	f	class:SubCircuit::Solver	typeref:typename:void
minisatSolver	yosys/libs/ezsat/ezminisat.h	/^	Solver *minisatSolver;$/;"	m	class:ezMiniSAT	typeref:typename:Solver *
minisatVars	yosys/libs/ezsat/ezminisat.h	/^	std::vector<int> minisatVars;$/;"	m	class:ezMiniSAT	typeref:typename:std::vector<int>
minlen	yosys/passes/techmap/shregmap.cc	/^	int minlen, maxlen;$/;"	m	struct:ShregmapOptions	typeref:typename:int	file:
minsrst	yosys/passes/techmap/dfflegalize.cc	/^	int minsrst;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
minwidth	yosys/passes/techmap/extract_counter.cc	/^	int minwidth;$/;"	m	struct:CounterExtractionSettings	typeref:typename:int	file:
mirror_x	yosys/libs/ezsat/puzzle3d.cc	/^	void mirror_x() { center_x *= -1; }$/;"	f	struct:blockgeom_t	typeref:typename:void	file:
mirror_y	yosys/libs/ezsat/puzzle3d.cc	/^	void mirror_y() { center_y *= -1; }$/;"	f	struct:blockgeom_t	typeref:typename:void	file:
mirror_z	yosys/libs/ezsat/puzzle3d.cc	/^	void mirror_z() { center_z *= -1; }$/;"	f	struct:blockgeom_t	typeref:typename:void	file:
miter_cells	yosys/passes/equiv/equiv_miter.cc	/^	pool<Cell*> seed_cells, miter_cells;$/;"	m	struct:EquivMiterWorker	typeref:typename:pool<Cell * >	file:
miter_module	yosys/passes/equiv/equiv_miter.cc	/^	Module *miter_module;$/;"	m	struct:EquivMiterWorker	typeref:typename:Module *	file:
miter_name	yosys/passes/equiv/equiv_miter.cc	/^	IdString miter_name;$/;"	m	struct:EquivMiterWorker	typeref:typename:IdString	file:
miter_wires	yosys/passes/equiv/equiv_miter.cc	/^	pool<Wire*> miter_wires;$/;"	m	struct:EquivMiterWorker	typeref:typename:pool<Wire * >	file:
mix	yosys/libs/fst/fstapi.cc	/^#define mix(/;"	d	file:
mkElimClause	yosys/libs/minisat/SimpSolver.cc	/^static void mkElimClause(vec<uint32_t>& elimclauses, Lit x)$/;"	f	typeref:typename:void	file:
mkElimClause	yosys/libs/minisat/SimpSolver.cc	/^static void mkElimClause(vec<uint32_t>& elimclauses, Var v, Clause& c)$/;"	f	typeref:typename:void	file:
mkLit	yosys/libs/minisat/SolverTypes.h	/^inline  Lit  mkLit     (Var var, bool sign = false) { Lit p; p.x = var + var + (int)sign; return/;"	f	namespace:Minisat	typeref:typename:Lit
mkVarData	yosys/libs/minisat/Solver.h	/^    static inline VarData mkVarData(CRef cr, int l){ VarData d = {cr, l}; return d; }$/;"	f	class:Minisat::Solver	typeref:typename:VarData
mkconst_bits	yosys/frontends/ast/ast.cc	/^AstNode *AstNode::mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed)$/;"	f	class:AstNode	typeref:typename:AstNode *
mkconst_bits	yosys/frontends/ast/ast.cc	/^AstNode *AstNode::mkconst_bits(const std::vector<RTLIL::State> &v, bool is_signed, bool is_unsiz/;"	f	class:AstNode	typeref:typename:AstNode *
mkconst_int	yosys/frontends/ast/ast.cc	/^AstNode *AstNode::mkconst_int(uint32_t v, bool is_signed, int width)$/;"	f	class:AstNode	typeref:typename:AstNode *
mkconst_str	yosys/frontends/ast/ast.cc	/^AstNode *AstNode::mkconst_str(const std::string &str)$/;"	f	class:AstNode	typeref:typename:AstNode *
mkconst_str	yosys/frontends/ast/ast.cc	/^AstNode *AstNode::mkconst_str(const std::vector<RTLIL::State> &v)$/;"	f	class:AstNode	typeref:typename:AstNode *
mkdir	yosys/kernel/yosys.h	/^#  define mkdir /;"	d
mkgate	yosys/backends/aiger/aiger.cc	/^	int mkgate(int a0, int a1)$/;"	f	struct:AigerWriter	typeref:typename:int	file:
mkgate	yosys/backends/aiger/xaiger.cc	/^	int mkgate(int a0, int a1)$/;"	f	struct:XAigerWriter	typeref:typename:int	file:
mkhash	yosys/kernel/hashlib.h	/^inline unsigned int mkhash(const T &v) {$/;"	f	namespace:hashlib	typeref:typename:unsigned int
mkhash	yosys/kernel/hashlib.h	/^inline unsigned int mkhash(unsigned int a, unsigned int b) {$/;"	f	namespace:hashlib	typeref:typename:unsigned int
mkhash_add	yosys/kernel/hashlib.h	/^inline unsigned int mkhash_add(unsigned int a, unsigned int b) {$/;"	f	namespace:hashlib	typeref:typename:unsigned int
mkhash_init	yosys/kernel/hashlib.h	/^const unsigned int mkhash_init = 5381;$/;"	v	namespace:hashlib	typeref:typename:const unsigned int
mkhash_xorshift	yosys/kernel/hashlib.h	/^inline unsigned int mkhash_xorshift(unsigned int a) {$/;"	f	namespace:hashlib	typeref:typename:unsigned int
mod	yosys/kernel/rtlil.cc	/^		RTLIL::Module *mod;$/;"	m	struct:RTLIL::Module::cloneInto::RewriteSigSpecWorker	typeref:typename:RTLIL::Module *	file:
mod	yosys/passes/equiv/equiv_miter.cc	/^			RTLIL::Module * mod;$/;"	m	struct:EquivMiterWorker::copy_to_miter::RewriteSigSpecWorker	typeref:typename:RTLIL::Module *	file:
mod1	yosys/passes/sat/eval.cc	/^	RTLIL::Module *mod1, *mod2;$/;"	m	struct:BruteForceEquivChecker	typeref:typename:RTLIL::Module *	file:
mod1_inputs	yosys/passes/sat/eval.cc	/^	RTLIL::SigSpec mod1_inputs, mod1_outputs;$/;"	m	struct:BruteForceEquivChecker	typeref:typename:RTLIL::SigSpec	file:
mod1_outputs	yosys/passes/sat/eval.cc	/^	RTLIL::SigSpec mod1_inputs, mod1_outputs;$/;"	m	struct:BruteForceEquivChecker	typeref:typename:RTLIL::SigSpec	file:
mod2	yosys/passes/sat/eval.cc	/^	RTLIL::Module *mod1, *mod2;$/;"	m	struct:BruteForceEquivChecker	typeref:typename:RTLIL::Module *	file:
mod2_inputs	yosys/passes/sat/eval.cc	/^	RTLIL::SigSpec mod2_inputs, mod2_outputs;$/;"	m	struct:BruteForceEquivChecker	typeref:typename:RTLIL::SigSpec	file:
mod2_outputs	yosys/passes/sat/eval.cc	/^	RTLIL::SigSpec mod2_inputs, mod2_outputs;$/;"	m	struct:BruteForceEquivChecker	typeref:typename:RTLIL::SigSpec	file:
mod_cost_cache	yosys/kernel/cost.h	/^	dict<RTLIL::IdString, int> mod_cost_cache;$/;"	m	struct:CellCosts	typeref:typename:dict<RTLIL::IdString,int>
mod_memories	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Module*, std::vector<Mem>> mod_memories;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<const RTLIL::Module *,std::vector<Mem>>	file:
mod_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> mod_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
mod_stbv_width	yosys/backends/smt2/smt2.cc	/^	dict<IdString, int> &mod_stbv_width;$/;"	m	struct:Smt2Worker	typeref:typename:dict<IdString,int> &	file:
mod_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> mod_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
mode	yosys/passes/cmds/select.cc	/^		char mode;$/;"	m	struct:__anon240a0d430111::expand_rule_t	typeref:typename:char	file:
mode	yosys/passes/sat/mutate.cc	/^	std::string mode;$/;"	m	struct:mutate_opts_t	typeref:typename:std::string	file:
mode	yosys/passes/sat/mutate.cc	/^	string mode;$/;"	m	struct:mutate_t	typeref:typename:string	file:
mode_assert	yosys/frontends/verific/verificsva.cc	/^	bool mode_assert = false;$/;"	m	struct:VerificSvaImporter	typeref:typename:bool	file:
mode_assert	yosys/passes/equiv/equiv_miter.cc	/^	bool mode_assert;$/;"	m	struct:EquivMiterWorker	typeref:typename:bool	file:
mode_assume	yosys/frontends/verific/verificsva.cc	/^	bool mode_assume = false;$/;"	m	struct:VerificSvaImporter	typeref:typename:bool	file:
mode_autocover	yosys/frontends/verific/verific.h	/^	bool mode_autocover, mode_fullinit;$/;"	m	struct:VerificImporter	typeref:typename:bool
mode_cmp	yosys/passes/equiv/equiv_miter.cc	/^	bool mode_cmp;$/;"	m	struct:EquivMiterWorker	typeref:typename:bool	file:
mode_cover	yosys/frontends/verific/verificsva.cc	/^	bool mode_cover = false;$/;"	m	struct:VerificSvaImporter	typeref:typename:bool	file:
mode_fullinit	yosys/frontends/verific/verific.h	/^	bool mode_autocover, mode_fullinit;$/;"	m	struct:VerificImporter	typeref:typename:bool
mode_fwd	yosys/passes/equiv/equiv_struct.cc	/^	bool mode_fwd;$/;"	m	struct:EquivStructWorker	typeref:typename:bool	file:
mode_gates	yosys/frontends/verific/verific.h	/^	bool mode_gates, mode_keep, mode_nosva, mode_names, mode_verific;$/;"	m	struct:VerificImporter	typeref:typename:bool
mode_icells	yosys/passes/equiv/equiv_struct.cc	/^	bool mode_icells;$/;"	m	struct:EquivStructWorker	typeref:typename:bool	file:
mode_keep	yosys/frontends/verific/verific.h	/^	bool mode_gates, mode_keep, mode_nosva, mode_names, mode_verific;$/;"	m	struct:VerificImporter	typeref:typename:bool
mode_keep_cnf	yosys/libs/ezsat/ezsat.h	/^	bool mode_keep_cnf() const { return flag_keep_cnf; }$/;"	f	class:ezSAT	typeref:typename:bool
mode_names	yosys/frontends/verific/verific.h	/^	bool mode_gates, mode_keep, mode_nosva, mode_names, mode_verific;$/;"	m	struct:VerificImporter	typeref:typename:bool
mode_non_incremental	yosys/libs/ezsat/ezsat.h	/^	bool mode_non_incremental() const { return flag_non_incremental; }$/;"	f	class:ezSAT	typeref:typename:bool
mode_nosva	yosys/frontends/verific/verific.h	/^	bool mode_gates, mode_keep, mode_nosva, mode_names, mode_verific;$/;"	m	struct:VerificImporter	typeref:typename:bool
mode_share_all	yosys/passes/opt/opt_merge.cc	/^	bool mode_share_all;$/;"	m	struct:OptMergeWorker	typeref:typename:bool	file:
mode_trigger	yosys/frontends/verific/verificsva.cc	/^	bool mode_trigger = false;$/;"	m	struct:VerificSvaImporter	typeref:typename:bool	file:
mode_trigger	yosys/passes/equiv/equiv_miter.cc	/^	bool mode_trigger;$/;"	m	struct:EquivMiterWorker	typeref:typename:bool	file:
mode_undef	yosys/passes/equiv/equiv_miter.cc	/^	bool mode_undef;$/;"	m	struct:EquivMiterWorker	typeref:typename:bool	file:
mode_verific	yosys/frontends/verific/verific.h	/^	bool mode_gates, mode_keep, mode_nosva, mode_names, mode_verific;$/;"	m	struct:VerificImporter	typeref:typename:bool
model	yosys/libs/minisat/Solver.h	/^    vec<lbool> model;             \/\/ If problem is satisfiable, this vector contains the model/;"	m	class:Minisat::Solver	typeref:typename:vec<lbool>
modelExpressions	yosys/passes/sat/sat.cc	/^	std::vector<int> modelExpressions;$/;"	m	struct:SatHelper	typeref:typename:std::vector<int>	file:
modelInfo	yosys/passes/sat/sat.cc	/^	std::set<ModelBlockInfo> modelInfo;$/;"	m	struct:SatHelper	typeref:typename:std::set<ModelBlockInfo>	file:
modelValue	yosys/libs/minisat/Solver.h	/^inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver	typeref:typename:lbool
modelValue	yosys/libs/minisat/Solver.h	/^inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }$/;"	f	class:Minisat::Solver	typeref:typename:lbool
modelValues	yosys/passes/sat/sat.cc	/^	std::vector<bool> modelValues;$/;"	m	struct:SatHelper	typeref:typename:std::vector<bool>	file:
model_undef	yosys/kernel/satgen.h	/^	bool model_undef;$/;"	m	struct:SatGen	typeref:typename:bool
modexp	yosys/libs/bigint/BigIntegerAlgorithms.cc	/^BigUnsigned modexp(const BigInteger &base, const BigUnsigned &exponent,$/;"	f	typeref:typename:BigUnsigned
modinv	yosys/libs/bigint/BigIntegerAlgorithms.cc	/^BigUnsigned modinv(const BigInteger &x, const BigUnsigned &n) {$/;"	f	typeref:typename:BigUnsigned
modports_used_in_submodule	yosys/passes/hierarchy/hierarchy.cc	/^	dict<RTLIL::IdString, RTLIL::IdString>  modports_used_in_submodule;$/;"	m	struct:IFExpander	typeref:typename:dict<RTLIL::IdString,RTLIL::IdString>	file:
modtypes	yosys/libs/fst/fstapi.cc	/^static const char *modtypes[] = {"module",$/;"	v	typeref:typename:const char * []	file:
module	yosys/backends/aiger/aiger.cc	/^	Module *module;$/;"	m	struct:AigerWriter	typeref:typename:Module *	file:
module	yosys/backends/aiger/xaiger.cc	/^	Module *module;$/;"	m	struct:XAigerWriter	typeref:typename:Module *	file:
module	yosys/backends/blif/blif.cc	/^	RTLIL::Module *module;$/;"	m	struct:BlifDumper	typeref:typename:RTLIL::Module *	file:
module	yosys/backends/btor/btor.cc	/^	RTLIL::Module *module;$/;"	m	struct:BtorWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/backends/cxxrtl/cxxrtl.h	/^	module() {}$/;"	f	struct:cxxrtl::module
module	yosys/backends/cxxrtl/cxxrtl.h	/^	std::unique_ptr<cxxrtl::module> module;$/;"	m	struct:_cxxrtl_toplevel	typeref:typename:std::unique_ptr<cxxrtl::module>
module	yosys/backends/cxxrtl/cxxrtl.h	/^struct module {$/;"	s	namespace:cxxrtl
module	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^	std::unique_ptr<cxxrtl::module> module;$/;"	m	struct:_cxxrtl_handle	typeref:typename:std::unique_ptr<cxxrtl::module>	file:
module	yosys/backends/firrtl/firrtl.cc	/^	Module *module;$/;"	m	struct:FirrtlWorker	typeref:typename:Module *	file:
module	yosys/backends/json/json.cc	/^	Module *module;$/;"	m	struct:JsonWriter	typeref:typename:Module *	file:
module	yosys/backends/simplec/simplec.cc	/^	Module *module;$/;"	m	struct:HierDirtyFlags	typeref:typename:Module *	file:
module	yosys/backends/smt2/smt2.cc	/^	RTLIL::Module *module;$/;"	m	struct:Smt2Worker	typeref:typename:RTLIL::Module *	file:
module	yosys/backends/smv/smv.cc	/^	RTLIL::Module *module;$/;"	m	struct:SmvWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/frontends/aiger/aigerparse.cc	/^	RTLIL::Module *module;$/;"	m	struct:ConstEvalAig	typeref:typename:RTLIL::Module *	file:
module	yosys/frontends/aiger/aigerparse.h	/^    RTLIL::Module *module;$/;"	m	struct:AigerReader	typeref:typename:RTLIL::Module *
module	yosys/frontends/verific/verific.h	/^	RTLIL::Module *module = nullptr;$/;"	m	struct:VerificClocking	typeref:typename:RTLIL::Module *
module	yosys/frontends/verific/verific.h	/^	RTLIL::Module *module;$/;"	m	struct:VerificImporter	typeref:typename:RTLIL::Module *
module	yosys/frontends/verific/verificsva.cc	/^	Module *module = nullptr;$/;"	m	struct:VerificSvaImporter	typeref:typename:Module *	file:
module	yosys/frontends/verific/verificsva.cc	/^	Module *module;$/;"	m	struct:SvaFsm	typeref:typename:Module *	file:
module	yosys/kernel/consteval.h	/^	RTLIL::Module *module;$/;"	m	struct:ConstEval	typeref:typename:RTLIL::Module *
module	yosys/kernel/ff.h	/^	Module *module;$/;"	m	struct:FfData	typeref:typename:Module *
module	yosys/kernel/ffmerge.h	/^	RTLIL::Module *module;$/;"	m	struct:FfMergeHelper	typeref:typename:RTLIL::Module *
module	yosys/kernel/mem.h	/^	Module *module;$/;"	m	struct:Mem	typeref:typename:Module *
module	yosys/kernel/modtools.h	/^	RTLIL::Module *module;$/;"	m	struct:ModIndex	typeref:typename:RTLIL::Module *
module	yosys/kernel/modtools.h	/^	RTLIL::Module *module;$/;"	m	struct:ModWalker	typeref:typename:RTLIL::Module *
module	yosys/kernel/rtlil.cc	/^		RTLIL::Module *module;$/;"	m	struct:RTLIL::Module::remove::DeleteWireWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/kernel/rtlil.cc	/^		RTLIL::Module *module;$/;"	m	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:RTLIL::Module *	file:
module	yosys/kernel/rtlil.cc	/^RTLIL::Module *RTLIL::Design::module(RTLIL::IdString name)$/;"	f	class:RTLIL::Design	typeref:typename:RTLIL::Module *
module	yosys/kernel/rtlil.cc	/^const RTLIL::Module *RTLIL::Design::module(RTLIL::IdString name) const$/;"	f	class:RTLIL::Design	typeref:typename:const RTLIL::Module *
module	yosys/kernel/rtlil.h	/^	RTLIL::Module *module;$/;"	m	struct:RTLIL::Cell	typeref:typename:RTLIL::Module *
module	yosys/kernel/rtlil.h	/^	RTLIL::Module *module;$/;"	m	struct:RTLIL::Process	typeref:typename:RTLIL::Module *
module	yosys/kernel/rtlil.h	/^	RTLIL::Module *module;$/;"	m	struct:RTLIL::Wire	typeref:typename:RTLIL::Module *
module	yosys/passes/cmds/glift.cc	/^	RTLIL::Module *module = nullptr;$/;"	m	struct:GliftWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/cmds/ltp.cc	/^	RTLIL::Module *module;$/;"	m	struct:LtpWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/cmds/qwp.cc	/^	Module *module;$/;"	m	struct:QwpWorker	typeref:typename:Module *	file:
module	yosys/passes/cmds/scc.cc	/^	RTLIL::Module *module;$/;"	m	struct:SccWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/cmds/show.cc	/^	RTLIL::Module *module;$/;"	m	struct:ShowWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/cmds/splice.cc	/^	RTLIL::Module *module;$/;"	m	struct:SpliceWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/cmds/sta.cc	/^	Module *module;$/;"	m	struct:StaWorker	typeref:typename:Module *	file:
module	yosys/passes/equiv/equiv_induct.cc	/^	Module *module;$/;"	m	struct:EquivInductWorker	typeref:typename:Module *	file:
module	yosys/passes/equiv/equiv_mark.cc	/^	Module *module;$/;"	m	struct:EquivMarkWorker	typeref:typename:Module *	file:
module	yosys/passes/equiv/equiv_purge.cc	/^	Module *module;$/;"	m	struct:EquivPurgeWorker	typeref:typename:Module *	file:
module	yosys/passes/equiv/equiv_simple.cc	/^	Module *module;$/;"	m	struct:EquivSimpleWorker	typeref:typename:Module *	file:
module	yosys/passes/equiv/equiv_struct.cc	/^	Module *module;$/;"	m	struct:EquivStructWorker	typeref:typename:Module *	file:
module	yosys/passes/fsm/fsm_detect.cc	/^static RTLIL::Module *module;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN RTLIL::Module *	file:
module	yosys/passes/fsm/fsm_expand.cc	/^	RTLIL::Module *module;$/;"	m	struct:FsmExpand	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/fsm/fsm_extract.cc	/^static RTLIL::Module *module;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN RTLIL::Module *	file:
module	yosys/passes/fsm/fsm_opt.cc	/^	RTLIL::Module *module;$/;"	m	struct:FsmOpt	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/hierarchy/hierarchy.cc	/^	RTLIL::Module                          &module;$/;"	m	struct:IFExpander	typeref:typename:RTLIL::Module &	file:
module	yosys/passes/hierarchy/submod.cc	/^	RTLIL::Module *module;$/;"	m	struct:SubmodWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/memory/memory_dff.cc	/^	Module *module;$/;"	m	struct:MemoryDffWorker	typeref:typename:Module *	file:
module	yosys/passes/memory/memory_map.cc	/^	RTLIL::Module *module;$/;"	m	struct:MemoryMapWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/memory/memory_share.cc	/^	RTLIL::Module *module;$/;"	m	struct:MemoryShareWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/opt/muxpack.cc	/^	Module *module;$/;"	m	struct:ExclusiveDatabase	typeref:typename:Module *	file:
module	yosys/passes/opt/muxpack.cc	/^	Module *module;$/;"	m	struct:MuxpackWorker	typeref:typename:Module *	file:
module	yosys/passes/opt/opt_dff.cc	/^	Module *module;$/;"	m	struct:OptDffWorker	typeref:typename:Module *	file:
module	yosys/passes/opt/opt_lut.cc	/^	RTLIL::Module *module;$/;"	m	struct:OptLutWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/opt/opt_mem_feedback.cc	/^	RTLIL::Module *module;$/;"	m	struct:OptMemFeedbackWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/opt/opt_merge.cc	/^	RTLIL::Module *module;$/;"	m	struct:OptMergeWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/opt/opt_muxtree.cc	/^	RTLIL::Module *module;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/opt/opt_reduce.cc	/^	RTLIL::Module *module;$/;"	m	struct:OptReduceWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/opt/pmux2shiftx.cc	/^	Module *module;$/;"	m	struct:OnehotDatabase	typeref:typename:Module *	file:
module	yosys/passes/opt/share.cc	/^	RTLIL::Module *module;$/;"	m	struct:ShareWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/opt/wreduce.cc	/^	Module *module;$/;"	m	struct:WreduceWorker	typeref:typename:Module *	file:
module	yosys/passes/proc/proc_dlatch.cc	/^	Module *module;$/;"	m	struct:proc_dlatch_db_t	typeref:typename:Module *	file:
module	yosys/passes/proc/proc_prune.cc	/^	RTLIL::Module *module;$/;"	m	struct:PruneWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/sat/assertpmux.cc	/^	Module *module;$/;"	m	struct:AssertpmuxWorker	typeref:typename:Module *	file:
module	yosys/passes/sat/fmcombine.cc	/^	Module *module = nullptr;$/;"	m	struct:FmcombineWorker	typeref:typename:Module *	file:
module	yosys/passes/sat/freduce.cc	/^	RTLIL::Module *module;$/;"	m	struct:FreduceWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/sat/mutate.cc	/^	IdString module, cell, port, wire;$/;"	m	struct:mutate_opts_t	typeref:typename:IdString	file:
module	yosys/passes/sat/mutate.cc	/^	IdString module, cell;$/;"	m	struct:mutate_t	typeref:typename:IdString	file:
module	yosys/passes/sat/sat.cc	/^	RTLIL::Module *module;$/;"	m	struct:SatHelper	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/sat/sim.cc	/^	Module *module;$/;"	m	struct:SimInstance	typeref:typename:Module *	file:
module	yosys/passes/techmap/abc.cc	/^RTLIL::Module *module;$/;"	v	typeref:typename:RTLIL::Module *
module	yosys/passes/techmap/alumacc.cc	/^	RTLIL::Module *module;$/;"	m	struct:AlumaccWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/techmap/extract_fa.cc	/^	Module *module;$/;"	m	struct:ExtractFaWorker	typeref:typename:Module *	file:
module	yosys/passes/techmap/flowmap.cc	/^	RTLIL::Module *module;$/;"	m	struct:FlowmapWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/techmap/hilomap.cc	/^static RTLIL::Module *module;$/;"	v	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/techmap/maccmap.cc	/^	RTLIL::Module *module;$/;"	m	struct:MaccmapWorker	typeref:typename:RTLIL::Module *	file:
module	yosys/passes/techmap/muxcover.cc	/^	Module *module;$/;"	m	struct:MuxcoverWorker	typeref:typename:Module *	file:
module	yosys/passes/techmap/nlutmap.cc	/^	Module *module;$/;"	m	struct:NlutmapWorker	typeref:typename:Module *	file:
module	yosys/passes/techmap/shregmap.cc	/^	Module *module;$/;"	m	struct:ShregmapWorker	typeref:typename:Module *	file:
module	yosys/passes/techmap/tribuf.cc	/^	Module *module;$/;"	m	struct:TribufWorker	typeref:typename:Module *	file:
module2graph	yosys/passes/techmap/extract.cc	/^bool module2graph(SubCircuit::Graph &graph, RTLIL::Module *mod, bool constports, RTLIL::Design */;"	f	typeref:typename:bool
module_	yosys/backends/protobuf/protobuf.cc	/^	Module *module_;$/;"	m	struct:ProtobufDesignSerializer	typeref:typename:Module *	file:
module_has_scc	yosys/passes/opt/share.cc	/^	bool module_has_scc()$/;"	f	struct:ShareWorker	typeref:typename:bool	file:
module_names	yosys/passes/sat/eval.cc	/^	std::vector<std::string> module_names;$/;"	m	struct:VlogHammerReporter	typeref:typename:std::vector<std::string>	file:
module_queue	yosys/passes/techmap/clkbufmap.cc	/^	void module_queue(Design *design, Module *module, std::vector<Module *> &modules_sorted, pool<M/;"	f	struct:ClkbufmapPass	typeref:typename:void	file:
module_queue	yosys/passes/techmap/iopadmap.cc	/^	void module_queue(Design *design, Module *module, std::vector<Module *> &modules_sorted, pool<M/;"	f	struct:IopadmapPass	typeref:typename:void	file:
module_queue	yosys/passes/techmap/techmap.cc	/^	pool<RTLIL::Module*> module_queue;$/;"	m	struct:TechmapWorker	typeref:typename:pool<RTLIL::Module * >	file:
modules	yosys/kernel/rtlil.cc	/^RTLIL::ObjRange<RTLIL::Module*> RTLIL::Design::modules()$/;"	f	class:RTLIL::Design	typeref:typename:RTLIL::ObjRange<RTLIL::Module * >
modules	yosys/passes/sat/eval.cc	/^	std::vector<RTLIL::Module*> modules;$/;"	m	struct:VlogHammerReporter	typeref:typename:std::vector<RTLIL::Module * >	file:
modules_	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, RTLIL::Module*> modules_;$/;"	m	struct:RTLIL::Design	typeref:typename:dict<RTLIL::IdString,RTLIL::Module * >
modwalker	yosys/kernel/qcsat.h	/^	ModWalker &modwalker;$/;"	m	struct:QuickConeSat	typeref:typename:ModWalker &
modwalker	yosys/passes/memory/memory_dff.cc	/^	ModWalker modwalker;$/;"	m	struct:MemoryDffWorker	typeref:typename:ModWalker	file:
modwalker	yosys/passes/memory/memory_share.cc	/^	ModWalker modwalker;$/;"	m	struct:MemoryShareWorker	typeref:typename:ModWalker	file:
modwalker	yosys/passes/opt/share.cc	/^	ModWalker modwalker;$/;"	m	struct:ShareWorker	typeref:typename:ModWalker	file:
monitors	yosys/kernel/rtlil.h	/^	pool<RTLIL::Monitor*> monitors;$/;"	m	struct:RTLIL::Design	typeref:typename:pool<RTLIL::Monitor * >
monitors	yosys/kernel/rtlil.h	/^	pool<RTLIL::Monitor*> monitors;$/;"	m	struct:RTLIL::Module	typeref:typename:pool<RTLIL::Monitor * >
moveTo	yosys/libs/minisat/Alloc.h	/^    void     moveTo(RegionAllocator& to) {$/;"	f	class:Minisat::RegionAllocator	typeref:typename:void
moveTo	yosys/libs/minisat/IntMap.h	/^        void     moveTo (IntMap& to)           { map.moveTo(to.map); to.index = index; }$/;"	f	class:Minisat::IntMap	typeref:typename:void
moveTo	yosys/libs/minisat/Map.h	/^    void moveTo(Map& other){$/;"	f	class:Minisat::Map	typeref:typename:void
moveTo	yosys/libs/minisat/SolverTypes.h	/^    void moveTo(CMap& other){ map.moveTo(other.map); }$/;"	f	class:Minisat::CMap	typeref:typename:void
moveTo	yosys/libs/minisat/SolverTypes.h	/^    void moveTo(ClauseAllocator& to){$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:void
moveTo	yosys/libs/minisat/Vec.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap/;"	f	class:Minisat::vec	typeref:typename:void
mrproper	yosys/Makefile	/^mrproper: clean$/;"	t
ms_expr	yosys/backends/cxxrtl/cxxrtl.h	/^	T &ms_expr;$/;"	m	struct:cxxrtl::concat_expr	typeref:typename:T &
msb_mask	yosys/backends/cxxrtl/cxxrtl.h	/^	static constexpr chunk::type msb_mask = (Bits % chunk::bits == 0) ? chunk::mask$/;"	m	struct:cxxrtl::value	typeref:typename:chunk::type
msg_func	yosys/frontends/verific/verific.cc	/^void msg_func(msg_type_t msg_type, const char *message_id, linefile_type linefile, const char *m/;"	f	typeref:typename:void
mul	yosys/backends/cxxrtl/cxxrtl.h	/^	value<ResultBits> mul(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<ResultBits>
mul_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> mul_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
mul_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> mul_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
mulshift.pdf	yosys/manual/PRESENTATION_ExAdv/Makefile	/^mulshift.pdf: mulshift_*$/;"	t
multiclock	yosys/passes/equiv/equiv_opt.cc	/^	bool assert, undef, multiclock, async2sync;$/;"	m	struct:EquivOptPass	typeref:typename:bool	file:
multiclock	yosys/passes/sat/sim.cc	/^	bool multiclock = false;$/;"	m	struct:SimShared	typeref:typename:bool	file:
multiply	yosys/libs/bigint/BigInteger.cc	/^void BigInteger::multiply(const BigInteger &a, const BigInteger &b) {$/;"	f	class:BigInteger	typeref:typename:void
multiply	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::multiply(const BigUnsigned &a, const BigUnsigned &b) {$/;"	f	class:BigUnsigned	typeref:typename:void
multiply_by_const	yosys/frontends/ast/simplify.cc	/^static AstNode *multiply_by_const(AstNode *expr_node, int stride)$/;"	f	typeref:typename:AstNode *	file:
multirange_dimensions	yosys/frontends/ast/ast.h	/^		std::vector<int> multirange_dimensions;$/;"	m	struct:AST::AstNode	typeref:typename:std::vector<int>
multirange_swapped	yosys/frontends/ast/ast.h	/^		std::vector<bool> multirange_swapped; \/\/ true if range is swapped, not used for structs$/;"	m	struct:AST::AstNode	typeref:typename:std::vector<bool>
mutate_chain_queue_t	yosys/passes/sat/mutate.cc	/^struct mutate_chain_queue_t$/;"	s	file:
mutate_cnot	yosys/passes/sat/mutate.cc	/^void mutate_cnot(Design *design, const mutate_opts_t &opts, bool one)$/;"	f	typeref:typename:void
mutate_const	yosys/passes/sat/mutate.cc	/^void mutate_const(Design *design, const mutate_opts_t &opts, bool one)$/;"	f	typeref:typename:void
mutate_ctrl	yosys/passes/sat/mutate.cc	/^SigBit mutate_ctrl(Module *module, const mutate_opts_t &opts)$/;"	f	typeref:typename:SigBit
mutate_ctrl_mux	yosys/passes/sat/mutate.cc	/^SigSpec mutate_ctrl_mux(Module *module, const mutate_opts_t &opts, SigSpec unchanged_sig, SigSpe/;"	f	typeref:typename:SigSpec
mutate_ctrl_sig	yosys/passes/sat/mutate.cc	/^SigSpec mutate_ctrl_sig(Module *module, IdString name, int width)$/;"	f	typeref:typename:SigSpec
mutate_inv	yosys/passes/sat/mutate.cc	/^void mutate_inv(Design *design, const mutate_opts_t &opts)$/;"	f	typeref:typename:void
mutate_list	yosys/passes/sat/mutate.cc	/^void mutate_list(Design *design, const mutate_opts_t &opts, const string &filename, const string/;"	f	typeref:typename:void
mutate_once_queue_t	yosys/passes/sat/mutate.cc	/^struct mutate_once_queue_t$/;"	s	file:
mutate_opts_t	yosys/passes/sat/mutate.cc	/^struct mutate_opts_t {$/;"	s	file:
mutate_queue_t	yosys/passes/sat/mutate.cc	/^struct mutate_queue_t$/;"	s	file:
mutate_t	yosys/passes/sat/mutate.cc	/^struct mutate_t {$/;"	s	file:
mutex	yosys/libs/fst/fstapi.cc	/^    pthread_mutex_t mutex;$/;"	m	struct:fstWriterContext	typeref:typename:pthread_mutex_t	file:
mux	yosys/kernel/satgen.h	/^	std::pair<std::vector<int>, std::vector<int>> mux(int s, int undef_s, const std::vector<int> &a/;"	f	struct:SatGen	typeref:typename:std::pair<std::vector<int>,std::vector<int>>
mux	yosys/passes/opt/opt_share.cc	/^	RTLIL::Cell *mux;$/;"	m	struct:OpMuxConn	typeref:typename:RTLIL::Cell *	file:
mux	yosys/passes/opt/opt_share.cc	/^	RTLIL::Cell *mux;$/;"	m	struct:__anonade320d40208	typeref:typename:RTLIL::Cell *	file:
mux2info	yosys/passes/opt/opt_muxtree.cc	/^	vector<muxinfo_t> mux2info;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:vector<muxinfo_t>	file:
mux2rtlil	yosys/frontends/ast/genrtlil.cc	/^static RTLIL::SigSpec mux2rtlil(AstNode *that, const RTLIL::SigSpec &cond, const RTLIL::SigSpec /;"	f	typeref:typename:RTLIL::SigSpec	file:
mux_count	yosys/passes/opt/muxpack.cc	/^	int mux_count, pmux_count;$/;"	m	struct:MuxpackWorker	typeref:typename:int	file:
mux_drivers	yosys/passes/opt/opt_muxtree.cc	/^		pool<int> mux_drivers;$/;"	m	struct:OptMuxtreeWorker::bitinfo_t	typeref:typename:pool<int>	file:
mux_drivers	yosys/passes/proc/proc_dlatch.cc	/^	dict<SigBit, pair<Cell*, int>> mux_drivers;$/;"	m	struct:proc_dlatch_db_t	typeref:typename:dict<SigBit,pair<Cell *,int>>	file:
mux_gate	yosys/kernel/cellaigs.cc	/^	int mux_gate(int A, int B, int S)$/;"	f	struct:AigMaker	typeref:typename:int	file:
mux_op	yosys/kernel/celledges.cc	/^void mux_op(AbstractCellEdgesDatabase *db, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
mux_port_id	yosys/passes/opt/opt_share.cc	/^	int mux_port_id;$/;"	m	struct:OpMuxConn	typeref:typename:int	file:
mux_port_offset	yosys/passes/opt/opt_share.cc	/^	int mux_port_offset;$/;"	m	struct:OpMuxConn	typeref:typename:int	file:
mux_srcbits	yosys/passes/proc/proc_dlatch.cc	/^	dict<Cell*, vector<SigBit>> mux_srcbits;$/;"	m	struct:proc_dlatch_db_t	typeref:typename:dict<Cell *,vector<SigBit>>	file:
mux_users	yosys/passes/opt/opt_muxtree.cc	/^		pool<int> mux_users;$/;"	m	struct:OptMuxtreeWorker::bitinfo_t	typeref:typename:pool<int>	file:
muxes	yosys/passes/techmap/muxcover.cc	/^		dict<SigBit, Cell*> muxes;$/;"	m	struct:MuxcoverWorker::tree_t	typeref:typename:dict<SigBit,Cell * >	file:
muxinfo_t	yosys/passes/opt/opt_muxtree.cc	/^	struct muxinfo_t {$/;"	s	struct:OptMuxtreeWorker	file:
muxport_actsignal	yosys/passes/sat/assertpmux.cc	/^	dict<tuple<Cell*, int>, SigBit> muxport_actsignal;$/;"	m	struct:AssertpmuxWorker	typeref:typename:dict<tuple<Cell *,int>,SigBit>	file:
muxtree_cells	yosys/passes/fsm/fsm_detect.cc	/^static std::set<RTLIL::Cell*> muxtree_cells;$/;"	v	typeref:typename:std::set<RTLIL::Cell * >	file:
mxebin	yosys/Makefile	/^mxebin: $(TARGETS) $(EXTRA_TARGETS)$/;"	t
my_clog2	yosys/libs/ezsat/ezsat.cc	/^static int my_clog2(int x)$/;"	f	typeref:typename:int	file:
my_cmd.so	yosys/manual/PRESENTATION_Prog/Makefile	/^my_cmd.so: my_cmd.cc$/;"	t
my_decimal_div_by_two	yosys/frontends/verilog/const2ast.cc	/^static int my_decimal_div_by_two(std::vector<uint8_t> &digits)$/;"	f	typeref:typename:int	file:
my_ilog2	yosys/frontends/verilog/const2ast.cc	/^static int my_ilog2(int x)$/;"	f	typeref:typename:int	file:
my_int_to_string	yosys/libs/ezsat/ezsat.cc	/^static std::string my_int_to_string(int i)$/;"	f	typeref:typename:std::string	file:
my_printf	yosys/libs/subcircuit/subcircuit.cc	/^#  define my_printf /;"	d	file:
my_stringf	yosys/libs/subcircuit/subcircuit.cc	/^#  define my_stringf /;"	d	file:
my_stringf	yosys/libs/subcircuit/subcircuit.cc	/^static std::string my_stringf(const char *fmt, ...)$/;"	f	typeref:typename:std::string	file:
my_strtobin	yosys/frontends/verilog/const2ast.cc	/^static void my_strtobin(std::vector<RTLIL::State> &data, const char *str, int len_in_bits, int b/;"	f	typeref:typename:void	file:
my_xorshift32_rng	yosys/passes/cmds/select.cc	/^static int my_xorshift32_rng() {$/;"	f	typeref:typename:int	file:
mymul.pdf	yosys/manual/PRESENTATION_ExAdv/Makefile	/^mymul.pdf: mymul_*$/;"	t
nAssigns	yosys/libs/minisat/Solver.h	/^inline int      Solver::nAssigns      ()      const   { return trail.size(); }$/;"	f	class:Minisat::Solver	typeref:typename:int
nClauses	yosys/libs/minisat/Solver.h	/^inline int      Solver::nClauses      ()      const   { return num_clauses; }$/;"	f	class:Minisat::Solver	typeref:typename:int
nFreeVars	yosys/libs/minisat/Solver.h	/^inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size()/;"	f	class:Minisat::Solver	typeref:typename:int
nLearnts	yosys/libs/minisat/Solver.h	/^inline int      Solver::nLearnts      ()      const   { return num_learnts; }$/;"	f	class:Minisat::Solver	typeref:typename:int
nVars	yosys/libs/minisat/Solver.h	/^inline int      Solver::nVars         ()      const   { return next_var; }$/;"	f	class:Minisat::Solver	typeref:typename:int
n_occ	yosys/libs/minisat/SimpSolver.h	/^        const LMap<int>& n_occ;$/;"	m	struct:Minisat::SimpSolver::ElimLt	typeref:typename:const LMap<int> &
n_occ	yosys/libs/minisat/SimpSolver.h	/^    LMap<int>           n_occ;$/;"	m	class:Minisat::SimpSolver	typeref:typename:LMap<int>
n_touched	yosys/libs/minisat/SimpSolver.h	/^    int                 n_touched;$/;"	m	class:Minisat::SimpSolver	typeref:typename:int
name	yosys/frontends/rpc/rpc_frontend.cc	/^	std::string name;$/;"	m	struct:RpcServer	typeref:typename:std::string	file:
name	yosys/frontends/verilog/preproc.cc	/^	std::string name;$/;"	m	struct:macro_arg_t	typeref:typename:std::string	file:
name	yosys/kernel/cellaigs.h	/^	string name;$/;"	m	struct:Aig	typeref:typename:string
name	yosys/kernel/ff.h	/^	IdString name;$/;"	m	struct:FfData	typeref:typename:IdString
name	yosys/kernel/fstdata.h	/^	std::string name;$/;"	m	struct:FstVar	typeref:typename:std::string
name	yosys/kernel/rtlil.h	/^	RTLIL::IdString name;$/;"	m	struct:RTLIL::Cell	typeref:typename:RTLIL::IdString
name	yosys/kernel/rtlil.h	/^	RTLIL::IdString name;$/;"	m	struct:RTLIL::Memory	typeref:typename:RTLIL::IdString
name	yosys/kernel/rtlil.h	/^	RTLIL::IdString name;$/;"	m	struct:RTLIL::Module	typeref:typename:RTLIL::IdString
name	yosys/kernel/rtlil.h	/^	RTLIL::IdString name;$/;"	m	struct:RTLIL::Process	typeref:typename:RTLIL::IdString
name	yosys/kernel/rtlil.h	/^	RTLIL::IdString name;$/;"	m	struct:RTLIL::Wire	typeref:typename:RTLIL::IdString
name	yosys/kernel/satgen.h	/^	string name;$/;"	m	struct:SatSolver	typeref:typename:string
name	yosys/kernel/timinginfo.h	/^		RTLIL::IdString name;$/;"	m	struct:TimingInfo::NameBit	typeref:typename:RTLIL::IdString
name	yosys/libs/ezsat/ezsat.h	/^		std::string name;$/;"	m	struct:ezSAT::_V	typeref:typename:std::string
name	yosys/libs/fst/fstapi.h	/^            const char *name;$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierAttr	typeref:typename:const char *
name	yosys/libs/fst/fstapi.h	/^            const char *name;$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierScope	typeref:typename:const char *
name	yosys/libs/fst/fstapi.h	/^            const char *name;$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierVar	typeref:typename:const char *
name	yosys/libs/fst/fstapi.h	/^    char *name;$/;"	m	struct:fstETab	typeref:typename:char *
name	yosys/libs/minisat/Options.h	/^    const char* name;$/;"	m	class:Minisat::Option	typeref:typename:const char *
name	yosys/passes/cmds/setattr.cc	/^	RTLIL::IdString name;$/;"	m	struct:setunset_t	typeref:typename:RTLIL::IdString	file:
name	yosys/passes/hierarchy/submod.cc	/^		std::string name, full_name;$/;"	m	struct:SubmodWorker::SubModule	typeref:typename:std::string	file:
name	yosys/passes/memory/memory_bram.cc	/^		IdString name;$/;"	m	struct:rules_t::bram_t	typeref:typename:IdString	file:
name	yosys/passes/memory/memory_bram.cc	/^		IdString name;$/;"	m	struct:rules_t::match_t	typeref:typename:IdString	file:
name	yosys/passes/sat/sim.cc	/^	IdString name() const$/;"	f	struct:SimInstance	typeref:typename:IdString	file:
name	yosys/passes/techmap/abc9_ops.cc	/^		IdString name;$/;"	m	struct:prep_lut::t_lut	typeref:typename:IdString	file:
name	yosys/passes/techmap/attrmap.cc	/^	string name, value;$/;"	m	struct:AttrmapRemove	typeref:typename:string	file:
name	yosys/passes/techmap/attrmap.cc	/^	string name;$/;"	m	struct:AttrmapTocase	typeref:typename:string	file:
name_cnt	yosys/passes/equiv/equiv_purge.cc	/^	int name_cnt;$/;"	m	struct:EquivPurgeWorker	typeref:typename:int	file:
name_has_dot	yosys/frontends/ast/simplify.cc	/^static bool name_has_dot(const std::string &name, std::string &struct_name)$/;"	f	typeref:typename:bool	file:
name_length	yosys/libs/fst/fstapi.h	/^            uint32_t name_length;      \/* strlen(u.scope.name) *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierScope	typeref:typename:uint32_t
name_length	yosys/libs/fst/fstapi.h	/^            uint32_t name_length;   \/* strlen(u.attr.name) *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierAttr	typeref:typename:uint32_t
name_length	yosys/libs/fst/fstapi.h	/^            uint32_t name_length; \/* strlen(u.var.name) *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierVar	typeref:typename:uint32_t
name_map	yosys/backends/edif/edif.cc	/^	std::map<std::string, std::string> name_map;$/;"	m	struct:EdifNames	typeref:typename:std::map<std::string,std::string>	file:
name_to_handle	yosys/kernel/fstdata.h	/^	std::map<std::string, fstHandle> name_to_handle;$/;"	m	class:FstData	typeref:typename:std::map<std::string,fstHandle>
name_to_pos	yosys/frontends/verilog/preproc.cc	/^	std::map<std::string, int> name_to_pos;$/;"	m	struct:arg_map_t	typeref:typename:std::map<std::string,int>	file:
namecache	yosys/backends/firrtl/firrtl.cc	/^dict<IdString, string> namecache;$/;"	v	typeref:typename:dict<IdString,string>
nan	yosys/libs/fst/fstapi.cc	/^    double nan; \/* nan value for uninitialized doubles *\/$/;"	m	struct:fstWriterContext	typeref:typename:double	file:
nand_gate	yosys/kernel/cellaigs.cc	/^	int nand_gate(int A, int B)$/;"	f	struct:AigMaker	typeref:typename:int	file:
narrow	yosys/kernel/mem.cc	/^void Mem::narrow() {$/;"	f	class:Mem	typeref:typename:void
native_doubles_for_cb	yosys/libs/fst/fstapi.cc	/^    unsigned native_doubles_for_cb : 1;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
ne_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> ne_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
ne_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> ne_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
needleGraphId	yosys/libs/subcircuit/subcircuit.h	/^			std::string needleGraphId, haystackGraphId;$/;"	m	struct:SubCircuit::Solver::Result	typeref:typename:std::string
needleNodeId	yosys/libs/subcircuit/subcircuit.h	/^			std::string needleNodeId, haystackNodeId;$/;"	m	struct:SubCircuit::Solver::ResultNodeMapping	typeref:typename:std::string
needleUserData	yosys/libs/subcircuit/subcircuit.h	/^			void *needleUserData, *haystackUserData;$/;"	m	struct:SubCircuit::Solver::ResultNodeMapping	typeref:typename:void *
neg	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> neg() const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
neg_s	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> neg_s(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
neg_u	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> neg_u(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
negate	yosys/libs/bigint/BigInteger.cc	/^void BigInteger::negate(const BigInteger &a) {$/;"	f	class:BigInteger	typeref:typename:void
negative	yosys/libs/bigint/BigInteger.hh	/^	enum Sign { negative = -1, zero = 0, positive = 1 };$/;"	e	enum:BigInteger::Sign
net_conn	yosys/passes/cmds/show.cc	/^	struct net_conn { std::set<std::pair<std::string, int>> in, out; std::string color; };$/;"	s	struct:ShowWorker	file:
net_conn_map	yosys/passes/cmds/show.cc	/^	std::map<std::string, net_conn> net_conn_map;$/;"	m	struct:ShowWorker	typeref:typename:std::map<std::string,net_conn>	file:
net_level_up_drive_down	yosys/frontends/verific/verific.cc	/^	std::map<Net*, Net*> net_level_up_drive_down;$/;"	m	struct:VerificExtNets	typeref:typename:std::map<Net *,Net * >	file:
net_level_up_drive_up	yosys/frontends/verific/verific.cc	/^	std::map<Net*, Net*> net_level_up_drive_up;$/;"	m	struct:VerificExtNets	typeref:typename:std::map<Net *,Net * >	file:
net_map	yosys/frontends/verific/verific.h	/^	std::map<Verific::Net*, RTLIL::SigBit> net_map;$/;"	m	struct:VerificImporter	typeref:typename:std::map<Verific::Net *,RTLIL::SigBit>
net_map_at	yosys/frontends/verific/verific.cc	/^RTLIL::SigBit VerificImporter::net_map_at(Net *net)$/;"	f	class:VerificImporter	typeref:typename:RTLIL::SigBit
net_to_ast_driver	yosys/frontends/verific/verificsva.cc	/^	Instance *net_to_ast_driver(Net *n)$/;"	f	struct:VerificSvaImporter	typeref:typename:Instance *	file:
netlist	yosys/frontends/verific/verific.h	/^	Verific::Netlist *netlist;$/;"	m	struct:VerificImporter	typeref:typename:Verific::Netlist *
netlist	yosys/frontends/verific/verificsva.cc	/^	Netlist *netlist = nullptr;$/;"	m	struct:VerificSvaImporter	typeref:typename:Netlist *	file:
netname	yosys/backends/intersynth/intersynth.cc	/^static std::string netname(std::set<std::string> &conntypes_code, std::set<std::string> &celltyp/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN std::string	file:
newDecisionLevel	yosys/libs/minisat/Solver.h	/^inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); /;"	f	class:Minisat::Solver	typeref:typename:void
newVar	yosys/libs/minisat/SimpSolver.cc	/^Var SimpSolver::newVar(lbool upol, bool dvar) {$/;"	f	class:SimpSolver	typeref:typename:Var
newVar	yosys/libs/minisat/Solver.cc	/^Var Solver::newVar(lbool upol, bool dvar)$/;"	f	class:Solver	typeref:typename:Var
new_connections	yosys/kernel/rtlil.cc	/^void RTLIL::Module::new_connections(const std::vector<RTLIL::SigSig> &new_conn)$/;"	f	class:RTLIL::Module	typeref:typename:void
new_id	yosys/kernel/yosys.cc	/^RTLIL::IdString new_id(std::string file, int line, std::string func)$/;"	f	typeref:typename:RTLIL::IdString
new_id_suffix	yosys/kernel/yosys.cc	/^RTLIL::IdString new_id_suffix(std::string file, int line, std::string func, std::string suffix)$/;"	f	typeref:typename:RTLIL::IdString
new_name	yosys/passes/techmap/attrmap.cc	/^	string old_name, new_name;$/;"	m	struct:AttrmapMap	typeref:typename:string	file:
new_name	yosys/passes/techmap/attrmap.cc	/^	string old_name, new_name;$/;"	m	struct:AttrmapRename	typeref:typename:string	file:
new_taint_outputs	yosys/passes/cmds/glift.cc	/^	std::vector<RTLIL::Wire *> new_taint_outputs;$/;"	m	struct:GliftWorker	typeref:typename:std::vector<RTLIL::Wire * >	file:
new_temp_count	yosys/frontends/ast/genrtlil.cc	/^	std::map<RTLIL::Wire*, int> new_temp_count;$/;"	m	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:std::map<RTLIL::Wire *,int>	file:
new_temp_signal	yosys/frontends/ast/genrtlil.cc	/^	RTLIL::SigSpec new_temp_signal(RTLIL::SigSpec sig)$/;"	f	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:RTLIL::SigSpec	file:
new_value	yosys/passes/techmap/attrmap.cc	/^	string old_value, new_value;$/;"	m	struct:AttrmapMap	typeref:typename:string	file:
new_verific_id	yosys/frontends/verific/verific.cc	/^RTLIL::IdString VerificImporter::new_verific_id(Verific::DesignObj *obj)$/;"	f	class:VerificImporter	typeref:typename:RTLIL::IdString
new_wire	yosys/passes/hierarchy/submod.cc	/^		RTLIL::Wire *new_wire;$/;"	m	struct:SubmodWorker::wire_flags_t	typeref:typename:RTLIL::Wire *	file:
newline	yosys/Makefile	/^define newline$/;"	m
newmux_t	yosys/passes/techmap/muxcover.cc	/^		newmux_t() : cost(0) {}$/;"	f	struct:MuxcoverWorker::newmux_t	file:
newmux_t	yosys/passes/techmap/muxcover.cc	/^	struct newmux_t$/;"	s	struct:MuxcoverWorker	file:
newmuxes	yosys/passes/techmap/muxcover.cc	/^		dict<SigBit, newmux_t> newmuxes;$/;"	m	struct:MuxcoverWorker::tree_t	typeref:typename:dict<SigBit,newmux_t>	file:
nex_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> nex_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
nex_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> nex_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
next	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> next;$/;"	m	struct:cxxrtl::wire	typeref:typename:value<Bits>
next	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		Vertex *prev, *next;$/;"	m	struct:Scheduler::Vertex	typeref:typename:Vertex *	file:
next	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	uint32_t *next;$/;"	m	struct:cxxrtl_object	typeref:typename:uint32_t *
next	yosys/kernel/hashlib.h	/^		int next;$/;"	m	struct:hashlib::dict::entry_t	typeref:typename:int
next	yosys/kernel/hashlib.h	/^		int next;$/;"	m	struct:hashlib::pool::entry_t	typeref:typename:int
next	yosys/kernel/satgen.h	/^	SatSolver *next;$/;"	m	struct:SatSolver	typeref:typename:SatSolver *
next	yosys/libs/fst/fstapi.cc	/^    struct collchain_t *next;$/;"	m	struct:collchain_t	typeref:struct:collchain_t *	file:
next	yosys/libs/fst/fstapi.cc	/^    struct fstBlackoutChain *next;$/;"	m	struct:fstBlackoutChain	typeref:struct:fstBlackoutChain *	file:
next	yosys/passes/sat/mutate.cc	/^	void next() {$/;"	f	struct:xs128_t	typeref:typename:void	file:
nextColor	yosys/passes/cmds/show.cc	/^	std::string nextColor()$/;"	f	struct:ShowWorker	typeref:typename:std::string	file:
nextColor	yosys/passes/cmds/show.cc	/^	std::string nextColor(RTLIL::SigSpec sig, std::string defaultColor)$/;"	f	struct:ShowWorker	typeref:typename:std::string	file:
nextColor	yosys/passes/cmds/show.cc	/^	std::string nextColor(const RTLIL::SigSig &conn)$/;"	f	struct:ShowWorker	typeref:typename:std::string	file:
nextColor	yosys/passes/cmds/show.cc	/^	std::string nextColor(const RTLIL::SigSig &conn, std::string defaultColor)$/;"	f	struct:ShowWorker	typeref:typename:std::string	file:
nextColor	yosys/passes/cmds/show.cc	/^	std::string nextColor(const RTLIL::SigSpec &sig)$/;"	f	struct:ShowWorker	typeref:typename:std::string	file:
nextColor	yosys/passes/cmds/show.cc	/^	std::string nextColor(std::string presetColor)$/;"	f	struct:ShowWorker	typeref:typename:std::string	file:
next_args	yosys/kernel/register.cc	/^std::vector<std::string> Frontend::next_args;$/;"	m	class:Frontend	typeref:typename:std::vector<std::string>
next_args	yosys/kernel/register.h	/^	static std::vector<std::string> next_args;$/;"	m	struct:Frontend	typeref:typename:std::vector<std::string>
next_auto_id	yosys/backends/verilog/verilog_backend.cc	/^std::string next_auto_id()$/;"	f	typeref:typename:std::string
next_bit	yosys/passes/cmds/setundef.cc	/^	RTLIL::State next_bit()$/;"	f	struct:SetundefWorker	typeref:typename:RTLIL::State	file:
next_bit_mode	yosys/passes/cmds/setundef.cc	/^	int next_bit_mode;$/;"	m	struct:SetundefWorker	typeref:typename:int	file:
next_bit_state	yosys/passes/cmds/setundef.cc	/^	uint32_t next_bit_state;$/;"	m	struct:SetundefWorker	typeref:typename:uint32_t	file:
next_char	yosys/frontends/verilog/preproc.cc	/^static char next_char()$/;"	f	typeref:typename:char	file:
next_char	yosys/passes/techmap/abc.cc	/^	void next_char(char ch)$/;"	f	struct:abc_output_filter	typeref:typename:void	file:
next_char	yosys/passes/techmap/abc9_exe.cc	/^	void next_char(char ch)$/;"	f	struct:abc9_output_filter	typeref:typename:void	file:
next_huge_break	yosys/libs/fst/fstapi.cc	/^    fstHandle next_huge_break;$/;"	m	struct:fstWriterContext	typeref:typename:fstHandle	file:
next_id	yosys/backends/firrtl/firrtl.cc	/^string next_id()$/;"	f	typeref:typename:string
next_line	yosys/passes/memory/memory_bram.cc	/^	bool next_line()$/;"	f	struct:rules_t	typeref:typename:bool	file:
next_line	yosys/passes/techmap/abc.cc	/^	void next_line(const std::string &line)$/;"	f	struct:abc_output_filter	typeref:typename:void	file:
next_line	yosys/passes/techmap/abc9_exe.cc	/^	void next_line(const std::string &line)$/;"	f	struct:abc9_output_filter	typeref:typename:void	file:
next_nid	yosys/backends/btor/btor.cc	/^	int next_nid = 1;$/;"	m	struct:BtorWorker	typeref:typename:int	file:
next_print_log	yosys/kernel/log.cc	/^static bool next_print_log = false;$/;"	v	typeref:typename:bool	file:
next_queued_pass	yosys/kernel/register.h	/^	Pass *next_queued_pass;$/;"	m	struct:Pass	typeref:typename:Pass *
next_region	yosys/passes/equiv/equiv_mark.cc	/^	int next_region;$/;"	m	struct:EquivMarkWorker	typeref:typename:int	file:
next_token	yosys/frontends/verilog/preproc.cc	/^static std::string next_token(bool pass_newline = false)$/;"	f	typeref:typename:std::string	file:
next_token	yosys/kernel/yosys.cc	/^std::string next_token(std::string &text, const char *sep, bool long_strings)$/;"	f	typeref:typename:std::string
next_var	yosys/libs/minisat/Solver.h	/^    Var                 next_var;         \/\/ Next variable to be created.$/;"	m	class:Minisat::Solver	typeref:typename:Var
nextstate	yosys/frontends/verific/verificsva.cc	/^	SigSpec nextstate;$/;"	m	struct:SvaDFsmNode	typeref:typename:SigSpec	file:
nid_width	yosys/backends/btor/btor.cc	/^	dict<int, int> nid_width;$/;"	m	struct:BtorWorker	typeref:typename:dict<int,int>	file:
noDict	yosys/libs/fst/lz4.cc	/^    noDict = 0,$/;"	e	enum:__anon9390dffe0503	file:
noDictIssue	yosys/libs/fst/lz4.cc	/^    noDictIssue = 0,$/;"	e	enum:__anon9390dffe0603	file:
no_candidate_set	yosys/passes/fsm/fsm_expand.cc	/^	std::set<RTLIL::Cell*, RTLIL::sort_by_name_id<RTLIL::Cell>> no_candidate_set;$/;"	m	struct:FsmExpand	typeref:typename:std::set<RTLIL::Cell *,RTLIL::sort_by_name_id<RTLIL::Cell>>	file:
no_outputs	yosys/passes/cmds/splice.cc	/^	bool no_outputs;$/;"	m	struct:SpliceWorker	typeref:typename:bool	file:
no_ports	yosys/passes/cmds/splice.cc	/^	std::set<RTLIL::IdString> no_ports;$/;"	m	struct:SpliceWorker	typeref:typename:std::set<RTLIL::IdString>	file:
noabc	yosys/techlibs/common/synth.cc	/^	bool autotop, flatten, noalumacc, nofsm, noabc, noshare, flowmap;$/;"	m	struct:SynthPass	typeref:typename:bool	file:
noabc	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
noaddf	yosys/techlibs/gatemate/synth_gatemate.cc	/^	bool noflatten, nobram, noaddf, nomult, nomx4, nomx8, dff, retime, noiopad, noclkbuf;$/;"	m	struct:SynthGateMatePass	typeref:typename:bool	file:
noalias_mode	yosys/backends/blif/blif.cc	/^	bool noalias_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
noalu	yosys/techlibs/gowin/synth_gowin.cc	/^	bool retime, nobram, nolutram, flatten, nodffe, nowidelut, abc9, noiopads, noalu;$/;"	m	struct:SynthGowinPass	typeref:typename:bool	file:
noalumacc	yosys/techlibs/common/synth.cc	/^	bool autotop, flatten, noalumacc, nofsm, noabc, noshare, flowmap;$/;"	m	struct:SynthPass	typeref:typename:bool	file:
noattr	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
nobisection	yosys/passes/sat/qbfsat.h	/^	bool nobisection = false, sat = false, unsat = false, show_smtbmc = false;$/;"	m	struct:QbfSolveOptions	typeref:typename:bool
noblackbox	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
nobram	yosys/techlibs/anlogic/synth_anlogic.cc	/^	bool flatten, retime, nolutram, nobram;$/;"	m	struct:SynthAnlogicPass	typeref:typename:bool	file:
nobram	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
nobram	yosys/techlibs/efinix/synth_efinix.cc	/^	bool flatten, retime, nobram;$/;"	m	struct:SynthEfinixPass	typeref:typename:bool	file:
nobram	yosys/techlibs/gatemate/synth_gatemate.cc	/^	bool noflatten, nobram, noaddf, nomult, nomx4, nomx8, dff, retime, noiopad, noclkbuf;$/;"	m	struct:SynthGateMatePass	typeref:typename:bool	file:
nobram	yosys/techlibs/gowin/synth_gowin.cc	/^	bool retime, nobram, nolutram, flatten, nodffe, nowidelut, abc9, noiopads, noalu;$/;"	m	struct:SynthGowinPass	typeref:typename:bool	file:
nobram	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
nobram	yosys/techlibs/intel/synth_intel.cc	/^	bool retime, flatten, nobram, iopads;$/;"	m	struct:SynthIntelPass	typeref:typename:bool	file:
nobram	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	bool flatten, quartus, nolutram, nobram, dff, nodsp, noiopad, noclkbuf;$/;"	m	struct:SynthIntelALMPass	typeref:typename:bool	file:
nobram	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
nobram	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
nocarry	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
nocarry	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
noccu2	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
noccu2	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
nocleanup	yosys/passes/sat/qbfsat.h	/^	bool specialize = false, specialize_from_file = false, write_solution = false, nocleanup = fals/;"	m	struct:QbfSolveOptions	typeref:typename:bool
noclkbuf	yosys/techlibs/gatemate/synth_gatemate.cc	/^	bool noflatten, nobram, noaddf, nomult, nomx4, nomx8, dff, retime, noiopad, noclkbuf;$/;"	m	struct:SynthGateMatePass	typeref:typename:bool	file:
noclkbuf	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	bool flatten, quartus, nolutram, nobram, dff, nodsp, noiopad, noclkbuf;$/;"	m	struct:SynthIntelALMPass	typeref:typename:bool	file:
noclkbuf	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
node	yosys/kernel/utils.h	/^	void node(T n)$/;"	f	struct:TopoSort	typeref:typename:void
node	yosys/passes/techmap/flowmap.cc	/^		RTLIL::SigBit node;$/;"	m	struct:FlowGraph::NodePrime	typeref:typename:RTLIL::SigBit	file:
node2index	yosys/kernel/cellaigs.cc	/^	int node2index(const AigNode &node)$/;"	f	struct:AigMaker	typeref:typename:int	file:
nodeId	yosys/libs/subcircuit/subcircuit.h	/^			std::string nodeId, typeId;$/;"	m	struct:SubCircuit::Graph::Node	typeref:typename:std::string
nodeId	yosys/libs/subcircuit/subcircuit.h	/^			std::string nodeId;$/;"	m	struct:SubCircuit::Solver::MineResultNode	typeref:typename:std::string
nodeIdx	yosys/libs/subcircuit/subcircuit.h	/^			int nodeIdx, portIdx, bitIdx;$/;"	m	struct:SubCircuit::Graph::BitRef	typeref:typename:int
nodeMap	yosys/libs/subcircuit/subcircuit.h	/^		std::map<std::string, int> nodeMap;$/;"	m	class:SubCircuit::Graph	typeref:typename:std::map<std::string,int>
node_comb_defs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<Node*, pool<const RTLIL::Wire*>, hash_ptr_ops> node_comb_defs, node_sync_defs, node_uses;$/;"	m	struct:FlowGraph	typeref:typename:dict<Node *,pool<const RTLIL::Wire * >,hash_ptr_ops>	file:
node_contains_assignment_to	yosys/frontends/ast/simplify.cc	/^static bool node_contains_assignment_to(const AstNode* node, const AstNode* var)$/;"	f	typeref:typename:bool	file:
node_flow	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, int> node_flow;$/;"	m	struct:FlowGraph	typeref:typename:dict<RTLIL::SigBit,int>	file:
node_int	yosys/frontends/ast/simplify.cc	/^static AstNode *node_int(int ival)$/;"	f	typeref:typename:AstNode *	file:
node_origins	yosys/passes/techmap/flowmap.cc	/^	dict<RTLIL::SigBit, ModIndex::PortInfo> node_origins;$/;"	m	struct:FlowmapWorker	typeref:typename:dict<RTLIL::SigBit,ModIndex::PortInfo>	file:
node_sync_defs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<Node*, pool<const RTLIL::Wire*>, hash_ptr_ops> node_comb_defs, node_sync_defs, node_uses;$/;"	m	struct:FlowGraph	typeref:typename:dict<Node *,pool<const RTLIL::Wire * >,hash_ptr_ops>	file:
node_to_unode	yosys/frontends/verific/verificsva.cc	/^	void node_to_unode(int node, int unode, SigSpec ctrl)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
node_uses	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<Node*, pool<const RTLIL::Wire*>, hash_ptr_ops> node_comb_defs, node_sync_defs, node_uses;$/;"	m	struct:FlowGraph	typeref:typename:dict<Node *,pool<const RTLIL::Wire * >,hash_ptr_ops>	file:
nodec	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
nodecode	yosys/passes/techmap/muxcover.cc	/^	bool nodecode;$/;"	m	struct:MuxcoverWorker	typeref:typename:bool	file:
nodes	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::vector<Node*> nodes;$/;"	m	struct:FlowGraph	typeref:typename:std::vector<Node * >	file:
nodes	yosys/frontends/verific/verificsva.cc	/^	vector<SvaNFsmNode> nodes;$/;"	m	struct:SvaFsm	typeref:typename:vector<SvaNFsmNode>	file:
nodes	yosys/kernel/cellaigs.h	/^	vector<AigNode> nodes;$/;"	m	struct:Aig	typeref:typename:vector<AigNode>
nodes	yosys/libs/subcircuit/subcircuit.cc	/^		std::set<int> nodes;$/;"	m	struct:SubCircuit::SolverWorker::NodeSet	typeref:typename:std::set<int>	file:
nodes	yosys/libs/subcircuit/subcircuit.h	/^			std::vector<MineResultNode> nodes;$/;"	m	struct:SubCircuit::Solver::MineResult	typeref:typename:std::vector<MineResultNode>
nodes	yosys/libs/subcircuit/subcircuit.h	/^		std::vector<Node> nodes;$/;"	m	class:SubCircuit::Graph	typeref:typename:std::vector<Node>
nodes	yosys/passes/cmds/qwp.cc	/^	vector<Node> nodes;$/;"	m	struct:QwpWorker	typeref:typename:vector<Node>	file:
nodes	yosys/passes/techmap/flowmap.cc	/^	pool<RTLIL::SigBit> nodes = {source};$/;"	m	struct:FlowGraph	typeref:typename:pool<RTLIL::SigBit>	file:
nodes	yosys/passes/techmap/flowmap.cc	/^	pool<RTLIL::SigBit> nodes, inputs, outputs;$/;"	m	struct:FlowmapWorker	typeref:typename:pool<RTLIL::SigBit>	file:
nodffe	yosys/passes/opt/opt_dff.cc	/^	bool nodffe;$/;"	m	struct:OptDffOptions	typeref:typename:bool	file:
nodffe	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
nodffe	yosys/techlibs/gowin/synth_gowin.cc	/^	bool retime, nobram, nolutram, flatten, nodffe, nowidelut, abc9, noiopads, noalu;$/;"	m	struct:SynthGowinPass	typeref:typename:bool	file:
nodffe	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
nodffe	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
nodsp	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
nodsp	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	bool flatten, quartus, nolutram, nobram, dff, nodsp, noiopad, noclkbuf;$/;"	m	struct:SynthIntelALMPass	typeref:typename:bool	file:
nodsp	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
nodsp	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
noexcept	yosys/libs/json11/json11.hpp	/^            #define noexcept /;"	d
noexpr	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
noflatten	yosys/techlibs/gatemate/synth_gatemate.cc	/^	bool noflatten, nobram, noaddf, nomult, nomx4, nomx8, dff, retime, noiopad, noclkbuf;$/;"	m	struct:SynthGateMatePass	typeref:typename:bool	file:
nofsm	yosys/techlibs/common/synth.cc	/^	bool autotop, flatten, noalumacc, nofsm, noabc, noshare, flowmap;$/;"	m	struct:SynthPass	typeref:typename:bool	file:
nohex	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
noiopad	yosys/techlibs/gatemate/synth_gatemate.cc	/^	bool noflatten, nobram, noaddf, nomult, nomx4, nomx8, dff, retime, noiopad, noclkbuf;$/;"	m	struct:SynthGateMatePass	typeref:typename:bool	file:
noiopad	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	bool flatten, quartus, nolutram, nobram, dff, nodsp, noiopad, noclkbuf;$/;"	m	struct:SynthIntelALMPass	typeref:typename:bool	file:
noiopad	yosys/techlibs/machxo2/synth_machxo2.cc	/^	bool flatten, vpr, noiopad;$/;"	m	struct:SynthMachXO2Pass	typeref:typename:bool	file:
noiopad	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
noiopad	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
noiopads	yosys/techlibs/gowin/synth_gowin.cc	/^	bool retime, nobram, nolutram, flatten, nodffe, nowidelut, abc9, noiopads, noalu;$/;"	m	struct:SynthGowinPass	typeref:typename:bool	file:
nokeepdc	yosys/techlibs/common/prep.cc	/^	bool autotop, flatten, ifxmode, memxmode, nomemmode, nokeepdc, rdff;$/;"	m	struct:PrepPass	typeref:typename:bool	file:
nolatches	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
nolram	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
nolutram	yosys/techlibs/anlogic/synth_anlogic.cc	/^	bool flatten, retime, nolutram, nobram;$/;"	m	struct:SynthAnlogicPass	typeref:typename:bool	file:
nolutram	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
nolutram	yosys/techlibs/gowin/synth_gowin.cc	/^	bool retime, nobram, nolutram, flatten, nodffe, nowidelut, abc9, noiopads, noalu;$/;"	m	struct:SynthGowinPass	typeref:typename:bool	file:
nolutram	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	bool flatten, quartus, nolutram, nobram, dff, nodsp, noiopad, noclkbuf;$/;"	m	struct:SynthIntelALMPass	typeref:typename:bool	file:
nolutram	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
nolutram	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
nomem2reg	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
nomeminit	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
nomemmode	yosys/techlibs/common/prep.cc	/^	bool autotop, flatten, ifxmode, memxmode, nomemmode, nokeepdc, rdff;$/;"	m	struct:PrepPass	typeref:typename:bool	file:
nomult	yosys/techlibs/gatemate/synth_gatemate.cc	/^	bool noflatten, nobram, noaddf, nomult, nomx4, nomx8, dff, retime, noiopad, noclkbuf;$/;"	m	struct:SynthGateMatePass	typeref:typename:bool	file:
nomx4	yosys/techlibs/gatemate/synth_gatemate.cc	/^	bool noflatten, nobram, noaddf, nomult, nomx4, nomx8, dff, retime, noiopad, noclkbuf;$/;"	m	struct:SynthGateMatePass	typeref:typename:bool	file:
nomx8	yosys/techlibs/gatemate/synth_gatemate.cc	/^	bool noflatten, nobram, noaddf, nomult, nomx4, nomx8, dff, retime, noiopad, noclkbuf;$/;"	m	struct:SynthGateMatePass	typeref:typename:bool	file:
non_incremental	yosys/libs/ezsat/ezsat.h	/^	void non_incremental() { flag_non_incremental = true; }$/;"	f	class:ezSAT	typeref:typename:void
non_incremental_solve_used_up	yosys/libs/ezsat/ezsat.h	/^	bool non_incremental_solve_used_up;$/;"	m	class:ezSAT	typeref:typename:bool
none	yosys/passes/sat/mutate.cc	/^	bool none = false;$/;"	m	struct:mutate_opts_t	typeref:typename:bool	file:
noopt	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
nooptimize	yosys/passes/sat/qbfsat.h	/^	bool dump_final_smt2 = false, assume_outputs = false, assume_neg = false, nooptimize = false;$/;"	m	struct:QbfSolveOptions	typeref:typename:bool
nop	yosys/passes/sat/fmcombine.cc	/^	bool nop = false;$/;"	m	struct:opts_t	typeref:typename:bool	file:
nopartial	yosys/passes/techmap/muxcover.cc	/^	bool nopartial;$/;"	m	struct:MuxcoverWorker	typeref:typename:bool	file:
nor_gate	yosys/kernel/cellaigs.cc	/^	int nor_gate(int A, int B)$/;"	f	struct:AigMaker	typeref:typename:int	file:
norename	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
nosdff	yosys/passes/opt/opt_dff.cc	/^	bool nosdff;$/;"	m	struct:OptDffOptions	typeref:typename:bool	file:
noshare	yosys/techlibs/common/synth.cc	/^	bool autotop, flatten, noalumacc, nofsm, noabc, noshare, flowmap;$/;"	m	struct:SynthPass	typeref:typename:bool	file:
nosrl	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
nostr	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
notLimited	yosys/libs/fst/lz4.cc	/^    notLimited = 0,$/;"	e	enum:__anon9390dffe0303	file:
not_gate	yosys/kernel/cellaigs.cc	/^	int not_gate(int A)$/;"	f	struct:AigMaker	typeref:typename:int	file:
not_inport	yosys/kernel/cellaigs.cc	/^	int not_inport(IdString portname, int portbit = 0)$/;"	f	struct:AigMaker	typeref:typename:int	file:
not_map	yosys/backends/aiger/aiger.cc	/^	dict<SigBit, SigBit> not_map, ff_map, alias_map;$/;"	m	struct:AigerWriter	typeref:typename:dict<SigBit,SigBit>	file:
not_map	yosys/backends/aiger/xaiger.cc	/^	dict<SigBit, SigBit> not_map, alias_map;$/;"	m	struct:XAigerWriter	typeref:typename:dict<SigBit,SigBit>	file:
not_s	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> not_s(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
not_u	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> not_u(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
notify_blackout	yosys/kernel/modtools.h	/^	void notify_blackout(RTLIL::Module *mod) override$/;"	f	struct:ModIndex	typeref:typename:void
notify_blackout	yosys/kernel/rtlil.h	/^	virtual void notify_blackout(RTLIL::Module*) { }$/;"	f	struct:RTLIL::Monitor	typeref:typename:void
notify_blackout	yosys/passes/cmds/trace.cc	/^	void notify_blackout(RTLIL::Module *module) override$/;"	f	struct:TraceMonitor	typeref:typename:void	file:
notify_connect	yosys/kernel/modtools.h	/^	void notify_connect(RTLIL::Cell *cell, const RTLIL::IdString &port, const RTLIL::SigSpec &old_s/;"	f	struct:ModIndex	typeref:typename:void
notify_connect	yosys/kernel/modtools.h	/^	void notify_connect(RTLIL::Module *mod, const RTLIL::SigSig &sigsig) override$/;"	f	struct:ModIndex	typeref:typename:void
notify_connect	yosys/kernel/modtools.h	/^	void notify_connect(RTLIL::Module *mod, const std::vector<RTLIL::SigSig>&) override$/;"	f	struct:ModIndex	typeref:typename:void
notify_connect	yosys/kernel/rtlil.h	/^	virtual void notify_connect(RTLIL::Cell*, const RTLIL::IdString&, const RTLIL::SigSpec&, const /;"	f	struct:RTLIL::Monitor	typeref:typename:void
notify_connect	yosys/kernel/rtlil.h	/^	virtual void notify_connect(RTLIL::Module*, const RTLIL::SigSig&) { }$/;"	f	struct:RTLIL::Monitor	typeref:typename:void
notify_connect	yosys/kernel/rtlil.h	/^	virtual void notify_connect(RTLIL::Module*, const std::vector<RTLIL::SigSig>&) { }$/;"	f	struct:RTLIL::Monitor	typeref:typename:void
notify_connect	yosys/passes/cmds/trace.cc	/^	void notify_connect(RTLIL::Cell *cell, const RTLIL::IdString &port, const RTLIL::SigSpec &old_s/;"	f	struct:TraceMonitor	typeref:typename:void	file:
notify_connect	yosys/passes/cmds/trace.cc	/^	void notify_connect(RTLIL::Module *module, const RTLIL::SigSig &sigsig) override$/;"	f	struct:TraceMonitor	typeref:typename:void	file:
notify_connect	yosys/passes/cmds/trace.cc	/^	void notify_connect(RTLIL::Module *module, const std::vector<RTLIL::SigSig> &sigsig_vec) overri/;"	f	struct:TraceMonitor	typeref:typename:void	file:
notify_module_add	yosys/kernel/rtlil.h	/^	virtual void notify_module_add(RTLIL::Module*) { }$/;"	f	struct:RTLIL::Monitor	typeref:typename:void
notify_module_add	yosys/passes/cmds/trace.cc	/^	void notify_module_add(RTLIL::Module *module) override$/;"	f	struct:TraceMonitor	typeref:typename:void	file:
notify_module_del	yosys/kernel/rtlil.h	/^	virtual void notify_module_del(RTLIL::Module*) { }$/;"	f	struct:RTLIL::Monitor	typeref:typename:void
notify_module_del	yosys/passes/cmds/trace.cc	/^	void notify_module_del(RTLIL::Module *module) override$/;"	f	struct:TraceMonitor	typeref:typename:void	file:
notitle	yosys/passes/cmds/show.cc	/^	bool notitle;$/;"	m	struct:ShowWorker	typeref:typename:bool	file:
nowb	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
nowidelut	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
nowidelut	yosys/techlibs/gowin/synth_gowin.cc	/^	bool retime, nobram, nolutram, flatten, nodffe, nowidelut, abc9, noiopads, noalu;$/;"	m	struct:SynthGowinPass	typeref:typename:bool	file:
nowidelut	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
nowidelut	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
nprimes	yosys/libs/minisat/Map.h	/^static const int nprimes          = 25;$/;"	v	namespace:Minisat	typeref:typename:const int
null	yosys/libs/json11/json11.cpp	/^    const std::shared_ptr<JsonValue> null = make_shared<JsonNull>();$/;"	m	struct:json11::Statics	typeref:typename:const std::shared_ptr<JsonValue>	file:
numCnfClauses	yosys/libs/ezsat/ezsat.h	/^	int numCnfClauses() const { return cnfClausesCount; }$/;"	f	class:ezSAT	typeref:typename:int
numCnfVariables	yosys/libs/ezsat/ezsat.h	/^	int numCnfVariables() const { return cnfVariableCount; }$/;"	f	class:ezSAT	typeref:typename:int
numExpressions	yosys/libs/ezsat/ezsat.h	/^	int numExpressions() const { return expressions.size(); }$/;"	f	class:ezSAT	typeref:typename:int
numLiterals	yosys/libs/ezsat/ezsat.h	/^	int numLiterals() const { return literals.size(); }$/;"	f	class:ezSAT	typeref:typename:int
num_alias	yosys/libs/fst/fstapi.cc	/^    uint64_t num_alias;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
num_blackouts	yosys/libs/fst/fstapi.cc	/^    uint32_t num_blackouts;$/;"	m	struct:fstReaderContext	typeref:typename:uint32_t	file:
num_blackouts	yosys/libs/fst/fstapi.cc	/^    uint32_t num_blackouts;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t	file:
num_cells_by_type	yosys/passes/cmds/stat.cc	/^	std::map<RTLIL::IdString, int, RTLIL::sort_by_id_str> num_cells_by_type;$/;"	m	struct:statdata_t	typeref:typename:std::map<RTLIL::IdString,int,RTLIL::sort_by_id_str>	file:
num_clauses	yosys/libs/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literal/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
num_inputs	yosys/passes/fsm/fsmdata.h	/^	int num_inputs, num_outputs, state_bits, reset_state;$/;"	m	struct:FsmData	typeref:typename:int
num_learnts	yosys/libs/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literal/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
num_outputs	yosys/passes/fsm/fsmdata.h	/^	int num_inputs, num_outputs, state_bits, reset_state;$/;"	m	struct:FsmData	typeref:typename:int
numberOfPermutations	yosys/libs/subcircuit/subcircuit.cc	/^	static int numberOfPermutations(const std::vector<std::string> &list)$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:int	file:
numberOfPermutationsArray	yosys/libs/subcircuit/subcircuit.cc	/^	static int numberOfPermutationsArray(const std::vector<std::vector<std::string>> &list)$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:int	file:
number_value	yosys/libs/json11/json11.cpp	/^    double number_value() const override { return m_value; }$/;"	f	class:json11::JsonDouble	typeref:typename:double	file:
number_value	yosys/libs/json11/json11.cpp	/^    double number_value() const override { return m_value; }$/;"	f	class:json11::JsonInt	typeref:typename:double	file:
number_value	yosys/libs/json11/json11.cpp	/^double                    JsonValue::number_value()              const { return 0; }$/;"	f	class:json11::JsonValue	typeref:typename:double
number_value	yosys/libs/json11/json11.cpp	/^double Json::number_value()                       const { return m_ptr->number_value(); }$/;"	f	class:json11::Json	typeref:typename:double
numscopes	yosys/libs/fst/fstapi.cc	/^    uint32_t numscopes;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t	file:
numsigs	yosys/libs/fst/fstapi.cc	/^    fstHandle numsigs;$/;"	m	struct:fstWriterContext	typeref:typename:fstHandle	file:
object	yosys/libs/json11/json11.hpp	/^    typedef std::map<std::string, Json> object;$/;"	t	class:json11::Json	typeref:typename:std::map<std::string,Json>
object_items	yosys/libs/json11/json11.cpp	/^    const Json::object &object_items() const override { return m_value; }$/;"	f	class:json11::JsonObject	typeref:typename:const Json::object &	file:
object_items	yosys/libs/json11/json11.cpp	/^const map<string, Json> & Json::object_items()    const { return m_ptr->object_items(); }$/;"	f	class:json11::Json	typeref:typename:const map<string,Json> &
object_items	yosys/libs/json11/json11.cpp	/^const map<string, Json> & JsonValue::object_items()              const { return statics().empty_/;"	f	class:json11::JsonValue	typeref:typename:const map<string,Json> &
objects	yosys/backends/cxxrtl/cxxrtl_capi.cc	/^	cxxrtl::debug_items objects;$/;"	m	struct:_cxxrtl_handle	typeref:typename:cxxrtl::debug_items	file:
occs	yosys/libs/minisat/SolverTypes.h	/^    IntMap<K, Vec,  MkIndex> occs;$/;"	m	class:Minisat::OccLists	typeref:typename:IntMap<K,Vec,MkIndex>
occurs	yosys/libs/minisat/SimpSolver.h	/^                        occurs;$/;"	m	class:Minisat::SimpSolver	typeref:typename:OccLists<Var,vec<CRef>,ClauseDeleted>
off	yosys/kernel/log.h	/^	void off() {$/;"	f	struct:LogMakeDebugHdl	typeref:typename:void
off_silent	yosys/kernel/log.h	/^	void off_silent() {$/;"	f	struct:LogMakeDebugHdl	typeref:typename:void
offset	yosys/frontends/ast/ast.h	/^			int offset;$/;"	m	struct:AST::AstNode::varinfo_t	typeref:typename:int
offset	yosys/kernel/modtools.h	/^		int offset;$/;"	m	struct:ModIndex::PortInfo	typeref:typename:int
offset	yosys/kernel/modtools.h	/^		int offset;$/;"	m	struct:ModWalker::PortBit	typeref:typename:int
offset	yosys/kernel/rtlil.h	/^		int offset;        \/\/ used if wire != NULL$/;"	m	union:RTLIL::SigBit::__anon4f1f9148010a	typeref:typename:int
offset	yosys/kernel/rtlil.h	/^	int width, offset;$/;"	m	struct:RTLIL::SigChunk	typeref:typename:int
offset	yosys/kernel/timinginfo.h	/^		int offset;$/;"	m	struct:TimingInfo::NameBit	typeref:typename:int
offset	yosys/passes/sat/sat.cc	/^		int timestep, offset, width;$/;"	m	struct:SatHelper::ModelBlockInfo	typeref:typename:int	file:
offset_indexed_range	yosys/frontends/ast/simplify.cc	/^static AstNode *offset_indexed_range(int offset, int stride, AstNode *left_expr, AstNode *right_/;"	f	typeref:typename:AstNode *	file:
oflag	yosys/passes/sat/qbfsat.h	/^	enum OptimizationLevel{O0, O1, O2} oflag = O0;$/;"	m	struct:QbfSolveOptions	typeref:enum:QbfSolveOptions::OptimizationLevel
ok	yosys/kernel/rtlil.h	/^			bool ok; \/\/ POD, will be initialized to zero$/;"	m	struct:RTLIL::IdString::destruct_guard_t	typeref:typename:bool
ok	yosys/libs/minisat/Solver.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiab/;"	m	class:Minisat::Solver	typeref:typename:bool
okay	yosys/libs/minisat/Solver.h	/^inline bool     Solver::okay          ()      const   { return ok; }$/;"	f	class:Minisat::Solver	typeref:typename:bool
old_name	yosys/passes/techmap/attrmap.cc	/^	string old_name, new_name;$/;"	m	struct:AttrmapMap	typeref:typename:string	file:
old_name	yosys/passes/techmap/attrmap.cc	/^	string old_name, new_name;$/;"	m	struct:AttrmapRename	typeref:typename:string	file:
old_value	yosys/passes/techmap/attrmap.cc	/^	string old_value, new_value;$/;"	m	struct:AttrmapMap	typeref:typename:string	file:
on	yosys/kernel/log.h	/^	void on() {$/;"	f	struct:LogMakeDebugHdl	typeref:typename:void
on_connection	yosys/passes/hierarchy/hierarchy.cc	/^	void on_connection(RTLIL::Module        &submodule,$/;"	f	struct:IFExpander	typeref:typename:void	file:
on_interface	yosys/passes/hierarchy/hierarchy.cc	/^	void on_interface(RTLIL::Module        &submodule,$/;"	f	struct:IFExpander	typeref:typename:void	file:
on_missing_interface	yosys/passes/hierarchy/hierarchy.cc	/^	void on_missing_interface(RTLIL::IdString interface_name)$/;"	f	struct:IFExpander	typeref:typename:void	file:
on_register	yosys/kernel/register.cc	/^void Pass::on_register()$/;"	f	class:Pass	typeref:typename:void
on_register	yosys/passes/techmap/abc9.cc	/^	void on_register() override$/;"	f	struct:Abc9Pass	typeref:typename:void	file:
on_register	yosys/techlibs/ecp5/synth_ecp5.cc	/^	void on_register() override$/;"	f	struct:SynthEcp5Pass	typeref:typename:void	file:
on_register	yosys/techlibs/ice40/synth_ice40.cc	/^	void on_register() override$/;"	f	struct:SynthIce40Pass	typeref:typename:void	file:
on_register	yosys/techlibs/nexus/synth_nexus.cc	/^	void on_register() override$/;"	f	struct:SynthNexusPass	typeref:typename:void	file:
on_register	yosys/techlibs/xilinx/synth_xilinx.cc	/^	void on_register() override$/;"	f	struct:SynthXilinxPass	typeref:typename:void	file:
on_shutdown	yosys/kernel/register.cc	/^void Pass::on_shutdown()$/;"	f	class:Pass	typeref:typename:void
onehot	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::onehot(const std::vector<int> &vec, bool max_only)$/;"	f	class:ezSAT	typeref:typename:int
op	yosys/passes/opt/opt_share.cc	/^	RTLIL::Cell *op;$/;"	m	struct:OpMuxConn	typeref:typename:RTLIL::Cell *	file:
op_outsig_offset	yosys/passes/opt/opt_share.cc	/^	int op_outsig_offset;$/;"	m	struct:OpMuxConn	typeref:typename:int	file:
open	yosys/kernel/register.cc	/^		bool open(const std::string &filename)$/;"	f	class:gzip_ostream::gzip_streambuf	typeref:typename:bool	file:
open	yosys/kernel/register.cc	/^	bool open(const std::string &filename)$/;"	f	class:gzip_ostream	typeref:typename:bool	file:
operator !=	yosys/backends/cxxrtl/cxxrtl.h	/^	bool operator !=(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:bool
operator !=	yosys/frontends/ast/ast.cc	/^bool AstNode::operator!=(const AstNode &other) const$/;"	f	class:AstNode	typeref:typename:bool
operator !=	yosys/kernel/hashlib.h	/^		bool operator!=(const const_iterator &other) const { return index != other.index; }$/;"	f	class:hashlib::dict::const_iterator	typeref:typename:bool
operator !=	yosys/kernel/hashlib.h	/^		bool operator!=(const const_iterator &other) const { return index != other.index; }$/;"	f	class:hashlib::idict::const_iterator	typeref:typename:bool
operator !=	yosys/kernel/hashlib.h	/^		bool operator!=(const const_iterator &other) const { return index != other.index; }$/;"	f	class:hashlib::pool::const_iterator	typeref:typename:bool
operator !=	yosys/kernel/hashlib.h	/^		bool operator!=(const iterator &other) const { return index != other.index; }$/;"	f	class:hashlib::dict::iterator	typeref:typename:bool
operator !=	yosys/kernel/hashlib.h	/^		bool operator!=(const iterator &other) const { return index != other.index; }$/;"	f	class:hashlib::pool::iterator	typeref:typename:bool
operator !=	yosys/kernel/hashlib.h	/^	bool operator!=(const dict &other) const {$/;"	f	class:hashlib::dict	typeref:typename:bool
operator !=	yosys/kernel/hashlib.h	/^	bool operator!=(const pool &other) const {$/;"	f	class:hashlib::pool	typeref:typename:bool
operator !=	yosys/kernel/rtlil.cc	/^bool RTLIL::Const::operator !=(const RTLIL::Const &other) const$/;"	f	class:RTLIL::Const	typeref:typename:bool
operator !=	yosys/kernel/rtlil.cc	/^bool RTLIL::SigChunk::operator !=(const RTLIL::SigChunk &other) const$/;"	f	class:RTLIL::SigChunk	typeref:typename:bool
operator !=	yosys/kernel/rtlil.h	/^		bool operator!=(const char *rhs) const { return strcmp(c_str(), rhs) != 0; }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
operator !=	yosys/kernel/rtlil.h	/^		bool operator!=(const std::string &rhs) const { return c_str() != rhs; }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
operator !=	yosys/kernel/rtlil.h	/^		inline bool operator!=(const IdString &rhs) const { return index_ != rhs.index_; }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
operator !=	yosys/kernel/rtlil.h	/^		inline bool operator!=(const RTLIL::ObjIterator<T> &other) const {$/;"	f	struct:RTLIL::ObjIterator	typeref:typename:bool
operator !=	yosys/kernel/rtlil.h	/^	inline bool operator !=(const RTLIL::SigSpec &other) const { return !(*this == other); }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:bool
operator !=	yosys/kernel/rtlil.h	/^	inline bool operator!=(const RTLIL::SigSpecConstIterator &other) const { return index != other./;"	f	struct:RTLIL::SigSpecConstIterator	typeref:typename:bool
operator !=	yosys/kernel/rtlil.h	/^	inline bool operator!=(const RTLIL::SigSpecIterator &other) const { return index != other.index/;"	f	struct:RTLIL::SigSpecIterator	typeref:typename:bool
operator !=	yosys/kernel/rtlil.h	/^inline bool RTLIL::SigBit::operator!=(const RTLIL::SigBit &other) const {$/;"	f	class:RTLIL::SigBit	typeref:typename:bool
operator !=	yosys/kernel/timinginfo.h	/^		bool operator!=(const NameBit& nb) const { return !operator==(nb); }$/;"	f	struct:TimingInfo::NameBit	typeref:typename:bool
operator !=	yosys/libs/bigint/BigInteger.hh	/^	bool operator !=(const BigInteger &x) const { return !operator ==(x); };$/;"	f	class:BigInteger	typeref:typename:bool
operator !=	yosys/libs/bigint/BigUnsigned.hh	/^	bool operator !=(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:bool
operator !=	yosys/libs/bigint/BigUnsignedInABase.hh	/^	bool operator !=(const BigUnsignedInABase &x) const { return !operator ==(x); }$/;"	f	class:BigUnsignedInABase	typeref:typename:bool
operator !=	yosys/libs/bigint/NumberlikeArray.hh	/^	bool operator !=(const NumberlikeArray<Blk> &x) const {$/;"	f	class:NumberlikeArray	typeref:typename:bool
operator !=	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator !=(const ezSATbit &other) { return ezSATbit(sat, sat.NOT(sat.IFF(id, other.id/;"	f	struct:ezSATbit	typeref:typename:ezSATbit
operator !=	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator !=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_ne(vec, other.vec));/;"	f	struct:ezSATvec	typeref:typename:ezSATbit
operator !=	yosys/libs/json11/json11.hpp	/^    bool operator!= (const Json &rhs) const { return !(*this == rhs); }$/;"	f	class:json11::Json	typeref:typename:bool
operator !=	yosys/libs/minisat/Solver.h	/^        bool operator!=(const Watcher& w) const { return cref != w.cref; }$/;"	f	struct:Minisat::Solver::Watcher	typeref:typename:bool
operator !=	yosys/libs/minisat/SolverTypes.h	/^    bool  operator != (lbool b) const { return !(*this == b); }$/;"	f	class:Minisat::lbool	typeref:typename:bool
operator !=	yosys/libs/minisat/SolverTypes.h	/^    bool operator != (Lit p) const { return x != p.x; }$/;"	f	struct:Minisat::Lit	typeref:typename:bool
operator !=	yosys/libs/minisat/SolverTypes.h	/^    bool operator!=(const ClauseIterator& ci) const { return crefs != ci.crefs; }$/;"	f	class:Minisat::ClauseIterator	typeref:typename:bool
operator !=	yosys/libs/minisat/SolverTypes.h	/^    bool operator!=(const TrailIterator& ti) const { return lits != ti.lits; }$/;"	f	class:Minisat::TrailIterator	typeref:typename:bool
operator !=	yosys/passes/techmap/flowmap.cc	/^		bool operator!=(const NodePrime &other) const$/;"	f	struct:FlowGraph::NodePrime	typeref:typename:bool	file:
operator %	yosys/libs/bigint/BigInteger.hh	/^inline BigInteger BigInteger::operator %(const BigInteger &x) const {$/;"	f	class:BigInteger	typeref:typename:BigInteger
operator %	yosys/libs/bigint/BigUnsigned.hh	/^inline BigUnsigned BigUnsigned::operator %(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned
operator %=	yosys/libs/bigint/BigInteger.hh	/^inline void BigInteger::operator %=(const BigInteger &x) {$/;"	f	class:BigInteger	typeref:typename:void
operator %=	yosys/libs/bigint/BigUnsigned.hh	/^inline void BigUnsigned::operator %=(const BigUnsigned &x) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator &	yosys/libs/bigint/BigUnsigned.hh	/^inline BigUnsigned BigUnsigned::operator &(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned
operator &	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator &(const ezSATbit &other) { return ezSATbit(sat, sat.AND(id, other.id)); }$/;"	f	struct:ezSATbit	typeref:typename:ezSATbit
operator &	yosys/libs/ezsat/ezsat.h	/^	ezSATvec operator &(const ezSATvec &other) { return ezSATvec(sat, sat.vec_and(vec, other.vec));/;"	f	struct:ezSATvec	typeref:typename:ezSATvec
operator &&	yosys/libs/minisat/SolverTypes.h	/^    lbool operator && (lbool b) const { $/;"	f	class:Minisat::lbool	typeref:typename:lbool
operator &=	yosys/libs/bigint/BigUnsigned.hh	/^inline void BigUnsigned::operator &=(const BigUnsigned &x) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator ()	yosys/backends/aiger/xaiger.cc	/^			bool operator()(const RTLIL::SigBit& a, const RTLIL::SigBit& b) const {$/;"	f	struct:XAigerWriter::XAigerWriter::sort_by_port_id	typeref:typename:bool	file:
operator ()	yosys/backends/cxxrtl/cxxrtl.h	/^		value<NewBits> operator()(const value<Bits> &val) {$/;"	f	struct:cxxrtl::value::sext_cast	typeref:typename:CXXRTL_ALWAYS_INLINE value<NewBits>
operator ()	yosys/backends/cxxrtl/cxxrtl.h	/^		value<NewBits> operator()(const value<Bits> &val) {$/;"	f	struct:cxxrtl::value::zext_cast	typeref:typename:CXXRTL_ALWAYS_INLINE value<NewBits>
operator ()	yosys/backends/edif/edif.cc	/^	std::string operator()(std::string id, bool define, bool port_rename = false, int range_left = /;"	f	struct:EdifNames	typeref:typename:std::string	file:
operator ()	yosys/kernel/ffinit.h	/^	RTLIL::Const operator()(const RTLIL::SigSpec &sig) const$/;"	f	struct:FfInitVals	typeref:typename:RTLIL::Const
operator ()	yosys/kernel/ffinit.h	/^	RTLIL::State operator()(RTLIL::SigBit bit) const$/;"	f	struct:FfInitVals	typeref:typename:RTLIL::State
operator ()	yosys/kernel/hashlib.h	/^	int operator()(const K &key) const$/;"	f	class:hashlib::mfp	typeref:typename:int
operator ()	yosys/kernel/hashlib.h	/^	int operator()(const K &key)$/;"	f	class:hashlib::idict	typeref:typename:int
operator ()	yosys/kernel/rtlil.cc	/^		void operator()(RTLIL::SigSpec &lhs, RTLIL::SigSpec &rhs) {$/;"	f	struct:RTLIL::Module::remove::DeleteWireWorker	typeref:typename:void	file:
operator ()	yosys/kernel/rtlil.cc	/^		void operator()(RTLIL::SigSpec &sig) {$/;"	f	struct:RTLIL::Module::remove::DeleteWireWorker	typeref:typename:void	file:
operator ()	yosys/kernel/rtlil.cc	/^		void operator()(RTLIL::SigSpec &sig)$/;"	f	struct:RTLIL::Module::cloneInto::RewriteSigSpecWorker	typeref:typename:void	file:
operator ()	yosys/kernel/rtlil.h	/^			bool operator()(const T *a, const T *b) const {$/;"	f	struct:RTLIL::IdString::compare_ptr_by_name	typeref:typename:bool
operator ()	yosys/kernel/rtlil.h	/^		bool operator()(RTLIL::IdString a, RTLIL::IdString b) const {$/;"	f	struct:RTLIL::sort_by_id_str	typeref:typename:bool
operator ()	yosys/kernel/rtlil.h	/^		bool operator()(T *a, T *b) const {$/;"	f	struct:RTLIL::sort_by_name_id	typeref:typename:bool
operator ()	yosys/kernel/rtlil.h	/^		bool operator()(T *a, T *b) const {$/;"	f	struct:RTLIL::sort_by_name_str	typeref:typename:bool
operator ()	yosys/kernel/sigtools.h	/^	RTLIL::SigBit operator()(RTLIL::SigBit bit) const$/;"	f	struct:SigMap	typeref:typename:RTLIL::SigBit
operator ()	yosys/kernel/sigtools.h	/^	RTLIL::SigSpec operator()(RTLIL::SigSpec sig) const$/;"	f	struct:SigMap	typeref:typename:RTLIL::SigSpec
operator ()	yosys/kernel/sigtools.h	/^	RTLIL::SigSpec operator()(RTLIL::Wire *wire) const$/;"	f	struct:SigMap	typeref:typename:RTLIL::SigSpec
operator ()	yosys/libs/ezsat/testbench.cc	/^	uint32_t operator()() {$/;"	f	struct:xorshift128	typeref:typename:uint32_t	file:
operator ()	yosys/libs/minisat/IntMap.h	/^        typename vec<T>::Size operator()(T t) const { return (typename vec<T>::Size)t; }$/;"	f	struct:Minisat::MkIndexDefault	typeref:typename:vec<T>::Size
operator ()	yosys/libs/minisat/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { retur/;"	f	struct:Minisat::DeepEqual	typeref:typename:bool
operator ()	yosys/libs/minisat/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { retur/;"	f	struct:Minisat::DeepHash	typeref:typename:uint32_t
operator ()	yosys/libs/minisat/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1/;"	f	struct:Minisat::Equal	typeref:typename:bool
operator ()	yosys/libs/minisat/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return ha/;"	f	struct:Minisat::Hash	typeref:typename:uint32_t
operator ()	yosys/libs/minisat/Options.h	/^        bool operator()(const Option* x, const Option* y) {$/;"	f	struct:Minisat::Option::OptionLt	typeref:typename:bool
operator ()	yosys/libs/minisat/SimpSolver.h	/^        bool operator()(Var x, Var y) const { return cost(x) < cost(y); }$/;"	f	struct:Minisat::SimpSolver::ElimLt	typeref:typename:bool
operator ()	yosys/libs/minisat/SimpSolver.h	/^        bool operator()(const CRef& cr) const { return ca[cr].mark() == 1; } };$/;"	f	struct:Minisat::SimpSolver::ClauseDeleted	typeref:typename:bool
operator ()	yosys/libs/minisat/Solver.h	/^        bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }$/;"	f	struct:Minisat::Solver::WatcherDeleted	typeref:typename:bool
operator ()	yosys/libs/minisat/SolverTypes.h	/^        uint32_t operator()(CRef cr) const { return (uint32_t)cr; } };$/;"	f	struct:Minisat::CMap::CRefHash	typeref:typename:uint32_t
operator ()	yosys/libs/minisat/SolverTypes.h	/^struct MkIndexLit { vec<Lit>::Size operator()(Lit l) const { return vec<Lit>::Size(l.x); } };$/;"	f	struct:Minisat::MkIndexLit	typeref:typename:vec<Lit>::Size
operator ()	yosys/passes/cmds/setundef.cc	/^	void operator()(RTLIL::SigSpec &sig)$/;"	f	struct:SetundefWorker	typeref:typename:void	file:
operator ()	yosys/passes/cmds/splitnets.cc	/^	void operator()(RTLIL::SigSpec &sig)$/;"	f	struct:SplitnetsWorker	typeref:typename:void	file:
operator ()	yosys/passes/equiv/equiv_miter.cc	/^			void operator()(SigSpec &sig) {$/;"	f	struct:EquivMiterWorker::copy_to_miter::RewriteSigSpecWorker	typeref:typename:void	file:
operator ()	yosys/passes/memory/memory_share.cc	/^	void operator()(RTLIL::Module* module)$/;"	f	struct:MemoryShareWorker	typeref:typename:void	file:
operator ()	yosys/passes/opt/opt_mem_feedback.cc	/^	void operator()(RTLIL::Module* module)$/;"	f	struct:OptMemFeedbackWorker	typeref:typename:void	file:
operator ()	yosys/passes/opt/share.cc	/^	void operator()(RTLIL::Module *module) {$/;"	f	struct:ShareWorker	typeref:typename:void	file:
operator ()	yosys/passes/sat/freduce.cc	/^	void operator()(RTLIL::SigSpec &sig) {$/;"	f	struct:CountBitUsage	typeref:typename:void	file:
operator ()	yosys/passes/sat/mutate.cc	/^	int operator()() {$/;"	f	struct:xs128_t	typeref:typename:int	file:
operator ()	yosys/passes/sat/mutate.cc	/^	int operator()(int n) {$/;"	f	struct:xs128_t	typeref:typename:int	file:
operator () 	yosys/libs/minisat/Solver.cc	/^    bool operator () (CRef x, CRef y) { $/;"	f	struct:reduceDB_lt	typeref:typename:bool	file:
operator () 	yosys/libs/minisat/Solver.h	/^        bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }$/;"	f	struct:Minisat::Solver::VarOrderLt	typeref:typename:bool
operator () 	yosys/libs/minisat/Sort.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:Minisat::LessThan_default	typeref:typename:bool
operator *	yosys/kernel/hashlib.h	/^		K &operator*() { return ptr->entries[index].udata; }$/;"	f	class:hashlib::pool::iterator	typeref:typename:K &
operator *	yosys/kernel/hashlib.h	/^		const K &operator*() const { return container[index]; }$/;"	f	class:hashlib::idict::const_iterator	typeref:typename:const K &
operator *	yosys/kernel/hashlib.h	/^		const K &operator*() const { return ptr->entries[index].udata; }$/;"	f	class:hashlib::pool::const_iterator	typeref:typename:const K &
operator *	yosys/kernel/hashlib.h	/^		const K &operator*() const { return ptr->entries[index].udata; }$/;"	f	class:hashlib::pool::iterator	typeref:typename:const K &
operator *	yosys/kernel/hashlib.h	/^		const std::pair<K, T> &operator*() const { return ptr->entries[index].udata; }$/;"	f	class:hashlib::dict::const_iterator	typeref:typename:const std::pair<K,T> &
operator *	yosys/kernel/hashlib.h	/^		const std::pair<K, T> &operator*() const { return ptr->entries[index].udata; }$/;"	f	class:hashlib::dict::iterator	typeref:typename:const std::pair<K,T> &
operator *	yosys/kernel/hashlib.h	/^		std::pair<K, T> &operator*() { return ptr->entries[index].udata; }$/;"	f	class:hashlib::dict::iterator	typeref:typename:std::pair<K,T> &
operator *	yosys/kernel/rtlil.h	/^		inline T operator*() const {$/;"	f	struct:RTLIL::ObjIterator	typeref:typename:T
operator *	yosys/kernel/rtlil.h	/^inline RTLIL::SigBit &RTLIL::SigSpecIterator::operator*() const {$/;"	f	class:RTLIL::SigSpecIterator	typeref:typename:RTLIL::SigBit &
operator *	yosys/kernel/rtlil.h	/^inline const RTLIL::SigBit &RTLIL::SigSpecConstIterator::operator*() const {$/;"	f	class:RTLIL::SigSpecConstIterator	typeref:typename:const RTLIL::SigBit &
operator *	yosys/libs/bigint/BigInteger.hh	/^inline BigInteger BigInteger::operator *(const BigInteger &x) const {$/;"	f	class:BigInteger	typeref:typename:BigInteger
operator *	yosys/libs/bigint/BigUnsigned.hh	/^inline BigUnsigned BigUnsigned::operator *(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned
operator *	yosys/libs/minisat/ParseUtils.h	/^    int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }$/;"	f	class:Minisat::StreamBuffer	typeref:typename:int
operator *	yosys/libs/minisat/SolverTypes.h	/^    Lit  operator*() const { return *lits; }$/;"	f	class:Minisat::TrailIterator	typeref:typename:Lit
operator *	yosys/libs/minisat/SolverTypes.h	/^    const Clause& operator*() const { return ca[*crefs]; }$/;"	f	class:Minisat::ClauseIterator	typeref:typename:const Clause &
operator *	yosys/passes/cmds/stat.cc	/^	statdata_t operator*(int other) const$/;"	f	struct:statdata_t	typeref:typename:statdata_t	file:
operator *=	yosys/libs/bigint/BigInteger.hh	/^inline void BigInteger::operator *=(const BigInteger &x) {$/;"	f	class:BigInteger	typeref:typename:void
operator *=	yosys/libs/bigint/BigUnsigned.hh	/^inline void BigUnsigned::operator *=(const BigUnsigned &x) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator +	yosys/kernel/rtlil.h	/^		inline ObjIterator<T> operator+(int amt) {$/;"	f	struct:RTLIL::ObjIterator	typeref:typename:ObjIterator<T>
operator +	yosys/libs/bigint/BigInteger.hh	/^inline BigInteger BigInteger::operator +(const BigInteger &x) const {$/;"	f	class:BigInteger	typeref:typename:BigInteger
operator +	yosys/libs/bigint/BigUnsigned.hh	/^inline BigUnsigned BigUnsigned::operator +(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned
operator +	yosys/libs/ezsat/ezsat.h	/^	ezSATvec operator +(const ezSATvec &other) { return ezSATvec(sat, sat.vec_add(vec, other.vec));/;"	f	struct:ezSATvec	typeref:typename:ezSATvec
operator +	yosys/passes/cmds/stat.cc	/^	statdata_t operator+(const statdata_t &other) const$/;"	f	struct:statdata_t	typeref:typename:statdata_t	file:
operator ++	yosys/kernel/hashlib.h	/^		const_iterator operator++() { index++; return *this; }$/;"	f	class:hashlib::idict::const_iterator	typeref:typename:const_iterator
operator ++	yosys/kernel/hashlib.h	/^		const_iterator operator++() { index--; return *this; }$/;"	f	class:hashlib::dict::const_iterator	typeref:typename:const_iterator
operator ++	yosys/kernel/hashlib.h	/^		const_iterator operator++() { index--; return *this; }$/;"	f	class:hashlib::pool::const_iterator	typeref:typename:const_iterator
operator ++	yosys/kernel/hashlib.h	/^		iterator operator++() { index--; return *this; }$/;"	f	class:hashlib::dict::iterator	typeref:typename:iterator
operator ++	yosys/kernel/hashlib.h	/^		iterator operator++() { index--; return *this; }$/;"	f	class:hashlib::pool::iterator	typeref:typename:iterator
operator ++	yosys/kernel/rtlil.h	/^		inline ObjIterator<T>& operator++() {$/;"	f	struct:RTLIL::ObjIterator	typeref:typename:ObjIterator<T> &
operator ++	yosys/kernel/rtlil.h	/^		inline const ObjIterator<T> operator++(int) {$/;"	f	struct:RTLIL::ObjIterator	typeref:typename:const ObjIterator<T>
operator ++	yosys/kernel/rtlil.h	/^	inline void operator++() { index++; }$/;"	f	struct:RTLIL::SigSpecConstIterator	typeref:typename:void
operator ++	yosys/kernel/rtlil.h	/^	inline void operator++() { index++; }$/;"	f	struct:RTLIL::SigSpecIterator	typeref:typename:void
operator ++	yosys/libs/bigint/BigInteger.cc	/^void BigInteger::operator ++() {$/;"	f	class:BigInteger	typeref:typename:void
operator ++	yosys/libs/bigint/BigInteger.cc	/^void BigInteger::operator ++(int) {$/;"	f	class:BigInteger	typeref:typename:void
operator ++	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::operator ++() {$/;"	f	class:BigUnsigned	typeref:typename:void
operator ++	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::operator ++(int) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator ++	yosys/libs/minisat/ParseUtils.h	/^    void operator ++ ()       { pos++; assureLookahead(); }$/;"	f	class:Minisat::StreamBuffer	typeref:typename:void
operator ++	yosys/libs/minisat/SolverTypes.h	/^    void operator++()   { lits++; }$/;"	f	class:Minisat::TrailIterator	typeref:typename:void
operator ++	yosys/libs/minisat/SolverTypes.h	/^    void operator++(){ crefs++; }$/;"	f	class:Minisat::ClauseIterator	typeref:typename:void
operator +=	yosys/kernel/hashlib.h	/^		const_iterator operator+=(int amt) { index -= amt; return *this; }$/;"	f	class:hashlib::dict::const_iterator	typeref:typename:const_iterator
operator +=	yosys/kernel/hashlib.h	/^		iterator operator+=(int amt) { index -= amt; return *this; }$/;"	f	class:hashlib::dict::iterator	typeref:typename:iterator
operator +=	yosys/kernel/rtlil.h	/^		inline ObjIterator<T>& operator+=(int amt) {$/;"	f	struct:RTLIL::ObjIterator	typeref:typename:ObjIterator<T> &
operator +=	yosys/libs/bigint/BigInteger.hh	/^inline void BigInteger::operator +=(const BigInteger &x) {$/;"	f	class:BigInteger	typeref:typename:void
operator +=	yosys/libs/bigint/BigUnsigned.hh	/^inline void BigUnsigned::operator +=(const BigUnsigned &x) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator -	yosys/libs/bigint/BigInteger.hh	/^inline BigInteger BigInteger::operator -() const {$/;"	f	class:BigInteger	typeref:typename:BigInteger
operator -	yosys/libs/bigint/BigInteger.hh	/^inline BigInteger BigInteger::operator -(const BigInteger &x) const {$/;"	f	class:BigInteger	typeref:typename:BigInteger
operator -	yosys/libs/bigint/BigUnsigned.hh	/^inline BigUnsigned BigUnsigned::operator -(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned
operator -	yosys/libs/ezsat/ezsat.h	/^	ezSATvec operator -() { return ezSATvec(sat, sat.vec_neg(vec)); }$/;"	f	struct:ezSATvec	typeref:typename:ezSATvec
operator -	yosys/libs/ezsat/ezsat.h	/^	ezSATvec operator -(const ezSATvec &other) { return ezSATvec(sat, sat.vec_sub(vec, other.vec));/;"	f	struct:ezSATvec	typeref:typename:ezSATvec
operator --	yosys/libs/bigint/BigInteger.cc	/^void BigInteger::operator --() {$/;"	f	class:BigInteger	typeref:typename:void
operator --	yosys/libs/bigint/BigInteger.cc	/^void BigInteger::operator --(int) {$/;"	f	class:BigInteger	typeref:typename:void
operator --	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::operator --() {$/;"	f	class:BigUnsigned	typeref:typename:void
operator --	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::operator --(int) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator -=	yosys/libs/bigint/BigInteger.hh	/^inline void BigInteger::operator -=(const BigInteger &x) {$/;"	f	class:BigInteger	typeref:typename:void
operator -=	yosys/libs/bigint/BigUnsigned.hh	/^inline void BigUnsigned::operator -=(const BigUnsigned &x) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator ->	yosys/kernel/hashlib.h	/^		K *operator->() { return &ptr->entries[index].udata; }$/;"	f	class:hashlib::pool::iterator	typeref:typename:K *
operator ->	yosys/kernel/hashlib.h	/^		const K *operator->() const { return &container[index]; }$/;"	f	class:hashlib::idict::const_iterator	typeref:typename:const K *
operator ->	yosys/kernel/hashlib.h	/^		const K *operator->() const { return &ptr->entries[index].udata; }$/;"	f	class:hashlib::pool::const_iterator	typeref:typename:const K *
operator ->	yosys/kernel/hashlib.h	/^		const K *operator->() const { return &ptr->entries[index].udata; }$/;"	f	class:hashlib::pool::iterator	typeref:typename:const K *
operator ->	yosys/kernel/hashlib.h	/^		const std::pair<K, T> *operator->() const { return &ptr->entries[index].udata; }$/;"	f	class:hashlib::dict::const_iterator	typeref:typename:const std::pair<K,T> *
operator ->	yosys/kernel/hashlib.h	/^		const std::pair<K, T> *operator->() const { return &ptr->entries[index].udata; }$/;"	f	class:hashlib::dict::iterator	typeref:typename:const std::pair<K,T> *
operator ->	yosys/kernel/hashlib.h	/^		std::pair<K, T> *operator->() { return &ptr->entries[index].udata; }$/;"	f	class:hashlib::dict::iterator	typeref:typename:std::pair<K,T> *
operator /	yosys/libs/bigint/BigInteger.hh	/^inline BigInteger BigInteger::operator \/(const BigInteger &x) const {$/;"	f	class:BigInteger	typeref:typename:BigInteger
operator /	yosys/libs/bigint/BigUnsigned.hh	/^inline BigUnsigned BigUnsigned::operator \/(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned
operator /=	yosys/libs/bigint/BigInteger.hh	/^inline void BigInteger::operator \/=(const BigInteger &x) {$/;"	f	class:BigInteger	typeref:typename:void
operator /=	yosys/libs/bigint/BigUnsigned.hh	/^inline void BigUnsigned::operator \/=(const BigUnsigned &x) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator <	yosys/kernel/hashlib.h	/^		bool operator<(const const_iterator &other) const { return index > other.index; }$/;"	f	class:hashlib::dict::const_iterator	typeref:typename:bool
operator <	yosys/kernel/hashlib.h	/^		bool operator<(const entry_t &other) const { return udata.first < other.udata.first; }$/;"	f	struct:hashlib::dict::entry_t	typeref:typename:bool
operator <	yosys/kernel/hashlib.h	/^		bool operator<(const iterator &other) const { return index > other.index; }$/;"	f	class:hashlib::dict::iterator	typeref:typename:bool
operator <	yosys/kernel/modtools.h	/^		bool operator<(const PortBit &other) const {$/;"	f	struct:ModWalker::PortBit	typeref:typename:bool
operator <	yosys/kernel/modtools.h	/^		bool operator<(const PortInfo &other) const {$/;"	f	struct:ModIndex::PortInfo	typeref:typename:bool
operator <	yosys/kernel/rtlil.cc	/^bool RTLIL::Const::operator <(const RTLIL::Const &other) const$/;"	f	class:RTLIL::Const	typeref:typename:bool
operator <	yosys/kernel/rtlil.cc	/^bool RTLIL::SigChunk::operator <(const RTLIL::SigChunk &other) const$/;"	f	class:RTLIL::SigChunk	typeref:typename:bool
operator <	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::operator <(const RTLIL::SigSpec &other) const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
operator <	yosys/kernel/rtlil.h	/^		inline bool operator<(const IdString &rhs) const {$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
operator <	yosys/kernel/rtlil.h	/^inline bool RTLIL::SigBit::operator<(const RTLIL::SigBit &other) const {$/;"	f	class:RTLIL::SigBit	typeref:typename:bool
operator <	yosys/libs/bigint/BigInteger.hh	/^	bool operator < (const BigInteger &x) const { return compareTo(x) == less   ; }$/;"	f	class:BigInteger	typeref:typename:bool
operator <	yosys/libs/bigint/BigUnsigned.hh	/^	bool operator < (const BigUnsigned &x) const { return compareTo(x) == less   ; }$/;"	f	class:BigUnsigned	typeref:typename:bool
operator <	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator < (const ezSATvec &other) { return ezSATbit(sat, sat.vec_lt_unsigned(vec, oth/;"	f	struct:ezSATvec	typeref:typename:ezSATbit
operator <	yosys/libs/ezsat/puzzle3d.cc	/^	bool operator< (const blockgeom_t &other) const {$/;"	f	struct:blockgeom_t	typeref:typename:bool	file:
operator <	yosys/libs/json11/json11.cpp	/^    bool operator<(NullStruct) const { return false; }$/;"	f	struct:json11::NullStruct	typeref:typename:bool	file:
operator <	yosys/libs/json11/json11.cpp	/^bool Json::operator< (const Json &other) const {$/;"	f	class:json11::Json	typeref:typename:bool
operator <	yosys/libs/minisat/SolverTypes.h	/^    bool operator <  (Lit p) const { return x < p.x;  } \/\/ '<' makes p, ~p adjacent in the ord/;"	f	struct:Minisat::Lit	typeref:typename:bool
operator <	yosys/libs/subcircuit/subcircuit.cc	/^		bool operator < (const DiBit &other) const$/;"	f	struct:SubCircuit::SolverWorker::DiBit	typeref:typename:bool	file:
operator <	yosys/libs/subcircuit/subcircuit.cc	/^		bool operator < (const DiEdge &other) const$/;"	f	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:bool	file:
operator <	yosys/libs/subcircuit/subcircuit.cc	/^		bool operator < (const DiNode &other) const$/;"	f	struct:SubCircuit::SolverWorker::DiNode	typeref:typename:bool	file:
operator <	yosys/libs/subcircuit/subcircuit.cc	/^		bool operator <(const NodeSet &other) const {$/;"	f	struct:SubCircuit::SolverWorker::NodeSet	typeref:typename:bool	file:
operator <	yosys/libs/subcircuit/subcircuit.cc	/^bool SubCircuit::Graph::BitRef::operator < (const BitRef &other) const$/;"	f	class:SubCircuit::Graph::BitRef	typeref:typename:bool
operator <	yosys/passes/opt/opt_share.cc	/^	bool operator<(const ExtSigSpec &other) const$/;"	f	struct:ExtSigSpec	typeref:typename:bool	file:
operator <	yosys/passes/opt/opt_share.cc	/^	bool operator<(const OpMuxConn &other) const$/;"	f	struct:OpMuxConn	typeref:typename:bool	file:
operator <	yosys/passes/sat/freduce.cc	/^	bool operator<(const equiv_bit_t &other) const {$/;"	f	struct:equiv_bit_t	typeref:typename:bool	file:
operator <	yosys/passes/sat/sat.cc	/^		bool operator < (const ModelBlockInfo &other) const {$/;"	f	struct:SatHelper::ModelBlockInfo	typeref:typename:bool	file:
operator <<	yosys/backends/cxxrtl/cxxrtl.h	/^std::ostream &operator<<(std::ostream &os, const value<Bits> &val) {$/;"	f	namespace:cxxrtl	typeref:typename:std::ostream &
operator <<	yosys/backends/cxxrtl/cxxrtl.h	/^std::ostream &operator<<(std::ostream &os, const wire<Bits> &val) {$/;"	f	namespace:cxxrtl	typeref:typename:std::ostream &
operator <<	yosys/libs/bigint/BigIntegerUtils.cc	/^std::ostream &operator <<(std::ostream &os, const BigInteger &x) {$/;"	f	typeref:typename:std::ostream &
operator <<	yosys/libs/bigint/BigIntegerUtils.cc	/^std::ostream &operator <<(std::ostream &os, const BigUnsigned &x) {$/;"	f	typeref:typename:std::ostream &
operator <<	yosys/libs/bigint/BigUnsigned.hh	/^inline BigUnsigned BigUnsigned::operator <<(int b) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned
operator <<	yosys/libs/ezsat/ezsat.h	/^	ezSATvec operator <<(int shift) { return ezSATvec(sat, sat.vec_shl(vec, shift)); }$/;"	f	struct:ezSATvec	typeref:typename:ezSATvec
operator <<=	yosys/libs/bigint/BigUnsigned.hh	/^inline void BigUnsigned::operator <<=(int b) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator <=	yosys/libs/bigint/BigInteger.hh	/^	bool operator <=(const BigInteger &x) const { return compareTo(x) != greater; }$/;"	f	class:BigInteger	typeref:typename:bool
operator <=	yosys/libs/bigint/BigUnsigned.hh	/^	bool operator <=(const BigUnsigned &x) const { return compareTo(x) != greater; }$/;"	f	class:BigUnsigned	typeref:typename:bool
operator <=	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator <=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_le_unsigned(vec, oth/;"	f	struct:ezSATvec	typeref:typename:ezSATbit
operator <=	yosys/libs/json11/json11.hpp	/^    bool operator<= (const Json &rhs) const { return !(rhs < *this); }$/;"	f	class:json11::Json	typeref:typename:bool
operator =	yosys/backends/cxxrtl/cxxrtl.h	/^	concat_expr<T, U> &operator=(const value<bits> &rhs) {$/;"	f	struct:cxxrtl::concat_expr	typeref:typename:CXXRTL_ALWAYS_INLINE concat_expr<T,U> &
operator =	yosys/backends/cxxrtl/cxxrtl.h	/^	memory<Width> &operator=(memory<Width> &&other) {$/;"	f	struct:cxxrtl::memory	typeref:typename:memory<Width> &
operator =	yosys/backends/cxxrtl/cxxrtl.h	/^	slice_expr<T, Stop, Start> &operator=(const value<bits> &rhs) {$/;"	f	struct:cxxrtl::slice_expr	typeref:typename:CXXRTL_ALWAYS_INLINE slice_expr<T,Stop,Start> &
operator =	yosys/kernel/hashlib.h	/^	dict &operator=(const dict &other) {$/;"	f	class:hashlib::dict	typeref:typename:dict &
operator =	yosys/kernel/hashlib.h	/^	dict &operator=(dict &&other) {$/;"	f	class:hashlib::dict	typeref:typename:dict &
operator =	yosys/kernel/hashlib.h	/^	pool &operator=(const pool &other) {$/;"	f	class:hashlib::pool	typeref:typename:pool &
operator =	yosys/kernel/hashlib.h	/^	pool &operator=(pool &&other) {$/;"	f	class:hashlib::pool	typeref:typename:pool &
operator =	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec &RTLIL::SigSpec::operator=(const RTLIL::SigSpec &other)$/;"	f	class:RTLIL::SigSpec	typeref:typename:RTLIL::SigSpec &
operator =	yosys/kernel/rtlil.h	/^		ObjIterator &operator=(const RTLIL::ObjIterator<T> &other) {$/;"	f	struct:RTLIL::ObjIterator	typeref:typename:ObjIterator &
operator =	yosys/kernel/rtlil.h	/^		inline void operator=(const IdString &rhs) {$/;"	f	struct:RTLIL::IdString	typeref:typename:void
operator =	yosys/kernel/rtlil.h	/^		inline void operator=(const char *rhs) {$/;"	f	struct:RTLIL::IdString	typeref:typename:void
operator =	yosys/kernel/rtlil.h	/^		inline void operator=(const std::string &rhs) {$/;"	f	struct:RTLIL::IdString	typeref:typename:void
operator =	yosys/kernel/rtlil.h	/^	const RTLIL::SigSpec &operator=(RTLIL::SigSpec &&other) {$/;"	f	struct:RTLIL::SigSpec	typeref:typename:const RTLIL::SigSpec &
operator =	yosys/kernel/utils.h	/^	void operator=(const Other &other)$/;"	f	struct:stackmap	typeref:typename:void
operator =	yosys/libs/bigint/BigInteger.cc	/^void BigInteger::operator =(const BigInteger &x) {$/;"	f	class:BigInteger	typeref:typename:void
operator =	yosys/libs/bigint/BigUnsigned.hh	/^	void operator=(const BigUnsigned &x) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator =	yosys/libs/bigint/BigUnsignedInABase.hh	/^	void operator =(const BigUnsignedInABase &x) {$/;"	f	class:BigUnsignedInABase	typeref:typename:void
operator =	yosys/libs/bigint/NumberlikeArray.hh	/^void NumberlikeArray<Blk>::operator=(const NumberlikeArray<Blk> &x) {$/;"	f	class:NumberlikeArray	typeref:typename:void
operator =	yosys/libs/minisat/Options.h	/^    BoolOption& operator=(bool b)     { value = b; return *this; }$/;"	f	class:Minisat::BoolOption	typeref:typename:BoolOption &
operator =	yosys/libs/minisat/Options.h	/^    DoubleOption& operator=(double x)   { value = x; return *this; }$/;"	f	class:Minisat::DoubleOption	typeref:typename:DoubleOption &
operator =	yosys/libs/minisat/Options.h	/^    Int64Option& operator= (int64_t x)  { value = x; return *this; }$/;"	f	class:Minisat::Int64Option	typeref:typename:Int64Option &
operator =	yosys/libs/minisat/Options.h	/^    IntOption& operator= (int32_t x)  { value = x; return *this; }$/;"	f	class:Minisat::IntOption	typeref:typename:IntOption &
operator =	yosys/libs/minisat/Options.h	/^    StringOption& operator=    (const char* x)  { value = x; return *this; }$/;"	f	class:Minisat::StringOption	typeref:typename:StringOption &
operator ==	yosys/backends/cxxrtl/cxxrtl.h	/^	bool operator ==(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:bool
operator ==	yosys/frontends/ast/ast.cc	/^bool AstNode::operator==(const AstNode &other) const$/;"	f	class:AstNode	typeref:typename:bool
operator ==	yosys/kernel/bitpattern.h	/^		bool operator==(const bits_t &other) const {$/;"	f	struct:BitPatternPool::bits_t	typeref:typename:bool
operator ==	yosys/kernel/cellaigs.cc	/^bool Aig::operator==(const Aig &other) const$/;"	f	class:Aig	typeref:typename:bool
operator ==	yosys/kernel/cellaigs.cc	/^bool AigNode::operator==(const AigNode &other) const$/;"	f	class:AigNode	typeref:typename:bool
operator ==	yosys/kernel/hashlib.h	/^		bool operator==(const const_iterator &other) const { return index == other.index; }$/;"	f	class:hashlib::dict::const_iterator	typeref:typename:bool
operator ==	yosys/kernel/hashlib.h	/^		bool operator==(const const_iterator &other) const { return index == other.index; }$/;"	f	class:hashlib::idict::const_iterator	typeref:typename:bool
operator ==	yosys/kernel/hashlib.h	/^		bool operator==(const const_iterator &other) const { return index == other.index; }$/;"	f	class:hashlib::pool::const_iterator	typeref:typename:bool
operator ==	yosys/kernel/hashlib.h	/^		bool operator==(const iterator &other) const { return index == other.index; }$/;"	f	class:hashlib::dict::iterator	typeref:typename:bool
operator ==	yosys/kernel/hashlib.h	/^		bool operator==(const iterator &other) const { return index == other.index; }$/;"	f	class:hashlib::pool::iterator	typeref:typename:bool
operator ==	yosys/kernel/hashlib.h	/^	bool operator==(const dict &other) const {$/;"	f	class:hashlib::dict	typeref:typename:bool
operator ==	yosys/kernel/hashlib.h	/^	bool operator==(const pool &other) const {$/;"	f	class:hashlib::pool	typeref:typename:bool
operator ==	yosys/kernel/modtools.h	/^		bool operator==(const PortBit &other) const {$/;"	f	struct:ModWalker::PortBit	typeref:typename:bool
operator ==	yosys/kernel/modtools.h	/^		bool operator==(const PortInfo &other) const {$/;"	f	struct:ModIndex::PortInfo	typeref:typename:bool
operator ==	yosys/kernel/modtools.h	/^		bool operator==(const SigBitInfo &other) const {$/;"	f	struct:ModIndex::SigBitInfo	typeref:typename:bool
operator ==	yosys/kernel/rtlil.cc	/^bool RTLIL::Const::operator ==(const RTLIL::Const &other) const$/;"	f	class:RTLIL::Const	typeref:typename:bool
operator ==	yosys/kernel/rtlil.cc	/^bool RTLIL::SigChunk::operator ==(const RTLIL::SigChunk &other) const$/;"	f	class:RTLIL::SigChunk	typeref:typename:bool
operator ==	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::operator ==(const RTLIL::SigSpec &other) const$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
operator ==	yosys/kernel/rtlil.h	/^		bool operator==(const char *rhs) const { return strcmp(c_str(), rhs) == 0; }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
operator ==	yosys/kernel/rtlil.h	/^		bool operator==(const std::string &rhs) const { return c_str() == rhs; }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
operator ==	yosys/kernel/rtlil.h	/^		inline bool operator==(const IdString &rhs) const { return index_ == rhs.index_; }$/;"	f	struct:RTLIL::IdString	typeref:typename:bool
operator ==	yosys/kernel/rtlil.h	/^		inline bool operator==(const RTLIL::ObjIterator<T> &other) const {$/;"	f	struct:RTLIL::ObjIterator	typeref:typename:bool
operator ==	yosys/kernel/rtlil.h	/^	inline bool operator==(const RTLIL::SigSpecIterator &other) const { return index == other.index/;"	f	struct:RTLIL::SigSpecConstIterator	typeref:typename:bool
operator ==	yosys/kernel/rtlil.h	/^	inline bool operator==(const RTLIL::SigSpecIterator &other) const { return index == other.index/;"	f	struct:RTLIL::SigSpecIterator	typeref:typename:bool
operator ==	yosys/kernel/rtlil.h	/^inline bool RTLIL::SigBit::operator==(const RTLIL::SigBit &other) const {$/;"	f	class:RTLIL::SigBit	typeref:typename:bool
operator ==	yosys/kernel/timinginfo.h	/^		bool operator==(const BitBit& bb) const { return bb.first == first && bb.second == second; }$/;"	f	struct:TimingInfo::BitBit	typeref:typename:bool
operator ==	yosys/kernel/timinginfo.h	/^		bool operator==(const NameBit& nb) const { return nb.name == name && nb.offset == offset; }$/;"	f	struct:TimingInfo::NameBit	typeref:typename:bool
operator ==	yosys/kernel/yosys.h	/^	bool operator==(const shared_str &other) const { return *content == *other.content; }$/;"	f	struct:shared_str	typeref:typename:bool
operator ==	yosys/libs/bigint/BigInteger.hh	/^	bool operator ==(const BigInteger &x) const {$/;"	f	class:BigInteger	typeref:typename:bool
operator ==	yosys/libs/bigint/BigUnsigned.hh	/^	bool operator ==(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:bool
operator ==	yosys/libs/bigint/BigUnsignedInABase.hh	/^	bool operator ==(const BigUnsignedInABase &x) const {$/;"	f	class:BigUnsignedInABase	typeref:typename:bool
operator ==	yosys/libs/bigint/NumberlikeArray.hh	/^bool NumberlikeArray<Blk>::operator ==(const NumberlikeArray<Blk> &x) const {$/;"	f	class:NumberlikeArray	typeref:typename:bool
operator ==	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator ==(const ezSATbit &other) { return ezSATbit(sat, sat.IFF(id, other.id)); }$/;"	f	struct:ezSATbit	typeref:typename:ezSATbit
operator ==	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator ==(const ezSATvec &other) { return ezSATbit(sat, sat.vec_eq(vec, other.vec));/;"	f	struct:ezSATvec	typeref:typename:ezSATbit
operator ==	yosys/libs/json11/json11.cpp	/^    bool operator==(NullStruct) const { return true; }$/;"	f	struct:json11::NullStruct	typeref:typename:bool	file:
operator ==	yosys/libs/json11/json11.cpp	/^bool Json::operator== (const Json &other) const {$/;"	f	class:json11::Json	typeref:typename:bool
operator ==	yosys/libs/minisat/Solver.h	/^        bool operator==(const Watcher& w) const { return cref == w.cref; }$/;"	f	struct:Minisat::Solver::Watcher	typeref:typename:bool
operator ==	yosys/libs/minisat/SolverTypes.h	/^    bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value /;"	f	class:Minisat::lbool	typeref:typename:bool
operator ==	yosys/libs/minisat/SolverTypes.h	/^    bool operator == (Lit p) const { return x == p.x; }$/;"	f	struct:Minisat::Lit	typeref:typename:bool
operator ==	yosys/libs/minisat/SolverTypes.h	/^    bool operator==(const ClauseIterator& ci) const { return crefs == ci.crefs; }$/;"	f	class:Minisat::ClauseIterator	typeref:typename:bool
operator ==	yosys/libs/minisat/SolverTypes.h	/^    bool operator==(const TrailIterator& ti) const { return lits == ti.lits; }$/;"	f	class:Minisat::TrailIterator	typeref:typename:bool
operator ==	yosys/passes/equiv/equiv_struct.cc	/^		bool operator==(const merge_key_t &other) const {$/;"	f	struct:EquivStructWorker::merge_key_t	typeref:typename:bool	file:
operator ==	yosys/passes/opt/opt_share.cc	/^	bool operator==(const ExtSigSpec &other) const { return is_signed == other.is_signed && sign ==/;"	f	struct:ExtSigSpec	typeref:typename:bool	file:
operator ==	yosys/passes/opt/opt_share.cc	/^	bool operator==(const RTLIL::SigSpec &other) const { return (sign != RTLIL::Const(0, 1)) ? fals/;"	f	struct:ExtSigSpec	typeref:typename:bool	file:
operator ==	yosys/passes/proc/proc_dlatch.cc	/^		bool operator==(const rule_node_t &other) const {$/;"	f	struct:proc_dlatch_db_t::rule_node_t	typeref:typename:bool	file:
operator ==	yosys/passes/techmap/flowmap.cc	/^		bool operator==(const NodePrime &other) const$/;"	f	struct:FlowGraph::NodePrime	typeref:typename:bool	file:
operator >	yosys/libs/bigint/BigInteger.hh	/^	bool operator > (const BigInteger &x) const { return compareTo(x) == greater; }$/;"	f	class:BigInteger	typeref:typename:bool
operator >	yosys/libs/bigint/BigUnsigned.hh	/^	bool operator > (const BigUnsigned &x) const { return compareTo(x) == greater; }$/;"	f	class:BigUnsigned	typeref:typename:bool
operator >	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator > (const ezSATvec &other) { return ezSATbit(sat, sat.vec_gt_unsigned(vec, oth/;"	f	struct:ezSATvec	typeref:typename:ezSATbit
operator >	yosys/libs/json11/json11.hpp	/^    bool operator>  (const Json &rhs) const { return  (rhs < *this); }$/;"	f	class:json11::Json	typeref:typename:bool
operator >=	yosys/libs/bigint/BigInteger.hh	/^	bool operator >=(const BigInteger &x) const { return compareTo(x) != less   ; }$/;"	f	class:BigInteger	typeref:typename:bool
operator >=	yosys/libs/bigint/BigUnsigned.hh	/^	bool operator >=(const BigUnsigned &x) const { return compareTo(x) != less   ; }$/;"	f	class:BigUnsigned	typeref:typename:bool
operator >=	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator >=(const ezSATvec &other) { return ezSATbit(sat, sat.vec_ge_unsigned(vec, oth/;"	f	struct:ezSATvec	typeref:typename:ezSATbit
operator >=	yosys/libs/json11/json11.hpp	/^    bool operator>= (const Json &rhs) const { return !(*this < rhs); }$/;"	f	class:json11::Json	typeref:typename:bool
operator >>	yosys/libs/bigint/BigUnsigned.hh	/^inline BigUnsigned BigUnsigned::operator >>(int b) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned
operator >>	yosys/libs/ezsat/ezsat.h	/^	ezSATvec operator >>(int shift) { return ezSATvec(sat, sat.vec_shr(vec, shift)); }$/;"	f	struct:ezSATvec	typeref:typename:ezSATvec
operator >>=	yosys/libs/bigint/BigUnsigned.hh	/^inline void BigUnsigned::operator >>=(int b) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator BigUnsigned	yosys/libs/bigint/BigUnsignedInABase.cc	/^BigUnsignedInABase::operator BigUnsigned() const {$/;"	f	class:BigUnsignedInABase
operator T*	yosys/libs/minisat/Vec.h	/^    operator T*       (void)           { return data; }$/;"	f	class:Minisat::vec
operator []	yosys/backends/cxxrtl/cxxrtl.h	/^	const debug_item &operator [](const std::string &name) const {$/;"	f	struct:cxxrtl::debug_items	typeref:typename:const debug_item &
operator []	yosys/backends/cxxrtl/cxxrtl.h	/^	const value<Width> &operator [](size_t index) const {$/;"	f	struct:cxxrtl::memory	typeref:typename:const value<Width> &
operator []	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Width> &operator [](size_t index) {$/;"	f	struct:cxxrtl::memory	typeref:typename:value<Width> &
operator []	yosys/kernel/bitpattern.h	/^		RTLIL::State &operator[](int index) {$/;"	f	struct:BitPatternPool::bits_t	typeref:typename:RTLIL::State &
operator []	yosys/kernel/bitpattern.h	/^		const RTLIL::State &operator[](int index) const {$/;"	f	struct:BitPatternPool::bits_t	typeref:typename:const RTLIL::State &
operator []	yosys/kernel/hashlib.h	/^	T& operator[](const K &key)$/;"	f	class:hashlib::dict	typeref:typename:T &
operator []	yosys/kernel/hashlib.h	/^	bool operator[](const K &key)$/;"	f	class:hashlib::pool	typeref:typename:bool
operator []	yosys/kernel/hashlib.h	/^	const K &operator[](int index) const$/;"	f	class:hashlib::idict	typeref:typename:const K &
operator []	yosys/kernel/hashlib.h	/^	const K &operator[](int index) const$/;"	f	class:hashlib::mfp	typeref:typename:const K &
operator []	yosys/kernel/rtlil.h	/^		char operator[](size_t i) const {$/;"	f	struct:RTLIL::IdString	typeref:typename:char
operator []	yosys/kernel/rtlil.h	/^	inline RTLIL::SigBit &operator[](int index) { inline_unpack(); return bits_.at(index); }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:RTLIL::SigBit &
operator []	yosys/kernel/rtlil.h	/^	inline RTLIL::State &operator[](int index) { return bits.at(index); }$/;"	f	struct:RTLIL::Const	typeref:typename:RTLIL::State &
operator []	yosys/kernel/rtlil.h	/^	inline const RTLIL::SigBit &operator[](int index) const { inline_unpack(); return bits_.at(inde/;"	f	struct:RTLIL::SigSpec	typeref:typename:const RTLIL::SigBit &
operator []	yosys/kernel/rtlil.h	/^	inline const RTLIL::State &operator[](int index) const { return bits.at(index); }$/;"	f	struct:RTLIL::Const	typeref:typename:const RTLIL::State &
operator []	yosys/libs/minisat/Alloc.h	/^    T&       operator[](Ref r)       { assert(r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator	typeref:typename:T &
operator []	yosys/libs/minisat/Alloc.h	/^    const T& operator[](Ref r) const { assert(r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator	typeref:typename:const T &
operator []	yosys/libs/minisat/Heap.h	/^    int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }$/;"	f	class:Minisat::Heap	typeref:typename:int
operator []	yosys/libs/minisat/IntMap.h	/^        V&       operator[](K k)       { assert(has(k)); return map[index(k)]; }$/;"	f	class:Minisat::IntMap	typeref:typename:V &
operator []	yosys/libs/minisat/IntMap.h	/^        const V& operator[](K k) const { assert(has(k)); return map[index(k)]; }$/;"	f	class:Minisat::IntMap	typeref:typename:const V &
operator []	yosys/libs/minisat/SolverTypes.h	/^    Clause&       operator[](CRef r)         { return (Clause&)ra[r]; }$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:Clause &
operator []	yosys/libs/minisat/SolverTypes.h	/^    Vec&  operator[](const K& idx){ return occs[idx]; }$/;"	f	class:Minisat::OccLists	typeref:typename:Vec &
operator []	yosys/libs/minisat/SolverTypes.h	/^    const Clause& operator[](CRef r) const   { return (Clause&)ra[r]; }$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:const Clause &
operator [] 	yosys/libs/json11/json11.cpp	/^const Json &              JsonValue::operator[] (const string &) const { return static_null(); }$/;"	f	class:json11::JsonValue	typeref:typename:const Json &
operator [] 	yosys/libs/json11/json11.cpp	/^const Json &              JsonValue::operator[] (size_t)         const { return static_null(); }$/;"	f	class:json11::JsonValue	typeref:typename:const Json &
operator [] 	yosys/libs/json11/json11.cpp	/^const Json & Json::operator[] (const string &key) const { return (*m_ptr)[key];         }$/;"	f	class:json11::Json	typeref:typename:const Json &
operator [] 	yosys/libs/json11/json11.cpp	/^const Json & Json::operator[] (size_t i)          const { return (*m_ptr)[i];           }$/;"	f	class:json11::Json	typeref:typename:const Json &
operator [] 	yosys/libs/json11/json11.cpp	/^const Json & JsonArray::operator[] (size_t i) const {$/;"	f	class:json11::JsonArray	typeref:typename:const Json &
operator [] 	yosys/libs/json11/json11.cpp	/^const Json & JsonObject::operator[] (const string &key) const {$/;"	f	class:json11::JsonObject	typeref:typename:const Json &
operator [] 	yosys/libs/minisat/IntMap.h	/^        K        operator [] (int index) const  { return xs[index]; }$/;"	f	class:Minisat::IntSet	typeref:typename:K
operator [] 	yosys/libs/minisat/Map.h	/^    D& operator [] (const K& k)$/;"	f	class:Minisat::Map	typeref:typename:D &
operator [] 	yosys/libs/minisat/Map.h	/^    const D& operator [] (const K& k) const$/;"	f	class:Minisat::Map	typeref:typename:const D &
operator [] 	yosys/libs/minisat/Queue.h	/^    T&       operator [] (int index)        { assert(index >= 0); assert(index < size()); return/;"	f	class:Minisat::Queue	typeref:typename:T &
operator [] 	yosys/libs/minisat/Queue.h	/^    const T& operator [] (int index) const  { assert(index >= 0); assert(index < size()); return/;"	f	class:Minisat::Queue	typeref:typename:const T &
operator [] 	yosys/libs/minisat/SolverTypes.h	/^    Lit          operator [] (int i) const   { return data[i].lit; }$/;"	f	class:Minisat::Clause	typeref:typename:Lit
operator [] 	yosys/libs/minisat/SolverTypes.h	/^    Lit&         operator [] (int i)         { return data[i].lit; }$/;"	f	class:Minisat::Clause	typeref:typename:Lit &
operator [] 	yosys/libs/minisat/SolverTypes.h	/^    T&       operator [] (CRef cr)            { return map[cr]; }$/;"	f	class:Minisat::CMap	typeref:typename:T &
operator [] 	yosys/libs/minisat/SolverTypes.h	/^    const T& operator [] (CRef cr) const      { return map[cr]; }$/;"	f	class:Minisat::CMap	typeref:typename:const T &
operator [] 	yosys/libs/minisat/Vec.h	/^    T&       operator [] (Size index)       { return data[index]; }$/;"	f	class:Minisat::vec	typeref:typename:T &
operator [] 	yosys/libs/minisat/Vec.h	/^    const T& operator [] (Size index) const { return data[index]; }$/;"	f	class:Minisat::vec	typeref:typename:const T &
operator ^	yosys/libs/bigint/BigUnsigned.hh	/^inline BigUnsigned BigUnsigned::operator ^(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned
operator ^	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator ^(const ezSATbit &other) { return ezSATbit(sat, sat.XOR(id, other.id)); }$/;"	f	struct:ezSATbit	typeref:typename:ezSATbit
operator ^	yosys/libs/ezsat/ezsat.h	/^	ezSATvec operator ^(const ezSATvec &other) { return ezSATvec(sat, sat.vec_xor(vec, other.vec));/;"	f	struct:ezSATvec	typeref:typename:ezSATvec
operator ^	yosys/libs/minisat/SolverTypes.h	/^    lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }$/;"	f	class:Minisat::lbool	typeref:typename:lbool
operator ^	yosys/libs/minisat/SolverTypes.h	/^inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }$/;"	f	namespace:Minisat	typeref:typename:Lit
operator ^=	yosys/libs/bigint/BigUnsigned.hh	/^inline void BigUnsigned::operator ^=(const BigUnsigned &x) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator bool	yosys/backends/cxxrtl/cxxrtl.h	/^	explicit operator bool() const {$/;"	f	struct:cxxrtl::value
operator bool	yosys/libs/minisat/Options.h	/^    operator    bool     (void) const { return value; }$/;"	f	class:Minisat::BoolOption
operator bool&	yosys/libs/minisat/Options.h	/^    operator    bool&    (void)       { return value; }$/;"	f	class:Minisat::BoolOption
operator const Lit*	yosys/libs/minisat/SolverTypes.h	/^    operator const Lit* (void) const         { return (Lit*)data; }$/;"	f	class:Minisat::Clause
operator const char*	yosys/libs/minisat/Options.h	/^    operator      const char*  (void) const     { return value; }$/;"	f	class:Minisat::StringOption
operator const char*&	yosys/libs/minisat/Options.h	/^    operator      const char*& (void)           { return value; }$/;"	f	class:Minisat::StringOption
operator const_iterator	yosys/kernel/hashlib.h	/^		operator const_iterator() const { return const_iterator(ptr, index); }$/;"	f	class:hashlib::dict::iterator
operator const_iterator	yosys/kernel/hashlib.h	/^		operator const_iterator() const { return const_iterator(ptr, index); }$/;"	f	class:hashlib::pool::iterator
operator double	yosys/libs/minisat/Options.h	/^    operator      double   (void) const { return value; }$/;"	f	class:Minisat::DoubleOption
operator double&	yosys/libs/minisat/Options.h	/^    operator      double&  (void)       { return value; }$/;"	f	class:Minisat::DoubleOption
operator ezSAT::_V	yosys/libs/ezsat/ezsat.h	/^	operator ezSAT::_V() const { return ezSAT::_V(id); }$/;"	f	struct:ezSATbit
operator int	yosys/libs/ezsat/ezsat.h	/^	operator int() const { return id; }$/;"	f	struct:ezSATbit
operator int32_t	yosys/libs/minisat/Options.h	/^    operator   int32_t   (void) const { return value; }$/;"	f	class:Minisat::IntOption
operator int32_t&	yosys/libs/minisat/Options.h	/^    operator   int32_t&  (void)       { return value; }$/;"	f	class:Minisat::IntOption
operator int64_t	yosys/libs/minisat/Options.h	/^    operator     int64_t   (void) const { return value; }$/;"	f	class:Minisat::Int64Option
operator int64_t&	yosys/libs/minisat/Options.h	/^    operator     int64_t&  (void)       { return value; }$/;"	f	class:Minisat::Int64Option
operator pool<T>	yosys/kernel/rtlil.h	/^		operator pool<T>() const {$/;"	f	struct:RTLIL::ObjRange
operator std::string	yosys/libs/bigint/BigUnsignedInABase.cc	/^BigUnsignedInABase::operator std::string() const {$/;"	f	class:BigUnsignedInABase
operator std::vector<RTLIL::SigBit>	yosys/kernel/rtlil.h	/^	operator std::vector<RTLIL::SigBit>() const { return bits(); }$/;"	f	struct:RTLIL::SigSpec
operator std::vector<RTLIL::SigChunk>	yosys/kernel/rtlil.h	/^	operator std::vector<RTLIL::SigChunk>() const { return chunks(); }$/;"	f	struct:RTLIL::SigSpec
operator std::vector<T>	yosys/kernel/rtlil.h	/^		operator std::vector<T>() const {$/;"	f	struct:RTLIL::ObjRange
operator std::vector<int>	yosys/libs/ezsat/ezsat.h	/^	operator std::vector<int>() const { return std::vector<int>(1, id); }$/;"	f	struct:ezSATbit
operator std::vector<int>	yosys/libs/ezsat/ezsat.h	/^	operator std::vector<int>() const { return vec; }$/;"	f	struct:ezSATvec
operator value<bits>	yosys/backends/cxxrtl/cxxrtl.h	/^	operator value<bits>() const {$/;"	f	struct:cxxrtl::concat_expr	typeref:typename:CXXRTL_ALWAYS_INLINE
operator value<bits>	yosys/backends/cxxrtl/cxxrtl.h	/^	operator value<bits>() const {$/;"	f	struct:cxxrtl::slice_expr	typeref:typename:CXXRTL_ALWAYS_INLINE
operator |	yosys/libs/bigint/BigUnsigned.hh	/^inline BigUnsigned BigUnsigned::operator |(const BigUnsigned &x) const {$/;"	f	class:BigUnsigned	typeref:typename:BigUnsigned
operator |	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator |(const ezSATbit &other) { return ezSATbit(sat, sat.OR(id, other.id)); }$/;"	f	struct:ezSATbit	typeref:typename:ezSATbit
operator |	yosys/libs/ezsat/ezsat.h	/^	ezSATvec operator |(const ezSATvec &other) { return ezSATvec(sat, sat.vec_or(vec, other.vec)); /;"	f	struct:ezSATvec	typeref:typename:ezSATvec
operator |=	yosys/libs/bigint/BigUnsigned.hh	/^inline void BigUnsigned::operator |=(const BigUnsigned &x) {$/;"	f	class:BigUnsigned	typeref:typename:void
operator ||	yosys/libs/minisat/SolverTypes.h	/^    lbool operator || (lbool b) const {$/;"	f	class:Minisat::lbool	typeref:typename:lbool
operator ~	yosys/libs/ezsat/ezsat.h	/^	ezSATbit operator ~() { return ezSATbit(sat, sat.NOT(id)); }$/;"	f	struct:ezSATbit	typeref:typename:ezSATbit
operator ~	yosys/libs/ezsat/ezsat.h	/^	ezSATvec operator ~() { return ezSATvec(sat, sat.vec_not(vec)); }$/;"	f	struct:ezSATvec	typeref:typename:ezSATvec
operator ~	yosys/libs/minisat/SolverTypes.h	/^inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }$/;"	f	namespace:Minisat	typeref:typename:Lit
operatorInport	yosys/frontends/verific/verific.cc	/^RTLIL::SigSpec VerificImporter::operatorInport(Instance *inst, const char *portname)$/;"	f	class:VerificImporter	typeref:typename:RTLIL::SigSpec
operatorInput	yosys/frontends/verific/verific.cc	/^RTLIL::SigSpec VerificImporter::operatorInput(Instance *inst)$/;"	f	class:VerificImporter	typeref:typename:RTLIL::SigSpec
operatorInput1	yosys/frontends/verific/verific.cc	/^RTLIL::SigSpec VerificImporter::operatorInput1(Instance *inst)$/;"	f	class:VerificImporter	typeref:typename:RTLIL::SigSpec
operatorInput2	yosys/frontends/verific/verific.cc	/^RTLIL::SigSpec VerificImporter::operatorInput2(Instance *inst)$/;"	f	class:VerificImporter	typeref:typename:RTLIL::SigSpec
operatorOutput	yosys/frontends/verific/verific.cc	/^RTLIL::SigSpec VerificImporter::operatorOutput(Instance *inst, const pool<Net*, hash_ptr_ops> *a/;"	f	class:VerificImporter	typeref:typename:RTLIL::SigSpec
ops	yosys/kernel/hashlib.h	/^	OPS ops;$/;"	m	class:hashlib::dict	typeref:typename:OPS
ops	yosys/kernel/hashlib.h	/^	OPS ops;$/;"	m	class:hashlib::pool	typeref:typename:OPS
opt	yosys/passes/opt/opt_dff.cc	/^	const OptDffOptions &opt;$/;"	m	struct:OptDffWorker	typeref:typename:const OptDffOptions &	file:
opt_aggressive	yosys/passes/opt/share.cc	/^	bool opt_aggressive;$/;"	m	struct:ShareWorkerConfig	typeref:typename:bool	file:
opt_alias_inputs	yosys/passes/fsm/fsm_opt.cc	/^	void opt_alias_inputs()$/;"	f	struct:FsmOpt	typeref:typename:void	file:
opt_bmux	yosys/passes/opt/opt_reduce.cc	/^	void opt_bmux(RTLIL::Cell *cell)$/;"	f	struct:OptReduceWorker	typeref:typename:void	file:
opt_ccmin_mode	yosys/libs/minisat/Solver.cc	/^static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minim/;"	v	typeref:typename:IntOption	file:
opt_clause_decay	yosys/libs/minisat/Solver.cc	/^static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay fact/;"	v	typeref:typename:DoubleOption	file:
opt_clause_lim	yosys/libs/minisat/SimpSolver.cc	/^static IntOption    opt_clause_lim       (_cat, "cl-lim",       "Variables are not eliminated if/;"	v	typeref:typename:IntOption	file:
opt_const_and_unused_inputs	yosys/passes/fsm/fsm_opt.cc	/^	void opt_const_and_unused_inputs()$/;"	f	struct:FsmOpt	typeref:typename:void	file:
opt_create_imprecise_model	yosys/passes/cmds/glift.cc	/^	bool opt_create_precise_model = false, opt_create_imprecise_model = false, opt_create_instrumen/;"	m	struct:GliftWorker	typeref:typename:bool	file:
opt_create_instrumented_model	yosys/passes/cmds/glift.cc	/^	bool opt_create_precise_model = false, opt_create_imprecise_model = false, opt_create_instrumen/;"	m	struct:GliftWorker	typeref:typename:bool	file:
opt_create_precise_model	yosys/passes/cmds/glift.cc	/^	bool opt_create_precise_model = false, opt_create_imprecise_model = false, opt_create_instrumen/;"	m	struct:GliftWorker	typeref:typename:bool	file:
opt_demux	yosys/passes/opt/opt_reduce.cc	/^	void opt_demux(RTLIL::Cell *cell)$/;"	f	struct:OptReduceWorker	typeref:typename:void	file:
opt_demux_bits	yosys/passes/opt/opt_reduce.cc	/^	bool opt_demux_bits(RTLIL::Cell *cell) {$/;"	f	struct:OptReduceWorker	typeref:typename:bool	file:
opt_eqpmux	yosys/passes/pmgen/test_pmgen.cc	/^void opt_eqpmux(test_pmgen_pm &pm)$/;"	f	typeref:typename:void
opt_fast	yosys/passes/opt/share.cc	/^	bool opt_fast;$/;"	m	struct:ShareWorkerConfig	typeref:typename:bool	file:
opt_feedback_inputs	yosys/passes/fsm/fsm_opt.cc	/^	void opt_feedback_inputs()$/;"	f	struct:FsmOpt	typeref:typename:void	file:
opt_find_dont_care	yosys/passes/fsm/fsm_opt.cc	/^	void opt_find_dont_care()$/;"	f	struct:FsmOpt	typeref:typename:void	file:
opt_find_dont_care_worker	yosys/passes/fsm/fsm_opt.cc	/^	void opt_find_dont_care_worker(std::set<RTLIL::Const> &set, int bit, FsmData::transition_t &tr,/;"	f	struct:FsmOpt	typeref:typename:void	file:
opt_force	yosys/passes/opt/share.cc	/^	bool opt_force;$/;"	m	struct:ShareWorkerConfig	typeref:typename:bool	file:
opt_garbage_frac	yosys/libs/minisat/Solver.cc	/^static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory /;"	v	typeref:typename:DoubleOption	file:
opt_grow	yosys/libs/minisat/SimpSolver.cc	/^static IntOption    opt_grow             (_cat, "grow",         "Allow a variable elimination st/;"	v	typeref:typename:IntOption	file:
opt_instrumentmore	yosys/passes/cmds/glift.cc	/^	bool opt_instrumentmore = false;$/;"	m	struct:GliftWorker	typeref:typename:bool	file:
opt_keepoutputs	yosys/passes/cmds/glift.cc	/^	bool opt_taintconstants = false, opt_keepoutputs = false, opt_simplecostmodel = false, opt_noco/;"	m	struct:GliftWorker	typeref:typename:bool	file:
opt_luby_restart	yosys/libs/minisat/Solver.cc	/^static BoolOption    opt_luby_restart      (_cat, "luby",        "Use the Luby restart sequence"/;"	v	typeref:typename:BoolOption	file:
opt_min_learnts_lim	yosys/libs/minisat/Solver.cc	/^static IntOption     opt_min_learnts_lim   (_cat, "min-learnts", "Minimum learnt clause limit", /;"	v	typeref:typename:IntOption	file:
opt_mux_bits	yosys/passes/opt/opt_reduce.cc	/^	bool opt_mux_bits(RTLIL::Cell *cell)$/;"	f	struct:OptReduceWorker	typeref:typename:bool	file:
opt_name	yosys/passes/hierarchy/submod.cc	/^	std::string opt_name;$/;"	m	struct:SubmodWorker	typeref:typename:std::string	file:
opt_nocostmodel	yosys/passes/cmds/glift.cc	/^	bool opt_taintconstants = false, opt_keepoutputs = false, opt_simplecostmodel = false, opt_noco/;"	m	struct:GliftWorker	typeref:typename:bool	file:
opt_phase_saving	yosys/libs/minisat/Solver.cc	/^static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase s/;"	v	typeref:typename:IntOption	file:
opt_pmux	yosys/passes/opt/opt_reduce.cc	/^	void opt_pmux(RTLIL::Cell *cell)$/;"	f	struct:OptReduceWorker	typeref:typename:void	file:
opt_random_seed	yosys/libs/minisat/Solver.cc	/^static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable se/;"	v	typeref:typename:DoubleOption	file:
opt_random_var_freq	yosys/libs/minisat/Solver.cc	/^static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the d/;"	v	typeref:typename:DoubleOption	file:
opt_reduce	yosys/passes/opt/opt_reduce.cc	/^	void opt_reduce(pool<RTLIL::Cell*> &cells, SigSet<RTLIL::Cell*> &drivers, RTLIL::Cell *cell)$/;"	f	struct:OptReduceWorker	typeref:typename:void	file:
opt_restart_first	yosys/libs/minisat/Solver.cc	/^static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 10/;"	v	typeref:typename:IntOption	file:
opt_restart_inc	yosys/libs/minisat/Solver.cc	/^static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase fact/;"	v	typeref:typename:DoubleOption	file:
opt_rnd_init_act	yosys/libs/minisat/Solver.cc	/^static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity/;"	v	typeref:typename:BoolOption	file:
opt_simp_garbage_frac	yosys/libs/minisat/SimpSolver.cc	/^static DoubleOption opt_simp_garbage_frac(_cat, "simp-gc-frac", "The fraction of wasted memory a/;"	v	typeref:typename:DoubleOption	file:
opt_simplecostmodel	yosys/passes/cmds/glift.cc	/^	bool opt_taintconstants = false, opt_keepoutputs = false, opt_simplecostmodel = false, opt_noco/;"	m	struct:GliftWorker	typeref:typename:bool	file:
opt_subsumption_lim	yosys/libs/minisat/SimpSolver.cc	/^static IntOption    opt_subsumption_lim  (_cat, "sub-lim",      "Do not check if subsumption aga/;"	v	typeref:typename:IntOption	file:
opt_taintconstants	yosys/passes/cmds/glift.cc	/^	bool opt_taintconstants = false, opt_keepoutputs = false, opt_simplecostmodel = false, opt_noco/;"	m	struct:GliftWorker	typeref:typename:bool	file:
opt_unreachable_states	yosys/passes/fsm/fsm_opt.cc	/^	void opt_unreachable_states()$/;"	f	struct:FsmOpt	typeref:typename:void	file:
opt_unused_outputs	yosys/passes/fsm/fsm_opt.cc	/^	void opt_unused_outputs()$/;"	f	struct:FsmOpt	typeref:typename:void	file:
opt_use_asymm	yosys/libs/minisat/SimpSolver.cc	/^static BoolOption   opt_use_asymm        (_cat, "asymm",        "Shrink clauses by asymmetric br/;"	v	typeref:typename:BoolOption	file:
opt_use_elim	yosys/libs/minisat/SimpSolver.cc	/^static BoolOption   opt_use_elim         (_cat, "elim",         "Perform variable elimination.",/;"	v	typeref:typename:BoolOption	file:
opt_use_rcheck	yosys/libs/minisat/SimpSolver.cc	/^static BoolOption   opt_use_rcheck       (_cat, "rcheck",       "Check if a clause is already im/;"	v	typeref:typename:BoolOption	file:
opt_var_decay	yosys/libs/minisat/Solver.cc	/^static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay fa/;"	v	typeref:typename:DoubleOption	file:
optarg	yosys/kernel/driver.cc	/^char *optarg;$/;"	v	typeref:typename:char *
optcur	yosys/kernel/driver.cc	/^int optind = 1, optcur = 1;$/;"	v	typeref:typename:int
optimize	yosys/kernel/macc.h	/^	void optimize(int width)$/;"	f	struct:Macc	typeref:typename:void
optimize	yosys/kernel/rtlil.cc	/^void RTLIL::Design::optimize()$/;"	f	class:RTLIL::Design	typeref:typename:void
optimize	yosys/kernel/rtlil.cc	/^void RTLIL::Module::optimize()$/;"	f	class:RTLIL::Module	typeref:typename:void
optimize	yosys/kernel/rtlil.cc	/^void RTLIL::Selection::optimize(RTLIL::Design *design)$/;"	f	class:RTLIL::Selection	typeref:typename:void
optimize_activation_patterns	yosys/passes/opt/share.cc	/^	void optimize_activation_patterns(pool<ssc_pair_t> &patterns)$/;"	f	struct:ShareWorker	typeref:typename:void	file:
optimize_area	yosys/passes/techmap/flowmap.cc	/^	void optimize_area(int depth, int optarea)$/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
optimize_cond	yosys/frontends/verific/verificsva.cc	/^	void optimize_cond(vector<Const> &values)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
optimize_fsm	yosys/passes/fsm/fsm_opt.cc	/^void YOSYS_NAMESPACE_PREFIX FsmData::optimize_fsm(RTLIL::Cell *cell, RTLIL::Module *module)$/;"	f	class:FsmData	typeref:typename:PRIVATE_NAMESPACE_END void YOSYS_NAMESPACE_PREFIX
optimze_as_needed	yosys/passes/fsm/fsm_expand.cc	/^	void optimze_as_needed()$/;"	f	struct:FsmExpand	typeref:typename:void	file:
optind	yosys/kernel/driver.cc	/^int optind = 1, optcur = 1;$/;"	v	typeref:typename:int
opts	yosys/passes/sat/fmcombine.cc	/^	const opts_t &opts;$/;"	m	struct:FmcombineWorker	typeref:typename:const opts_t &	file:
opts	yosys/passes/techmap/shregmap.cc	/^	const ShregmapOptions &opts;$/;"	m	struct:ShregmapWorker	typeref:typename:const ShregmapOptions &	file:
opts_t	yosys/passes/sat/fmcombine.cc	/^struct opts_t$/;"	s	file:
or_gate	yosys/kernel/cellaigs.cc	/^	int or_gate(int A, int B)$/;"	f	struct:AigMaker	typeref:typename:int	file:
or_generator	yosys/passes/techmap/pmuxtree.cc	/^static SigSpec or_generator(Module *module, const SigSpec &sig)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN SigSpec	file:
or_next_if_better	yosys/passes/memory/memory_bram.cc	/^		bool or_next_if_better, make_transp, make_outreg;$/;"	m	struct:rules_t::match_t	typeref:typename:bool	file:
or_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> or_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
or_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> or_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
order	yosys/passes/techmap/flowmap.cc	/^	int order;$/;"	m	struct:FlowmapWorker	typeref:typename:int	file:
order_heap	yosys/libs/minisat/Solver.h	/^    Heap<Var,VarOrderLt>order_heap;       \/\/ A priority queue of variables ordered with respec/;"	m	class:Minisat::Solver	typeref:typename:Heap<Var,VarOrderLt>
ordered	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::ordered(const std::vector<int> &vec1, const std::vector<int> &vec2, bool allow_equal)$/;"	f	class:ezSAT	typeref:typename:int
ordered_latches	yosys/backends/aiger/aiger.cc	/^	dict<SigBit, int> ordered_latches;$/;"	m	struct:AigerWriter	typeref:typename:dict<SigBit,int>	file:
ordered_outputs	yosys/backends/aiger/aiger.cc	/^	dict<SigBit, int> ordered_outputs;$/;"	m	struct:AigerWriter	typeref:typename:dict<SigBit,int>	file:
ordered_outputs	yosys/backends/aiger/xaiger.cc	/^	dict<SigBit, int> ordered_outputs;$/;"	m	struct:XAigerWriter	typeref:typename:dict<SigBit,int>	file:
orig_type	yosys/passes/sat/fmcombine.cc	/^	IdString orig_type, combined_type;$/;"	m	struct:FmcombineWorker	typeref:typename:IdString	file:
original	yosys/passes/sat/fmcombine.cc	/^	Module *original = nullptr;$/;"	m	struct:FmcombineWorker	typeref:typename:Module *	file:
ornot_gate	yosys/kernel/cellaigs.cc	/^	int ornot_gate(int A, int B)$/;"	f	struct:AigMaker	typeref:typename:int	file:
osu035_stdcells.lib	yosys/examples/osu035/Makefile	/^osu035_stdcells.lib:$/;"	t
out	yosys/passes/cmds/show.cc	/^	struct net_conn { std::set<std::pair<std::string, int>> in, out; std::string color; };$/;"	m	struct:ShowWorker::net_conn	typeref:typename:std::set<std::pair<std::string,int>>	file:
out_bits	yosys/passes/sat/freduce.cc	/^	std::vector<RTLIL::SigBit> out_bits, pi_bits;$/;"	m	struct:PerformReduction	typeref:typename:std::vector<RTLIL::SigBit>	file:
out_depth	yosys/passes/sat/freduce.cc	/^	std::vector<int> out_depth;$/;"	m	struct:PerformReduction	typeref:typename:std::vector<int>	file:
out_inverted	yosys/passes/sat/freduce.cc	/^	std::vector<bool> out_inverted;$/;"	m	struct:PerformReduction	typeref:typename:std::vector<bool>	file:
outbuf	yosys/kernel/register.cc	/^	} outbuf;$/;"	m	class:gzip_ostream	typeref:class:gzip_ostream::gzip_streambuf	file:
outline	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	struct _cxxrtl_outline *outline;$/;"	m	struct:cxxrtl_object	typeref:struct:_cxxrtl_outline *
outline	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^		debug_outline *outline;$/;"	m	struct:cxxrtl::vcd_writer::variable	typeref:typename:debug_outline *
outline_warm	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^		bool *outline_warm;$/;"	m	struct:cxxrtl::vcd_writer::variable	typeref:typename:bool *
outlines	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	std::map<debug_outline*, bool> outlines;$/;"	m	class:cxxrtl::vcd_writer	typeref:typename:std::map<debug_outline *,bool>
outnode	yosys/frontends/verific/verificsva.cc	/^	int outnode;$/;"	m	struct:SvaDFsmNode	typeref:typename:int	file:
outport	yosys/kernel/cellaigs.cc	/^	void outport(int node, IdString portname, int portbit = 0)$/;"	f	struct:AigMaker	typeref:typename:void	file:
outport_bool	yosys/kernel/cellaigs.cc	/^	void outport_bool(int node, IdString portname)$/;"	f	struct:AigMaker	typeref:typename:void	file:
outport_vec	yosys/kernel/cellaigs.cc	/^	void outport_vec(const vector<int> &vec, IdString portname)$/;"	f	struct:AigMaker	typeref:typename:void	file:
outports	yosys/kernel/cellaigs.h	/^	vector<pair<IdString, int>> outports;$/;"	m	struct:AigNode	typeref:typename:vector<pair<IdString,int>>
output	yosys/kernel/rtlil.cc	/^bool RTLIL::Cell::output(RTLIL::IdString portname) const$/;"	f	class:RTLIL::Cell	typeref:typename:bool
output	yosys/passes/hierarchy/hierarchy.cc	/^	bool input, output;$/;"	m	struct:generate_port_decl_t	typeref:typename:bool	file:
outputSignals	yosys/frontends/ast/genrtlil.cc	/^	RTLIL::SigSpec outputSignals;$/;"	m	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:RTLIL::SigSpec	file:
output_bits	yosys/backends/aiger/aiger.cc	/^	pool<SigBit> input_bits, output_bits;$/;"	m	struct:AigerWriter	typeref:typename:pool<SigBit>	file:
output_bits	yosys/backends/aiger/xaiger.cc	/^	pool<SigBit> input_bits, output_bits;$/;"	m	struct:XAigerWriter	typeref:typename:pool<SigBit>	file:
output_code	yosys/frontends/verilog/preproc.cc	/^static std::list<std::string> output_code;$/;"	v	typeref:typename:std::list<std::string>	file:
output_data	yosys/passes/sat/sim.cc	/^	std::vector<std::pair<int,std::map<int,Const>>> output_data;$/;"	m	struct:SimShared	typeref:typename:std::vector<std::pair<int,std::map<int,Const>>>	file:
outputfiles	yosys/passes/sat/sim.cc	/^	std::vector<std::unique_ptr<OutputWriter>> outputfiles;$/;"	m	struct:SimShared	typeref:typename:std::vector<std::unique_ptr<OutputWriter>>	file:
outputs	yosys/frontends/aiger/aigerparse.h	/^    std::vector<RTLIL::Wire*> outputs;$/;"	m	struct:AigerReader	typeref:typename:std::vector<RTLIL::Wire * >
outputs	yosys/kernel/celltypes.h	/^	pool<RTLIL::IdString> inputs, outputs;$/;"	m	struct:CellType	typeref:typename:pool<RTLIL::IdString>
outputs	yosys/passes/techmap/flowmap.cc	/^	pool<RTLIL::SigBit> nodes, inputs, outputs;$/;"	m	struct:FlowmapWorker	typeref:typename:pool<RTLIL::SigBit>	file:
outsig	yosys/passes/techmap/extract_counter.cc	/^	RTLIL::SigSpec outsig;			\/\/counter overflow output signal$/;"	m	struct:CounterExtraction	typeref:typename:RTLIL::SigSpec	file:
outval_alloc_siz	yosys/libs/fst/fstapi.cc	/^    uint32_t outval_alloc_siz;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t	file:
outval_mem	yosys/libs/fst/fstapi.cc	/^    unsigned char *outval_mem; \/* for two-state \/ Verilator-style value changes *\/$/;"	m	struct:fstWriterContext	typeref:typename:unsigned char *	file:
overflow_cell	yosys/passes/techmap/extract_counter.cc	/^	RTLIL::Cell* overflow_cell;		\/\/cell for counter overflow (either inverter reduction or $eq)$/;"	m	struct:CounterExtraction	typeref:typename:RTLIL::Cell *	file:
pack	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::pack() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
pack_cells	yosys/passes/techmap/flowmap.cc	/^	void pack_cells(int minlut)$/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
packed	yosys/kernel/mem.h	/^	bool packed;$/;"	m	struct:Mem	typeref:typename:bool
packed	yosys/kernel/rtlil.h	/^	inline bool packed() const {$/;"	f	struct:RTLIL::SigSpec	typeref:typename:bool
packed_count	yosys/passes/techmap/flowmap.cc	/^	int gate_count = 0, lut_count = 0, packed_count = 0;$/;"	m	struct:FlowmapWorker	typeref:typename:int	file:
packtypes	yosys/libs/fst/fstapi.cc	/^static const char *packtypes[] = {"none", "unpacked", "packed", "tagged_packed"};$/;"	v	typeref:typename:const char * []	file:
page_counter	yosys/passes/cmds/show.cc	/^	int page_counter;$/;"	m	struct:ShowWorker	typeref:typename:int	file:
parallel_cells	yosys/passes/techmap/extract_counter.cc	/^	pool<RTLIL::IdString>& parallel_cells;$/;"	m	struct:CounterExtractionSettings	typeref:typename:pool<RTLIL::IdString> &	file:
parallel_enabled	yosys/libs/fst/fstapi.cc	/^    unsigned parallel_enabled : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
parallel_was_enabled	yosys/libs/fst/fstapi.cc	/^    unsigned parallel_was_enabled : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
param	yosys/kernel/rtlil.cc	/^		int param(RTLIL::IdString name)$/;"	f	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:int	file:
param_bits	yosys/kernel/rtlil.cc	/^		void param_bits(RTLIL::IdString name, int width)$/;"	f	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:void	file:
param_bool	yosys/kernel/rtlil.cc	/^		int param_bool(RTLIL::IdString name)$/;"	f	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:int	file:
param_bool	yosys/kernel/rtlil.cc	/^		int param_bool(RTLIL::IdString name, bool expected)$/;"	f	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:int	file:
param_bool	yosys/passes/techmap/extract.cc	/^	#define param_bool(/;"	d	file:
param_has_no_default	yosys/frontends/ast/ast.cc	/^static bool param_has_no_default(const AstNode *param) {$/;"	f	typeref:typename:bool	file:
param_int	yosys/passes/techmap/extract.cc	/^	#define param_int(/;"	d	file:
param_mode	yosys/backends/blif/blif.cc	/^	bool param_mode;$/;"	m	struct:BlifDumperConfig	typeref:typename:bool	file:
parameter_default_values	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, RTLIL::Const> parameter_default_values;$/;"	m	struct:RTLIL::Module	typeref:typename:dict<RTLIL::IdString,RTLIL::Const>
parameters	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, RTLIL::Const> parameters;$/;"	m	struct:RTLIL::Cell	typeref:typename:dict<RTLIL::IdString,RTLIL::Const>
parameters	yosys/passes/equiv/equiv_struct.cc	/^		vector<pair<IdString, Const>> parameters;$/;"	m	struct:EquivStructWorker::merge_key_t	typeref:typename:vector<pair<IdString,Const>>	file:
params	yosys/passes/techmap/shregmap.cc	/^	bool zinit, init, params, ffe;$/;"	m	struct:ShregmapOptions	typeref:typename:bool	file:
parent	yosys/backends/simplec/simplec.cc	/^	HierDirtyFlags *parent;$/;"	m	struct:HierDirtyFlags	typeref:typename:HierDirtyFlags *	file:
parent	yosys/libs/minisat/Heap.h	/^    static inline int parent(int i) { return (i-1) >> 1; }$/;"	f	class:Minisat::Heap	typeref:typename:int
parent	yosys/passes/sat/sim.cc	/^	SimInstance *parent;$/;"	m	struct:SimInstance	typeref:typename:SimInstance *	file:
parent_pass	yosys/kernel/register.h	/^		Pass *parent_pass;$/;"	m	struct:Pass::pre_post_exec_state_t	typeref:typename:Pass *
parents	yosys/kernel/hashlib.h	/^	mutable std::vector<int> parents;$/;"	m	class:hashlib::mfp	typeref:typename:std::vector<int>
parse	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::parse(RTLIL::SigSpec &sig, RTLIL::Module *module, std::string str)$/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
parse	yosys/libs/json11/json11.cpp	/^Json Json::parse(const string &in, string &err, JsonParse strategy) {$/;"	f	class:json11::Json	typeref:typename:Json
parse	yosys/libs/json11/json11.hpp	/^    static Json parse(const char * in,$/;"	f	class:json11::Json	typeref:typename:Json
parse	yosys/libs/minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::BoolOption	typeref:typename:bool
parse	yosys/libs/minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::DoubleOption	typeref:typename:bool
parse	yosys/libs/minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::Int64Option	typeref:typename:bool
parse	yosys/libs/minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::IntOption	typeref:typename:bool
parse	yosys/libs/minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::StringOption	typeref:typename:bool
parse	yosys/passes/memory/memory_bram.cc	/^	void parse(string filename)$/;"	f	struct:rules_t	typeref:typename:void	file:
parse	yosys/passes/techmap/libparse.cc	/^LibertyAst *LibertyParser::parse()$/;"	f	class:LibertyParser	typeref:typename:LibertyAst *
parseInt	yosys/libs/minisat/ParseUtils.h	/^static int parseInt(B& in) {$/;"	f	namespace:Minisat	typeref:typename:int
parseOptions	yosys/libs/minisat/Options.cc	/^void Minisat::parseOptions(int& argc, char** argv, bool strict)$/;"	f	class:Minisat	typeref:typename:void
parse_DIMACS_main	yosys/libs/minisat/Dimacs.h	/^static void parse_DIMACS_main(B& in, Solver& S, bool strictp = false) {$/;"	f	namespace:Minisat	typeref:typename:void
parse_aiger	yosys/frontends/aiger/aigerparse.cc	/^void AigerReader::parse_aiger()$/;"	f	class:AigerReader	typeref:typename:void
parse_aiger_ascii	yosys/frontends/aiger/aigerparse.cc	/^void AigerReader::parse_aiger_ascii()$/;"	f	class:AigerReader	typeref:typename:void
parse_aiger_binary	yosys/frontends/aiger/aigerparse.cc	/^void AigerReader::parse_aiger_binary()$/;"	f	class:AigerReader	typeref:typename:void
parse_args	yosys/passes/sat/qbfsat.cc	/^QbfSolveOptions parse_args(const std::vector<std::string> &args) {$/;"	f	typeref:typename:QbfSolveOptions
parse_argv	yosys/misc/launcher.c	/^char **parse_argv(char *cmdline, int *argc)$/;"	f	typeref:typename:char **
parse_attrmap_paramap_options	yosys/passes/techmap/attrmap.cc	/^bool parse_attrmap_paramap_options(size_t &argidx, std::vector<std::string> &args, vector<std::u/;"	f	typeref:typename:bool
parse_blif	yosys/frontends/blif/blifparse.cc	/^void parse_blif(RTLIL::Design *design, std::istream &f, IdString dff_name, bool run_clean, bool /;"	f	typeref:typename:void
parse_bram	yosys/passes/memory/memory_bram.cc	/^	void parse_bram()$/;"	f	struct:rules_t	typeref:typename:void	file:
parse_comma_list	yosys/passes/cmds/select.cc	/^static int parse_comma_list(std::set<RTLIL::IdString> &tokens, const std::string &str, size_t po/;"	f	typeref:typename:int	file:
parse_consecutive_repeat	yosys/frontends/verific/verificsva.cc	/^	int parse_consecutive_repeat(SvaFsm &fsm, int start_node, Net *net, bool add_pre_delay, bool ad/;"	f	struct:VerificSvaImporter	typeref:typename:int	file:
parse_expression	yosys/frontends/verific/verificsva.cc	/^	SigBit parse_expression(Net *net)$/;"	f	struct:VerificSvaImporter	typeref:typename:SigBit	file:
parse_func_expr	yosys/frontends/liberty/liberty.cc	/^static RTLIL::SigSpec parse_func_expr(RTLIL::Module *module, const char *expr)$/;"	f	typeref:typename:RTLIL::SigSpec	file:
parse_func_identifier	yosys/frontends/liberty/liberty.cc	/^static RTLIL::SigSpec parse_func_identifier(RTLIL::Module *module, const char *&expr)$/;"	f	typeref:typename:RTLIL::SigSpec	file:
parse_func_reduce	yosys/frontends/liberty/liberty.cc	/^static bool parse_func_reduce(RTLIL::Module *module, std::vector<token_t> &stack, token_t next_t/;"	f	typeref:typename:bool	file:
parse_int_vect	yosys/passes/memory/memory_bram.cc	/^	bool parse_int_vect(const char *stmt, vector<int> &value)$/;"	f	struct:rules_t	typeref:typename:bool	file:
parse_json	yosys/libs/json11/json11.cpp	/^    Json parse_json(int depth) {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:Json	file:
parse_match	yosys/passes/memory/memory_bram.cc	/^	void parse_match()$/;"	f	struct:rules_t	typeref:typename:void	file:
parse_multi	yosys/libs/json11/json11.cpp	/^vector<Json> Json::parse_multi(const string &in,$/;"	f	class:json11::Json	typeref:typename:vector<Json>
parse_multi	yosys/libs/json11/json11.hpp	/^    static inline std::vector<Json> parse_multi($/;"	f	class:json11::Json	typeref:typename:std::vector<Json>
parse_next_delta_literal	yosys/frontends/aiger/aigerparse.cc	/^static unsigned parse_next_delta_literal(std::istream &f, unsigned ref)$/;"	f	typeref:typename:unsigned	file:
parse_number	yosys/libs/json11/json11.cpp	/^    Json parse_number() {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:Json	file:
parse_pin	yosys/passes/techmap/dfflibmap.cc	/^static bool parse_pin(LibertyAst *cell, LibertyAst *attr, std::string &pin_name, bool &pin_pol)$/;"	f	typeref:typename:bool	file:
parse_property	yosys/frontends/verific/verificsva.cc	/^	void parse_property(Net *net, SigBit *accept_p, SigBit *reject_p)$/;"	f	struct:VerificSvaImporter	typeref:typename:void	file:
parse_rhs	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::parse_rhs(const RTLIL::SigSpec &lhs, RTLIL::SigSpec &sig, RTLIL::Module *mo/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
parse_sel	yosys/kernel/rtlil.cc	/^bool RTLIL::SigSpec::parse_sel(RTLIL::SigSpec &sig, RTLIL::Design *design, RTLIL::Module *module/;"	f	class:RTLIL::SigSpec	typeref:typename:bool
parse_sequence	yosys/frontends/verific/verificsva.cc	/^	int parse_sequence(SvaFsm &fsm, int start_node, Net *net)$/;"	f	struct:VerificSvaImporter	typeref:typename:int	file:
parse_single_int	yosys/passes/memory/memory_bram.cc	/^	bool parse_single_int(const char *stmt, int &value)$/;"	f	struct:rules_t	typeref:typename:bool	file:
parse_string	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::parse_string(const std::string &)$/;"	f	class:ezSAT	typeref:typename:int
parse_string	yosys/libs/json11/json11.cpp	/^    string parse_string() {$/;"	f	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:string	file:
parse_type_map	yosys/frontends/liberty/liberty.cc	/^void parse_type_map(std::map<std::string, std::tuple<int, int, bool>> &type_map, LibertyAst *ast/;"	f	typeref:typename:void
parse_xaiger	yosys/frontends/aiger/aigerparse.cc	/^void AigerReader::parse_xaiger()$/;"	f	class:AigerReader	typeref:typename:void
parse_xaiger_literal	yosys/frontends/aiger/aigerparse.cc	/^static uint32_t parse_xaiger_literal(std::istream &f)$/;"	f	typeref:typename:uint32_t	file:
parser_error	yosys/frontends/verific/verificsva.cc	/^	[[noreturn]] void parser_error(Instance *inst)$/;"	f	struct:VerificSvaImporter	typeref:typename:void	file:
parser_error	yosys/frontends/verific/verificsva.cc	/^	[[noreturn]] void parser_error(std::string errmsg)$/;"	f	struct:VerificSvaImporter	typeref:typename:void	file:
parser_error	yosys/frontends/verific/verificsva.cc	/^	[[noreturn]] void parser_error(std::string errmsg, Instance *inst)$/;"	f	struct:VerificSvaImporter	typeref:typename:void	file:
parser_error	yosys/frontends/verific/verificsva.cc	/^	[[noreturn]] void parser_error(std::string errmsg, linefile_type loc)$/;"	f	struct:VerificSvaImporter	typeref:typename:void	file:
part	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^	string top_opt, part, json_file;$/;"	m	struct:SynthGreenPAK4Pass	typeref:typename:string	file:
partial	yosys/libs/fst/lz4.cc	/^    partial = 1$/;"	e	enum:__anon9390dffe0803	file:
partial_assignment_bits	yosys/backends/smv/smv.cc	/^	dict<SigBit, std::pair<const char*, int>> partial_assignment_bits;$/;"	m	struct:SmvWorker	typeref:typename:dict<SigBit,std::pair<const char *,int>>	file:
partial_assignment_wires	yosys/backends/smv/smv.cc	/^	pool<Wire*> partial_assignment_wires;$/;"	m	struct:SmvWorker	typeref:typename:pool<Wire * >	file:
parts_at	yosys/backends/cxxrtl/cxxrtl.h	/^	const std::vector<debug_item> &parts_at(const std::string &name) const {$/;"	f	struct:cxxrtl::debug_items	typeref:typename:const std::vector<debug_item> &
pass_control_to_child	yosys/misc/launcher.c	/^void pass_control_to_child(DWORD control_type) {$/;"	f	typeref:typename:void
pass_name	yosys/kernel/register.h	/^	std::string pass_name, short_help;$/;"	m	struct:Pass	typeref:typename:std::string
pass_register	yosys/kernel/register.cc	/^std::map<std::string, Pass*> pass_register;$/;"	v	typeref:typename:std::map<std::string,Pass * >
past_ad	yosys/passes/sat/sim.cc	/^		Const past_ad;$/;"	m	struct:SimInstance::ff_state_t	typeref:typename:Const	file:
past_ce	yosys/passes/sat/sim.cc	/^		State past_ce;$/;"	m	struct:SimInstance::ff_state_t	typeref:typename:State	file:
past_clk	yosys/passes/sat/sim.cc	/^		State past_clk;$/;"	m	struct:SimInstance::ff_state_t	typeref:typename:State	file:
past_d	yosys/passes/sat/sim.cc	/^		Const past_d;$/;"	m	struct:SimInstance::ff_state_t	typeref:typename:Const	file:
past_data	yosys/kernel/fstdata.h	/^	std::map<fstHandle, std::string> past_data;$/;"	m	class:FstData	typeref:typename:std::map<fstHandle,std::string>
past_srst	yosys/passes/sat/sim.cc	/^		State past_srst;$/;"	m	struct:SimInstance::ff_state_t	typeref:typename:State	file:
past_time	yosys/kernel/fstdata.h	/^	uint64_t past_time;$/;"	m	class:FstData	typeref:typename:uint64_t
past_wr_addr	yosys/passes/sat/sim.cc	/^		std::vector<Const> past_wr_addr;$/;"	m	struct:SimInstance::mem_state_t	typeref:typename:std::vector<Const>	file:
past_wr_clk	yosys/passes/sat/sim.cc	/^		std::vector<Const> past_wr_clk;$/;"	m	struct:SimInstance::mem_state_t	typeref:typename:std::vector<Const>	file:
past_wr_data	yosys/passes/sat/sim.cc	/^		std::vector<Const> past_wr_data;$/;"	m	struct:SimInstance::mem_state_t	typeref:typename:std::vector<Const>	file:
past_wr_en	yosys/passes/sat/sim.cc	/^		std::vector<Const> past_wr_en;$/;"	m	struct:SimInstance::mem_state_t	typeref:typename:std::vector<Const>	file:
path_array	yosys/libs/fst/fstapi.cc	/^    Pvoid_t path_array;$/;"	m	struct:fstWriterContext	typeref:typename:Pvoid_t	file:
path_array_count	yosys/libs/fst/fstapi.cc	/^    uint32_t path_array_count;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t	file:
pathologicalInt	yosys/libs/bigint/testsuite.cc	/^int pathologicalInt = ~((unsigned int)(~0) >> 1);$/;"	v	typeref:typename:int
pathologicalLong	yosys/libs/bigint/testsuite.cc	/^long pathologicalLong = ~((unsigned long)(~0) >> 1);$/;"	v	typeref:typename:long
pathologicalShort	yosys/libs/bigint/testsuite.cc	/^short pathologicalShort = ~((unsigned short)(~0) >> 1);$/;"	v	typeref:typename:short
patmatch	yosys/kernel/yosys.cc	/^bool patmatch(const char *pattern, const char *string)$/;"	f	typeref:typename:bool
pattern	yosys/kernel/log.h	/^	YS_REGEX_TYPE pattern;$/;"	m	struct:LogExpectedItem	typeref:typename:YS_REGEX_TYPE
pattern_is_subset	yosys/passes/fsm/fsm_map.cc	/^static bool pattern_is_subset(const RTLIL::Const &super_pattern, const RTLIL::Const &sub_pattern/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool	file:
pattern_t	yosys/passes/opt/opt_dff.cc	/^	typedef std::map<RTLIL::SigBit, bool> pattern_t;$/;"	t	struct:OptDffWorker	typeref:typename:std::map<RTLIL::SigBit,bool>	file:
patterns	yosys/passes/proc/proc_rmdead.cc	/^	pool<RTLIL::SigSpec> patterns;$/;"	m	struct:FullyDefinedPool	typeref:typename:pool<RTLIL::SigSpec>	file:
patterns	yosys/passes/sat/eval.cc	/^	std::vector<RTLIL::Const> patterns;$/;"	m	struct:VlogHammerReporter	typeref:typename:std::vector<RTLIL::Const>	file:
patterns_t	yosys/passes/opt/opt_dff.cc	/^	typedef std::set<pattern_t> patterns_t;$/;"	t	struct:OptDffWorker	typeref:typename:std::set<pattern_t>	file:
payload	yosys/libs/fst/fstapi.cc	/^    void *payload;$/;"	m	struct:collchain_t	typeref:typename:void *	file:
pb_	yosys/backends/protobuf/protobuf.cc	/^	yosys::pb::Design *pb_;$/;"	m	struct:ProtobufDesignSerializer	typeref:typename:yosys::pb::Design *	file:
pclose	yosys/kernel/yosys.h	/^#  define pclose /;"	d
peek	yosys/libs/minisat/Map.h	/^    bool peek   (const K& k, D& d) const {$/;"	f	class:Minisat::Map	typeref:typename:bool
peek	yosys/libs/minisat/Queue.h	/^    T    peek  () const { assert(first != end); return buf[first]; }$/;"	f	class:Minisat::Queue	typeref:typename:T
percolateDown	yosys/libs/minisat/Heap.h	/^    void percolateDown(int i)$/;"	f	class:Minisat::Heap	typeref:typename:void
percolateUp	yosys/libs/minisat/Heap.h	/^    void percolateUp(int i)$/;"	f	class:Minisat::Heap	typeref:typename:void
permutateVectorToMap	yosys/libs/subcircuit/subcircuit.cc	/^	static void permutateVectorToMap(std::map<std::string, std::string> &map, const std::vector<std/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
permutateVectorToMapArray	yosys/libs/subcircuit/subcircuit.cc	/^	static void permutateVectorToMapArray(std::map<std::string, std::string> &map, const std::vecto/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
phase_saving	yosys/libs/minisat/Solver.h	/^    int       phase_saving;       \/\/ Controls the level of phase saving (0=none, 1=limited, 2=/;"	m	class:Minisat::Solver	typeref:typename:int
piNum	yosys/frontends/aiger/aigerparse.h	/^    uint32_t piNum, flopNum;$/;"	m	struct:AigerReader	typeref:typename:uint32_t
pi_bits	yosys/passes/sat/freduce.cc	/^	std::vector<RTLIL::SigBit> out_bits, pi_bits;$/;"	m	struct:PerformReduction	typeref:typename:std::vector<RTLIL::SigBit>	file:
pi_map	yosys/passes/techmap/abc.cc	/^dict<int, std::string> pi_map, po_map;$/;"	v	typeref:typename:dict<int,std::string>
pick	yosys/passes/sat/mutate.cc	/^	mutate_t *pick(xs128_t &rng, coverdb_t &coverdb, const mutate_opts_t &opts) {$/;"	f	struct:mutate_chain_queue_t	typeref:typename:mutate_t *	file:
pick	yosys/passes/sat/mutate.cc	/^	mutate_t *pick(xs128_t &rng, coverdb_t &coverdb, const mutate_opts_t &opts) {$/;"	f	struct:mutate_once_queue_t	typeref:typename:mutate_t *	file:
pick	yosys/passes/sat/mutate.cc	/^	mutate_t *pick(xs128_t &rng, coverdb_t &coverdb, const mutate_opts_t &opts) {$/;"	f	struct:mutate_queue_t	typeref:typename:mutate_t *	file:
pickBranchLit	yosys/libs/minisat/Solver.cc	/^Lit Solver::pickBranchLit()$/;"	f	class:Solver	typeref:typename:Lit
pick_cover_prcnt	yosys/passes/sat/mutate.cc	/^	int pick_cover_prcnt = 80;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
pid	yosys/frontends/rpc/rpc_frontend.cc	/^	pid_t pid;$/;"	m	struct:FdRpcServer	typeref:typename:pid_t	file:
pmtest_addports	yosys/passes/pmgen/generate.h	/^void pmtest_addports(Module *module)$/;"	f	typeref:typename:void
pmux_count	yosys/passes/opt/muxpack.cc	/^	int mux_count, pmux_count;$/;"	m	struct:MuxpackWorker	typeref:typename:int	file:
po_map	yosys/passes/techmap/abc.cc	/^dict<int, std::string> pi_map, po_map;$/;"	v	typeref:typename:dict<int,std::string>
pointer	yosys/kernel/rtlil.h	/^		using pointer = T*;$/;"	t	struct:RTLIL::ObjIterator	typeref:typename:T *
pol_aload	yosys/kernel/ff.h	/^	bool pol_aload;$/;"	m	struct:FfData	typeref:typename:bool
pol_arst	yosys/kernel/ff.h	/^	bool pol_arst;$/;"	m	struct:FfData	typeref:typename:bool
pol_ce	yosys/kernel/ff.h	/^	bool pol_ce;$/;"	m	struct:FfData	typeref:typename:bool
pol_clk	yosys/kernel/ff.h	/^	bool pol_clk;$/;"	m	struct:FfData	typeref:typename:bool
pol_clr	yosys/kernel/ff.h	/^	bool pol_clr;$/;"	m	struct:FfData	typeref:typename:bool
pol_set	yosys/kernel/ff.h	/^	bool pol_set;$/;"	m	struct:FfData	typeref:typename:bool
pol_srst	yosys/kernel/ff.h	/^	bool pol_srst;$/;"	m	struct:FfData	typeref:typename:bool
polarity	yosys/libs/minisat/Solver.h	/^    VMap<char>          polarity;         \/\/ The preferred polarity of each variable.$/;"	m	class:Minisat::Solver	typeref:typename:VMap<char>
polarity	yosys/passes/cmds/exec.cc	/^			bool polarity;	\/\/true: this regex must match at least one line$/;"	m	struct:ExecPass::execute::expect_stdout_elem	typeref:typename:bool	file:
pool	yosys/kernel/hashlib.h	/^	pool()$/;"	f	class:hashlib::pool
pool	yosys/kernel/hashlib.h	/^	pool(InputIterator first, InputIterator last)$/;"	f	class:hashlib::pool
pool	yosys/kernel/hashlib.h	/^	pool(const pool &other)$/;"	f	class:hashlib::pool
pool	yosys/kernel/hashlib.h	/^	pool(const std::initializer_list<K> &list)$/;"	f	class:hashlib::pool
pool	yosys/kernel/hashlib.h	/^	pool(pool &&other)$/;"	f	class:hashlib::pool
pool	yosys/kernel/hashlib.h	/^class pool$/;"	c	namespace:hashlib
pop	yosys/kernel/consteval.h	/^	void pop()$/;"	f	struct:ConstEval	typeref:typename:void
pop	yosys/kernel/hashlib.h	/^	K pop()$/;"	f	class:hashlib::pool	typeref:typename:K
pop	yosys/libs/minisat/Queue.h	/^    void pop   () { assert(first != end); first++; if (first == buf.size()) first = 0; }$/;"	f	class:Minisat::Queue	typeref:typename:void
pop	yosys/libs/minisat/SolverTypes.h	/^    void         pop         ()              { shrink(1); }$/;"	f	class:Minisat::Clause	typeref:typename:void
pop	yosys/libs/minisat/Vec.h	/^    void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec	typeref:typename:void
popDisable	yosys/frontends/verific/verificsva.cc	/^	void popDisable()$/;"	f	struct:SvaFsm	typeref:typename:void	file:
popThroughout	yosys/frontends/verific/verificsva.cc	/^	void popThroughout()$/;"	f	struct:SvaFsm	typeref:typename:void	file:
popen	yosys/kernel/yosys.h	/^#  define popen /;"	d
port	yosys/kernel/modtools.h	/^		RTLIL::IdString port;$/;"	m	struct:ModIndex::PortInfo	typeref:typename:RTLIL::IdString
port	yosys/kernel/modtools.h	/^		RTLIL::IdString port;$/;"	m	struct:ModWalker::PortBit	typeref:typename:RTLIL::IdString
port	yosys/kernel/rtlil.cc	/^		void port(RTLIL::IdString name, int width)$/;"	f	struct:__anon3311ba060111::InternalCellChecker	typeref:typename:void	file:
port	yosys/passes/cmds/sta.cc	/^		IdString port;$/;"	m	struct:StaWorker::t_endpoint	typeref:typename:IdString	file:
port	yosys/passes/memory/memory_dff.cc	/^	MemRd &port;$/;"	m	struct:MemQueryCache	typeref:typename:MemRd &	file:
port	yosys/passes/sat/mutate.cc	/^	IdString module, cell, port, wire;$/;"	m	struct:mutate_opts_t	typeref:typename:IdString	file:
port	yosys/passes/sat/mutate.cc	/^	IdString port, wire;$/;"	m	struct:mutate_t	typeref:typename:IdString	file:
port	yosys/passes/techmap/extract.cc	/^	std::string cell, port;$/;"	m	struct:bit_ref_t	typeref:typename:std::string	file:
portBits	yosys/libs/subcircuit/subcircuit.h	/^			std::set<BitRef> portBits;$/;"	m	struct:SubCircuit::Graph::Edge	typeref:typename:std::set<BitRef>
portId	yosys/libs/subcircuit/subcircuit.h	/^			std::string portId;$/;"	m	struct:SubCircuit::Graph::Port	typeref:typename:std::string
portIdx	yosys/libs/subcircuit/subcircuit.h	/^			int nodeIdx, portIdx, bitIdx;$/;"	m	struct:SubCircuit::Graph::BitRef	typeref:typename:int
portMap	yosys/libs/subcircuit/subcircuit.h	/^			std::map<std::string, int> portMap;$/;"	m	struct:SubCircuit::Graph::Node	typeref:typename:std::map<std::string,int>
portMapping	yosys/libs/subcircuit/subcircuit.h	/^			std::map<std::string, std::string> portMapping;$/;"	m	struct:SubCircuit::Solver::ResultNodeMapping	typeref:typename:std::map<std::string,std::string>
portSizes	yosys/libs/subcircuit/subcircuit.cc	/^		std::map<std::string, int> portSizes;$/;"	m	struct:SubCircuit::SolverWorker::DiNode	typeref:typename:std::map<std::string,int>	file:
port_add	yosys/kernel/modtools.h	/^	void port_add(RTLIL::Cell *cell, RTLIL::IdString port, const RTLIL::SigSpec &sig)$/;"	f	struct:ModIndex	typeref:typename:void
port_del	yosys/kernel/modtools.h	/^	void port_del(RTLIL::Cell *cell, RTLIL::IdString port, const RTLIL::SigSpec &sig)$/;"	f	struct:ModIndex	typeref:typename:void
port_id	yosys/frontends/ast/ast.h	/^		int port_id, range_left, range_right;$/;"	m	struct:AST::AstNode	typeref:typename:int
port_id	yosys/kernel/rtlil.h	/^	int width, start_offset, port_id;$/;"	m	struct:RTLIL::Wire	typeref:typename:int
port_input	yosys/kernel/rtlil.h	/^	bool port_input, port_output, upto, is_signed;$/;"	m	struct:RTLIL::Wire	typeref:typename:bool
port_names	yosys/passes/cmds/select.cc	/^		std::set<RTLIL::IdString> cell_types, port_names;$/;"	m	struct:__anon240a0d430111::expand_rule_t	typeref:typename:std::set<RTLIL::IdString>	file:
port_output	yosys/kernel/rtlil.h	/^	bool port_input, port_output, upto, is_signed;$/;"	m	struct:RTLIL::Wire	typeref:typename:bool
port_ren	yosys/passes/memory/memory_dff.cc	/^	int port_ren;$/;"	m	struct:MemQueryCache	typeref:typename:int	file:
port_sizes	yosys/passes/equiv/equiv_struct.cc	/^		vector<pair<IdString, int>> port_sizes;$/;"	m	struct:EquivStructWorker::merge_key_t	typeref:typename:vector<pair<IdString,int>>	file:
port_t	yosys/kernel/macc.h	/^	struct port_t {$/;"	s	struct:Macc
portbit	yosys/kernel/cellaigs.h	/^	int portbit;$/;"	m	struct:AigNode	typeref:typename:int
portbit	yosys/passes/sat/mutate.cc	/^	int portbit = -1;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
portbit	yosys/passes/sat/mutate.cc	/^	int portbit = -1;$/;"	m	struct:mutate_t	typeref:typename:int	file:
portdecl_t	yosys/passes/cmds/connwrappers.cc	/^	struct portdecl_t {$/;"	s	struct:ConnwrappersWorker	file:
portidx	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		int portidx;$/;"	m	struct:FlowGraph::Node	typeref:typename:int	file:
portinfo_t	yosys/passes/memory/memory_bram.cc	/^	struct portinfo_t {$/;"	s	struct:rules_t	file:
portinfo_t	yosys/passes/opt/opt_muxtree.cc	/^	struct portinfo_t {$/;"	s	struct:OptMuxtreeWorker	file:
portname	yosys/kernel/cellaigs.h	/^	IdString portname;$/;"	m	struct:AigNode	typeref:typename:IdString
portname	yosys/passes/hierarchy/hierarchy.cc	/^	string portname;$/;"	m	struct:generate_port_decl_t	typeref:typename:string	file:
portname_cnt	yosys/frontends/verific/verific.cc	/^	int portname_cnt = 0;$/;"	m	struct:VerificExtNets	typeref:typename:int	file:
ports	yosys/kernel/macc.h	/^	std::vector<port_t> ports;$/;"	m	struct:Macc	typeref:typename:std::vector<port_t>
ports	yosys/kernel/modtools.h	/^		pool<PortInfo> ports;$/;"	m	struct:ModIndex::SigBitInfo	typeref:typename:pool<PortInfo>
ports	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::IdString> ports;$/;"	m	struct:RTLIL::Module	typeref:typename:std::vector<RTLIL::IdString>
ports	yosys/libs/subcircuit/subcircuit.h	/^			std::vector<Port> ports;$/;"	m	struct:SubCircuit::Graph::Node	typeref:typename:std::vector<Port>
ports	yosys/passes/cmds/splice.cc	/^	std::set<RTLIL::IdString> ports;$/;"	m	struct:SpliceWorker	typeref:typename:std::set<RTLIL::IdString>	file:
ports	yosys/passes/memory/memory_bram.cc	/^		vector<int> ports, wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::bram_t	typeref:typename:vector<int>	file:
ports	yosys/passes/opt/opt_muxtree.cc	/^		vector<portinfo_t> ports;$/;"	m	struct:OptMuxtreeWorker::muxinfo_t	typeref:typename:vector<portinfo_t>	file:
ports	yosys/passes/opt/opt_share.cc	/^	std::vector<OpMuxConn> ports;$/;"	m	struct:__anonade320d40208	typeref:typename:std::vector<OpMuxConn>	file:
ports	yosys/passes/techmap/dfflibmap.cc	/^	std::map<std::string, char> ports;$/;"	m	struct:cell_mapping	typeref:typename:std::map<std::string,char>	file:
pos	yosys/libs/minisat/ParseUtils.h	/^    int            pos;$/;"	m	class:Minisat::StreamBuffer	typeref:typename:int
pos	yosys/passes/cmds/qwp.cc	/^		double pos, alt_pos;$/;"	m	struct:QwpWorker::Node	typeref:typename:double	file:
pos_s	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> pos_s(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
pos_u	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> pos_u(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
posedge	yosys/frontends/verific/verific.h	/^	bool posedge = true;$/;"	m	struct:VerificClocking	typeref:typename:bool
position	yosys/libs/minisat/ParseUtils.h	/^    int  position    () const { return pos; }$/;"	f	class:Minisat::StreamBuffer	typeref:typename:int
positive	yosys/libs/bigint/BigInteger.hh	/^	enum Sign { negative = -1, zero = 0, positive = 1 };$/;"	e	enum:BigInteger::Sign
post_execute	yosys/kernel/register.cc	/^void Pass::post_execute(Pass::pre_post_exec_state_t state)$/;"	f	class:Pass	typeref:typename:void
post_process	yosys/frontends/aiger/aigerparse.cc	/^void AigerReader::post_process()$/;"	f	class:AigerReader	typeref:typename:void
pouts	yosys/passes/techmap/extract_counter.cc	/^	pool<ModIndex::PortInfo> pouts;	\/\/Ports that take a parallel output from us$/;"	m	struct:CounterExtraction	typeref:typename:pool<ModIndex::PortInfo>	file:
poutsig	yosys/passes/techmap/extract_counter.cc	/^	RTLIL::SigSpec poutsig;			\/\/counter parallel output signal$/;"	m	struct:CounterExtraction	typeref:typename:RTLIL::SigSpec	file:
preSolverCallback	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::preSolverCallback()$/;"	f	class:ezSAT	typeref:typename:void
pre_execute	yosys/kernel/register.cc	/^Pass::pre_post_exec_state_t Pass::pre_execute()$/;"	f	class:Pass	typeref:typename:Pass::pre_post_exec_state_t
pre_post_exec_state_t	yosys/kernel/register.h	/^	struct pre_post_exec_state_t {$/;"	s	struct:Pass
preds	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		pool<Vertex*, hash_ptr_ops> preds, succs;$/;"	m	struct:Scheduler::Vertex	typeref:typename:pool<Vertex *,hash_ptr_ops>	file:
prefix	yosys/backends/simplec/simplec.cc	/^	string prefix, log_prefix;$/;"	m	struct:HierDirtyFlags	typeref:typename:string	file:
prefix	yosys/kernel/satgen.h	/^	std::string prefix;$/;"	m	struct:SatGen	typeref:typename:std::string
prefixEnd	yosys/libs/fst/lz4.cc	/^    const BYTE *prefixEnd;$/;"	m	struct:__anon9390dffe0908	typeref:typename:const BYTE *	file:
prefixSize	yosys/libs/fst/lz4.cc	/^    size_t prefixSize;$/;"	m	struct:__anon9390dffe0908	typeref:typename:size_t	file:
prefix_id	yosys/frontends/ast/simplify.cc	/^static std::string prefix_id(const std::string &prefix, const std::string &str)$/;"	f	typeref:typename:std::string	file:
prep_box	yosys/passes/techmap/abc9_ops.cc	/^void prep_box(RTLIL::Design *design)$/;"	f	typeref:typename:void
prep_bypass	yosys/passes/techmap/abc9_ops.cc	/^void prep_bypass(RTLIL::Design *design)$/;"	f	typeref:typename:void
prep_delays	yosys/passes/techmap/abc9_ops.cc	/^void prep_delays(RTLIL::Design *design, bool dff_mode)$/;"	f	typeref:typename:void
prep_dff	yosys/passes/techmap/abc9_ops.cc	/^void prep_dff(RTLIL::Design *design)$/;"	f	typeref:typename:void
prep_dff_submod	yosys/passes/techmap/abc9_ops.cc	/^void prep_dff_submod(RTLIL::Design *design)$/;"	f	typeref:typename:void
prep_dff_unmap	yosys/passes/techmap/abc9_ops.cc	/^void prep_dff_unmap(RTLIL::Design *design)$/;"	f	typeref:typename:void
prep_hier	yosys/passes/techmap/abc9_ops.cc	/^void prep_hier(RTLIL::Design *design, bool dff_mode)$/;"	f	typeref:typename:void
prep_lut	yosys/passes/techmap/abc9_ops.cc	/^void prep_lut(RTLIL::Design *design, int maxlut)$/;"	f	typeref:typename:void
prep_xaiger	yosys/passes/techmap/abc9_ops.cc	/^void prep_xaiger(RTLIL::Module *module, bool dff)$/;"	f	typeref:typename:void
prepare	yosys/kernel/qcsat.cc	/^void QuickConeSat::prepare()$/;"	f	class:QuickConeSat	typeref:typename:void
prepare	yosys/tests/unit/Makefile	/^prepare:$/;"	t
prepare_decode_mux	yosys/passes/techmap/muxcover.cc	/^	int prepare_decode_mux(SigBit &A, SigBit B, SigBit sel, SigBit bit)$/;"	f	struct:MuxcoverWorker	typeref:typename:int	file:
prepare_design	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void prepare_design(RTLIL::Design *design)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
prepare_rd_merge	yosys/kernel/mem.cc	/^void Mem::prepare_rd_merge(int idx1, int idx2, FfInitVals *initvals) {$/;"	f	class:Mem	typeref:typename:void
prepare_wr_merge	yosys/kernel/mem.cc	/^void Mem::prepare_wr_merge(int idx1, int idx2, FfInitVals *initvals) {$/;"	f	class:Mem	typeref:typename:void
prev	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		Vertex *prev, *next;$/;"	m	struct:Scheduler::Vertex	typeref:typename:Vertex *	file:
prev	yosys/libs/fst/fstapi.cc	/^    struct fstCurrHier *prev;$/;"	m	struct:fstCurrHier	typeref:struct:fstCurrHier *	file:
prim	yosys/techlibs/nexus/synth_nexus.cc	/^		std::string prim;$/;"	m	struct:SynthNexusPass::DSPRule	typeref:typename:std::string	file:
prime5bytes	yosys/libs/fst/lz4.cc	/^static const U64 prime5bytes = 889523592379ULL;$/;"	v	typeref:typename:const U64	file:
primes	yosys/libs/minisat/Map.h	/^static const int primes [nprimes] = { 31, 73, 151, 313, 643, 1291, 2593, 5233, 10501, 21013, 420/;"	v	namespace:Minisat	typeref:typename:const int[]
print	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Graph::print()$/;"	f	class:SubCircuit::Graph	typeref:typename:void
printAdjMatrix	yosys/libs/subcircuit/subcircuit.cc	/^	static void printAdjMatrix(const adjMatrix_t &matrix)$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
printDIMACS	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::printDIMACS(FILE *f, bool verbose) const$/;"	f	class:ezSAT	typeref:typename:void
printEdgeTypes	yosys/libs/subcircuit/subcircuit.cc	/^		void printEdgeTypes() const$/;"	f	struct:SubCircuit::SolverWorker::DiCache	typeref:typename:void	file:
printEnumerationMatrix	yosys/libs/subcircuit/subcircuit.cc	/^	void printEnumerationMatrix(const std::vector<std::set<int>> &enumerationMatrix, int maxHaystac/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
printInternalState	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::printInternalState(FILE *f) const$/;"	f	class:ezSAT	typeref:typename:void
printStats	yosys/libs/minisat/Solver.cc	/^void Solver::printStats() const$/;"	f	class:Solver	typeref:typename:void
printUsageAndExit	yosys/libs/minisat/Options.cc	/^void Minisat::printUsageAndExit (int \/*argc*\/, char** argv, bool verbose)$/;"	f	class:Minisat	typeref:typename:void
print_debug_wire_types	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool print_debug_wire_types = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
print_internal_names	yosys/backends/btor/btor.cc	/^	bool print_internal_names;$/;"	m	struct:BtorWorker	typeref:typename:bool	file:
print_model	yosys/passes/sat/sat.cc	/^	void print_model()$/;"	f	struct:SatHelper	typeref:typename:void	file:
print_proof_failed	yosys/passes/sat/qbfsat.h	/^void print_proof_failed()$/;"	f	typeref:typename:void
print_proof_failed	yosys/passes/sat/sat.cc	/^void print_proof_failed()$/;"	f	typeref:typename:void
print_qed	yosys/passes/sat/qbfsat.h	/^void print_qed()$/;"	f	typeref:typename:void
print_qed	yosys/passes/sat/sat.cc	/^void print_qed()$/;"	f	typeref:typename:void
print_results	yosys/libs/ezsat/demo_bit.cc	/^void print_results(bool satisfiable, const std::vector<bool> &modelValues)$/;"	f	typeref:typename:void
print_spice_module	yosys/backends/spice/spice.cc	/^static void print_spice_module(std::ostream &f, RTLIL::Module *module, RTLIL::Design *design, st/;"	f	typeref:typename:void	file:
print_spice_net	yosys/backends/spice/spice.cc	/^static void print_spice_net(std::ostream &f, RTLIL::SigBit s, std::string &neg, std::string &pos/;"	f	typeref:typename:void	file:
print_timeout	yosys/passes/sat/sat.cc	/^void print_timeout()$/;"	f	typeref:typename:void
print_wire_types	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool print_wire_types = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
printpath	yosys/passes/cmds/ltp.cc	/^	void printpath(SigBit bit)$/;"	f	struct:LtpWorker	typeref:typename:void	file:
priority	yosys/backends/cxxrtl/cxxrtl.h	/^		int priority;$/;"	m	struct:cxxrtl::memory::write	typeref:typename:int
priority_mask	yosys/kernel/mem.h	/^	std::vector<bool> priority_mask;$/;"	m	struct:MemWr	typeref:typename:std::vector<bool>
priority_mask	yosys/kernel/rtlil.h	/^	RTLIL::Const priority_mask;$/;"	m	struct:RTLIL::MemWriteAction	typeref:typename:RTLIL::Const
proc	yosys/frontends/ast/genrtlil.cc	/^	RTLIL::Process *proc;$/;"	m	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:RTLIL::Process *	file:
proc_arst	yosys/passes/proc/proc_arst.cc	/^void proc_arst(RTLIL::Module *mod, RTLIL::Process *proc, SigMap &assign_map)$/;"	f	typeref:typename:void
proc_clean	yosys/passes/proc/proc_clean.cc	/^void proc_clean(RTLIL::Module *mod, RTLIL::Process *proc, int &total_count, bool quiet)$/;"	f	typeref:typename:YOSYS_NAMESPACE_END PRIVATE_NAMESPACE_BEGIN void
proc_clean_case	yosys/passes/proc/proc_clean.cc	/^void proc_clean_case(RTLIL::CaseRule *cs, bool &did_something, int &count, int max_depth)$/;"	f	typeref:typename:PRIVATE_NAMESPACE_END YOSYS_NAMESPACE_BEGIN void
proc_clean_switch	yosys/passes/proc/proc_clean.cc	/^void proc_clean_switch(RTLIL::SwitchRule *sw, RTLIL::CaseRule *parent, bool &did_something, int /;"	f	typeref:typename:YOSYS_NAMESPACE_END USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
proc_dff	yosys/passes/proc/proc_dff.cc	/^void proc_dff(RTLIL::Module *mod, RTLIL::Process *proc, ConstEval &ce)$/;"	f	typeref:typename:void
proc_dlatch	yosys/passes/proc/proc_dlatch.cc	/^void proc_dlatch(proc_dlatch_db_t &db, RTLIL::Process *proc)$/;"	f	typeref:typename:void
proc_dlatch_db_t	yosys/passes/proc/proc_dlatch.cc	/^	proc_dlatch_db_t(Module *module) : module(module), sigmap(module)$/;"	f	struct:proc_dlatch_db_t	file:
proc_dlatch_db_t	yosys/passes/proc/proc_dlatch.cc	/^struct proc_dlatch_db_t$/;"	s	file:
proc_init	yosys/passes/proc/proc_init.cc	/^void proc_init(RTLIL::Module *mod, SigMap &sigmap, RTLIL::Process *proc)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
proc_memwr	yosys/passes/proc/proc_memwr.cc	/^void proc_memwr(RTLIL::Module *mod, RTLIL::Process *proc, dict<IdString, int> &next_port_id)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
proc_mux	yosys/passes/proc/proc_mux.cc	/^void proc_mux(RTLIL::Module *mod, RTLIL::Process *proc, bool ifxmode)$/;"	f	typeref:typename:void
proc_program_prefix	yosys/kernel/yosys.cc	/^std::string proc_program_prefix()$/;"	f	typeref:typename:std::string
proc_rmdead	yosys/passes/proc/proc_rmdead.cc	/^void proc_rmdead(RTLIL::SwitchRule *sw, int &counter, int &full_case_counter)$/;"	f	typeref:typename:void
proc_rmdead_impl	yosys/passes/proc/proc_rmdead.cc	/^static void proc_rmdead_impl(RTLIL::SwitchRule *sw, int &counter, int &full_case_counter)$/;"	f	typeref:typename:void	file:
proc_self_dirname	yosys/kernel/yosys.cc	/^std::string proc_self_dirname()$/;"	f	typeref:typename:std::string
proc_share_dirname	yosys/kernel/yosys.cc	/^std::string proc_share_dirname()$/;"	f	typeref:typename:std::string
process	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		const RTLIL::Process *process = nullptr;$/;"	m	struct:FlowGraph::Node	typeref:typename:const RTLIL::Process *	file:
process	yosys/frontends/ast/ast.cc	/^void AST::process(RTLIL::Design *design, AstNode *ast, bool dump_ast1, bool dump_ast2, bool no_d/;"	f	class:AST	typeref:typename:void
processAst	yosys/frontends/ast/genrtlil.cc	/^	void processAst(AstNode *ast)$/;"	f	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:void	file:
processMemWrites	yosys/frontends/ast/genrtlil.cc	/^	void processMemWrites(RTLIL::SyncRule *sync)$/;"	f	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:void	file:
process_and_replace_module	yosys/frontends/ast/ast.cc	/^AST_INTERNAL::process_and_replace_module(RTLIL::Design *design,$/;"	f	class:AST_INTERNAL	typeref:typename:RTLIL::Module *
process_chain	yosys/passes/opt/muxpack.cc	/^	void process_chain(vector<Cell*> &chain)$/;"	f	struct:MuxpackWorker	typeref:typename:void	file:
process_chain	yosys/passes/techmap/shregmap.cc	/^	void process_chain(vector<Cell*> &chain)$/;"	f	struct:ShregmapWorker	typeref:typename:void	file:
process_format_str	yosys/frontends/ast/simplify.cc	/^std::string AstNode::process_format_str(const std::string &sformat, int next_arg, int stage, int/;"	f	class:AstNode	typeref:typename:std::string
process_instance	yosys/backends/firrtl/firrtl.cc	/^	void process_instance(RTLIL::Cell *cell, vector<string> &wire_exprs)$/;"	f	struct:FirrtlWorker	typeref:typename:void	file:
process_mask	yosys/libs/fst/fstapi.cc	/^    unsigned char *process_mask;          \/* maxhandle-based, bitwise sized *\/$/;"	m	struct:fstReaderContext	typeref:typename:unsigned char *	file:
process_module	yosys/frontends/ast/ast.cc	/^static RTLIL::Module *process_module(RTLIL::Design *design, AstNode *ast, bool defer, AstNode *o/;"	f	typeref:typename:RTLIL::Module *	file:
processes	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, RTLIL::Process*> processes;$/;"	m	struct:RTLIL::Module	typeref:typename:dict<RTLIL::IdString,RTLIL::Process * >
program	yosys/libs/bigint/Makefile	/^program = sample$/;"	m
program-objects	yosys/libs/bigint/Makefile	/^program-objects = sample.o$/;"	m
progressEstimate	yosys/libs/minisat/Solver.cc	/^double Solver::progressEstimate() const$/;"	f	class:Solver	typeref:typename:double
progress_estimate	yosys/libs/minisat/Solver.h	/^    double              progress_estimate;\/\/ Set by 'search()'.$/;"	m	class:Minisat::Solver	typeref:typename:double
proj_left	yosys/passes/cmds/qwp.cc	/^		void proj_left(double midpos) {$/;"	f	struct:QwpWorker::Node	typeref:typename:void	file:
proj_right	yosys/passes/cmds/qwp.cc	/^		void proj_right(double midpos) {$/;"	f	struct:QwpWorker::Node	typeref:typename:void	file:
promote	yosys/kernel/hashlib.h	/^	void promote(const K &a)$/;"	f	class:hashlib::mfp	typeref:typename:void
promoted_count	yosys/passes/proc/proc_prune.cc	/^	int removed_count = 0, promoted_count = 0;$/;"	m	struct:PruneWorker	typeref:typename:int	file:
prompt	yosys/kernel/driver.cc	/^const char *prompt()$/;"	f	typeref:typename:const char *
propagate	yosys/libs/minisat/Solver.cc	/^CRef Solver::propagate()$/;"	f	class:Solver	typeref:typename:CRef
propagation_budget	yosys/libs/minisat/Solver.h	/^    int64_t             propagation_budget; \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver	typeref:typename:int64_t
propagations	yosys/libs/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
property_matches_sequence	yosys/frontends/verific/verific.h	/^	bool property_matches_sequence(const VerificClocking &seq) const {$/;"	f	struct:VerificClocking	typeref:typename:bool
prove	yosys/passes/sat/sat.cc	/^	std::vector<std::pair<std::string, std::string>> sets, prove, prove_x, sets_init;$/;"	m	struct:SatHelper	typeref:typename:std::vector<std::pair<std::string,std::string>>	file:
prove_asserts	yosys/passes/sat/sat.cc	/^	bool prove_asserts, set_assumes;$/;"	m	struct:SatHelper	typeref:typename:bool	file:
prove_x	yosys/passes/sat/sat.cc	/^	std::vector<std::pair<std::string, std::string>> sets, prove, prove_x, sets_init;$/;"	m	struct:SatHelper	typeref:typename:std::vector<std::pair<std::string,std::string>>	file:
pruneEnumerationMatrix	yosys/libs/subcircuit/subcircuit.cc	/^	bool pruneEnumerationMatrix(std::vector<std::set<int>> &enumerationMatrix, const GraphData &nee/;"	f	class:SubCircuit::SolverWorker	typeref:typename:bool	file:
prunePortmapCandidates	yosys/libs/subcircuit/subcircuit.cc	/^	bool prunePortmapCandidates(std::vector<std::set<std::map<std::string, std::string>>> &portmapC/;"	f	class:SubCircuit::SolverWorker	typeref:typename:bool	file:
ptr	yosys/frontends/ast/dpicall.cc	/^	union { double f64; float f32; int32_t i32; void *ptr; } value_store [args.size() + 1];$/;"	m	union:AST::dpi_call::__anonad5aa9e1010a	typeref:typename:void *	file:
ptr	yosys/kernel/hashlib.h	/^		const dict *ptr;$/;"	m	class:hashlib::dict::const_iterator	typeref:typename:const dict *
ptr	yosys/kernel/hashlib.h	/^		const pool *ptr;$/;"	m	class:hashlib::pool::const_iterator	typeref:typename:const pool *
ptr	yosys/kernel/hashlib.h	/^		dict *ptr;$/;"	m	class:hashlib::dict::iterator	typeref:typename:dict *
ptr	yosys/kernel/hashlib.h	/^		pool *ptr;$/;"	m	class:hashlib::pool::iterator	typeref:typename:pool *
push	yosys/kernel/consteval.h	/^	void push()$/;"	f	struct:ConstEval	typeref:typename:void
push	yosys/libs/minisat/Vec.h	/^    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); new (&data[sz++]) T(elem/;"	f	class:Minisat::vec	typeref:typename:void
push	yosys/libs/minisat/Vec.h	/^    void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz+/;"	f	class:Minisat::vec	typeref:typename:void
pushDisable	yosys/frontends/verific/verificsva.cc	/^	void pushDisable(SigBit sig)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
pushThroughout	yosys/frontends/verific/verificsva.cc	/^	void pushThroughout(SigBit sig)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
push_	yosys/libs/minisat/Vec.h	/^    void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }$/;"	f	class:Minisat::vec	typeref:typename:void
pushed_designs	yosys/passes/cmds/design.cc	/^std::vector<RTLIL::Design*> pushed_designs;$/;"	v	typeref:typename:std::vector<RTLIL::Design * >
put_reference	yosys/kernel/rtlil.h	/^		static inline void put_reference(int idx)$/;"	f	struct:RTLIL::IdString	typeref:typename:void
put_reference	yosys/kernel/rtlil.h	/^		static inline void put_reference(int) { }$/;"	f	struct:RTLIL::IdString	typeref:typename:void
puzzle3d	yosys/libs/ezsat/Makefile	/^puzzle3d: puzzle3d.o ezsat.o ezminisat.o$/;"	t
pwires	yosys/frontends/ast/ast.h	/^		bool nolatches, nomeminit, nomem2reg, mem2reg, noblackbox, lib, nowb, noopt, icells, pwires, a/;"	m	struct:AST::AstModule	typeref:typename:bool
qbf_solve	yosys/passes/sat/qbfsat.cc	/^QbfSolutionType qbf_solve(RTLIL::Module *mod, const QbfSolveOptions &opt) {$/;"	f	typeref:typename:QbfSolutionType
qcsat	yosys/passes/memory/memory_dff.cc	/^	QuickConeSat &qcsat;$/;"	m	struct:MemQueryCache	typeref:typename:QuickConeSat &	file:
qhead	yosys/libs/minisat/Solver.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more/;"	m	class:Minisat::Solver	typeref:typename:int
qtcreator	yosys/Makefile	/^qtcreator:$/;"	t
quartus	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	bool flatten, quartus, nolutram, nobram, dff, nodsp, noiopad, noclkbuf;$/;"	m	struct:SynthIntelALMPass	typeref:typename:bool	file:
query	yosys/kernel/log.h	/^	static int64_t query() {$/;"	f	struct:PerformanceTimer	typeref:typename:int64_t
query	yosys/kernel/modtools.h	/^	SigBitInfo *query(RTLIL::SigBit bit)$/;"	f	struct:ModIndex	typeref:typename:SigBitInfo *
query	yosys/passes/opt/muxpack.cc	/^	bool query(const SigSpec &sig) const$/;"	f	struct:ExclusiveDatabase	typeref:typename:bool	file:
query	yosys/passes/opt/opt_clean.cc	/^	bool query(Cell *cell, bool ignore_specify = false)$/;"	f	struct:keep_cache_t	typeref:typename:bool	file:
query	yosys/passes/opt/opt_clean.cc	/^	bool query(Module *module)$/;"	f	struct:keep_cache_t	typeref:typename:bool	file:
query	yosys/passes/opt/pmux2shiftx.cc	/^	bool query(const SigSpec &sig)$/;"	f	struct:OnehotDatabase	typeref:typename:bool	file:
query_is_input	yosys/kernel/modtools.h	/^	bool query_is_input(RTLIL::SigBit bit)$/;"	f	struct:ModIndex	typeref:typename:bool
query_is_output	yosys/kernel/modtools.h	/^	bool query_is_output(RTLIL::SigBit bit)$/;"	f	struct:ModIndex	typeref:typename:bool
query_ports	yosys/kernel/modtools.h	/^	pool<PortInfo> &query_ports(RTLIL::SigBit bit)$/;"	f	struct:ModIndex	typeref:typename:pool<PortInfo> &
query_worker	yosys/passes/opt/pmux2shiftx.cc	/^	void query_worker(const SigSpec &sig, bool &retval, bool &cache, int indent)$/;"	f	struct:OnehotDatabase	typeref:typename:void	file:
queue	yosys/passes/cmds/sta.cc	/^	std::deque<SigBit> queue;$/;"	m	struct:StaWorker	typeref:typename:std::deque<SigBit>	file:
queue	yosys/passes/equiv/equiv_mark.cc	/^	pool<SigBit> queue, visited;$/;"	m	struct:EquivMarkWorker	typeref:typename:pool<SigBit>	file:
quickcheck	yosys/passes/proc/proc_dlatch.cc	/^	bool quickcheck(const SigSpec &haystack, const SigSpec &needle)$/;"	f	struct:proc_dlatch_db_t	typeref:typename:bool	file:
quoted	yosys/misc/launcher.c	/^char *quoted(char *data) {$/;"	f	typeref:typename:char *
r_alpha	yosys/passes/techmap/flowmap.cc	/^	int r_alpha, r_beta, r_gamma;$/;"	m	struct:FlowmapWorker	typeref:typename:int	file:
r_beta	yosys/passes/techmap/flowmap.cc	/^	int r_alpha, r_beta, r_gamma;$/;"	m	struct:FlowmapWorker	typeref:typename:int	file:
r_gamma	yosys/passes/techmap/flowmap.cc	/^	int r_alpha, r_beta, r_gamma;$/;"	m	struct:FlowmapWorker	typeref:typename:int	file:
ra	yosys/libs/minisat/SolverTypes.h	/^    RegionAllocator<uint32_t> ra;$/;"	m	class:Minisat::ClauseAllocator	typeref:typename:RegionAllocator<uint32_t>
radius	yosys/passes/cmds/qwp.cc	/^	double radius;$/;"	m	struct:QwpWorker	typeref:typename:double	file:
randomShuffle	yosys/libs/minisat/Rnd.h	/^static void randomShuffle(double& seed, vec<T>& xs)$/;"	f	namespace:Minisat	typeref:typename:void
randomShuffle	yosys/libs/minisat/Rnd.h	/^static void randomShuffle(double& seed, vec<vec<T> >& xs)$/;"	f	namespace:Minisat	typeref:typename:void
random_seed	yosys/libs/minisat/Solver.h	/^    double    random_seed;$/;"	m	class:Minisat::Solver	typeref:typename:double
random_var_freq	yosys/libs/minisat/Solver.h	/^    double    random_var_freq;$/;"	m	class:Minisat::Solver	typeref:typename:double
range	yosys/libs/minisat/Options.h	/^    DoubleRange range;$/;"	m	class:Minisat::DoubleOption	typeref:typename:DoubleRange
range	yosys/libs/minisat/Options.h	/^    Int64Range range;$/;"	m	class:Minisat::Int64Option	typeref:typename:Int64Range
range	yosys/libs/minisat/Options.h	/^    IntRange range;$/;"	m	class:Minisat::IntOption	typeref:typename:IntRange
range_left	yosys/frontends/ast/ast.h	/^		int port_id, range_left, range_right;$/;"	m	struct:AST::AstNode	typeref:typename:int
range_right	yosys/frontends/ast/ast.h	/^		int port_id, range_left, range_right;$/;"	m	struct:AST::AstNode	typeref:typename:int
range_swapped	yosys/frontends/ast/ast.h	/^			bool range_swapped;$/;"	m	struct:AST::AstNode::varinfo_t	typeref:typename:bool
range_swapped	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
range_valid	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
range_width	yosys/frontends/ast/simplify.cc	/^static int range_width(AstNode *node, AstNode *rnode)$/;"	f	typeref:typename:int	file:
rd_ports	yosys/kernel/mem.cc	/^		dict<IdString, pool<Cell *>> rd_ports;$/;"	m	struct:__anon62474a9e0111::MemIndex	typeref:typename:dict<IdString,pool<Cell * >>	file:
rd_ports	yosys/kernel/mem.h	/^	std::vector<MemRd> rd_ports;$/;"	m	struct:Mem	typeref:typename:std::vector<MemRd>
rdff	yosys/techlibs/common/prep.cc	/^	bool autotop, flatten, ifxmode, memxmode, nomemmode, nokeepdc, rdff;$/;"	m	struct:PrepPass	typeref:typename:bool	file:
rdwr_can_collide	yosys/passes/memory/memory_share.cc	/^	bool rdwr_can_collide(Mem &mem, int ridx, int widx) {$/;"	f	struct:MemoryShareWorker	typeref:typename:bool	file:
re	yosys/passes/cmds/exec.cc	/^			YS_REGEX_TYPE re;$/;"	m	struct:ExecPass::execute::expect_stdout_elem	typeref:typename:YS_REGEX_TYPE	file:
reachable	yosys/frontends/verific/verificsva.cc	/^	bool reachable;$/;"	m	struct:SvaUFsmNode	typeref:typename:bool	file:
reactivated_cells	yosys/backends/simplec/simplec.cc	/^	pool<string> reactivated_cells;$/;"	m	struct:SimplecWorker	typeref:typename:pool<string>	file:
read	yosys/frontends/rpc/rpc_frontend.cc	/^	std::string read() override {$/;"	f	struct:FdRpcServer	typeref:typename:std::string	file:
read	yosys/frontends/rpc/rpc_frontend.cc	/^	std::string read() override {$/;"	f	struct:HandleRpcServer	typeref:typename:std::string	file:
read	yosys/libs/sha1/sha1.cpp	/^void SHA1::read(std::istream &is, std::string &s, size_t max)$/;"	f	class:SHA1	typeref:typename:void
readClause	yosys/libs/minisat/Dimacs.h	/^static void readClause(B& in, Solver& S, vec<Lit>& lits) {$/;"	f	namespace:Minisat	typeref:typename:void
readLine	yosys/libs/subcircuit/scshell.cc	/^std::vector<std::string> readLine()$/;"	f	typeref:typename:std::vector<std::string>
read_argument	yosys/frontends/verilog/preproc.cc	/^static bool read_argument(std::string &dest)$/;"	f	typeref:typename:bool	file:
read_blacklists	yosys/passes/equiv/equiv_make.cc	/^	void read_blacklists()$/;"	f	struct:EquivMakeWorker	typeref:typename:void	file:
read_define	yosys/frontends/verilog/preproc.cc	/^read_define(const std::string &filename,$/;"	f	typeref:typename:void	file:
read_define_args	yosys/frontends/verilog/preproc.cc	/^read_define_args()$/;"	f	typeref:typename:std::pair<int,arg_map_t>	file:
read_encfiles	yosys/passes/equiv/equiv_make.cc	/^	void read_encfiles()$/;"	f	struct:EquivMakeWorker	typeref:typename:void	file:
read_id_num	yosys/passes/hierarchy/hierarchy.cc	/^bool read_id_num(RTLIL::IdString str, int *dst)$/;"	f	typeref:typename:bool
read_liberty_cellarea	yosys/passes/cmds/stat.cc	/^void read_liberty_cellarea(dict<IdString, double> &cell_area, string liberty_file)$/;"	f	typeref:typename:void
read_next_line	yosys/frontends/blif/blifparse.cc	/^static bool read_next_line(char *&buffer, size_t &buffer_size, int &line_count, std::istream &f)$/;"	f	typeref:typename:YOSYS_NAMESPACE_BEGIN bool	file:
readline_cmd_generator	yosys/kernel/yosys.cc	/^static char *readline_cmd_generator(const char *text, int state)$/;"	f	typeref:typename:char *	file:
readline_completion	yosys/kernel/yosys.cc	/^static char **readline_completion(const char *text, int start, int)$/;"	f	typeref:typename:char **	file:
readline_obj_generator	yosys/kernel/yosys.cc	/^static char *readline_obj_generator(const char *text, int state)$/;"	f	typeref:typename:char *	file:
readmem	yosys/frontends/ast/simplify.cc	/^AstNode *AstNode::readmem(bool is_readmemh, std::string mem_filename, AstNode *memory, int start/;"	f	class:AstNode	typeref:typename:AstNode *
readsome	yosys/kernel/yosys.cc	/^int readsome(std::istream &f, char *s, int n)$/;"	f	typeref:typename:int
realAsConst	yosys/frontends/ast/ast.cc	/^RTLIL::Const AstNode::realAsConst(int width)$/;"	f	class:AstNode	typeref:typename:RTLIL::Const
realize_derealize_lut	yosys/passes/techmap/flowmap.cc	/^	void realize_derealize_lut(RTLIL::SigBit lut, pool<RTLIL::SigBit> *changed = nullptr)$/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
realvalue	yosys/frontends/ast/ast.h	/^		double realvalue;$/;"	m	struct:AST::AstNode	typeref:typename:double
reason	yosys/libs/minisat/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::Solver::VarData	typeref:typename:CRef
reason	yosys/libs/minisat/Solver.h	/^inline CRef Solver::reason(Var x) const { return vardata[x].reason; }$/;"	f	class:Minisat::Solver	typeref:typename:CRef
rebuildOrderHeap	yosys/libs/minisat/Solver.cc	/^void Solver::rebuildOrderHeap()$/;"	f	class:Solver	typeref:typename:void
reconstructAllAtTimes	yosys/kernel/fstdata.cc	/^void FstData::reconstructAllAtTimes(std::vector<fstHandle> &signal, uint64_t start, uint64_t end/;"	f	class:FstData	typeref:typename:void
reconstruct_callback_attimes	yosys/kernel/fstdata.cc	/^void FstData::reconstruct_callback_attimes(uint64_t pnt_time, fstHandle pnt_facidx, const unsign/;"	f	class:FstData	typeref:typename:void
reconstruct_clb_attimes	yosys/kernel/fstdata.cc	/^static void reconstruct_clb_attimes(void *user_data, uint64_t pnt_time, fstHandle pnt_facidx, co/;"	f	typeref:typename:void	file:
reconstruct_clb_varlen_attimes	yosys/kernel/fstdata.cc	/^static void reconstruct_clb_varlen_attimes(void *user_data, uint64_t pnt_time, fstHandle pnt_fac/;"	f	typeref:typename:void	file:
recover_solution	yosys/passes/sat/qbfsat.h	/^	void recover_solution() {$/;"	f	struct:QbfSolutionType	typeref:typename:void
recursion_guard	yosys/passes/opt/pmux2shiftx.cc	/^	pool<SigSpec> recursion_guard;$/;"	m	struct:OnehotDatabase	typeref:typename:pool<SigSpec>	file:
recursion_guard	yosys/passes/sat/freduce.cc	/^	pool<SigBit> recursion_guard;$/;"	m	struct:PerformReduction	typeref:typename:pool<SigBit>	file:
recursion_state	yosys/passes/opt/share.cc	/^	pool<RTLIL::Cell*> recursion_state;$/;"	m	struct:ShareWorker	typeref:typename:pool<RTLIL::Cell * >	file:
recursive_cells	yosys/backends/smt2/smt2.cc	/^	pool<Cell*> recursive_cells, registers;$/;"	m	struct:Smt2Worker	typeref:typename:pool<Cell * >	file:
recursive_mode	yosys/passes/techmap/techmap.cc	/^	bool recursive_mode = false;$/;"	m	struct:TechmapWorker	typeref:typename:bool	file:
recursive_mux_generator	yosys/passes/techmap/pmuxtree.cc	/^static SigSpec recursive_mux_generator(Module *module, const SigSpec &sig_data, const SigSpec &s/;"	f	typeref:typename:SigSpec	file:
red_or3x1.pdf	yosys/manual/PRESENTATION_ExAdv/Makefile	/^red_or3x1.pdf: red_or3x1_*$/;"	t
reduceDB	yosys/libs/minisat/Solver.cc	/^void Solver::reduceDB()$/;"	f	class:Solver	typeref:typename:void
reduceDB_lt	yosys/libs/minisat/Solver.cc	/^    reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}$/;"	f	struct:reduceDB_lt	file:
reduceDB_lt	yosys/libs/minisat/Solver.cc	/^struct reduceDB_lt { $/;"	s	file:
reduce_and	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> reduce_and(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
reduce_bool	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> reduce_bool(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
reduce_chain	yosys/passes/pmgen/test_pmgen.cc	/^void reduce_chain(test_pmgen_pm &pm)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
reduce_counter	yosys/passes/sat/freduce.cc	/^int verbose_level, reduce_counter, reduce_stop_at;$/;"	v	typeref:typename:int
reduce_op	yosys/kernel/celledges.cc	/^void reduce_op(AbstractCellEdgesDatabase *db, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
reduce_or	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> reduce_or(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
reduce_stop_at	yosys/passes/sat/freduce.cc	/^int verbose_level, reduce_counter, reduce_stop_at;$/;"	v	typeref:typename:int
reduce_tree	yosys/passes/pmgen/test_pmgen.cc	/^void reduce_tree(test_pmgen_pm &pm)$/;"	f	typeref:typename:void
reduce_xnor	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> reduce_xnor(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
reduce_xor	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> reduce_xor(const value<BitsA> &a) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
refcount_cells_	yosys/kernel/rtlil.h	/^	int refcount_cells_;$/;"	m	struct:RTLIL::Module	typeref:typename:int
refcount_modules_	yosys/kernel/rtlil.h	/^	int refcount_modules_;$/;"	m	struct:RTLIL::Design	typeref:typename:int
refcount_p	yosys/kernel/rtlil.h	/^		int *refcount_p;$/;"	m	struct:RTLIL::ObjIterator	typeref:typename:int *
refcount_p	yosys/kernel/rtlil.h	/^		int *refcount_p;$/;"	m	struct:RTLIL::ObjRange	typeref:typename:int *
refcount_wires_	yosys/kernel/rtlil.h	/^	int refcount_wires_;$/;"	m	struct:RTLIL::Module	typeref:typename:int
reference	yosys/kernel/rtlil.h	/^		using reference = T&;$/;"	t	struct:RTLIL::ObjIterator	typeref:typename:T &
reg_wires	yosys/backends/verilog/verilog_backend.cc	/^std::set<RTLIL::IdString> reg_wires;$/;"	v	typeref:typename:std::set<RTLIL::IdString>
region_mf	yosys/passes/equiv/equiv_mark.cc	/^	mfp<int> region_mf;$/;"	m	struct:EquivMarkWorker	typeref:typename:mfp<int>	file:
register_bool	yosys/backends/smt2/smt2.cc	/^	void register_bool(RTLIL::SigBit bit, int id)$/;"	f	struct:Smt2Worker	typeref:typename:void	file:
register_boolvec	yosys/backends/smt2/smt2.cc	/^	void register_boolvec(RTLIL::SigSpec sig, int id)$/;"	f	struct:Smt2Worker	typeref:typename:void	file:
register_bv	yosys/backends/smt2/smt2.cc	/^	void register_bv(RTLIL::SigSpec sig, int id)$/;"	f	struct:Smt2Worker	typeref:typename:void	file:
register_cone	yosys/passes/sat/freduce.cc	/^	void register_cone(std::vector<RTLIL::SigBit> &pi, RTLIL::SigBit out)$/;"	f	struct:FindReducedInputs	typeref:typename:void	file:
register_cone_worker	yosys/passes/sat/freduce.cc	/^	int register_cone_worker(std::set<RTLIL::Cell*> &celldone, std::map<RTLIL::SigBit, int> &sigdep/;"	f	struct:PerformReduction	typeref:typename:int	file:
register_cone_worker	yosys/passes/sat/freduce.cc	/^	void register_cone_worker(std::set<RTLIL::SigBit> &pi, std::set<RTLIL::SigBit> &sigdone, RTLIL:/;"	f	struct:FindReducedInputs	typeref:typename:void	file:
register_edge_signal	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void register_edge_signal(SigMap &sigmap, RTLIL::SigSpec signal, RTLIL::SyncType type)$/;"	f	struct:CxxrtlWorker	typeref:typename:void	file:
register_output_step	yosys/passes/sat/sim.cc	/^	void register_output_step(int t)$/;"	f	struct:SimWorker	typeref:typename:void	file:
register_output_step_values	yosys/passes/sat/sim.cc	/^	void register_output_step_values(std::map<int,Const> *data)$/;"	f	struct:SimInstance	typeref:typename:void	file:
register_pi_bit	yosys/passes/sat/freduce.cc	/^	void register_pi_bit(RTLIL::SigBit bit)$/;"	f	struct:FindReducedInputs	typeref:typename:void	file:
register_reverse_wire_map	yosys/backends/firrtl/firrtl.cc	/^	void register_reverse_wire_map(string id, SigSpec sig)$/;"	f	struct:FirrtlWorker	typeref:typename:void	file:
register_signals	yosys/passes/sat/sim.cc	/^	void register_signals()$/;"	f	struct:SimWorker	typeref:typename:void	file:
register_signals	yosys/passes/sat/sim.cc	/^	void register_signals(int &id)$/;"	f	struct:SimInstance	typeref:typename:void	file:
register_variable	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	variable &register_variable(size_t width, chunk_t *curr, bool constant = false, debug_outline */;"	f	class:cxxrtl::vcd_writer	typeref:typename:variable &
registers	yosys/backends/smt2/smt2.cc	/^	pool<Cell*> recursive_cells, registers;$/;"	m	struct:Smt2Worker	typeref:typename:pool<Cell * >	file:
rehash	yosys/libs/minisat/Map.h	/^    void    rehash () {$/;"	f	class:Minisat::Map	typeref:typename:void
reintegrate	yosys/passes/techmap/abc9_ops.cc	/^void reintegrate(RTLIL::Module *module, bool dff_mode)$/;"	f	typeref:typename:void
reject	yosys/frontends/verific/verificsva.cc	/^	vector<Const> accept, reject;$/;"	m	struct:SvaDFsmNode	typeref:typename:vector<Const>	file:
rel	yosys/libs/minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anonb7535e3e020a	typeref:typename:CRef
relax_depth_for_bound	yosys/passes/techmap/flowmap.cc	/^	bool relax_depth_for_bound(bool first, int depth_bound, dict<RTLIL::SigBit, pool<RTLIL::SigBit>/;"	f	struct:FlowmapWorker	typeref:typename:bool	file:
releaseVar	yosys/libs/minisat/SimpSolver.cc	/^void SimpSolver::releaseVar(Lit l)$/;"	f	class:SimpSolver	typeref:typename:void
releaseVar	yosys/libs/minisat/Solver.cc	/^void Solver::releaseVar(Lit l)$/;"	f	class:Solver	typeref:typename:void
released_vars	yosys/libs/minisat/Solver.h	/^    vec<Var>            released_vars;$/;"	m	class:Minisat::Solver	typeref:typename:vec<Var>
relevant	yosys/passes/memory/memory_dff.cc	/^	bool relevant;$/;"	m	struct:PortData	typeref:typename:bool	file:
relink	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	void relink(Vertex *vertex)$/;"	f	struct:Scheduler	typeref:typename:void	file:
reload_module	yosys/kernel/modtools.h	/^	void reload_module(bool reset_sigmap = true)$/;"	f	struct:ModIndex	typeref:typename:void
reloc	yosys/libs/minisat/SolverTypes.h	/^    void reloc(CRef& cr, ClauseAllocator& to)$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:void
relocAll	yosys/libs/minisat/SimpSolver.cc	/^void SimpSolver::relocAll(ClauseAllocator& to)$/;"	f	class:SimpSolver	typeref:typename:void
relocAll	yosys/libs/minisat/Solver.cc	/^void Solver::relocAll(ClauseAllocator& to)$/;"	f	class:Solver	typeref:typename:void
relocate	yosys/libs/minisat/SolverTypes.h	/^    void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }$/;"	f	class:Minisat::Clause	typeref:typename:void
relocation	yosys/libs/minisat/SolverTypes.h	/^    CRef         relocation  ()      const   { return data[0].rel; }$/;"	f	class:Minisat::Clause	typeref:typename:CRef
reloced	yosys/libs/minisat/SolverTypes.h	/^        unsigned reloced   : 1;$/;"	m	struct:Minisat::Clause::__anonb7535e3e0108	typeref:typename:unsigned:1
reloced	yosys/libs/minisat/SolverTypes.h	/^    bool         reloced     ()      const   { return header.reloced; }$/;"	f	class:Minisat::Clause	typeref:typename:bool
remap_name	yosys/passes/techmap/abc.cc	/^std::string remap_name(RTLIL::IdString abc_name, RTLIL::Wire **orig_wire = nullptr)$/;"	f	typeref:typename:std::string
remap_name	yosys/passes/techmap/abc9_ops.cc	/^inline std::string remap_name(RTLIL::IdString abc9_name)$/;"	f	typeref:typename:std::string
remove	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	Vertex *remove(Vertex *vertex)$/;"	f	struct:Scheduler	typeref:typename:Vertex *	file:
remove	yosys/kernel/ff.cc	/^void FfData::remove() {$/;"	f	class:FfData	typeref:typename:void
remove	yosys/kernel/mem.cc	/^void Mem::remove() {$/;"	f	class:Mem	typeref:typename:USING_YOSYS_NAMESPACE void
remove	yosys/kernel/rtlil.cc	/^void RTLIL::Design::remove(RTLIL::Module *module)$/;"	f	class:RTLIL::Design	typeref:typename:void
remove	yosys/kernel/rtlil.cc	/^void RTLIL::Module::remove(RTLIL::Cell *cell)$/;"	f	class:RTLIL::Module	typeref:typename:void
remove	yosys/kernel/rtlil.cc	/^void RTLIL::Module::remove(RTLIL::Process *process)$/;"	f	class:RTLIL::Module	typeref:typename:void
remove	yosys/kernel/rtlil.cc	/^void RTLIL::Module::remove(const pool<RTLIL::Wire*> &wires)$/;"	f	class:RTLIL::Module	typeref:typename:void
remove	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::remove(const RTLIL::SigSpec &pattern)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
remove	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::remove(const RTLIL::SigSpec &pattern, RTLIL::SigSpec *other) const$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
remove	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::remove(const pool<RTLIL::SigBit> &pattern)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
remove	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::remove(const pool<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other) const$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
remove	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::remove(int offset, int length)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
remove	yosys/kernel/sigtools.h	/^	RTLIL::SigSpec remove(const RTLIL::SigSpec &sig) const$/;"	f	struct:SigPool	typeref:typename:RTLIL::SigSpec
remove	yosys/libs/minisat/Alg.h	/^static inline void remove(V& ts, const T& t)$/;"	f	namespace:Minisat	typeref:typename:void
remove	yosys/libs/minisat/Heap.h	/^    void remove(K k)$/;"	f	class:Minisat::Heap	typeref:typename:void
remove	yosys/libs/minisat/Map.h	/^    void remove(const K& k) {$/;"	f	class:Minisat::Map	typeref:typename:void
remove	yosys/libs/minisat/SolverTypes.h	/^    void     remove      (CRef cr)            { map.remove(cr); }$/;"	f	class:Minisat::CMap	typeref:typename:void
remove2	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::remove2(const RTLIL::SigSpec &pattern, RTLIL::SigSpec *other)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
remove2	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::remove2(const pool<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
remove2	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::remove2(const std::set<RTLIL::SigBit> &pattern, RTLIL::SigSpec *other)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
removeClause	yosys/libs/minisat/SimpSolver.cc	/^void SimpSolver::removeClause(CRef cr)$/;"	f	class:SimpSolver	typeref:typename:void
removeClause	yosys/libs/minisat/Solver.cc	/^void Solver::removeClause(CRef cr) {$/;"	f	class:Solver	typeref:typename:void
removeMin	yosys/libs/minisat/Heap.h	/^    K removeMin()$/;"	f	class:Minisat::Heap	typeref:typename:K
removeSatisfied	yosys/libs/minisat/Solver.cc	/^void Solver::removeSatisfied(vec<CRef>& cs)$/;"	f	class:Solver	typeref:typename:void
removeSignalFromCaseTree	yosys/frontends/ast/genrtlil.cc	/^	void removeSignalFromCaseTree(const RTLIL::SigSpec &pattern, RTLIL::CaseRule *cs)$/;"	f	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:void	file:
remove_cell	yosys/passes/opt/share.cc	/^	void remove_cell(Cell *cell)$/;"	f	struct:ShareWorker	typeref:typename:void	file:
remove_cells	yosys/passes/opt/muxpack.cc	/^	pool<Cell*> remove_cells;$/;"	m	struct:MuxpackWorker	typeref:typename:pool<Cell * >	file:
remove_cells	yosys/passes/techmap/shregmap.cc	/^	pool<Cell*> remove_cells;$/;"	m	struct:ShregmapWorker	typeref:typename:pool<Cell * >	file:
remove_const	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::remove_const()$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
remove_directory	yosys/kernel/yosys.cc	/^void remove_directory(std::string dirname)$/;"	f	typeref:typename:void
remove_init	yosys/kernel/ff.h	/^	void remove_init() {$/;"	f	struct:FfData	typeref:typename:void
remove_init	yosys/kernel/ffinit.h	/^	void remove_init(RTLIL::SigBit bit)$/;"	f	struct:FfInitVals	typeref:typename:void
remove_init	yosys/kernel/ffinit.h	/^	void remove_init(const RTLIL::SigSpec &sig)$/;"	f	struct:FfInitVals	typeref:typename:void
remove_lut_edge	yosys/passes/techmap/flowmap.cc	/^	void remove_lut_edge(RTLIL::SigBit pred, RTLIL::SigBit succ, pool<RTLIL::SigBit> *changed = nul/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
remove_output_ff	yosys/kernel/ffmerge.cc	/^void FfMergeHelper::remove_output_ff(const pool<std::pair<Cell *, int>> &bits) {$/;"	f	class:FfMergeHelper	typeref:typename:void
remove_satisfied	yosys/libs/minisat/Solver.h	/^    bool                remove_satisfied; \/\/ Indicates whether possibly inefficient linear sca/;"	m	class:Minisat::Solver	typeref:typename:bool
remove_spaces	yosys/kernel/fstdata.cc	/^static std::string remove_spaces(std::string str)$/;"	f	typeref:typename:std::string	file:
remove_unwanted_lvalue_bits	yosys/frontends/ast/genrtlil.cc	/^	void remove_unwanted_lvalue_bits(RTLIL::SigSpec &lhs, RTLIL::SigSpec &rhs)$/;"	f	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:void	file:
removed	yosys/kernel/mem.h	/^	bool removed;$/;"	m	struct:MemInit	typeref:typename:bool
removed	yosys/kernel/mem.h	/^	bool removed;$/;"	m	struct:MemRd	typeref:typename:bool
removed	yosys/kernel/mem.h	/^	bool removed;$/;"	m	struct:MemWr	typeref:typename:bool
removed_count	yosys/passes/opt/opt_muxtree.cc	/^	int removed_count;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:int	file:
removed_count	yosys/passes/proc/proc_prune.cc	/^	int removed_count = 0, promoted_count = 0;$/;"	m	struct:PruneWorker	typeref:typename:int	file:
rename	yosys/kernel/rtlil.cc	/^void RTLIL::Design::rename(RTLIL::Module *module, RTLIL::IdString new_name)$/;"	f	class:RTLIL::Design	typeref:typename:void
rename	yosys/kernel/rtlil.cc	/^void RTLIL::Module::rename(RTLIL::Cell *cell, RTLIL::IdString new_name)$/;"	f	class:RTLIL::Module	typeref:typename:void
rename	yosys/kernel/rtlil.cc	/^void RTLIL::Module::rename(RTLIL::IdString old_name, RTLIL::IdString new_name)$/;"	f	class:RTLIL::Module	typeref:typename:void
rename	yosys/kernel/rtlil.cc	/^void RTLIL::Module::rename(RTLIL::Wire *wire, RTLIL::IdString new_name)$/;"	f	class:RTLIL::Module	typeref:typename:void
rename_in_module	yosys/passes/cmds/rename.cc	/^static void rename_in_module(RTLIL::Module *module, std::string from_name, std::string to_name, /;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void	file:
rename_in_package_stmts	yosys/frontends/ast/ast.cc	/^static void rename_in_package_stmts(AstNode *pkg)$/;"	f	typeref:typename:void	file:
repack_on_close	yosys/libs/fst/fstapi.cc	/^    unsigned repack_on_close : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
repeat	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits * Count> repeat() const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE value<Bits * Count>
repeat	yosys/kernel/rtlil.cc	/^RTLIL::SigSpec RTLIL::SigSpec::repeat(int num) const$/;"	f	class:RTLIL::SigSpec	typeref:typename:RTLIL::SigSpec
replace	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::replace(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec &with)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
replace	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::replace(const RTLIL::SigSpec &pattern, const RTLIL::SigSpec &with, RTLIL::S/;"	f	class:RTLIL::SigSpec	typeref:typename:void
replace	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::replace(const dict<RTLIL::SigBit, RTLIL::SigBit> &rules)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
replace	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::replace(const dict<RTLIL::SigBit, RTLIL::SigBit> &rules, RTLIL::SigSpec *ot/;"	f	class:RTLIL::SigSpec	typeref:typename:void
replace	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::replace(const std::map<RTLIL::SigBit, RTLIL::SigBit> &rules)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
replace	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::replace(const std::map<RTLIL::SigBit, RTLIL::SigBit> &rules, RTLIL::SigSpec/;"	f	class:RTLIL::SigSpec	typeref:typename:void
replace	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::replace(int offset, const RTLIL::SigSpec &with)$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
replace	yosys/passes/techmap/extract.cc	/^RTLIL::Cell *replace(RTLIL::Module *needle, RTLIL::Module *haystack, SubCircuit::Solver::Result /;"	f	typeref:typename:RTLIL::Cell *
replace_alu	yosys/passes/techmap/alumacc.cc	/^	void replace_alu()$/;"	f	struct:AlumaccWorker	typeref:typename:void	file:
replace_cell	yosys/passes/opt/opt_expr.cc	/^void replace_cell(SigMap &assign_map, RTLIL::Module *module, RTLIL::Cell *cell,$/;"	f	typeref:typename:void
replace_const_cells	yosys/passes/opt/opt_expr.cc	/^void replace_const_cells(RTLIL::Design *design, RTLIL::Module *module, bool consume_x, bool mux_/;"	f	typeref:typename:void
replace_const_connections	yosys/passes/opt/opt_expr.cc	/^void replace_const_connections(RTLIL::Module *module) {$/;"	f	typeref:typename:void
replace_known	yosys/passes/opt/opt_muxtree.cc	/^	void replace_known(knowledge_t &knowledge, muxinfo_t &muxinfo, IdString portname)$/;"	f	struct:OptMuxtreeWorker	typeref:typename:void	file:
replace_macc	yosys/passes/techmap/alumacc.cc	/^	void replace_macc()$/;"	f	struct:AlumaccWorker	typeref:typename:void	file:
replace_memory	yosys/passes/memory/memory_bram.cc	/^bool replace_memory(Mem &mem, const rules_t &rules, FfInitVals *initvals, const rules_t::bram_t /;"	f	typeref:typename:bool
replace_result_wire_name_in_function	yosys/frontends/ast/simplify.cc	/^void AstNode::replace_result_wire_name_in_function(const std::string &from, const std::string &t/;"	f	class:AstNode	typeref:typename:void
replace_tempdir	yosys/passes/techmap/abc.cc	/^std::string replace_tempdir(std::string text, std::string tempdir_name, bool show_tempdir)$/;"	f	typeref:typename:std::string
replace_tempdir	yosys/passes/techmap/abc9_exe.cc	/^std::string replace_tempdir(std::string text, std::string tempdir_name, bool show_tempdir)$/;"	f	typeref:typename:std::string
replace_undriven	yosys/passes/opt/opt_expr.cc	/^void replace_undriven(RTLIL::Module *module, const CellTypes &ct)$/;"	f	typeref:typename:void
replace_variables	yosys/frontends/ast/simplify.cc	/^bool AstNode::replace_variables(std::map<std::string, AstNode::varinfo_t> &variables, AstNode *f/;"	f	class:AstNode	typeref:typename:bool
reprocess_if_necessary	yosys/frontends/ast/ast.cc	/^bool AstModule::reprocess_if_necessary(RTLIL::Design *design)$/;"	f	class:AstModule	typeref:typename:bool
reprocess_if_necessary	yosys/kernel/rtlil.cc	/^bool RTLIL::Module::reprocess_if_necessary(RTLIL::Design *)$/;"	f	class:RTLIL::Module	typeref:typename:bool
required	yosys/kernel/timinginfo.h	/^		dict<NameBit, std::pair<int,NameBit>> arrival, required;$/;"	m	struct:TimingInfo::ModuleTiming	typeref:typename:dict<NameBit,std::pair<int,NameBit>>
required	yosys/passes/cmds/sta.cc	/^		int required;$/;"	m	struct:StaWorker::t_endpoint	typeref:typename:int	file:
reserve	yosys/kernel/hashlib.h	/^	void reserve(size_t n) { database.reserve(n); }$/;"	f	class:hashlib::idict	typeref:typename:void
reserve	yosys/kernel/hashlib.h	/^	void reserve(size_t n) { database.reserve(n); }$/;"	f	class:hashlib::mfp	typeref:typename:void
reserve	yosys/kernel/hashlib.h	/^	void reserve(size_t n) { entries.reserve(n); }$/;"	f	class:hashlib::dict	typeref:typename:void
reserve	yosys/kernel/hashlib.h	/^	void reserve(size_t n) { entries.reserve(n); }$/;"	f	class:hashlib::pool	typeref:typename:void
reserve	yosys/libs/minisat/IntMap.h	/^        void     reserve(K key)              { map.growTo(index(key)+1); }$/;"	f	class:Minisat::IntMap	typeref:typename:void
reserve	yosys/libs/minisat/IntMap.h	/^        void     reserve(K key, V pad)       { map.growTo(index(key)+1, pad); }$/;"	f	class:Minisat::IntMap	typeref:typename:void
reserved_cids	yosys/backends/simplec/simplec.cc	/^static pool<string> reserved_cids;$/;"	v	typeref:typename:pool<string>	file:
reset	yosys/kernel/log.h	/^	void reset() {$/;"	f	struct:PerformanceTimer	typeref:typename:void
reset	yosys/kernel/utils.h	/^	void reset(const Key &k)$/;"	f	struct:stackmap	typeref:typename:void
reset	yosys/libs/sha1/sha1.cpp	/^void SHA1::reset()$/;"	f	class:SHA1	typeref:typename:void
reset	yosys/passes/opt/opt_clean.cc	/^	void reset(Design *design = nullptr)$/;"	f	struct:keep_cache_t	typeref:typename:void	file:
reset	yosys/passes/sat/sim.cc	/^	pool<IdString> clock, clockn, reset, resetn;$/;"	m	struct:SimWorker	typeref:typename:pool<IdString>	file:
reset_auto_counter	yosys/backends/verilog/verilog_backend.cc	/^void reset_auto_counter(RTLIL::Module *module)$/;"	f	typeref:typename:void
reset_auto_counter_id	yosys/backends/verilog/verilog_backend.cc	/^void reset_auto_counter_id(RTLIL::IdString id, bool may_rename)$/;"	f	typeref:typename:void
reset_outlines	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void reset_outlines() {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
reset_state	yosys/passes/fsm/fsmdata.h	/^	int num_inputs, num_outputs, state_bits, reset_state;$/;"	m	struct:FsmData	typeref:typename:int
resetn	yosys/passes/sat/sim.cc	/^	pool<IdString> clock, clockn, reset, resetn;$/;"	m	struct:SimWorker	typeref:typename:pool<IdString>	file:
resolve_fn	yosys/frontends/ast/dpicall.cc	/^static ffi_fptr resolve_fn (std::string symbol_name)$/;"	f	typeref:typename:ffi_fptr	file:
restart_first	yosys/libs/minisat/Solver.h	/^    int       restart_first;      \/\/ The initial restart limit.                               /;"	m	class:Minisat::Solver	typeref:typename:int
restart_inc	yosys/libs/minisat/Solver.h	/^    double    restart_inc;        \/\/ The factor with which the restart limit is multiplied in /;"	m	class:Minisat::Solver	typeref:typename:double
restore	yosys/kernel/utils.h	/^	void restore()$/;"	f	struct:stackmap	typeref:typename:void
restore_macro_arg	yosys/frontends/verilog/preproc.cc	/^static void restore_macro_arg(define_map_t &defines, macro_arg_stack_t &macro_arg_stack)$/;"	f	typeref:typename:void	file:
retime	yosys/techlibs/achronix/synth_achronix.cc	/^  bool retime, flatten;$/;"	m	struct:SynthAchronixPass	typeref:typename:bool	file:
retime	yosys/techlibs/anlogic/synth_anlogic.cc	/^	bool flatten, retime, nolutram, nobram;$/;"	m	struct:SynthAnlogicPass	typeref:typename:bool	file:
retime	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^	bool flatten, retime;$/;"	m	struct:SynthCoolrunner2Pass	typeref:typename:bool	file:
retime	yosys/techlibs/easic/synth_easic.cc	/^	bool flatten, retime;$/;"	m	struct:SynthEasicPass	typeref:typename:bool	file:
retime	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
retime	yosys/techlibs/efinix/synth_efinix.cc	/^	bool flatten, retime, nobram;$/;"	m	struct:SynthEfinixPass	typeref:typename:bool	file:
retime	yosys/techlibs/gatemate/synth_gatemate.cc	/^	bool noflatten, nobram, noaddf, nomult, nomx4, nomx8, dff, retime, noiopad, noclkbuf;$/;"	m	struct:SynthGateMatePass	typeref:typename:bool	file:
retime	yosys/techlibs/gowin/synth_gowin.cc	/^	bool retime, nobram, nolutram, flatten, nodffe, nowidelut, abc9, noiopads, noalu;$/;"	m	struct:SynthGowinPass	typeref:typename:bool	file:
retime	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^	bool flatten, retime;$/;"	m	struct:SynthGreenPAK4Pass	typeref:typename:bool	file:
retime	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
retime	yosys/techlibs/intel/synth_intel.cc	/^	bool retime, flatten, nobram, iopads;$/;"	m	struct:SynthIntelPass	typeref:typename:bool	file:
retime	yosys/techlibs/nexus/synth_nexus.cc	/^	bool noccu2, nodffe, nolram, nobram, nolutram, nowidelut, noiopad, nodsp, flatten, dff, retime,/;"	m	struct:SynthNexusPass	typeref:typename:bool	file:
retime	yosys/techlibs/sf2/synth_sf2.cc	/^	bool flatten, retime, iobs, clkbuf;$/;"	m	struct:SynthSf2Pass	typeref:typename:bool	file:
retime	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
return_char	yosys/frontends/verilog/preproc.cc	/^static void return_char(char ch)$/;"	f	typeref:typename:void	file:
reverse	yosys/kernel/rtlil.h	/^	void reverse() { inline_unpack(); std::reverse(bits_.begin(), bits_.end()); }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:void
reverse_wire_map	yosys/backends/firrtl/firrtl.cc	/^	dict<SigBit, pair<string, int>> reverse_wire_map;$/;"	m	struct:FirrtlWorker	typeref:typename:dict<SigBit,pair<string,int>>	file:
rewrite_filename	yosys/kernel/yosys.cc	/^void rewrite_filename(std::string &filename)$/;"	f	typeref:typename:void
rewrite_interface_connections	yosys/passes/hierarchy/hierarchy.cc	/^	void rewrite_interface_connections(RTLIL::Cell &cell) const$/;"	f	struct:IFExpander	typeref:typename:void	file:
rewrite_lookaheadids	yosys/frontends/ast/genrtlil.cc	/^	void rewrite_lookaheadids(AstNode *node, bool lhs = false)$/;"	f	struct:AST_INTERNAL::LookaheadRewriter	typeref:typename:void	file:
rewrite_sigspecs	yosys/kernel/rtlil.h	/^void RTLIL::CaseRule::rewrite_sigspecs(T &functor) {$/;"	f	class:RTLIL::CaseRule	typeref:typename:void
rewrite_sigspecs	yosys/kernel/rtlil.h	/^void RTLIL::Cell::rewrite_sigspecs(T &functor) {$/;"	f	class:RTLIL::Cell	typeref:typename:void
rewrite_sigspecs	yosys/kernel/rtlil.h	/^void RTLIL::Module::rewrite_sigspecs(T &functor)$/;"	f	class:RTLIL::Module	typeref:typename:void
rewrite_sigspecs	yosys/kernel/rtlil.h	/^void RTLIL::Process::rewrite_sigspecs(T &functor)$/;"	f	class:RTLIL::Process	typeref:typename:void
rewrite_sigspecs	yosys/kernel/rtlil.h	/^void RTLIL::SwitchRule::rewrite_sigspecs(T &functor)$/;"	f	class:RTLIL::SwitchRule	typeref:typename:void
rewrite_sigspecs	yosys/kernel/rtlil.h	/^void RTLIL::SyncRule::rewrite_sigspecs(T &functor)$/;"	f	class:RTLIL::SyncRule	typeref:typename:void
rewrite_sigspecs2	yosys/kernel/rtlil.h	/^void RTLIL::CaseRule::rewrite_sigspecs2(T &functor) {$/;"	f	class:RTLIL::CaseRule	typeref:typename:void
rewrite_sigspecs2	yosys/kernel/rtlil.h	/^void RTLIL::Cell::rewrite_sigspecs2(T &functor) {$/;"	f	class:RTLIL::Cell	typeref:typename:void
rewrite_sigspecs2	yosys/kernel/rtlil.h	/^void RTLIL::Module::rewrite_sigspecs2(T &functor)$/;"	f	class:RTLIL::Module	typeref:typename:void
rewrite_sigspecs2	yosys/kernel/rtlil.h	/^void RTLIL::Process::rewrite_sigspecs2(T &functor)$/;"	f	class:RTLIL::Process	typeref:typename:void
rewrite_sigspecs2	yosys/kernel/rtlil.h	/^void RTLIL::SwitchRule::rewrite_sigspecs2(T &functor)$/;"	f	class:RTLIL::SwitchRule	typeref:typename:void
rewrite_sigspecs2	yosys/kernel/rtlil.h	/^void RTLIL::SyncRule::rewrite_sigspecs2(T &functor)$/;"	f	class:RTLIL::SyncRule	typeref:typename:void
right	yosys/libs/minisat/Heap.h	/^    static inline int right (int i) { return (i+1)*2; }$/;"	f	class:Minisat::Heap	typeref:typename:int
right_parent	yosys/kernel/cellaigs.h	/^	int left_parent, right_parent;$/;"	m	struct:AigNode	typeref:typename:int
rminitbits	yosys/passes/pmgen/peepopt.cc	/^pool<SigBit> rminitbits;$/;"	v	typeref:typename:pool<SigBit>
rmunused_module	yosys/passes/opt/opt_clean.cc	/^void rmunused_module(RTLIL::Module *module, bool purge_mode, bool verbose, bool rminit)$/;"	f	typeref:typename:void
rmunused_module_cells	yosys/passes/opt/opt_clean.cc	/^void rmunused_module_cells(Module *module, bool verbose)$/;"	f	typeref:typename:void
rmunused_module_init	yosys/passes/opt/opt_clean.cc	/^bool rmunused_module_init(RTLIL::Module *module, bool verbose)$/;"	f	typeref:typename:bool
rmunused_module_signals	yosys/passes/opt/opt_clean.cc	/^bool rmunused_module_signals(RTLIL::Module *module, bool purge_mode, bool verbose)$/;"	f	typeref:typename:bool
rnd_decisions	yosys/libs/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
rnd_init_act	yosys/libs/minisat/Solver.h	/^    bool      rnd_init_act;       \/\/ Initialize variable activities with a small random value.$/;"	m	class:Minisat::Solver	typeref:typename:bool
rnd_pol	yosys/libs/minisat/Solver.h	/^    bool      rnd_pol;            \/\/ Use random polarities for branching heuristics.$/;"	m	class:Minisat::Solver	typeref:typename:bool
root	yosys/frontends/verific/verificsva.cc	/^	Instance *root = nullptr;$/;"	m	struct:VerificSvaImporter	typeref:typename:Instance *	file:
root	yosys/passes/techmap/muxcover.cc	/^		SigBit root;$/;"	m	struct:MuxcoverWorker::tree_t	typeref:typename:SigBit	file:
root_case	yosys/kernel/rtlil.h	/^	RTLIL::CaseRule root_case;$/;"	m	struct:RTLIL::Process	typeref:typename:RTLIL::CaseRule
root_enable_muxes	yosys/passes/opt/opt_muxtree.cc	/^	vector<bool> root_enable_muxes;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:vector<bool>	file:
root_mux_rerun	yosys/passes/opt/opt_muxtree.cc	/^	pool<int> root_mux_rerun;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:pool<int>	file:
root_muxes	yosys/passes/opt/opt_muxtree.cc	/^	vector<bool> root_muxes;$/;"	m	struct:OptMuxtreeWorker	typeref:typename:vector<bool>	file:
rotate_x	yosys/libs/ezsat/puzzle3d.cc	/^	void rotate_x() { int tmp[4] = { center_y, center_z, size_y, size_z }; center_y = tmp[1]; cente/;"	f	struct:blockgeom_t	typeref:typename:void	file:
rotate_y	yosys/libs/ezsat/puzzle3d.cc	/^	void rotate_y() { int tmp[4] = { center_x, center_z, size_x, size_z }; center_x = tmp[1]; cente/;"	f	struct:blockgeom_t	typeref:typename:void	file:
rotate_z	yosys/libs/ezsat/puzzle3d.cc	/^	void rotate_z() { int tmp[4] = { center_x, center_y, size_x, size_y }; center_x = tmp[1]; cente/;"	f	struct:blockgeom_t	typeref:typename:void	file:
route_up	yosys/frontends/verific/verific.cc	/^	Net *route_up(Net *net, bool drive_up, Net *final_net = nullptr)$/;"	f	struct:VerificExtNets	typeref:typename:Net *	file:
route_up	yosys/frontends/verific/verific.cc	/^	Net *route_up(Net *net, bool drive_up, Netlist *dest, Net *final_net = nullptr)$/;"	f	struct:VerificExtNets	typeref:typename:Net *	file:
rst	yosys/passes/techmap/extract_counter.cc	/^	RTLIL::SigSpec rst;				\/\/reset pin$/;"	m	struct:CounterExtraction	typeref:typename:RTLIL::SigSpec	file:
rst_inverted	yosys/passes/techmap/extract_counter.cc	/^	bool rst_inverted;				\/\/true if reset is active low$/;"	m	struct:CounterExtraction	typeref:typename:bool	file:
rst_to_max	yosys/passes/techmap/extract_counter.cc	/^	bool rst_to_max;				\/\/true if we reset to max instead of 0$/;"	m	struct:CounterExtraction	typeref:typename:bool	file:
rstlen	yosys/passes/sat/sim.cc	/^	int rstlen = 1;$/;"	m	struct:SimShared	typeref:typename:int	file:
rtlil_frontend_yyerror	yosys/frontends/rtlil/rtlil_frontend.cc	/^void rtlil_frontend_yyerror(char const *s)$/;"	f	typeref:typename:void
rtrunc	yosys/backends/cxxrtl/cxxrtl.h	/^	value<NewBits> rtrunc() const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE value<NewBits>
rule_node_t	yosys/passes/proc/proc_dlatch.cc	/^	struct rule_node_t$/;"	s	struct:proc_dlatch_db_t	file:
rules_db	yosys/passes/proc/proc_dlatch.cc	/^	idict<rule_node_t, 3> rules_db;$/;"	m	struct:proc_dlatch_db_t	typeref:typename:idict<rule_node_t,3>	file:
rules_sig	yosys/passes/proc/proc_dlatch.cc	/^	dict<int, SigBit> rules_sig;$/;"	m	struct:proc_dlatch_db_t	typeref:typename:dict<int,SigBit>	file:
rules_t	yosys/passes/memory/memory_bram.cc	/^struct rules_t$/;"	s	file:
run	yosys/backends/firrtl/firrtl.cc	/^	void run()$/;"	f	struct:FirrtlWorker	typeref:typename:void	file:
run	yosys/backends/simplec/simplec.cc	/^	void run(Module *mod)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
run	yosys/backends/smt2/smt2.cc	/^	void run()$/;"	f	struct:Smt2Worker	typeref:typename:void	file:
run	yosys/backends/smv/smv.cc	/^	void run()$/;"	f	struct:SmvWorker	typeref:typename:void	file:
run	yosys/frontends/verific/verific.cc	/^	void run(Netlist *nl)$/;"	f	struct:VerificExtNets	typeref:typename:void	file:
run	yosys/kernel/driver.cc	/^void run(const char *command)$/;"	f	typeref:typename:void
run	yosys/kernel/register.cc	/^void ScriptPass::run(std::string command, std::string info)$/;"	f	class:ScriptPass	typeref:typename:void
run	yosys/misc/launcher.c	/^int run(int argc, char **argv, int is_gui) {$/;"	f	typeref:typename:int
run	yosys/passes/cmds/ltp.cc	/^	void run()$/;"	f	struct:LtpWorker	typeref:typename:void	file:
run	yosys/passes/cmds/qwp.cc	/^	void run()$/;"	f	struct:QwpWorker	typeref:typename:void	file:
run	yosys/passes/cmds/scc.cc	/^	void run(RTLIL::Cell *cell, int depth, int maxDepth)$/;"	f	struct:SccWorker	typeref:typename:void	file:
run	yosys/passes/cmds/splice.cc	/^	void run()$/;"	f	struct:SpliceWorker	typeref:typename:void	file:
run	yosys/passes/cmds/sta.cc	/^	void run()$/;"	f	struct:StaWorker	typeref:typename:void	file:
run	yosys/passes/equiv/equiv_induct.cc	/^	void run()$/;"	f	struct:EquivInductWorker	typeref:typename:void	file:
run	yosys/passes/equiv/equiv_make.cc	/^	void run()$/;"	f	struct:EquivMakeWorker	typeref:typename:void	file:
run	yosys/passes/equiv/equiv_mark.cc	/^	void run()$/;"	f	struct:EquivMarkWorker	typeref:typename:void	file:
run	yosys/passes/equiv/equiv_miter.cc	/^	void run()$/;"	f	struct:EquivMiterWorker	typeref:typename:void	file:
run	yosys/passes/equiv/equiv_purge.cc	/^	void run()$/;"	f	struct:EquivPurgeWorker	typeref:typename:void	file:
run	yosys/passes/equiv/equiv_simple.cc	/^	int run()$/;"	f	struct:EquivSimpleWorker	typeref:typename:int	file:
run	yosys/passes/memory/memory_dff.cc	/^	void run()$/;"	f	struct:MemoryDffWorker	typeref:typename:void	file:
run	yosys/passes/memory/memory_map.cc	/^	void run()$/;"	f	struct:MemoryMapWorker	typeref:typename:void	file:
run	yosys/passes/opt/opt_dff.cc	/^	bool run() {$/;"	f	struct:OptDffWorker	typeref:typename:bool	file:
run	yosys/passes/opt/wreduce.cc	/^	void run()$/;"	f	struct:WreduceWorker	typeref:typename:void	file:
run	yosys/passes/sat/assertpmux.cc	/^	void run(Cell *pmux)$/;"	f	struct:AssertpmuxWorker	typeref:typename:void	file:
run	yosys/passes/sat/eval.cc	/^	void run()$/;"	f	struct:VlogHammerReporter	typeref:typename:void	file:
run	yosys/passes/sat/freduce.cc	/^	int run()$/;"	f	struct:FreduceWorker	typeref:typename:int	file:
run	yosys/passes/sat/sim.cc	/^	void run(Module *topmod, int numcycles)$/;"	f	struct:SimWorker	typeref:typename:void	file:
run	yosys/passes/techmap/alumacc.cc	/^	void run()$/;"	f	struct:AlumaccWorker	typeref:typename:void	file:
run	yosys/passes/techmap/extract_fa.cc	/^	void run()$/;"	f	struct:ExtractFaWorker	typeref:typename:void	file:
run	yosys/passes/techmap/muxcover.cc	/^	void run()$/;"	f	struct:MuxcoverWorker	typeref:typename:void	file:
run	yosys/passes/techmap/nlutmap.cc	/^	void run()$/;"	f	struct:NlutmapWorker	typeref:typename:void	file:
run	yosys/passes/techmap/tribuf.cc	/^	void run()$/;"	f	struct:TribufWorker	typeref:typename:void	file:
run-tests	yosys/tests/unit/Makefile	/^run-tests: $(TESTS)$/;"	t
run_abc	yosys/passes/techmap/nlutmap.cc	/^	void run_abc(int lut_size)$/;"	f	struct:NlutmapWorker	typeref:typename:void	file:
run_backend	yosys/kernel/yosys.cc	/^void run_backend(std::string filename, std::string command, RTLIL::Design *design)$/;"	f	typeref:typename:void
run_cell	yosys/passes/equiv/equiv_simple.cc	/^	bool run_cell()$/;"	f	struct:EquivSimpleWorker	typeref:typename:bool	file:
run_cell	yosys/passes/opt/wreduce.cc	/^	void run_cell(Cell *cell)$/;"	f	struct:WreduceWorker	typeref:typename:void	file:
run_cell_dff	yosys/passes/opt/wreduce.cc	/^	void run_cell_dff(Cell *cell)$/;"	f	struct:WreduceWorker	typeref:typename:void	file:
run_cell_mux	yosys/passes/opt/wreduce.cc	/^	void run_cell_mux(Cell *cell)$/;"	f	struct:WreduceWorker	typeref:typename:void	file:
run_checker	yosys/passes/sat/eval.cc	/^	void run_checker(RTLIL::SigSpec &inputs)$/;"	f	struct:BruteForceEquivChecker	typeref:typename:void	file:
run_command	yosys/kernel/yosys.cc	/^int run_command(const std::string &command, std::function<void(const std::string&)> process_line/;"	f	typeref:typename:int
run_constbits	yosys/passes/opt/opt_dff.cc	/^	bool run_constbits() {$/;"	f	struct:OptDffWorker	typeref:typename:bool	file:
run_cosim_aiger_witness	yosys/passes/sat/sim.cc	/^	void run_cosim_aiger_witness(Module *topmod)$/;"	f	struct:SimWorker	typeref:typename:void	file:
run_cosim_btor2_witness	yosys/passes/sat/sim.cc	/^	void run_cosim_btor2_witness(Module *topmod)$/;"	f	struct:SimWorker	typeref:typename:void	file:
run_cosim_fst	yosys/passes/sat/sim.cc	/^	void run_cosim_fst(Module *topmod, int numcycles)$/;"	f	struct:SimWorker	typeref:typename:void	file:
run_edges_test	yosys/passes/tests/test_cell.cc	/^static void run_edges_test(RTLIL::Design *design, bool verbose)$/;"	f	typeref:typename:void	file:
run_eval_test	yosys/passes/tests/test_cell.cc	/^static void run_eval_test(RTLIL::Design *design, bool verbose, bool nosat, std::string uut_name,/;"	f	typeref:typename:void	file:
run_fixed	yosys/passes/pmgen/xilinx_srl.cc	/^void run_fixed(xilinx_srl_pm &pm)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
run_flatten	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool run_flatten = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
run_frontend	yosys/kernel/yosys.cc	/^bool run_frontend(std::string filename, std::string command, RTLIL::Design *design, std::string /;"	f	typeref:typename:bool
run_hierarchy	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool run_hierarchy = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
run_ice40_braminit	yosys/techlibs/ice40/ice40_braminit.cc	/^static void run_ice40_braminit(Module *module)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void	file:
run_ice40_opts	yosys/techlibs/ice40/ice40_opt.cc	/^static void run_ice40_opts(Module *module)$/;"	f	typeref:typename:void	file:
run_nocheck	yosys/kernel/register.cc	/^void ScriptPass::run_nocheck(std::string command, std::string info)$/;"	f	class:ScriptPass	typeref:typename:void
run_pass	yosys/kernel/yosys.cc	/^void run_pass(std::string command, RTLIL::Design *design)$/;"	f	typeref:typename:void
run_proc	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool run_proc = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
run_reduce_inport	yosys/passes/opt/wreduce.cc	/^	void run_reduce_inport(Cell *cell, char port, int max_port_size, bool &port_signed, bool &did_s/;"	f	struct:WreduceWorker	typeref:typename:void	file:
run_register	yosys/kernel/register.cc	/^void Backend::run_register()$/;"	f	class:Backend	typeref:typename:void
run_register	yosys/kernel/register.cc	/^void Frontend::run_register()$/;"	f	class:Frontend	typeref:typename:void
run_register	yosys/kernel/register.cc	/^void Pass::run_register()$/;"	f	class:Pass	typeref:typename:void
run_script	yosys/kernel/register.cc	/^void ScriptPass::run_script(RTLIL::Design *design, std::string run_from, std::string run_to)$/;"	f	class:ScriptPass	typeref:typename:void
run_variable	yosys/passes/pmgen/xilinx_srl.cc	/^void run_variable(xilinx_srl_pm &pm)$/;"	f	typeref:typename:void
run_worker	yosys/passes/cmds/qwp.cc	/^	void run_worker(int indent)$/;"	f	struct:QwpWorker	typeref:typename:void	file:
run_yosys	yosys/passes/cmds/bugpoint.cc	/^	bool run_yosys(RTLIL::Design *design, string runner, string yosys_cmd, string yosys_arg)$/;"	f	struct:BugpointPass	typeref:typename:bool	file:
runner	yosys/passes/cmds/ltp.cc	/^	void runner(SigBit bit, int level, SigBit from, Cell *via)$/;"	f	struct:LtpWorker	typeref:typename:void	file:
runtime_ns	yosys/kernel/register.h	/^	int64_t runtime_ns;$/;"	m	struct:Pass	typeref:typename:int64_t
rvalue	yosys/backends/smv/smv.cc	/^	const char *rvalue(SigSpec sig, int width = -1, bool is_signed = false)$/;"	f	struct:SmvWorker	typeref:typename:const char *	file:
rvalue_s	yosys/backends/smv/smv.cc	/^	const char *rvalue_s(SigSpec sig, int width = -1, bool is_signed = true)$/;"	f	struct:SmvWorker	typeref:typename:const char *	file:
rvalue_u	yosys/backends/smv/smv.cc	/^	const char *rvalue_u(SigSpec sig, int width = -1)$/;"	f	struct:SmvWorker	typeref:typename:const char *	file:
rvat_beg_tim	yosys/libs/fst/fstapi.cc	/^    uint64_t rvat_beg_tim, rvat_end_tim;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
rvat_chain_facidx	yosys/libs/fst/fstapi.cc	/^    fstHandle rvat_chain_facidx;$/;"	m	struct:fstReaderContext	typeref:typename:fstHandle	file:
rvat_chain_len	yosys/libs/fst/fstapi.cc	/^    uint32_t rvat_chain_len;$/;"	m	struct:fstReaderContext	typeref:typename:uint32_t	file:
rvat_chain_mem	yosys/libs/fst/fstapi.cc	/^    unsigned char *rvat_chain_mem;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned char *	file:
rvat_chain_pos_idx	yosys/libs/fst/fstapi.cc	/^    uint32_t rvat_chain_pos_idx;$/;"	m	struct:fstReaderContext	typeref:typename:uint32_t	file:
rvat_chain_pos_tidx	yosys/libs/fst/fstapi.cc	/^    uint32_t rvat_chain_pos_tidx;$/;"	m	struct:fstReaderContext	typeref:typename:uint32_t	file:
rvat_chain_pos_time	yosys/libs/fst/fstapi.cc	/^    uint64_t rvat_chain_pos_time;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
rvat_chain_pos_valid	yosys/libs/fst/fstapi.cc	/^    unsigned rvat_chain_pos_valid : 1;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
rvat_chain_table	yosys/libs/fst/fstapi.cc	/^    fst_off_t *rvat_chain_table;$/;"	m	struct:fstReaderContext	typeref:typename:fst_off_t *	file:
rvat_chain_table_lengths	yosys/libs/fst/fstapi.cc	/^    uint32_t *rvat_chain_table_lengths;$/;"	m	struct:fstReaderContext	typeref:typename:uint32_t *	file:
rvat_data_valid	yosys/libs/fst/fstapi.cc	/^    unsigned rvat_data_valid : 1;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
rvat_end_tim	yosys/libs/fst/fstapi.cc	/^    uint64_t rvat_beg_tim, rvat_end_tim;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
rvat_frame_data	yosys/libs/fst/fstapi.cc	/^    unsigned char *rvat_frame_data;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned char *	file:
rvat_frame_maxhandle	yosys/libs/fst/fstapi.cc	/^    uint64_t rvat_frame_maxhandle;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
rvat_packtype	yosys/libs/fst/fstapi.cc	/^    int rvat_packtype;$/;"	m	struct:fstReaderContext	typeref:typename:int	file:
rvat_sig_offs	yosys/libs/fst/fstapi.cc	/^    uint32_t *rvat_sig_offs;$/;"	m	struct:fstReaderContext	typeref:typename:uint32_t *	file:
rvat_time_table	yosys/libs/fst/fstapi.cc	/^    uint64_t *rvat_time_table;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t *	file:
rvat_vc_maxhandle	yosys/libs/fst/fstapi.cc	/^    uint64_t rvat_vc_maxhandle;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
rvat_vc_start	yosys/libs/fst/fstapi.cc	/^    fst_off_t rvat_vc_start;$/;"	m	struct:fstReaderContext	typeref:typename:fst_off_t	file:
rvs_buf	yosys/libs/fst/fstapi.cc	/^                            unsigned char rvs_buf[8];$/;"	m	union:fstReaderInit::__anonaa21f10b010a	typeref:typename:unsigned char[8]	file:
rwire	yosys/passes/techmap/extract_counter.cc	/^	RTLIL::Wire* rwire;				\/\/the register output$/;"	m	struct:CounterExtraction	typeref:typename:RTLIL::Wire *	file:
rzext	yosys/backends/cxxrtl/cxxrtl.h	/^	value<NewBits> rzext() const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE value<NewBits>
sample	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void sample(uint64_t timestamp) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
sat	yosys/libs/ezsat/ezsat.h	/^	ezSAT &sat;$/;"	m	struct:ezSATbit	typeref:typename:ezSAT &
sat	yosys/libs/ezsat/ezsat.h	/^	ezSAT &sat;$/;"	m	struct:ezSATvec	typeref:typename:ezSAT &
sat	yosys/passes/opt/opt_dff.cc	/^	bool sat;$/;"	m	struct:OptDffOptions	typeref:typename:bool	file:
sat	yosys/passes/sat/qbfsat.h	/^	bool nobisection = false, sat = false, unsat = false, show_smtbmc = false;$/;"	m	struct:QbfSolveOptions	typeref:typename:bool
sat	yosys/passes/sat/qbfsat.h	/^	bool sat = false;$/;"	m	struct:QbfSolutionType	typeref:typename:bool
sat_check	yosys/passes/sat/eval.cc	/^	void sat_check(RTLIL::Module *module, RTLIL::SigSpec recorded_set_vars, RTLIL::Const recorded_s/;"	f	struct:VlogHammerReporter	typeref:typename:void	file:
sat_def	yosys/passes/sat/freduce.cc	/^	std::vector<int> sat_pi, sat_out, sat_def;$/;"	m	struct:PerformReduction	typeref:typename:std::vector<int>	file:
sat_out	yosys/passes/sat/freduce.cc	/^	std::vector<int> sat_pi, sat_out, sat_def;$/;"	m	struct:PerformReduction	typeref:typename:std::vector<int>	file:
sat_pi	yosys/passes/sat/freduce.cc	/^	std::map<RTLIL::SigBit, int> sat_pi;$/;"	m	struct:FindReducedInputs	typeref:typename:std::map<RTLIL::SigBit,int>	file:
sat_pi	yosys/passes/sat/freduce.cc	/^	std::vector<int> sat_pi, sat_out, sat_def;$/;"	m	struct:PerformReduction	typeref:typename:std::vector<int>	file:
sat_pi_uniq_bitvec	yosys/passes/sat/freduce.cc	/^	std::vector<int> sat_pi_uniq_bitvec;$/;"	m	struct:FindReducedInputs	typeref:typename:std::vector<int>	file:
satgen	yosys/kernel/qcsat.h	/^	SatGen satgen;$/;"	m	struct:QuickConeSat	typeref:typename:SatGen
satgen	yosys/passes/equiv/equiv_induct.cc	/^	SatGen satgen;$/;"	m	struct:EquivInductWorker	typeref:typename:SatGen	file:
satgen	yosys/passes/equiv/equiv_simple.cc	/^	SatGen satgen;$/;"	m	struct:EquivSimpleWorker	typeref:typename:SatGen	file:
satgen	yosys/passes/sat/freduce.cc	/^	SatGen satgen;$/;"	m	struct:FindReducedInputs	typeref:typename:SatGen	file:
satgen	yosys/passes/sat/freduce.cc	/^	SatGen satgen;$/;"	m	struct:PerformReduction	typeref:typename:SatGen	file:
satgen	yosys/passes/sat/sat.cc	/^	SatGen satgen;$/;"	m	struct:SatHelper	typeref:typename:SatGen	file:
satisfied	yosys/libs/minisat/Solver.cc	/^bool Solver::satisfied(const Clause& c) const {$/;"	f	class:Solver	typeref:typename:bool
save	yosys/kernel/utils.h	/^	void save()$/;"	f	struct:stackmap	typeref:typename:void
save_struct_array_width	yosys/frontends/ast/simplify.cc	/^static void save_struct_array_width(AstNode *node, int width)$/;"	f	typeref:typename:void	file:
saved_designs	yosys/passes/cmds/design.cc	/^std::map<std::string, RTLIL::Design*> saved_designs;$/;"	v	typeref:typename:YOSYS_NAMESPACE_BEGIN std::map<std::string,RTLIL::Design * >
scast	yosys/backends/cxxrtl/cxxrtl.h	/^	value<NewBits> scast() const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE value<NewBits>
sccList	yosys/passes/cmds/scc.cc	/^	std::vector<std::set<RTLIL::Cell*>> sccList;$/;"	m	struct:SccWorker	typeref:typename:std::vector<std::set<RTLIL::Cell * >>	file:
schedule	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Module*, std::vector<FlowGraph::Node>> schedule, debug_schedule;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<const RTLIL::Module *,std::vector<FlowGraph::Node>>	file:
schedule	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::vector<Vertex*> schedule()$/;"	f	struct:Scheduler	typeref:typename:std::vector<Vertex * >	file:
scmp	yosys/backends/cxxrtl/cxxrtl.h	/^	bool scmp(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:bool
scope	yosys/kernel/fstdata.h	/^	std::string scope;$/;"	m	struct:FstVar	typeref:typename:std::string
scope	yosys/libs/fst/fstapi.h	/^        } scope;$/;"	m	union:fstHier::__anonafd27bad010a	typeref:struct:fstHier::__anonafd27bad010a::fstHierScope
scope	yosys/passes/sat/sim.cc	/^	std::string scope;$/;"	m	struct:SimInstance	typeref:typename:std::string	file:
scope	yosys/passes/sat/sim.cc	/^	std::string scope;$/;"	m	struct:SimWorker	typeref:typename:std::string	file:
scope_count	yosys/libs/fst/fstapi.cc	/^    uint64_t scope_count;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
score	yosys/passes/sat/mutate.cc	/^	int score(const mutate_t &m) {$/;"	f	struct:coverdb_t	typeref:typename:int	file:
score_metamux_select	yosys/passes/cmds/glift.cc	/^	RTLIL::SigSpec score_metamux_select(const RTLIL::SigSpec &metamux_select, const RTLIL::IdString/;"	f	struct:GliftWorker	typeref:typename:RTLIL::SigSpec	file:
scrambler_p01.pdf	yosys/manual/PRESENTATION_ExOth/Makefile	/^scrambler_p01.pdf: scrambler.ys scrambler.v$/;"	t
scrambler_p02.pdf	yosys/manual/PRESENTATION_ExOth/Makefile	/^scrambler_p02.pdf: scrambler_p01.pdf$/;"	t
scratchpad	yosys/kernel/rtlil.h	/^	dict<std::string, std::string> scratchpad;$/;"	m	struct:RTLIL::Design	typeref:typename:dict<std::string,std::string>
scratchpad_get_bool	yosys/kernel/rtlil.cc	/^bool RTLIL::Design::scratchpad_get_bool(const std::string &varname, bool default_value) const$/;"	f	class:RTLIL::Design	typeref:typename:bool
scratchpad_get_int	yosys/kernel/rtlil.cc	/^int RTLIL::Design::scratchpad_get_int(const std::string &varname, int default_value) const$/;"	f	class:RTLIL::Design	typeref:typename:int
scratchpad_get_string	yosys/kernel/rtlil.cc	/^std::string RTLIL::Design::scratchpad_get_string(const std::string &varname, const std::string &/;"	f	class:RTLIL::Design	typeref:typename:std::string
scratchpad_set_bool	yosys/kernel/rtlil.cc	/^void RTLIL::Design::scratchpad_set_bool(const std::string &varname, bool value)$/;"	f	class:RTLIL::Design	typeref:typename:void
scratchpad_set_int	yosys/kernel/rtlil.cc	/^void RTLIL::Design::scratchpad_set_int(const std::string &varname, int value)$/;"	f	class:RTLIL::Design	typeref:typename:void
scratchpad_set_string	yosys/kernel/rtlil.cc	/^void RTLIL::Design::scratchpad_set_string(const std::string &varname, std::string value)$/;"	f	class:RTLIL::Design	typeref:typename:void
scratchpad_unset	yosys/kernel/rtlil.cc	/^void RTLIL::Design::scratchpad_unset(const std::string &varname)$/;"	f	class:RTLIL::Design	typeref:typename:void
script	yosys/passes/equiv/equiv_opt.cc	/^	void script() override$/;"	f	struct:EquivOptPass	typeref:typename:void	file:
script	yosys/passes/techmap/abc9.cc	/^	void script() override$/;"	f	struct:Abc9Pass	typeref:typename:void	file:
script	yosys/techlibs/achronix/synth_achronix.cc	/^  void script() override$/;"	f	struct:SynthAchronixPass	typeref:typename:void	file:
script	yosys/techlibs/anlogic/synth_anlogic.cc	/^	void script() override$/;"	f	struct:SynthAnlogicPass	typeref:typename:void	file:
script	yosys/techlibs/common/prep.cc	/^	void script() override$/;"	f	struct:PrepPass	typeref:typename:void	file:
script	yosys/techlibs/common/synth.cc	/^	void script() override$/;"	f	struct:SynthPass	typeref:typename:void	file:
script	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^	void script() override$/;"	f	struct:SynthCoolrunner2Pass	typeref:typename:void	file:
script	yosys/techlibs/easic/synth_easic.cc	/^	void script() override$/;"	f	struct:SynthEasicPass	typeref:typename:void	file:
script	yosys/techlibs/ecp5/synth_ecp5.cc	/^	void script() override$/;"	f	struct:SynthEcp5Pass	typeref:typename:void	file:
script	yosys/techlibs/efinix/synth_efinix.cc	/^	void script() override$/;"	f	struct:SynthEfinixPass	typeref:typename:void	file:
script	yosys/techlibs/gatemate/synth_gatemate.cc	/^	void script() override$/;"	f	struct:SynthGateMatePass	typeref:typename:void	file:
script	yosys/techlibs/gowin/synth_gowin.cc	/^	void script() override$/;"	f	struct:SynthGowinPass	typeref:typename:void	file:
script	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^	void script() override$/;"	f	struct:SynthGreenPAK4Pass	typeref:typename:void	file:
script	yosys/techlibs/ice40/synth_ice40.cc	/^	void script() override$/;"	f	struct:SynthIce40Pass	typeref:typename:void	file:
script	yosys/techlibs/intel/synth_intel.cc	/^	void script() override$/;"	f	struct:SynthIntelPass	typeref:typename:void	file:
script	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	void script() override$/;"	f	struct:SynthIntelALMPass	typeref:typename:void	file:
script	yosys/techlibs/machxo2/synth_machxo2.cc	/^	void script() override$/;"	f	struct:SynthMachXO2Pass	typeref:typename:void	file:
script	yosys/techlibs/nexus/synth_nexus.cc	/^	void script() override$/;"	f	struct:SynthNexusPass	typeref:typename:void	file:
script	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	void script() override$/;"	f	struct:SynthQuickLogicPass	typeref:typename:void	file:
script	yosys/techlibs/sf2/synth_sf2.cc	/^	void script() override$/;"	f	struct:SynthSf2Pass	typeref:typename:void	file:
script	yosys/techlibs/xilinx/synth_xilinx.cc	/^	void script() override$/;"	f	struct:SynthXilinxPass	typeref:typename:void	file:
scshell	yosys/libs/subcircuit/Makefile	/^scshell: scshell.o subcircuit.o$/;"	t
sdt_workspace	yosys/libs/fst/fstapi.h	/^            unsigned char sdt_workspace; \/* zeroed out by FST reader, for client code use *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierVar	typeref:typename:unsigned char
search	yosys/libs/minisat/Solver.cc	/^lbool Solver::search(int nof_conflicts)$/;"	f	class:Solver	typeref:typename:lbool
sec	yosys/kernel/log.h	/^	float sec() const {$/;"	f	struct:PerformanceTimer	typeref:typename:float
secnum	yosys/libs/fst/fstapi.cc	/^    uint32_t secnum;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t	file:
second	yosys/kernel/timinginfo.h	/^		NameBit first, second;$/;"	m	struct:TimingInfo::BitBit	typeref:typename:NameBit
section_header_only	yosys/libs/fst/fstapi.cc	/^    unsigned section_header_only : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
section_header_truncpos	yosys/libs/fst/fstapi.cc	/^    fst_off_t section_header_truncpos;$/;"	m	struct:fstWriterContext	typeref:typename:fst_off_t	file:
section_start	yosys/libs/fst/fstapi.cc	/^    fst_off_t section_start;$/;"	m	struct:fstWriterContext	typeref:typename:fst_off_t	file:
seed	yosys/passes/sat/mutate.cc	/^	int seed = 0;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
seed_cells	yosys/passes/equiv/equiv_miter.cc	/^	pool<Cell*> seed_cells, miter_cells;$/;"	m	struct:EquivMiterWorker	typeref:typename:pool<Cell * >	file:
seen	yosys/libs/minisat/Solver.h	/^    VMap<char>          seen;$/;"	m	class:Minisat::Solver	typeref:typename:VMap<char>
seen_failed	yosys/libs/minisat/Solver.cc	/^    enum { seen_undef = 0, seen_source = 1, seen_removable = 2, seen_failed = 3 };$/;"	e	enum:Solver::litRedundant::__anonf4a4afe70103	file:
seen_non_mux	yosys/passes/opt/opt_muxtree.cc	/^		bool seen_non_mux;$/;"	m	struct:OptMuxtreeWorker::bitinfo_t	typeref:typename:bool	file:
seen_removable	yosys/libs/minisat/Solver.cc	/^    enum { seen_undef = 0, seen_source = 1, seen_removable = 2, seen_failed = 3 };$/;"	e	enum:Solver::litRedundant::__anonf4a4afe70103	file:
seen_source	yosys/libs/minisat/Solver.cc	/^    enum { seen_undef = 0, seen_source = 1, seen_removable = 2, seen_failed = 3 };$/;"	e	enum:Solver::litRedundant::__anonf4a4afe70103	file:
seen_undef	yosys/libs/minisat/Solver.cc	/^    enum { seen_undef = 0, seen_source = 1, seen_removable = 2, seen_failed = 3 };$/;"	e	enum:Solver::litRedundant::__anonf4a4afe70103	file:
sel_any_bit	yosys/passes/cmds/splice.cc	/^	bool sel_any_bit;$/;"	m	struct:SpliceWorker	typeref:typename:bool	file:
sel_by_cell	yosys/passes/cmds/splice.cc	/^	bool sel_by_cell;$/;"	m	struct:SpliceWorker	typeref:typename:bool	file:
sel_by_wire	yosys/passes/cmds/splice.cc	/^	bool sel_by_wire;$/;"	m	struct:SpliceWorker	typeref:typename:bool	file:
select	yosys/kernel/rtlil.h	/^	template<typename T1, typename T2> void select(T1 *module, T2 *member) {$/;"	f	struct:RTLIL::Design	typeref:typename:void
select	yosys/kernel/rtlil.h	/^	template<typename T1, typename T2> void select(T1 *module, T2 *member) {$/;"	f	struct:RTLIL::Selection	typeref:typename:void
select	yosys/kernel/rtlil.h	/^	template<typename T1> void select(T1 *module) {$/;"	f	struct:RTLIL::Design	typeref:typename:void
select	yosys/kernel/rtlil.h	/^	template<typename T1> void select(T1 *module) {$/;"	f	struct:RTLIL::Selection	typeref:typename:void
select	yosys/passes/cmds/scc.cc	/^	void select(RTLIL::Selection &sel)$/;"	f	struct:SccWorker	typeref:typename:void	file:
select.pdf	yosys/manual/PRESENTATION_ExAdv/Makefile	/^select.pdf: select.v select.ys$/;"	t
select_filter_active_mod	yosys/passes/cmds/select.cc	/^static void select_filter_active_mod(RTLIL::Design *design, RTLIL::Selection &sel)$/;"	f	typeref:typename:void	file:
select_op_alias	yosys/passes/cmds/select.cc	/^static void select_op_alias(RTLIL::Design *design, RTLIL::Selection &lhs)$/;"	f	typeref:typename:void	file:
select_op_cells_to_modules	yosys/passes/cmds/select.cc	/^static void select_op_cells_to_modules(RTLIL::Design *design, RTLIL::Selection &lhs)$/;"	f	typeref:typename:void	file:
select_op_diff	yosys/passes/cmds/select.cc	/^static void select_op_diff(RTLIL::Design *design, RTLIL::Selection &lhs, const RTLIL::Selection /;"	f	typeref:typename:void	file:
select_op_expand	yosys/passes/cmds/select.cc	/^static int select_op_expand(RTLIL::Design *design, RTLIL::Selection &lhs, std::vector<expand_rul/;"	f	typeref:typename:int	file:
select_op_expand	yosys/passes/cmds/select.cc	/^static void select_op_expand(RTLIL::Design *design, const std::string &arg, char mode, bool eval/;"	f	typeref:typename:void	file:
select_op_fullmod	yosys/passes/cmds/select.cc	/^static void select_op_fullmod(RTLIL::Design *design, RTLIL::Selection &lhs)$/;"	f	typeref:typename:void	file:
select_op_intersect	yosys/passes/cmds/select.cc	/^static void select_op_intersect(RTLIL::Design *design, RTLIL::Selection &lhs, const RTLIL::Selec/;"	f	typeref:typename:void	file:
select_op_module_to_cells	yosys/passes/cmds/select.cc	/^static void select_op_module_to_cells(RTLIL::Design *design, RTLIL::Selection &lhs)$/;"	f	typeref:typename:void	file:
select_op_neg	yosys/passes/cmds/select.cc	/^static void select_op_neg(RTLIL::Design *design, RTLIL::Selection &lhs)$/;"	f	typeref:typename:void	file:
select_op_random	yosys/passes/cmds/select.cc	/^static void select_op_random(RTLIL::Design *design, RTLIL::Selection &lhs, int count)$/;"	f	typeref:typename:void	file:
select_op_submod	yosys/passes/cmds/select.cc	/^static void select_op_submod(RTLIL::Design *design, RTLIL::Selection &lhs)$/;"	f	typeref:typename:void	file:
select_op_union	yosys/passes/cmds/select.cc	/^static void select_op_union(RTLIL::Design*, RTLIL::Selection &lhs, const RTLIL::Selection &rhs)$/;"	f	typeref:typename:void	file:
select_stmt	yosys/passes/cmds/select.cc	/^static void select_stmt(RTLIL::Design *design, std::string arg, bool disable_empty_warning = fal/;"	f	typeref:typename:void	file:
selected	yosys/kernel/rtlil.h	/^	template<typename T1, typename T2> bool selected(T1 *module, T2 *member) const {$/;"	f	struct:RTLIL::Design	typeref:typename:bool
selected	yosys/kernel/rtlil.h	/^	template<typename T1> bool selected(T1 *module) const {$/;"	f	struct:RTLIL::Design	typeref:typename:bool
selected	yosys/kernel/rtlil.h	/^	template<typename T> bool selected(T *member) const {$/;"	f	struct:RTLIL::Module	typeref:typename:bool
selected_active_module	yosys/kernel/rtlil.h	/^	std::string selected_active_module;$/;"	m	struct:RTLIL::Design	typeref:typename:std::string
selected_cells	yosys/kernel/rtlil.cc	/^std::vector<RTLIL::Cell*> RTLIL::Module::selected_cells() const$/;"	f	class:RTLIL::Module	typeref:typename:std::vector<RTLIL::Cell * >
selected_member	yosys/kernel/rtlil.cc	/^bool RTLIL::Design::selected_member(RTLIL::IdString mod_name, RTLIL::IdString memb_name) const$/;"	f	class:RTLIL::Design	typeref:typename:bool
selected_member	yosys/kernel/rtlil.cc	/^bool RTLIL::Selection::selected_member(RTLIL::IdString mod_name, RTLIL::IdString memb_name) cons/;"	f	class:RTLIL::Selection	typeref:typename:bool
selected_members	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, pool<RTLIL::IdString>> selected_members;$/;"	m	struct:RTLIL::Selection	typeref:typename:dict<RTLIL::IdString,pool<RTLIL::IdString>>
selected_module	yosys/kernel/rtlil.cc	/^bool RTLIL::Design::selected_module(RTLIL::IdString mod_name) const$/;"	f	class:RTLIL::Design	typeref:typename:bool
selected_module	yosys/kernel/rtlil.cc	/^bool RTLIL::Design::selected_module(RTLIL::Module *mod) const$/;"	f	class:RTLIL::Design	typeref:typename:bool
selected_module	yosys/kernel/rtlil.cc	/^bool RTLIL::Selection::selected_module(RTLIL::IdString mod_name) const$/;"	f	class:RTLIL::Selection	typeref:typename:bool
selected_modules	yosys/kernel/rtlil.cc	/^std::vector<RTLIL::Module*> RTLIL::Design::selected_modules() const$/;"	f	class:RTLIL::Design	typeref:typename:std::vector<RTLIL::Module * >
selected_modules	yosys/kernel/rtlil.h	/^	pool<RTLIL::IdString> selected_modules;$/;"	m	struct:RTLIL::Selection	typeref:typename:pool<RTLIL::IdString>
selected_whole_module	yosys/kernel/rtlil.cc	/^bool RTLIL::Design::selected_whole_module(RTLIL::IdString mod_name) const$/;"	f	class:RTLIL::Design	typeref:typename:bool
selected_whole_module	yosys/kernel/rtlil.cc	/^bool RTLIL::Design::selected_whole_module(RTLIL::Module *mod) const$/;"	f	class:RTLIL::Design	typeref:typename:bool
selected_whole_module	yosys/kernel/rtlil.cc	/^bool RTLIL::Selection::selected_whole_module(RTLIL::IdString mod_name) const$/;"	f	class:RTLIL::Selection	typeref:typename:bool
selected_whole_modules	yosys/kernel/rtlil.cc	/^std::vector<RTLIL::Module*> RTLIL::Design::selected_whole_modules() const$/;"	f	class:RTLIL::Design	typeref:typename:std::vector<RTLIL::Module * >
selected_whole_modules_warn	yosys/kernel/rtlil.cc	/^std::vector<RTLIL::Module*> RTLIL::Design::selected_whole_modules_warn(bool include_wb) const$/;"	f	class:RTLIL::Design	typeref:typename:std::vector<RTLIL::Module * >
selected_wires	yosys/kernel/rtlil.cc	/^std::vector<RTLIL::Wire*> RTLIL::Module::selected_wires() const$/;"	f	class:RTLIL::Module	typeref:typename:std::vector<RTLIL::Wire * >
selection	yosys/kernel/rtlil.h	/^	RTLIL::Selection &selection() {$/;"	f	struct:RTLIL::Design	typeref:typename:RTLIL::Selection &
selection	yosys/kernel/rtlil.h	/^	const RTLIL::Selection &selection() const {$/;"	f	struct:RTLIL::Design	typeref:typename:const RTLIL::Selection &
selectionSort	yosys/libs/minisat/Sort.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f	namespace:Minisat	typeref:typename:void
selectionSort	yosys/libs/minisat/Sort.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat	typeref:typename:void
selection_stack	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::Selection> selection_stack;$/;"	m	struct:RTLIL::Design	typeref:typename:std::vector<RTLIL::Selection>
selection_vars	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, RTLIL::Selection> selection_vars;$/;"	m	struct:RTLIL::Design	typeref:typename:dict<RTLIL::IdString,RTLIL::Selection>
selects	yosys/passes/techmap/muxcover.cc	/^		vector<SigBit> inputs, selects;$/;"	m	struct:MuxcoverWorker::newmux_t	typeref:typename:vector<SigBit>	file:
semantics	yosys/passes/opt/opt_share.cc	/^	RTLIL::IdString semantics;$/;"	m	struct:ExtSigSpec	typeref:typename:RTLIL::IdString	file:
serialize_design	yosys/backends/protobuf/protobuf.cc	/^	void serialize_design(yosys::pb::Design *pb, Design *design)$/;"	f	struct:ProtobufDesignSerializer	typeref:typename:void	file:
serialize_models	yosys/backends/protobuf/protobuf.cc	/^	void serialize_models(google::protobuf::Map<string, yosys::pb::Model> *models)$/;"	f	struct:ProtobufDesignSerializer	typeref:typename:void	file:
serialize_module	yosys/backends/protobuf/protobuf.cc	/^	void serialize_module(yosys::pb::Module* out, Module *module)$/;"	f	struct:ProtobufDesignSerializer	typeref:typename:void	file:
serialize_param_value	yosys/frontends/ast/ast.cc	/^static std::string serialize_param_value(const RTLIL::Const &val) {$/;"	f	typeref:typename:std::string	file:
serialize_parameters	yosys/backends/protobuf/protobuf.cc	/^	void serialize_parameters(google::protobuf::Map<std::string, yosys::pb::Parameter> *out,$/;"	f	struct:ProtobufDesignSerializer	typeref:typename:void	file:
server	yosys/frontends/rpc/rpc_frontend.cc	/^	std::shared_ptr<RpcServer> server;$/;"	m	struct:RpcModule	typeref:typename:std::shared_ptr<RpcServer>	file:
set	yosys/backends/cxxrtl/cxxrtl.h	/^	void set(IntegerT other) const {$/;"	f	struct:cxxrtl::debug_item	typeref:typename:void
set	yosys/backends/cxxrtl/cxxrtl.h	/^	void set(IntegerT other) {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE void
set	yosys/backends/cxxrtl/cxxrtl.h	/^	void set(IntegerT other) {$/;"	f	struct:cxxrtl::wire	typeref:typename:CXXRTL_ALWAYS_INLINE void
set	yosys/frontends/aiger/aigerparse.cc	/^	void set(RTLIL::SigBit sig, RTLIL::State value)$/;"	f	struct:ConstEvalAig	typeref:typename:void	file:
set	yosys/kernel/consteval.h	/^	void set(RTLIL::SigSpec sig, RTLIL::Const value)$/;"	f	struct:ConstEval	typeref:typename:void
set	yosys/kernel/ffinit.h	/^	void set(const SigMap *sigmap_, RTLIL::Module *module)$/;"	f	struct:FfInitVals	typeref:typename:void
set	yosys/kernel/ffmerge.cc	/^void FfMergeHelper::set(FfInitVals *initvals_, RTLIL::Module *module_)$/;"	f	class:FfMergeHelper	typeref:typename:void
set	yosys/kernel/sigtools.h	/^	void set(RTLIL::Module *module)$/;"	f	struct:SigMap	typeref:typename:void
set	yosys/kernel/utils.h	/^	void set(const Key &k, const T &v)$/;"	f	struct:stackmap	typeref:typename:void
setBit	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::setBit(Index bi, bool newBit) {$/;"	f	class:BigUnsigned	typeref:typename:void
setBlock	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::setBlock(Index i, Blk newBlock) {$/;"	f	class:BigUnsigned	typeref:typename:void
setConfBudget	yosys/libs/minisat/Solver.h	/^inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }$/;"	f	class:Minisat::Solver	typeref:typename:void
setContext	yosys/kernel/satgen.h	/^	void setContext(SigMap *sigmap, std::string prefix = std::string())$/;"	f	struct:SatGen	typeref:typename:void
setDecisionVar	yosys/libs/minisat/Solver.h	/^inline void     Solver::setDecisionVar(Var v, bool b) $/;"	f	class:Minisat::Solver	typeref:typename:void
setFrozen	yosys/libs/minisat/SimpSolver.h	/^inline void SimpSolver::setFrozen    (Var v, bool b) { frozen[v] = (char)b; if (use_simplificati/;"	f	class:Minisat::SimpSolver	typeref:typename:void
setHelpPrefixStr	yosys/libs/minisat/Options.cc	/^void Minisat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }$/;"	f	class:Minisat	typeref:typename:void
setInitState	yosys/kernel/satgen.h	/^	void setInitState(int timestep)$/;"	f	struct:SatGen	typeref:typename:void
setInitState	yosys/passes/sat/sim.cc	/^	bool setInitState()$/;"	f	struct:SimInstance	typeref:typename:bool	file:
setMemState	yosys/passes/sat/sim.cc	/^	void setMemState(dict<int, std::pair<std::string,int>> bits, std::string values)$/;"	f	struct:SimInstance	typeref:typename:void	file:
setParam	yosys/kernel/rtlil.cc	/^void RTLIL::Cell::setParam(RTLIL::IdString paramname, RTLIL::Const value)$/;"	f	class:RTLIL::Cell	typeref:typename:void
setPolarity	yosys/libs/minisat/Solver.h	/^inline void     Solver::setPolarity   (Var v, lbool b){ user_pol[v] = b; }$/;"	f	class:Minisat::Solver	typeref:typename:void
setPort	yosys/kernel/rtlil.cc	/^void RTLIL::Cell::setPort(RTLIL::IdString portname, RTLIL::SigSpec signal)$/;"	f	class:RTLIL::Cell	typeref:typename:void
setPropBudget	yosys/libs/minisat/Solver.h	/^inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }$/;"	f	class:Minisat::Solver	typeref:typename:void
setSolverTimeout	yosys/libs/ezsat/ezsat.h	/^	void setSolverTimeout(int newTimeoutSeconds) {$/;"	f	class:ezSAT	typeref:typename:void
setState	yosys/passes/sat/sim.cc	/^	void setState(dict<int, std::pair<SigBit,bool>> bits, std::string values)$/;"	f	struct:SimInstance	typeref:typename:void	file:
setUsageHelp	yosys/libs/minisat/Options.cc	/^void Minisat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }$/;"	f	class:Minisat	typeref:typename:void
setVerbose	yosys/libs/subcircuit/subcircuit.cc	/^	void setVerbose()$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
setVerbose	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::setVerbose()$/;"	f	class:SubCircuit::Solver	typeref:typename:void
set_assumes	yosys/passes/sat/sat.cc	/^	bool prove_asserts, set_assumes;$/;"	m	struct:SatHelper	typeref:typename:bool	file:
set_bit	yosys/backends/cxxrtl/cxxrtl.h	/^	void set_bit(size_t offset, bool value = true) {$/;"	f	struct:cxxrtl::value	typeref:typename:void
set_bool_attribute	yosys/kernel/rtlil.cc	/^void RTLIL::AttrObject::set_bool_attribute(RTLIL::IdString id, bool value)$/;"	f	class:RTLIL::AttrObject	typeref:typename:void
set_dirty	yosys/backends/simplec/simplec.cc	/^	void set_dirty(Cell *cell)$/;"	f	struct:HierDirtyFlags	typeref:typename:void	file:
set_dirty	yosys/backends/simplec/simplec.cc	/^	void set_dirty(SigBit bit)$/;"	f	struct:HierDirtyFlags	typeref:typename:void	file:
set_hdlname_attribute	yosys/kernel/rtlil.cc	/^void RTLIL::AttrObject::set_hdlname_attribute(const vector<string> &hierarchy)$/;"	f	class:RTLIL::AttrObject	typeref:typename:void
set_incremental	yosys/frontends/aiger/aigerparse.cc	/^	void set_incremental(RTLIL::SigSpec sig, RTLIL::Const value)$/;"	f	struct:ConstEvalAig	typeref:typename:void	file:
set_init	yosys/kernel/ffinit.h	/^	void set_init(RTLIL::SigBit bit, RTLIL::State val)$/;"	f	struct:FfInitVals	typeref:typename:void
set_init	yosys/kernel/ffinit.h	/^	void set_init(const RTLIL::SigSpec &sig, RTLIL::Const val)$/;"	f	struct:FfInitVals	typeref:typename:void
set_init_def	yosys/passes/sat/sat.cc	/^	bool enable_undef, set_init_def, set_init_undef, set_init_zero, ignore_unknown_cells;$/;"	m	struct:SatHelper	typeref:typename:bool	file:
set_init_undef	yosys/passes/sat/sat.cc	/^	bool enable_undef, set_init_def, set_init_undef, set_init_zero, ignore_unknown_cells;$/;"	m	struct:SatHelper	typeref:typename:bool	file:
set_init_zero	yosys/passes/sat/sat.cc	/^	bool enable_undef, set_init_def, set_init_undef, set_init_zero, ignore_unknown_cells;$/;"	m	struct:SatHelper	typeref:typename:bool	file:
set_inports	yosys/passes/sat/sim.cc	/^	void set_inports(pool<IdString> ports, State value)$/;"	f	struct:SimWorker	typeref:typename:void	file:
set_intvec_attribute	yosys/kernel/rtlil.cc	/^void RTLIL::AttrObject::set_intvec_attribute(RTLIL::IdString id, const vector<int> &data)$/;"	f	class:RTLIL::AttrObject	typeref:typename:void
set_keep_assert	yosys/passes/hierarchy/hierarchy.cc	/^bool set_keep_assert(std::map<RTLIL::Module*, bool> &cache, RTLIL::Module *mod)$/;"	f	typeref:typename:bool
set_line_num	yosys/frontends/ast/ast.cc	/^	void (*set_line_num)(int) = NULL;$/;"	v	namespace:AST	typeref:typename:void (*)(int)
set_memory_state	yosys/passes/sat/sim.cc	/^	void set_memory_state(IdString memid, Const addr, Const data)$/;"	f	struct:SimInstance	typeref:typename:void	file:
set_memory_state_bit	yosys/passes/sat/sim.cc	/^	void set_memory_state_bit(IdString memid, int offset, State data)$/;"	f	struct:SimInstance	typeref:typename:void	file:
set_simplify_design_context	yosys/frontends/ast/simplify.cc	/^void AST::set_simplify_design_context(const RTLIL::Design *design)$/;"	f	class:AST	typeref:typename:void
set_src_attr	yosys/frontends/ast/ast.cc	/^void AST::set_src_attr(RTLIL::AttrObject *obj, const AstNode *ast)$/;"	f	class:AST	typeref:typename:void
set_src_attribute	yosys/kernel/rtlil.h	/^	void set_src_attribute(const std::string &src) {$/;"	f	struct:RTLIL::AttrObject	typeref:typename:void
set_state	yosys/passes/sat/sim.cc	/^	bool set_state(SigSpec sig, Const value)$/;"	f	struct:SimInstance	typeref:typename:bool	file:
set_string_attribute	yosys/kernel/rtlil.cc	/^void RTLIL::AttrObject::set_string_attribute(RTLIL::IdString id, string value)$/;"	f	class:RTLIL::AttrObject	typeref:typename:void
set_strpool_attribute	yosys/kernel/rtlil.cc	/^void RTLIL::AttrObject::set_strpool_attribute(RTLIL::IdString id, const pool<string> &data)$/;"	f	class:RTLIL::AttrObject	typeref:typename:void
sets	yosys/passes/sat/sat.cc	/^	std::vector<std::pair<std::string, std::string>> sets, prove, prove_x, sets_init;$/;"	m	struct:SatHelper	typeref:typename:std::vector<std::pair<std::string,std::string>>	file:
sets_all_undef	yosys/passes/sat/sat.cc	/^	std::vector<std::string> sets_def, sets_any_undef, sets_all_undef;$/;"	m	struct:SatHelper	typeref:typename:std::vector<std::string>	file:
sets_all_undef_at	yosys/passes/sat/sat.cc	/^	std::map<int, std::vector<std::string>> sets_def_at, sets_any_undef_at, sets_all_undef_at;$/;"	m	struct:SatHelper	typeref:typename:std::map<int,std::vector<std::string>>	file:
sets_any_undef	yosys/passes/sat/sat.cc	/^	std::vector<std::string> sets_def, sets_any_undef, sets_all_undef;$/;"	m	struct:SatHelper	typeref:typename:std::vector<std::string>	file:
sets_any_undef_at	yosys/passes/sat/sat.cc	/^	std::map<int, std::vector<std::string>> sets_def_at, sets_any_undef_at, sets_all_undef_at;$/;"	m	struct:SatHelper	typeref:typename:std::map<int,std::vector<std::string>>	file:
sets_at	yosys/passes/sat/sat.cc	/^	std::map<int, std::vector<std::pair<std::string, std::string>>> sets_at;$/;"	m	struct:SatHelper	typeref:typename:std::map<int,std::vector<std::pair<std::string,std::string>>>	file:
sets_def	yosys/passes/sat/sat.cc	/^	std::vector<std::string> sets_def, sets_any_undef, sets_all_undef;$/;"	m	struct:SatHelper	typeref:typename:std::vector<std::string>	file:
sets_def_at	yosys/passes/sat/sat.cc	/^	std::map<int, std::vector<std::string>> sets_def_at, sets_any_undef_at, sets_all_undef_at;$/;"	m	struct:SatHelper	typeref:typename:std::map<int,std::vector<std::string>>	file:
sets_init	yosys/passes/sat/sat.cc	/^	std::vector<std::pair<std::string, std::string>> sets, prove, prove_x, sets_init;$/;"	m	struct:SatHelper	typeref:typename:std::vector<std::pair<std::string,std::string>>	file:
setunset_t	yosys/passes/cmds/setattr.cc	/^	setunset_t(std::string set_name, std::string set_value) : name(RTLIL::escape_id(set_name)), val/;"	f	struct:setunset_t	file:
setunset_t	yosys/passes/cmds/setattr.cc	/^	setunset_t(std::string unset_name) : name(RTLIL::escape_id(unset_name)), value(), unset(true) {/;"	f	struct:setunset_t	file:
setunset_t	yosys/passes/cmds/setattr.cc	/^struct setunset_t$/;"	s	file:
setup	yosys/kernel/celltypes.h	/^	void setup(RTLIL::Design *design = NULL)$/;"	f	struct:CellTypes	typeref:typename:void
setup	yosys/kernel/modtools.h	/^	void setup(RTLIL::Module *module, CellTypes *filter_ct = NULL)$/;"	f	struct:ModWalker	typeref:typename:void
setup	yosys/kernel/timinginfo.h	/^	void setup(RTLIL::Design *design)$/;"	f	struct:TimingInfo	typeref:typename:void
setup	yosys/passes/sat/sat.cc	/^	void setup(int timestep = -1, bool initstate = false)$/;"	f	struct:SatHelper	typeref:typename:void	file:
setup_design	yosys/kernel/celltypes.h	/^	void setup_design(RTLIL::Design *design)$/;"	f	struct:CellTypes	typeref:typename:void
setup_internals	yosys/kernel/celltypes.h	/^	void setup_internals()$/;"	f	struct:CellTypes	typeref:typename:void
setup_internals_eval	yosys/kernel/celltypes.h	/^	void setup_internals_eval()$/;"	f	struct:CellTypes	typeref:typename:void
setup_internals_ff	yosys/kernel/celltypes.h	/^	void setup_internals_ff()$/;"	f	struct:CellTypes	typeref:typename:void
setup_internals_mem	yosys/kernel/celltypes.h	/^	void setup_internals_mem()$/;"	f	struct:CellTypes	typeref:typename:void
setup_module	yosys/kernel/celltypes.h	/^	void setup_module(RTLIL::Module *module)$/;"	f	struct:CellTypes	typeref:typename:void
setup_module	yosys/kernel/timinginfo.h	/^	const ModuleTiming& setup_module(RTLIL::Module *module)$/;"	f	struct:TimingInfo	typeref:typename:const ModuleTiming &
setup_proof	yosys/passes/sat/sat.cc	/^	int setup_proof(int timestep = -1)$/;"	f	struct:SatHelper	typeref:typename:int	file:
setup_stdcells	yosys/kernel/celltypes.h	/^	void setup_stdcells()$/;"	f	struct:CellTypes	typeref:typename:void
setup_stdcells_eval	yosys/kernel/celltypes.h	/^	void setup_stdcells_eval()$/;"	f	struct:CellTypes	typeref:typename:void
setup_stdcells_mem	yosys/kernel/celltypes.h	/^	void setup_stdcells_mem()$/;"	f	struct:CellTypes	typeref:typename:void
setup_type	yosys/kernel/celltypes.h	/^	void setup_type(RTLIL::IdString type, const pool<RTLIL::IdString> &inputs, const pool<RTLIL::Id/;"	f	struct:CellTypes	typeref:typename:void
sext	yosys/backends/cxxrtl/cxxrtl.h	/^	value<NewBits> sext() const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE value<NewBits>
sext_cast	yosys/backends/cxxrtl/cxxrtl.h	/^	struct sext_cast {$/;"	s	struct:cxxrtl::value
sext_cast	yosys/backends/cxxrtl/cxxrtl.h	/^	struct sext_cast<NewBits, typename std::enable_if<(NewBits < Bits)>::type> {$/;"	s	struct:cxxrtl::value
sha1	yosys/libs/sha1/sha1.cpp	/^std::string sha1(const std::string &string)$/;"	f	typeref:typename:std::string
sha1_if_contain_spaces	yosys/frontends/verific/verific.cc	/^static std::string sha1_if_contain_spaces(std::string str)$/;"	f	typeref:typename:std::string	file:
shape	yosys/libs/json11/json11.hpp	/^    typedef std::initializer_list<std::pair<std::string, Type>> shape;$/;"	t	class:json11::Json	typeref:typename:std::initializer_list<std::pair<std::string,Type>>
share_macc	yosys/passes/opt/share.cc	/^	int share_macc(RTLIL::Cell *c1, RTLIL::Cell *c2,$/;"	f	struct:ShareWorker	typeref:typename:int	file:
share_macc_ports	yosys/passes/opt/share.cc	/^	int share_macc_ports(Macc::port_t &p1, Macc::port_t &p2, int w1, int w2,$/;"	f	struct:ShareWorker	typeref:typename:int	file:
shareable_cells	yosys/passes/opt/share.cc	/^	pool<RTLIL::Cell*> shareable_cells;$/;"	m	struct:ShareWorker	typeref:typename:pool<RTLIL::Cell * >	file:
shared	yosys/libs/subcircuit/subcircuit.h	/^			bool shared;$/;"	m	struct:SubCircuit::Graph::Node	typeref:typename:bool
shared	yosys/passes/sat/sim.cc	/^	SimShared *shared;$/;"	m	struct:SimInstance	typeref:typename:SimShared *	file:
shared_operand	yosys/passes/opt/opt_share.cc	/^	ExtSigSpec shared_operand;$/;"	m	struct:__anonade320d40208	typeref:typename:ExtSigSpec	file:
shared_str	yosys/kernel/yosys.h	/^	shared_str() { }$/;"	f	struct:shared_str
shared_str	yosys/kernel/yosys.h	/^	shared_str(const char *s) { content = std::shared_ptr<string>(new string(s)); }$/;"	f	struct:shared_str
shared_str	yosys/kernel/yosys.h	/^	shared_str(string s) { content = std::shared_ptr<string>(new string(s)); }$/;"	f	struct:shared_str
shared_str	yosys/kernel/yosys.h	/^struct shared_str {$/;"	s
shell	yosys/kernel/yosys.cc	/^void shell(RTLIL::Design *design)$/;"	f	typeref:typename:void
shift_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shift_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shift_su	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shift_su(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shift_us	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shift_us(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shift_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shift_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shiftx_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shiftx_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shiftx_su	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shiftx_su(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shiftx_us	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shiftx_us(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shiftx_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shiftx_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shl	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> shl(const value<AmountBits> &amount) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
shl_su	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shl_su(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shl_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shl_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
short_cones	yosys/passes/equiv/equiv_simple.cc	/^	bool short_cones;$/;"	m	struct:EquivSimpleWorker	typeref:typename:bool	file:
short_help	yosys/kernel/register.h	/^	std::string pass_name, short_help;$/;"	m	struct:Pass	typeref:typename:std::string
show_drivers	yosys/passes/sat/sat.cc	/^	SigSet<RTLIL::Cell*> show_drivers;$/;"	m	struct:SatHelper	typeref:typename:SigSet<RTLIL::Cell * >	file:
show_signal_pool	yosys/passes/sat/sat.cc	/^	SigPool show_signal_pool;$/;"	m	struct:SatHelper	typeref:typename:SigPool	file:
show_smtbmc	yosys/passes/sat/qbfsat.h	/^	bool nobisection = false, sat = false, unsat = false, show_smtbmc = false;$/;"	m	struct:QbfSolveOptions	typeref:typename:bool
show_stats_by_arity	yosys/passes/opt/opt_lut.cc	/^	void show_stats_by_arity()$/;"	f	struct:OptLutWorker	typeref:typename:void	file:
show_tempdir	yosys/passes/techmap/abc.cc	/^	bool show_tempdir;$/;"	m	struct:abc_output_filter	typeref:typename:bool	file:
show_tempdir	yosys/passes/techmap/abc9_exe.cc	/^	bool show_tempdir;$/;"	m	struct:abc9_output_filter	typeref:typename:bool	file:
shows	yosys/passes/sat/sat.cc	/^	std::vector<std::string> shows;$/;"	m	struct:SatHelper	typeref:typename:std::vector<std::string>	file:
shr	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> shr(const value<AmountBits> &amount) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
shr_su	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shr_su(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shr_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> shr_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
shreg_count	yosys/passes/techmap/shregmap.cc	/^	int dff_count, shreg_count;$/;"	m	struct:ShregmapWorker	typeref:typename:int	file:
shrink	yosys/libs/minisat/SolverTypes.h	/^    void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[h/;"	f	class:Minisat::Clause	typeref:typename:void
shrink	yosys/libs/minisat/Vec.h	/^    void     shrink   (Size nelems)  { assert(nelems <= sz); for (Size i = 0; i < nelems; i++) s/;"	f	class:Minisat::vec	typeref:typename:void
shrink_	yosys/libs/minisat/Vec.h	/^    void     shrink_  (Size nelems)  { assert(nelems <= sz); sz -= nelems; }$/;"	f	class:Minisat::vec	typeref:typename:void
shuffle_enable	yosys/passes/memory/memory_bram.cc	/^		char shuffle_enable;$/;"	m	struct:rules_t::match_t	typeref:typename:char	file:
sig	yosys/frontends/liberty/liberty.cc	/^	RTLIL::SigSpec sig;$/;"	m	struct:token_t	typeref:typename:RTLIL::SigSpec	file:
sig	yosys/passes/opt/opt_share.cc	/^	RTLIL::SigSpec sig;$/;"	m	struct:ExtSigSpec	typeref:typename:RTLIL::SigSpec	file:
sig	yosys/passes/opt/opt_share.cc	/^	RTLIL::SigSpec sig;$/;"	m	struct:OpMuxConn	typeref:typename:RTLIL::SigSpec	file:
sig2bits	yosys/kernel/bitpattern.h	/^	bits_t sig2bits(RTLIL::SigSpec sig)$/;"	f	struct:BitPatternPool	typeref:typename:bits_t
sig2bits	yosys/passes/opt/opt_muxtree.cc	/^	vector<int> sig2bits(RTLIL::SigSpec sig, bool skip_non_wires = true)$/;"	f	struct:OptMuxtreeWorker	typeref:typename:vector<int>	file:
sig2const	yosys/passes/fsm/fsm_extract.cc	/^static RTLIL::Const sig2const(ConstEval &ce, RTLIL::SigSpec sig, RTLIL::State noconst_state, RTL/;"	f	typeref:typename:RTLIL::Const	file:
sig2deps	yosys/frontends/aiger/aigerparse.cc	/^	dict<SigBit, pool<RTLIL::SigBit>> sig2deps;$/;"	m	struct:ConstEvalAig	typeref:typename:dict<SigBit,pool<RTLIL::SigBit>>	file:
sig2driver	yosys/frontends/aiger/aigerparse.cc	/^	dict<RTLIL::SigBit, RTLIL::Cell*> sig2driver;$/;"	m	struct:ConstEvalAig	typeref:typename:dict<RTLIL::SigBit,RTLIL::Cell * >	file:
sig2driver	yosys/kernel/consteval.h	/^	SigSet<RTLIL::Cell*> sig2driver;$/;"	m	struct:ConstEval	typeref:typename:SigSet<RTLIL::Cell * >
sig2driver	yosys/passes/fsm/fsm_detect.cc	/^static SigSet<sig2driver_entry_t> sig2driver, sig2user;$/;"	v	typeref:typename:SigSet<sig2driver_entry_t>	file:
sig2driver	yosys/passes/fsm/fsm_expand.cc	/^	SigSet<RTLIL::Cell*, RTLIL::sort_by_name_id<RTLIL::Cell>> sig2driver, sig2user;$/;"	m	struct:FsmExpand	typeref:typename:SigSet<RTLIL::Cell *,RTLIL::sort_by_name_id<RTLIL::Cell>>	file:
sig2driver	yosys/passes/fsm/fsm_extract.cc	/^static SigSet<sig2driver_entry_t> sig2driver, sig2trigger;$/;"	v	typeref:typename:SigSet<sig2driver_entry_t>	file:
sig2driver_entry_t	yosys/passes/fsm/fsm_detect.cc	/^typedef std::pair<RTLIL::Cell*, RTLIL::IdString> sig2driver_entry_t;$/;"	t	typeref:typename:std::pair<RTLIL::Cell *,RTLIL::IdString>	file:
sig2driver_entry_t	yosys/passes/fsm/fsm_extract.cc	/^typedef std::pair<RTLIL::IdString, RTLIL::IdString> sig2driver_entry_t;$/;"	t	typeref:typename:std::pair<RTLIL::IdString,RTLIL::IdString>	file:
sig2trigger	yosys/passes/fsm/fsm_extract.cc	/^static SigSet<sig2driver_entry_t> sig2driver, sig2trigger;$/;"	v	typeref:typename:SigSet<sig2driver_entry_t>	file:
sig2user	yosys/passes/fsm/fsm_detect.cc	/^static SigSet<sig2driver_entry_t> sig2driver, sig2user;$/;"	v	typeref:typename:SigSet<sig2driver_entry_t>	file:
sig2user	yosys/passes/fsm/fsm_expand.cc	/^	SigSet<RTLIL::Cell*, RTLIL::sort_by_name_id<RTLIL::Cell>> sig2driver, sig2user;$/;"	m	struct:FsmExpand	typeref:typename:SigSet<RTLIL::Cell *,RTLIL::sort_by_name_id<RTLIL::Cell>>	file:
sigTerm	yosys/libs/minisat/System.cc	/^void Minisat::sigTerm(void handler(int))$/;"	f	class:Minisat	typeref:typename:void
sig_ad	yosys/kernel/ff.h	/^	SigSpec sig_ad;$/;"	m	struct:FfData	typeref:typename:SigSpec
sig_aload	yosys/kernel/ff.h	/^	SigSpec sig_aload;$/;"	m	struct:FfData	typeref:typename:SigSpec
sig_alu	yosys/passes/techmap/alumacc.cc	/^	dict<RTLIL::SigSig, pool<alunode_t*, hash_ptr_ops>> sig_alu;$/;"	m	struct:AlumaccWorker	typeref:typename:dict<RTLIL::SigSig,pool<alunode_t *,hash_ptr_ops>>	file:
sig_arst	yosys/kernel/ff.h	/^	SigSpec sig_arst;$/;"	m	struct:FfData	typeref:typename:SigSpec
sig_arst	yosys/passes/sat/expose.cc	/^	RTLIL::SigSpec sig_d, sig_clk, sig_arst;$/;"	m	struct:dff_map_info_t	typeref:typename:RTLIL::SigSpec	file:
sig_at_port	yosys/passes/fsm/fsm_detect.cc	/^static SigPool sig_at_port;$/;"	v	typeref:typename:SigPool	file:
sig_ce	yosys/kernel/ff.h	/^	SigSpec sig_ce;$/;"	m	struct:FfData	typeref:typename:SigSpec
sig_chain_next	yosys/passes/opt/muxpack.cc	/^	dict<SigSpec, Cell*> sig_chain_next;$/;"	m	struct:MuxpackWorker	typeref:typename:dict<SigSpec,Cell * >	file:
sig_chain_prev	yosys/passes/opt/muxpack.cc	/^	dict<SigSpec, Cell*> sig_chain_prev;$/;"	m	struct:MuxpackWorker	typeref:typename:dict<SigSpec,Cell * >	file:
sig_clk	yosys/kernel/ff.h	/^	SigSpec sig_clk;$/;"	m	struct:FfData	typeref:typename:SigSpec
sig_clk	yosys/passes/sat/expose.cc	/^	RTLIL::SigSpec sig_d, sig_clk, sig_arst;$/;"	m	struct:dff_map_info_t	typeref:typename:RTLIL::SigSpec	file:
sig_clr	yosys/kernel/ff.h	/^	SigSpec sig_clr;$/;"	m	struct:FfData	typeref:typename:SigSpec
sig_cmp_prev	yosys/passes/opt/muxpack.cc	/^	dict<SigBit, std::pair<SigSpec,std::vector<Const>>> sig_cmp_prev;$/;"	m	struct:ExclusiveDatabase	typeref:typename:dict<SigBit,std::pair<SigSpec,std::vector<Const>>>	file:
sig_d	yosys/kernel/ff.h	/^	SigSpec sig_d;$/;"	m	struct:FfData	typeref:typename:SigSpec
sig_d	yosys/passes/sat/expose.cc	/^	RTLIL::SigSpec sig_d, sig_clk, sig_arst;$/;"	m	struct:dff_map_info_t	typeref:typename:RTLIL::SigSpec	file:
sig_macc	yosys/passes/techmap/alumacc.cc	/^	dict<RTLIL::SigSpec, maccnode_t*> sig_macc;$/;"	m	struct:AlumaccWorker	typeref:typename:dict<RTLIL::SigSpec,maccnode_t * >	file:
sig_nid	yosys/backends/btor/btor.cc	/^	dict<SigSpec, int> sig_nid;$/;"	m	struct:BtorWorker	typeref:typename:dict<SigSpec,int>	file:
sig_onehot_cache	yosys/passes/opt/pmux2shiftx.cc	/^	dict<SigSpec, bool> sig_onehot_cache;$/;"	m	struct:OnehotDatabase	typeref:typename:dict<SigSpec,bool>	file:
sig_other	yosys/passes/memory/memory_dff.cc	/^	std::vector<SigSpec> sig_other;$/;"	m	struct:MuxData	typeref:typename:std::vector<SigSpec>	file:
sig_p	yosys/kernel/rtlil.h	/^	RTLIL::SigSpec *sig_p;$/;"	m	struct:RTLIL::SigSpecIterator	typeref:typename:RTLIL::SigSpec *
sig_p	yosys/kernel/rtlil.h	/^	const RTLIL::SigSpec *sig_p;$/;"	m	struct:RTLIL::SigSpecConstIterator	typeref:typename:const RTLIL::SigSpec *
sig_q	yosys/kernel/ff.h	/^	SigSpec sig_q;$/;"	m	struct:FfData	typeref:typename:SigSpec
sig_s	yosys/passes/memory/memory_dff.cc	/^	SigSpec sig_s;$/;"	m	struct:MuxData	typeref:typename:SigSpec	file:
sig_set	yosys/kernel/ff.h	/^	SigSpec sig_set;$/;"	m	struct:FfData	typeref:typename:SigSpec
sig_sources_db	yosys/passes/opt/pmux2shiftx.cc	/^	dict<SigSpec, pool<SigSpec>> sig_sources_db;$/;"	m	struct:OnehotDatabase	typeref:typename:dict<SigSpec,pool<SigSpec>>	file:
sig_srst	yosys/kernel/ff.h	/^	SigSpec sig_srst;$/;"	m	struct:FfData	typeref:typename:SigSpec
sig_subst	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	RTLIL::SigSpec sig_subst = {}; \/\/ for INLINE, ALIAS, and CONST$/;"	m	struct:WireType	typeref:typename:RTLIL::SigSpec	file:
sig_to_mux	yosys/passes/opt/opt_mem_feedback.cc	/^	dict<RTLIL::SigBit, std::pair<RTLIL::Cell*, int>> sig_to_mux;$/;"	m	struct:OptMemFeedbackWorker	typeref:typename:dict<RTLIL::SigBit,std::pair<RTLIL::Cell *,int>>	file:
sig_users_count	yosys/passes/opt/opt_mem_feedback.cc	/^	dict<RTLIL::SigBit, int> sig_users_count;$/;"	m	struct:OptMemFeedbackWorker	typeref:typename:dict<RTLIL::SigBit,int>	file:
sigbit_actsignals	yosys/passes/sat/assertpmux.cc	/^	dict<SigBit, SigBit> sigbit_actsignals;$/;"	m	struct:AssertpmuxWorker	typeref:typename:dict<SigBit,SigBit>	file:
sigbit_chain_next	yosys/passes/techmap/shregmap.cc	/^	dict<SigBit, Cell*> sigbit_chain_next;$/;"	m	struct:ShregmapWorker	typeref:typename:dict<SigBit,Cell * >	file:
sigbit_chain_prev	yosys/passes/techmap/shregmap.cc	/^	dict<SigBit, Cell*> sigbit_chain_prev;$/;"	m	struct:ShregmapWorker	typeref:typename:dict<SigBit,Cell * >	file:
sigbit_muxusers	yosys/passes/sat/assertpmux.cc	/^	dict<SigBit, pool<tuple<Cell*, int, int>>> sigbit_muxusers;$/;"	m	struct:AssertpmuxWorker	typeref:typename:dict<SigBit,pool<tuple<Cell *,int,int>>>	file:
sigbit_users_count	yosys/kernel/ffmerge.h	/^	dict<SigBit, int> sigbit_users_count;$/;"	m	struct:FfMergeHelper	typeref:typename:dict<SigBit,int>
sigbit_with_non_chain_users	yosys/passes/opt/muxpack.cc	/^	pool<SigBit> sigbit_with_non_chain_users;$/;"	m	struct:MuxpackWorker	typeref:typename:pool<SigBit>	file:
sigbit_with_non_chain_users	yosys/passes/techmap/shregmap.cc	/^	pool<SigBit> sigbit_with_non_chain_users;$/;"	m	struct:ShregmapWorker	typeref:typename:pool<SigBit>	file:
sigidcounter	yosys/backends/json/json.cc	/^	int sigidcounter;$/;"	m	struct:JsonWriter	typeref:typename:int	file:
sigidcounter_	yosys/backends/protobuf/protobuf.cc	/^	int sigidcounter_;$/;"	m	struct:ProtobufDesignSerializer	typeref:typename:int	file:
sigids	yosys/backends/json/json.cc	/^	dict<SigBit, string> sigids;$/;"	m	struct:JsonWriter	typeref:typename:dict<SigBit,string>	file:
sigids_	yosys/backends/protobuf/protobuf.cc	/^	dict<SigBit, uint64_t> sigids_;$/;"	m	struct:ProtobufDesignSerializer	typeref:typename:dict<SigBit,uint64_t>	file:
sigidx	yosys/passes/proc/proc_mux.cc	/^	idict<SigSpec> sigidx;$/;"	m	struct:SigSnippets	typeref:typename:idict<SigSpec>	file:
siglist	yosys/passes/cmds/setundef.cc	/^	vector<SigSpec*> siglist;$/;"	m	struct:SetundefWorker	typeref:typename:vector<SigSpec * >	file:
sigmap	yosys/backends/aiger/aiger.cc	/^	SigMap sigmap;$/;"	m	struct:AigerWriter	typeref:typename:SigMap	file:
sigmap	yosys/backends/aiger/xaiger.cc	/^	SigMap sigmap;$/;"	m	struct:XAigerWriter	typeref:typename:SigMap	file:
sigmap	yosys/backends/blif/blif.cc	/^	SigMap sigmap;$/;"	m	struct:BlifDumper	typeref:typename:SigMap	file:
sigmap	yosys/backends/btor/btor.cc	/^	SigMap sigmap;$/;"	m	struct:BtorWorker	typeref:typename:SigMap	file:
sigmap	yosys/backends/json/json.cc	/^	SigMap sigmap;$/;"	m	struct:JsonWriter	typeref:typename:SigMap	file:
sigmap	yosys/backends/smt2/smt2.cc	/^	SigMap sigmap;$/;"	m	struct:Smt2Worker	typeref:typename:SigMap	file:
sigmap	yosys/backends/smv/smv.cc	/^	SigMap sigmap;$/;"	m	struct:SmvWorker	typeref:typename:SigMap	file:
sigmap	yosys/kernel/celledges.h	/^	SigMap &sigmap;$/;"	m	struct:FwdCellEdgesDatabase	typeref:typename:SigMap &
sigmap	yosys/kernel/celledges.h	/^	SigMap &sigmap;$/;"	m	struct:RevCellEdgesDatabase	typeref:typename:SigMap &
sigmap	yosys/kernel/ffinit.h	/^	const SigMap *sigmap;$/;"	m	struct:FfInitVals	typeref:typename:const SigMap *
sigmap	yosys/kernel/ffmerge.h	/^	const SigMap *sigmap;$/;"	m	struct:FfMergeHelper	typeref:typename:const SigMap *
sigmap	yosys/kernel/modtools.h	/^	SigMap sigmap;$/;"	m	struct:ModIndex	typeref:typename:SigMap
sigmap	yosys/kernel/modtools.h	/^	SigMap sigmap;$/;"	m	struct:ModWalker	typeref:typename:SigMap
sigmap	yosys/kernel/satgen.h	/^	SigMap *sigmap;$/;"	m	struct:SatGen	typeref:typename:SigMap *
sigmap	yosys/passes/cmds/ltp.cc	/^	SigMap sigmap;$/;"	m	struct:LtpWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/cmds/scc.cc	/^	SigMap sigmap;$/;"	m	struct:SccWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/cmds/splice.cc	/^	SigMap sigmap;$/;"	m	struct:SpliceWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/cmds/sta.cc	/^	SigMap sigmap;$/;"	m	struct:StaWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/equiv/equiv_induct.cc	/^	SigMap sigmap;$/;"	m	struct:EquivInductWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/equiv/equiv_mark.cc	/^	SigMap sigmap;$/;"	m	struct:EquivMarkWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/equiv/equiv_miter.cc	/^	SigMap sigmap;$/;"	m	struct:EquivMiterWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/equiv/equiv_purge.cc	/^	SigMap sigmap;$/;"	m	struct:EquivPurgeWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/equiv/equiv_simple.cc	/^	SigMap &sigmap;$/;"	m	struct:EquivSimpleWorker	typeref:typename:SigMap &	file:
sigmap	yosys/passes/equiv/equiv_struct.cc	/^	SigMap sigmap;$/;"	m	struct:EquivStructWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/hierarchy/submod.cc	/^	SigMap sigmap;$/;"	m	struct:SubmodWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/memory/memory_map.cc	/^	SigMap sigmap;$/;"	m	struct:MemoryMapWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/memory/memory_share.cc	/^	SigMap sigmap, sigmap_xmux;$/;"	m	struct:MemoryShareWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/opt/muxpack.cc	/^	SigMap sigmap;$/;"	m	struct:MuxpackWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/opt/muxpack.cc	/^	const SigMap &sigmap;$/;"	m	struct:ExclusiveDatabase	typeref:typename:const SigMap &	file:
sigmap	yosys/passes/opt/opt_dff.cc	/^	SigMap sigmap;$/;"	m	struct:OptDffWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/opt/opt_lut.cc	/^	SigMap sigmap;$/;"	m	struct:OptLutWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/opt/opt_mem_feedback.cc	/^	SigMap sigmap, sigmap_xmux;$/;"	m	struct:OptMemFeedbackWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/opt/pmux2shiftx.cc	/^	const SigMap &sigmap;$/;"	m	struct:OnehotDatabase	typeref:typename:const SigMap &	file:
sigmap	yosys/passes/proc/proc_dlatch.cc	/^	SigMap sigmap;$/;"	m	struct:proc_dlatch_db_t	typeref:typename:SigMap	file:
sigmap	yosys/passes/proc/proc_prune.cc	/^	SigMap sigmap;$/;"	m	struct:PruneWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/sat/assertpmux.cc	/^	SigMap sigmap;$/;"	m	struct:AssertpmuxWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/sat/freduce.cc	/^	SigMap &sigmap;$/;"	m	struct:CountBitUsage	typeref:typename:SigMap &	file:
sigmap	yosys/passes/sat/freduce.cc	/^	SigMap &sigmap;$/;"	m	struct:FindReducedInputs	typeref:typename:SigMap &	file:
sigmap	yosys/passes/sat/freduce.cc	/^	SigMap &sigmap;$/;"	m	struct:PerformReduction	typeref:typename:SigMap &	file:
sigmap	yosys/passes/sat/freduce.cc	/^	SigMap sigmap;$/;"	m	struct:FreduceWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/sat/sat.cc	/^	SigMap sigmap;$/;"	m	struct:SatHelper	typeref:typename:SigMap	file:
sigmap	yosys/passes/sat/sim.cc	/^	SigMap sigmap;$/;"	m	struct:SimInstance	typeref:typename:SigMap	file:
sigmap	yosys/passes/techmap/alumacc.cc	/^	SigMap sigmap;$/;"	m	struct:AlumaccWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/techmap/dfflegalize.cc	/^	SigMap sigmap;$/;"	m	struct:DffLegalizePass	typeref:typename:SigMap	file:
sigmap	yosys/passes/techmap/extract_fa.cc	/^	SigMap &sigmap;$/;"	m	struct:ExtractFaWorker	typeref:typename:SigMap &	file:
sigmap	yosys/passes/techmap/flowmap.cc	/^	SigMap sigmap;$/;"	m	struct:FlowmapWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/techmap/muxcover.cc	/^	SigMap sigmap;$/;"	m	struct:MuxcoverWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/techmap/shregmap.cc	/^	SigMap sigmap;$/;"	m	struct:ShregmapWorker	typeref:typename:SigMap	file:
sigmap	yosys/passes/techmap/tribuf.cc	/^	SigMap sigmap;$/;"	m	struct:TribufWorker	typeref:typename:SigMap	file:
sigmap_	yosys/backends/protobuf/protobuf.cc	/^	SigMap sigmap_;$/;"	m	struct:ProtobufDesignSerializer	typeref:typename:SigMap	file:
sigmap_xmux	yosys/passes/memory/memory_share.cc	/^	SigMap sigmap, sigmap_xmux;$/;"	m	struct:MemoryShareWorker	typeref:typename:SigMap	file:
sigmap_xmux	yosys/passes/opt/opt_mem_feedback.cc	/^	SigMap sigmap, sigmap_xmux;$/;"	m	struct:OptMemFeedbackWorker	typeref:typename:SigMap	file:
sigmaps	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Module*, SigMap> sigmaps;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<const RTLIL::Module *,SigMap>	file:
sigmaps	yosys/backends/simplec/simplec.cc	/^	dict<Module*, SigMap> sigmaps;$/;"	m	struct:SimplecWorker	typeref:typename:dict<Module *,SigMap>	file:
sigmaps	yosys/passes/techmap/techmap.cc	/^	dict<Module*, SigMap> sigmaps;$/;"	m	struct:TechmapWorker	typeref:typename:dict<Module *,SigMap>	file:
sign	yosys/libs/bigint/BigInteger.hh	/^	Sign sign;$/;"	m	class:BigInteger	typeref:typename:Sign
sign	yosys/libs/minisat/SolverTypes.h	/^inline  bool sign      (Lit p)              { return p.x & 1; }$/;"	f	namespace:Minisat	typeref:typename:bool
sign	yosys/passes/opt/opt_share.cc	/^	RTLIL::SigSpec sign;$/;"	m	struct:ExtSigSpec	typeref:typename:RTLIL::SigSpec	file:
signOf	yosys/libs/bigint/BigInteger.cc	/^	BigInteger::Sign signOf(X x) {$/;"	f	namespace:__anon944949140111	typeref:typename:BigInteger::Sign
signal	yosys/kernel/rtlil.h	/^	RTLIL::SigSpec signal;$/;"	m	struct:RTLIL::SwitchRule	typeref:typename:RTLIL::SigSpec
signal	yosys/kernel/rtlil.h	/^	RTLIL::SigSpec signal;$/;"	m	struct:RTLIL::SyncRule	typeref:typename:RTLIL::SigSpec
signal	yosys/passes/proc/proc_dlatch.cc	/^		SigBit signal, match;$/;"	m	struct:proc_dlatch_db_t::rule_node_t	typeref:typename:SigBit	file:
signal_consumers	yosys/kernel/modtools.h	/^	dict<RTLIL::SigBit, pool<PortBit>> signal_consumers;$/;"	m	struct:ModWalker	typeref:typename:dict<RTLIL::SigBit,pool<PortBit>>
signal_database	yosys/passes/sat/sim.cc	/^	dict<Wire*, pair<int, Const>> signal_database;$/;"	m	struct:SimInstance	typeref:typename:dict<Wire *,pair<int,Const>>	file:
signal_declarations	yosys/backends/simplec/simplec.cc	/^	vector<string> signal_declarations;$/;"	m	struct:SimplecWorker	typeref:typename:vector<string>	file:
signal_drivers	yosys/kernel/modtools.h	/^	dict<RTLIL::SigBit, pool<PortBit>> signal_drivers;$/;"	m	struct:ModWalker	typeref:typename:dict<RTLIL::SigBit,pool<PortBit>>
signal_inputs	yosys/kernel/modtools.h	/^	pool<RTLIL::SigBit> signal_inputs, signal_outputs;$/;"	m	struct:ModWalker	typeref:typename:pool<RTLIL::SigBit>
signal_is_unused	yosys/passes/fsm/fsm_opt.cc	/^	bool signal_is_unused(RTLIL::SigSpec sig)$/;"	f	struct:FsmOpt	typeref:typename:bool	file:
signal_lens	yosys/libs/fst/fstapi.cc	/^    uint32_t *signal_lens;                \/* maxhandle sized *\/$/;"	m	struct:fstReaderContext	typeref:typename:uint32_t *	file:
signal_list	yosys/passes/sat/sim.cc	/^	std::string signal_list(std::map<Wire*,fstHandle> &signals)$/;"	f	struct:SimWorker	typeref:typename:std::string	file:
signal_list	yosys/passes/techmap/abc.cc	/^std::vector<gate_t> signal_list;$/;"	v	typeref:typename:std::vector<gate_t>
signal_map	yosys/passes/techmap/abc.cc	/^std::map<RTLIL::SigBit, int> signal_map;$/;"	v	typeref:typename:std::map<RTLIL::SigBit,int>
signal_name	yosys/passes/sat/sim.cc	/^	std::string signal_name(std::string const & name)$/;"	f	struct:SimWorker	typeref:typename:std::string	file:
signal_outputs	yosys/kernel/modtools.h	/^	pool<RTLIL::SigBit> signal_inputs, signal_outputs;$/;"	m	struct:ModWalker	typeref:typename:pool<RTLIL::SigBit>
signal_to_mux_tree	yosys/passes/proc/proc_mux.cc	/^RTLIL::SigSpec signal_to_mux_tree(RTLIL::Module *mod, SnippetSwCache &swcache, dict<RTLIL::Switc/;"	f	typeref:typename:RTLIL::SigSpec
signal_typs	yosys/libs/fst/fstapi.cc	/^    unsigned char *signal_typs;           \/* maxhandle sized *\/$/;"	m	struct:fstReaderContext	typeref:typename:unsigned char *	file:
signals_eq	yosys/kernel/satgen.h	/^	int signals_eq(RTLIL::SigSpec lhs, RTLIL::SigSpec rhs, int timestep_lhs = -1, int timestep_rhs /;"	f	struct:SatGen	typeref:typename:int
signparam	yosys/passes/cmds/connwrappers.cc	/^		std::string widthparam, signparam;$/;"	m	struct:ConnwrappersWorker::portdecl_t	typeref:typename:std::string	file:
sigspec_actsignals	yosys/passes/sat/assertpmux.cc	/^	dict<SigSpec, SigBit> sigspec_actsignals;$/;"	m	struct:AssertpmuxWorker	typeref:typename:dict<SigSpec,SigBit>	file:
sigspec_parse_get_dummy_line_num	yosys/kernel/rtlil.cc	/^static int sigspec_parse_get_dummy_line_num()$/;"	f	typeref:typename:int	file:
sigspec_parse_split	yosys/kernel/rtlil.cc	/^static void sigspec_parse_split(std::vector<std::string> &tokens, const std::string &text, char /;"	f	typeref:typename:void	file:
sigtype	yosys/backends/simplec/simplec.cc	/^	string sigtype(int n)$/;"	f	struct:SimplecWorker	typeref:typename:string	file:
sigusers	yosys/passes/proc/proc_dlatch.cc	/^	dict<SigBit, int> sigusers;$/;"	m	struct:proc_dlatch_db_t	typeref:typename:dict<SigBit,int>	file:
sim	yosys/passes/sat/sim.cc	/^	sim,$/;"	e	enum:SimulationMode	file:
sim_filename	yosys/passes/sat/sim.cc	/^	std::string sim_filename;$/;"	m	struct:SimWorker	typeref:typename:std::string	file:
sim_mode	yosys/passes/sat/sim.cc	/^	SimulationMode sim_mode = SimulationMode::sim;$/;"	m	struct:SimShared	typeref:typename:SimulationMode	file:
siminit	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
simpDB_assigns	yosys/libs/minisat/Solver.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execut/;"	m	class:Minisat::Solver	typeref:typename:int
simpDB_props	yosys/libs/minisat/Solver.h	/^    int64_t             simpDB_props;     \/\/ Remaining number of propagations that must be mad/;"	m	class:Minisat::Solver	typeref:typename:int64_t
simp_garbage_frac	yosys/libs/minisat/SimpSolver.h	/^    double  simp_garbage_frac; \/\/ A different limit for when to issue a GC during simplificati/;"	m	class:Minisat::SimpSolver	typeref:typename:double
simple_dffe	yosys/passes/opt/opt_dff.cc	/^	bool simple_dffe;$/;"	m	struct:OptDffOptions	typeref:typename:bool	file:
simple_lhs	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
simplemap	yosys/passes/techmap/simplemap.cc	/^void simplemap(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_bitop	yosys/passes/techmap/simplemap.cc	/^void simplemap_bitop(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_bmux	yosys/passes/techmap/simplemap.cc	/^void simplemap_bmux(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_concat	yosys/passes/techmap/simplemap.cc	/^void simplemap_concat(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_eqne	yosys/passes/techmap/simplemap.cc	/^void simplemap_eqne(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_ff	yosys/passes/techmap/simplemap.cc	/^void simplemap_ff(RTLIL::Module *, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_get_mappers	yosys/passes/techmap/simplemap.cc	/^void simplemap_get_mappers(dict<IdString, void(*)(RTLIL::Module*, RTLIL::Cell*)> &mappers)$/;"	f	typeref:typename:void
simplemap_logbin	yosys/passes/techmap/simplemap.cc	/^void simplemap_logbin(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_lognot	yosys/passes/techmap/simplemap.cc	/^void simplemap_lognot(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_lut	yosys/passes/techmap/simplemap.cc	/^void simplemap_lut(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_mappers	yosys/passes/techmap/techmap.cc	/^	dict<IdString, void(*)(RTLIL::Module*, RTLIL::Cell*)> simplemap_mappers;$/;"	m	struct:TechmapWorker	typeref:typename:dict<IdString,void (*)(RTLIL::Module *,RTLIL::Cell *)>	file:
simplemap_mux	yosys/passes/techmap/simplemap.cc	/^void simplemap_mux(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_not	yosys/passes/techmap/simplemap.cc	/^void simplemap_not(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE YOSYS_NAMESPACE_BEGIN void
simplemap_pos	yosys/passes/techmap/simplemap.cc	/^void simplemap_pos(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_reduce	yosys/passes/techmap/simplemap.cc	/^void simplemap_reduce(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_slice	yosys/passes/techmap/simplemap.cc	/^void simplemap_slice(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_sop	yosys/passes/techmap/simplemap.cc	/^void simplemap_sop(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplemap_tribuf	yosys/passes/techmap/simplemap.cc	/^void simplemap_tribuf(RTLIL::Module *module, RTLIL::Cell *cell)$/;"	f	typeref:typename:void
simplify	yosys/frontends/ast/simplify.cc	/^bool AstNode::simplify(bool const_fold, bool at_zero, bool in_lvalue, int stage, int width_hint,/;"	f	class:AstNode	typeref:typename:bool
simplify	yosys/libs/minisat/Solver.cc	/^bool Solver::simplify()$/;"	f	class:Solver	typeref:typename:bool
simplify_design_context	yosys/frontends/ast/simplify.cc	/^static const RTLIL::Design *simplify_design_context = nullptr;$/;"	v	typeref:typename:const RTLIL::Design *	file:
simplify_patterns	yosys/passes/opt/opt_dff.cc	/^	void simplify_patterns(patterns_t&)$/;"	f	struct:OptDffWorker	typeref:typename:void	file:
simplify_something	yosys/passes/cmds/bugpoint.cc	/^	RTLIL::Design *simplify_something(RTLIL::Design *design, int &seed, bool stage2, bool modules, /;"	f	struct:BugpointPass	typeref:typename:RTLIL::Design *	file:
single_bad	yosys/backends/btor/btor.cc	/^	bool single_bad;$/;"	m	struct:BtorWorker	typeref:typename:bool	file:
single_idx_count	yosys/passes/cmds/show.cc	/^	int single_idx_count;$/;"	m	struct:ShowWorker	typeref:typename:int	file:
singleton_mode	yosys/passes/techmap/hilomap.cc	/^static bool singleton_mode;$/;"	v	typeref:typename:bool	file:
sink	yosys/passes/cmds/sta.cc	/^		Cell *sink;$/;"	m	struct:StaWorker::t_endpoint	typeref:typename:Cell *	file:
sink	yosys/passes/techmap/flowmap.cc	/^	RTLIL::SigBit sink;$/;"	m	struct:FlowGraph	typeref:typename:RTLIL::SigBit	file:
sinks	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	Vertex *sinks = new Vertex;$/;"	m	struct:Scheduler	typeref:typename:Vertex *	file:
sint_value	yosys/backends/cxxrtl/cxxrtl.h	/^	const signed      sint_value = 0;$/;"	m	struct:cxxrtl::metadata	typeref:typename:const signed
size	yosys/kernel/hashlib.h	/^	size_t size() const { return database.size(); }$/;"	f	class:hashlib::idict	typeref:typename:size_t
size	yosys/kernel/hashlib.h	/^	size_t size() const { return database.size(); }$/;"	f	class:hashlib::mfp	typeref:typename:size_t
size	yosys/kernel/hashlib.h	/^	size_t size() const { return entries.size(); }$/;"	f	class:hashlib::dict	typeref:typename:size_t
size	yosys/kernel/hashlib.h	/^	size_t size() const { return entries.size(); }$/;"	f	class:hashlib::pool	typeref:typename:size_t
size	yosys/kernel/mem.h	/^	int width, start_offset, size;$/;"	m	struct:Mem	typeref:typename:int
size	yosys/kernel/rtlil.h	/^		size_t size() const {$/;"	f	struct:RTLIL::IdString	typeref:typename:size_t
size	yosys/kernel/rtlil.h	/^		size_t size() const {$/;"	f	struct:RTLIL::ObjRange	typeref:typename:size_t
size	yosys/kernel/rtlil.h	/^	inline int size() const { return bits.size(); }$/;"	f	struct:RTLIL::Const	typeref:typename:int
size	yosys/kernel/rtlil.h	/^	inline int size() const { return width; }$/;"	f	struct:RTLIL::SigChunk	typeref:typename:int
size	yosys/kernel/rtlil.h	/^	inline int size() const { return width_; }$/;"	f	struct:RTLIL::SigSpec	typeref:typename:int
size	yosys/kernel/rtlil.h	/^	int width, start_offset, size;$/;"	m	struct:RTLIL::Memory	typeref:typename:int
size	yosys/kernel/sigtools.h	/^	size_t size() const$/;"	f	struct:SigPool	typeref:typename:size_t
size	yosys/libs/minisat/Alloc.h	/^    uint32_t size      () const      { return sz; }$/;"	f	class:Minisat::RegionAllocator	typeref:typename:uint32_t
size	yosys/libs/minisat/Heap.h	/^    int  size      ()          const { return heap.size(); }$/;"	f	class:Minisat::Heap	typeref:typename:int
size	yosys/libs/minisat/IntMap.h	/^        int      size        (void)      const  { return xs.size(); }$/;"	f	class:Minisat::IntSet	typeref:typename:int
size	yosys/libs/minisat/Map.h	/^    int        size;$/;"	m	class:Minisat::Map	typeref:typename:int
size	yosys/libs/minisat/ParseUtils.h	/^    int            size;$/;"	m	class:Minisat::StreamBuffer	typeref:typename:int
size	yosys/libs/minisat/Queue.h	/^    int  size  () const { return (end >= first) ? end - first : end - first + buf.size(); }$/;"	f	class:Minisat::Queue	typeref:typename:int
size	yosys/libs/minisat/SolverTypes.h	/^        unsigned size      : 27; }                        header;$/;"	m	struct:Minisat::Clause::__anonb7535e3e0108	typeref:typename:unsigned:27
size	yosys/libs/minisat/SolverTypes.h	/^    int          size        ()      const   { return header.size; }$/;"	f	class:Minisat::Clause	typeref:typename:int
size	yosys/libs/minisat/SolverTypes.h	/^    int      size        ()                const      { return map.elems(); }$/;"	f	class:Minisat::CMap	typeref:typename:int
size	yosys/libs/minisat/SolverTypes.h	/^    uint32_t size      () const      { return ra.size(); }$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:uint32_t
size	yosys/libs/minisat/Vec.h	/^    Size     size     (void) const   { return sz; }$/;"	f	class:Minisat::vec	typeref:typename:Size
size	yosys/passes/memory/memory_dff.cc	/^	int size;$/;"	m	struct:MuxData	typeref:typename:int	file:
size_limit_locked	yosys/libs/fst/fstapi.cc	/^    unsigned size_limit_locked : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
size_packed_struct	yosys/frontends/ast/simplify.cc	/^static int size_packed_struct(AstNode *snode, int base_offset)$/;"	f	typeref:typename:int	file:
size_x	yosys/libs/ezsat/puzzle3d.cc	/^	int size_x, size_y, size_z;$/;"	m	struct:blockgeom_t	typeref:typename:int	file:
size_y	yosys/libs/ezsat/puzzle3d.cc	/^	int size_x, size_y, size_z;$/;"	m	struct:blockgeom_t	typeref:typename:int	file:
size_z	yosys/libs/ezsat/puzzle3d.cc	/^	int size_x, size_y, size_z;$/;"	m	struct:blockgeom_t	typeref:typename:int	file:
skipLine	yosys/libs/minisat/ParseUtils.h	/^static void skipLine(B& in) {$/;"	f	namespace:Minisat	typeref:typename:void
skipWhitespace	yosys/libs/minisat/ParseUtils.h	/^static void skipWhitespace(B& in) {$/;"	f	namespace:Minisat	typeref:typename:void
skip_spaces	yosys/frontends/verilog/preproc.cc	/^static std::string skip_spaces()$/;"	f	typeref:typename:std::string	file:
skip_writing_section_hdr	yosys/libs/fst/fstapi.cc	/^    unsigned skip_writing_section_hdr : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
slice	yosys/backends/cxxrtl/cxxrtl.h	/^	slice_expr<T, Stop, Start> slice() {$/;"	f	struct:cxxrtl::expr_base	typeref:typename:CXXRTL_ALWAYS_INLINE slice_expr<T,Stop,Start>
slice	yosys/backends/cxxrtl/cxxrtl.h	/^	slice_expr<const T, Stop, Start> slice() const {$/;"	f	struct:cxxrtl::expr_base	typeref:typename:CXXRTL_ALWAYS_INLINE slice_expr<const T,Stop,Start>
slice	yosys/kernel/ff.cc	/^FfData FfData::slice(const std::vector<int> &bits) {$/;"	f	class:FfData	typeref:typename:FfData
slice_expr	yosys/backends/cxxrtl/cxxrtl.h	/^	slice_expr(T &expr) : expr(expr) {}$/;"	f	struct:cxxrtl::slice_expr
slice_expr	yosys/backends/cxxrtl/cxxrtl.h	/^struct slice_expr : public expr_base<slice_expr<T, Stop, Start>> {$/;"	s	namespace:cxxrtl
slice_range	yosys/frontends/ast/simplify.cc	/^static AstNode *slice_range(AstNode *rnode, AstNode *snode)$/;"	f	typeref:typename:AstNode *	file:
sliced_signals_cache	yosys/passes/cmds/splice.cc	/^	std::map<RTLIL::SigSpec, RTLIL::SigSpec> sliced_signals_cache;$/;"	m	struct:SpliceWorker	typeref:typename:std::map<RTLIL::SigSpec,RTLIL::SigSpec>	file:
smudge	yosys/libs/minisat/SolverTypes.h	/^    void  smudge    (const K& idx){$/;"	f	class:Minisat::OccLists	typeref:typename:void
snippets	yosys/passes/proc/proc_mux.cc	/^	const SigSnippets *snippets;$/;"	m	struct:SnippetSwCache	typeref:typename:const SigSnippets *	file:
snippets	yosys/passes/proc/proc_mux.cc	/^	pool<int> snippets;$/;"	m	struct:SigSnippets	typeref:typename:pool<int>	file:
snprintf	yosys/kernel/yosys.h	/^#  define snprintf /;"	d
snprintf	yosys/libs/json11/json11.hpp	/^            #define snprintf /;"	d
solve	yosys/libs/ezsat/ezsat.h	/^	bool solve(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, const std:/;"	f	class:ezSAT	typeref:typename:bool
solve	yosys/libs/ezsat/ezsat.h	/^	bool solve(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues, int a = 0,/;"	f	class:ezSAT	typeref:typename:bool
solve	yosys/libs/ezsat/ezsat.h	/^	bool solve(int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0) {$/;"	f	class:ezSAT	typeref:typename:bool
solve	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::solve        (                     bool do_simp, bool turn_off_simp)  { /;"	f	class:Minisat::SimpSolver	typeref:typename:bool
solve	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p       ,        bool do_simp, bool turn_off_simp)  { /;"	f	class:Minisat::SimpSolver	typeref:typename:bool
solve	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p, Lit q,        bool do_simp, bool turn_off_simp)  { /;"	f	class:Minisat::SimpSolver	typeref:typename:bool
solve	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::solve        (Lit p, Lit q, Lit r, bool do_simp, bool turn_off_simp)  { /;"	f	class:Minisat::SimpSolver	typeref:typename:bool
solve	yosys/libs/minisat/SimpSolver.h	/^inline bool SimpSolver::solve        (const vec<Lit>& assumps, bool do_simp, bool turn_off_simp)/;"	f	class:Minisat::SimpSolver	typeref:typename:bool
solve	yosys/libs/minisat/Solver.h	/^inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); /;"	f	class:Minisat::Solver	typeref:typename:bool
solve	yosys/libs/minisat/Solver.h	/^inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); /;"	f	class:Minisat::Solver	typeref:typename:bool
solve	yosys/libs/minisat/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); /;"	f	class:Minisat::Solver	typeref:typename:bool
solve	yosys/libs/minisat/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); /;"	f	class:Minisat::Solver	typeref:typename:bool
solve	yosys/libs/minisat/Solver.h	/^inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(ass/;"	f	class:Minisat::Solver	typeref:typename:bool
solve	yosys/libs/subcircuit/subcircuit.cc	/^	void solve(std::vector<Solver::Result> &results, std::string needleGraphId, std::string haystac/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
solve	yosys/libs/subcircuit/subcircuit.cc	/^void SubCircuit::Solver::solve(std::vector<Result> &results, std::string needleGraphId, std::str/;"	f	class:SubCircuit::Solver	typeref:typename:void
solve	yosys/passes/cmds/qwp.cc	/^	void solve(bool alt_mode = false)$/;"	f	struct:QwpWorker	typeref:typename:void	file:
solve	yosys/passes/sat/sat.cc	/^	bool solve(const std::vector<int> &assumptions)$/;"	f	struct:SatHelper	typeref:typename:bool	file:
solve	yosys/passes/sat/sat.cc	/^	bool solve(int a = 0, int b = 0, int c = 0, int d = 0, int e = 0, int f = 0)$/;"	f	struct:SatHelper	typeref:typename:bool	file:
solveForMining	yosys/libs/subcircuit/subcircuit.cc	/^	void solveForMining(std::vector<Solver::Result> &results, const GraphData &needle)$/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
solveLimited	yosys/libs/minisat/SimpSolver.h	/^inline lbool SimpSolver::solveLimited (const vec<Lit>& assumps, bool do_simp, bool turn_off_simp/;"	f	class:Minisat::SimpSolver	typeref:typename:lbool
solveLimited	yosys/libs/minisat/Solver.h	/^inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); re/;"	f	class:Minisat::Solver	typeref:typename:lbool
solve_	yosys/libs/minisat/SimpSolver.cc	/^lbool SimpSolver::solve_(bool do_simp, bool turn_off_simp)$/;"	f	class:SimpSolver	typeref:typename:lbool
solve_	yosys/libs/minisat/Solver.cc	/^lbool Solver::solve_()$/;"	f	class:Solver	typeref:typename:lbool
solver	yosys/libs/ezsat/ezminisat.cc	/^bool ezMiniSAT::solver(const std::vector<int> &modelExpressions, std::vector<bool> &modelValues,/;"	f	class:ezMiniSAT	typeref:typename:bool
solver	yosys/libs/ezsat/ezsat.cc	/^bool ezSAT::solver(const std::vector<int>&, std::vector<bool>&, const std::vector<int>&)$/;"	f	class:ezSAT	typeref:typename:bool
solver	yosys/passes/sat/qbfsat.h	/^	enum Solver{Z3, Yices, CVC4} solver = Yices;$/;"	m	struct:QbfSolveOptions	typeref:enum:QbfSolveOptions::Solver
solverTimeout	yosys/libs/ezsat/ezsat.h	/^	int solverTimeout;$/;"	m	class:ezSAT	typeref:typename:int
solverTimoutStatus	yosys/libs/ezsat/ezsat.h	/^	bool solverTimoutStatus;$/;"	m	class:ezSAT	typeref:typename:bool
solver_options	yosys/passes/sat/qbfsat.h	/^	dict<std::string, std::string> solver_options;$/;"	m	struct:QbfSolveOptions	typeref:typename:dict<std::string,std::string>
solver_time	yosys/passes/sat/qbfsat.h	/^	double solver_time = 0;$/;"	m	struct:QbfSolutionType	typeref:typename:double
solves	yosys/libs/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
sort	yosys/kernel/hashlib.h	/^	void sort(Compare comp = Compare())$/;"	f	class:hashlib::dict	typeref:typename:void
sort	yosys/kernel/hashlib.h	/^	void sort(Compare comp = Compare())$/;"	f	class:hashlib::pool	typeref:typename:void
sort	yosys/kernel/rtlil.cc	/^void RTLIL::Cell::sort()$/;"	f	class:RTLIL::Cell	typeref:typename:void
sort	yosys/kernel/rtlil.cc	/^void RTLIL::Design::sort()$/;"	f	class:RTLIL::Design	typeref:typename:void
sort	yosys/kernel/rtlil.cc	/^void RTLIL::Module::sort()$/;"	f	class:RTLIL::Module	typeref:typename:void
sort	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::sort()$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
sort	yosys/kernel/utils.h	/^	bool sort()$/;"	f	struct:TopoSort	typeref:typename:bool
sort	yosys/libs/minisat/Sort.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f	namespace:Minisat	typeref:typename:void
sort	yosys/libs/minisat/Sort.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f	namespace:Minisat	typeref:typename:void
sort	yosys/libs/minisat/Sort.h	/^template <class T> void sort(vec<T>& v) {$/;"	f	namespace:Minisat	typeref:typename:void
sort	yosys/libs/minisat/Sort.h	/^void sort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat	typeref:typename:void
sort_and_unify	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::sort_and_unify()$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
sort_by_id_str	yosys/kernel/rtlil.h	/^	struct sort_by_id_str {$/;"	s	namespace:RTLIL
sort_by_name_id	yosys/kernel/rtlil.h	/^	template <typename T> struct sort_by_name_id {$/;"	s	namespace:RTLIL
sort_by_name_id_guard	yosys/kernel/sigtools.h	/^using sort_by_name_id_guard = typename std::enable_if<std::is_same<T,RTLIL::Cell*>::value>::type/;"	t	typeref:typename:std::enable_if<std::is_same<T,RTLIL::Cell * >::value>::type
sort_by_name_str	yosys/kernel/rtlil.h	/^	template <typename T> struct sort_by_name_str {$/;"	s	namespace:RTLIL
sort_by_port_id	yosys/backends/aiger/xaiger.cc	/^		struct sort_by_port_id {$/;"	s	function:XAigerWriter::XAigerWriter	file:
sort_check_activation_pattern	yosys/passes/opt/share.cc	/^	bool sort_check_activation_pattern(ssc_pair_t &p)$/;"	f	struct:ShareWorker	typeref:typename:bool	file:
sort_pmux_conn	yosys/passes/opt/opt_merge.cc	/^	static void sort_pmux_conn(dict<RTLIL::IdString, RTLIL::SigSpec> &conn)$/;"	f	struct:OptMergeWorker	typeref:typename:void	file:
sort_worker	yosys/kernel/utils.h	/^	void sort_worker(const T &n, std::set<T, C> &marked_cells, std::set<T, C> &active_cells, std::v/;"	f	struct:TopoSort	typeref:typename:void
sorted	yosys/kernel/utils.h	/^	std::vector<T> sorted;$/;"	m	struct:TopoSort	typeref:typename:std::vector<T>
sorts_bv	yosys/backends/btor/btor.cc	/^	dict<int, int> sorts_bv;$/;"	m	struct:BtorWorker	typeref:typename:dict<int,int>	file:
sorts_mem	yosys/backends/btor/btor.cc	/^	dict<pair<int, int>, int> sorts_mem;$/;"	m	struct:BtorWorker	typeref:typename:dict<pair<int,int>,int>	file:
source	yosys/passes/techmap/flowmap.cc	/^	const RTLIL::SigBit source;$/;"	m	struct:FlowGraph	typeref:typename:const RTLIL::SigBit	file:
source_module	yosys/passes/equiv/equiv_miter.cc	/^	Module *source_module;$/;"	m	struct:EquivMiterWorker	typeref:typename:Module *	file:
sources	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	Vertex *sources = new Vertex;$/;"	m	struct:Scheduler	typeref:typename:Vertex *	file:
specialize	yosys/passes/sat/qbfsat.cc	/^void specialize(RTLIL::Module *module, const QbfSolutionType &sol, bool quiet = false) {$/;"	f	typeref:typename:void
specialize	yosys/passes/sat/qbfsat.h	/^	bool specialize = false, specialize_from_file = false, write_solution = false, nocleanup = fals/;"	m	struct:QbfSolveOptions	typeref:typename:bool
specialize_from_file	yosys/passes/sat/qbfsat.cc	/^void specialize_from_file(RTLIL::Module *module, const std::string &file) {$/;"	f	typeref:typename:void
specialize_from_file	yosys/passes/sat/qbfsat.h	/^	bool specialize = false, specialize_from_file = false, write_solution = false, nocleanup = fals/;"	m	struct:QbfSolveOptions	typeref:typename:bool
specialize_soln_file	yosys/passes/sat/qbfsat.h	/^	std::string specialize_soln_file = "";$/;"	m	struct:QbfSolveOptions	typeref:typename:std::string
specifyCells	yosys/passes/cmds/scc.cc	/^	CellTypes ct, specifyCells;$/;"	m	struct:SccWorker	typeref:typename:CellTypes	file:
spice_id2str	yosys/backends/spice/spice.cc	/^static string spice_id2str(IdString id)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN string	file:
spice_id2str	yosys/backends/spice/spice.cc	/^static string spice_id2str(IdString id, bool use_inames, idict<IdString, 1> &inums)$/;"	f	typeref:typename:string	file:
spliced_signals_cache	yosys/passes/cmds/splice.cc	/^	std::map<RTLIL::SigSpec, RTLIL::SigSpec> spliced_signals_cache;$/;"	m	struct:SpliceWorker	typeref:typename:std::map<RTLIL::SigSpec,RTLIL::SigSpec>	file:
split	yosys/passes/opt/opt_lut.cc	/^static void split(std::vector<std::string> &tokens, const std::string &text, char sep)$/;"	f	typeref:typename:void	file:
split	yosys/passes/sat/eval.cc	/^	std::vector<std::string> split(std::string text, const char *delim)$/;"	f	struct:VlogHammerReporter	typeref:typename:std::vector<std::string>	file:
split	yosys/passes/sat/sim.cc	/^	std::vector<std::string> split(std::string text, const char *delim)$/;"	f	struct:SimWorker	typeref:typename:std::vector<std::string>	file:
split	yosys/passes/techmap/flowmap.cc	/^static void split(std::vector<std::string> &tokens, const std::string &text, char sep)$/;"	f	typeref:typename:void	file:
split_by	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^std::vector<std::string> split_by(const std::string &str, const std::string &sep)$/;"	f	typeref:typename:std::vector<std::string>
split_hierarchy	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	static std::vector<std::string> split_hierarchy(const std::string &hier_name) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:std::vector<std::string>
split_intf	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool split_intf = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
split_modport_from_type	yosys/frontends/ast/ast.cc	/^std::pair<std::string,std::string> AST::split_modport_from_type(std::string name_type)$/;"	f	class:AST	typeref:typename:std::pair<std::string,std::string>
split_portname_pair	yosys/passes/techmap/clkbufmap.cc	/^void split_portname_pair(std::string &port1, std::string &port2)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
split_portname_pair	yosys/passes/techmap/extractinv.cc	/^void split_portname_pair(std::string &port1, std::string &port2)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
split_portname_pair	yosys/passes/techmap/iopadmap.cc	/^void split_portname_pair(std::string &port1, std::string &port2)$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void
split_tokens	yosys/kernel/yosys.cc	/^std::vector<std::string> split_tokens(const std::string &text, const char *sep)$/;"	f	typeref:typename:std::vector<std::string>
splitmap	yosys/passes/cmds/splitnets.cc	/^	std::map<RTLIL::Wire*, std::vector<RTLIL::SigBit>> splitmap;$/;"	m	struct:SplitnetsWorker	typeref:typename:std::map<RTLIL::Wire *,std::vector<RTLIL::SigBit>>	file:
src	yosys/passes/sat/mutate.cc	/^	pool<string> src;$/;"	m	struct:mutate_opts_t	typeref:typename:pool<string>	file:
src	yosys/passes/sat/mutate.cc	/^	pool<string> src;$/;"	m	struct:mutate_t	typeref:typename:pool<string>	file:
src_db	yosys/passes/sat/mutate.cc	/^	dict<string, int> src_db;$/;"	m	struct:coverdb_t	typeref:typename:dict<string,int>	file:
src_port	yosys/passes/cmds/sta.cc	/^		IdString dst_port, src_port;$/;"	m	struct:StaWorker::t_data	typeref:typename:IdString	file:
srcsymbols	yosys/backends/btor/btor.cc	/^	pool<string> srcsymbols;$/;"	m	struct:BtorWorker	typeref:typename:pool<string>	file:
srst	yosys/kernel/mem.h	/^	SigSpec clk, en, arst, srst, addr, data;$/;"	m	struct:MemRd	typeref:typename:SigSpec
srst_polarity	yosys/passes/techmap/abc.cc	/^bool clk_polarity, en_polarity, arst_polarity, srst_polarity;$/;"	v	typeref:typename:bool
srst_sig	yosys/passes/techmap/abc.cc	/^RTLIL::SigSpec clk_sig, en_sig, arst_sig, srst_sig;$/;"	v	typeref:typename:RTLIL::SigSpec
srst_used	yosys/passes/techmap/dfflegalize.cc	/^	dict<SigBit, int> srst_used;$/;"	m	struct:DffLegalizePass	typeref:typename:dict<SigBit,int>	file:
srst_value	yosys/kernel/mem.h	/^	Const arst_value, srst_value, init_value;$/;"	m	struct:MemRd	typeref:typename:Const
ssc_pair_t	yosys/passes/opt/share.cc	/^typedef std::pair<RTLIL::SigSpec, RTLIL::Const> ssc_pair_t;$/;"	t	typeref:typename:std::pair<RTLIL::SigSpec,RTLIL::Const>	file:
sshl_su	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> sshl_su(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
sshl_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> sshl_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
sshr	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> sshr(const value<AmountBits> &amount) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
sshr_su	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> sshr_su(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
sshr_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> sshr_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
ssize_t	yosys/frontends/rpc/rpc_frontend.cc	/^typedef SSIZE_T ssize_t;$/;"	t	typeref:typename:SSIZE_T	file:
ssize_t	yosys/libs/fst/fstapi.h	/^#define ssize_t /;"	d
stack	yosys/kernel/consteval.h	/^	std::vector<SigMap> stack;$/;"	m	struct:ConstEval	typeref:typename:std::vector<SigMap>
stackmap	yosys/kernel/utils.h	/^	stackmap() { }$/;"	f	struct:stackmap
stackmap	yosys/kernel/utils.h	/^	stackmap(const dict<Key, T, OPS> &other) : current_state(other) { }$/;"	f	struct:stackmap
stackmap	yosys/kernel/utils.h	/^struct stackmap$/;"	s
startNode	yosys/frontends/verific/verificsva.cc	/^	int startNode, acceptNode, condNode;$/;"	m	struct:SvaFsm	typeref:typename:int	file:
start_cell	yosys/passes/hierarchy/hierarchy.cc	/^	void start_cell()$/;"	f	struct:IFExpander	typeref:typename:void	file:
start_offset	yosys/kernel/mem.h	/^	int width, start_offset, size;$/;"	m	struct:Mem	typeref:typename:int
start_offset	yosys/kernel/rtlil.h	/^	int width, start_offset, port_id;$/;"	m	struct:RTLIL::Wire	typeref:typename:int
start_offset	yosys/kernel/rtlil.h	/^	int width, start_offset, size;$/;"	m	struct:RTLIL::Memory	typeref:typename:int
start_time	yosys/kernel/fstdata.h	/^	uint64_t start_time;$/;"	m	class:FstData	typeref:typename:uint64_t
start_time	yosys/libs/fst/fstapi.cc	/^    uint64_t start_time, end_time;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
start_time	yosys/passes/sat/sim.cc	/^	double start_time = 0;$/;"	m	struct:SimShared	typeref:typename:double	file:
starts	yosys/libs/minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
statdata_t	yosys/passes/cmds/stat.cc	/^	statdata_t()$/;"	f	struct:statdata_t	file:
statdata_t	yosys/passes/cmds/stat.cc	/^	statdata_t(RTLIL::Design *design, RTLIL::Module *mod, bool width_mode, const dict<IdString, dou/;"	f	struct:statdata_t	file:
statdata_t	yosys/passes/cmds/stat.cc	/^struct statdata_t$/;"	s	file:
state_bits	yosys/passes/fsm/fsmdata.h	/^	int num_inputs, num_outputs, state_bits, reset_state;$/;"	m	struct:FsmData	typeref:typename:int
state_in	yosys/passes/fsm/fsmdata.h	/^	struct transition_t { int state_in, state_out; RTLIL::Const ctrl_in, ctrl_out; };$/;"	m	struct:FsmData::transition_t	typeref:typename:int
state_nets	yosys/passes/sat/sim.cc	/^	dict<SigBit, State> state_nets;$/;"	m	struct:SimInstance	typeref:typename:dict<SigBit,State>	file:
state_out	yosys/passes/fsm/fsmdata.h	/^	struct transition_t { int state_in, state_out; RTLIL::Const ctrl_in, ctrl_out; };$/;"	m	struct:FsmData::transition_t	typeref:typename:int
state_table	yosys/passes/fsm/fsmdata.h	/^	std::vector<RTLIL::Const> state_table;$/;"	m	struct:FsmData	typeref:typename:std::vector<RTLIL::Const>
statebv	yosys/backends/smt2/smt2.cc	/^	bool bvmode, memmode, wiresmode, verbose, statebv, statedt, forallmode;$/;"	m	struct:Smt2Worker	typeref:typename:bool	file:
statebv_width	yosys/backends/smt2/smt2.cc	/^	int idcounter = 0, statebv_width = 0;$/;"	m	struct:Smt2Worker	typeref:typename:int	file:
statedt	yosys/backends/smt2/smt2.cc	/^	bool bvmode, memmode, wiresmode, verbose, statebv, statedt, forallmode;$/;"	m	struct:Smt2Worker	typeref:typename:bool	file:
statehash	yosys/libs/ezsat/ezsat.h	/^	unsigned int statehash;$/;"	m	class:ezSAT	typeref:typename:unsigned int
statesig	yosys/frontends/verific/verificsva.cc	/^	SigBit statesig;$/;"	m	struct:SvaDFsmNode	typeref:typename:SigBit	file:
statewires	yosys/backends/btor/btor.cc	/^	pool<Wire*> statewires;$/;"	m	struct:BtorWorker	typeref:typename:pool<Wire * >	file:
static_null	yosys/libs/json11/json11.cpp	/^static const Json & static_null() {$/;"	f	namespace:json11	typeref:typename:const Json &	file:
statics	yosys/libs/json11/json11.cpp	/^static const Statics & statics() {$/;"	f	namespace:json11	typeref:typename:const Statics &	file:
status	yosys/kernel/log.h	/^	bool status = false;$/;"	m	struct:LogMakeDebugHdl	typeref:typename:bool
stdmap	yosys/kernel/utils.h	/^	const dict<Key, T, OPS> &stdmap()$/;"	f	struct:stackmap	typeref:typename:const dict<Key,T,OPS> &
stdout_lines	yosys/passes/sat/qbfsat.h	/^	std::vector<std::string> stdout_lines = {};$/;"	m	struct:QbfSolutionType	typeref:typename:std::vector<std::string>
step	yosys/backends/cxxrtl/cxxrtl.h	/^	size_t step() {$/;"	f	struct:cxxrtl::module	typeref:typename:size_t
sticky_dirty_bits	yosys/backends/simplec/simplec.cc	/^	pool<SigBit> sticky_dirty_bits;$/;"	m	struct:HierDirtyFlags	typeref:typename:pool<SigBit>	file:
stop	yosys/kernel/consteval.h	/^	void stop(RTLIL::SigSpec sig)$/;"	f	struct:ConstEval	typeref:typename:void
stop_signals	yosys/kernel/consteval.h	/^	SigPool stop_signals;$/;"	m	struct:ConstEval	typeref:typename:SigPool
stop_time	yosys/passes/sat/sim.cc	/^	double stop_time = -1;$/;"	m	struct:SimShared	typeref:typename:double	file:
str	yosys/backends/blif/blif.cc	/^	const std::string str(RTLIL::IdString id)$/;"	f	struct:BlifDumper	typeref:typename:const std::string	file:
str	yosys/backends/blif/blif.cc	/^	const std::string str(RTLIL::SigBit sig)$/;"	f	struct:BlifDumper	typeref:typename:const std::string	file:
str	yosys/backends/cxxrtl/cxxrtl.h	/^	std::string str() const {$/;"	f	struct:cxxrtl::value	typeref:typename:std::string
str	yosys/frontends/ast/ast.h	/^		std::string str;$/;"	m	struct:AST::AstNode	typeref:typename:std::string
str	yosys/kernel/rtlil.h	/^		inline std::string str() const {$/;"	f	struct:RTLIL::IdString	typeref:typename:std::string
str	yosys/kernel/yosys.h	/^	const string &str() const { return *content; }$/;"	f	struct:shared_str	typeref:typename:const string &
str	yosys/libs/json11/json11.cpp	/^    const string &str;$/;"	m	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:const string &	file:
str	yosys/passes/cmds/exec.cc	/^			std::string str;$/;"	m	struct:ExecPass::execute::expect_stdout_elem	typeref:typename:std::string	file:
str2wstr	yosys/frontends/rpc/rpc_frontend.cc	/^static std::wstring str2wstr(const std::string &in) {$/;"	f	typeref:typename:YOSYS_NAMESPACE_BEGIN std::wstring	file:
str_init	yosys/backends/blif/blif.cc	/^	const std::string str_init(RTLIL::SigBit sig)$/;"	f	struct:BlifDumper	typeref:typename:const std::string	file:
str_scope_comp	yosys/libs/fst/fstapi.cc	/^    char str_scope_comp[FST_ID_NAM_SIZ + 1];$/;"	m	struct:fstReaderContext	typeref:typename:char[]	file:
str_scope_nam	yosys/libs/fst/fstapi.cc	/^    char str_scope_nam[FST_ID_NAM_SIZ + 1];$/;"	m	struct:fstReaderContext	typeref:typename:char[]	file:
str_token	yosys/frontends/verilog/preproc.cc	/^	static std::string str_token(const std::string &macro_name, int pos)$/;"	f	struct:arg_map_t	typeref:typename:std::string	file:
strategy	yosys/libs/json11/json11.cpp	/^    const JsonParse strategy;$/;"	m	struct:json11::__anon5ec0faac0111::JsonParser	typeref:typename:const JsonParse	file:
strbuf	yosys/backends/smv/smv.cc	/^	vector<shared_str> strbuf;$/;"	m	struct:SmvWorker	typeref:typename:vector<shared_str>	file:
strdup	yosys/kernel/yosys.h	/^#  define strdup /;"	d
streaming	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	bool streaming = false;$/;"	m	class:cxxrtl::vcd_writer	typeref:typename:bool
strengthen	yosys/libs/minisat/SolverTypes.h	/^inline void Clause::strengthen(Lit p)$/;"	f	class:Minisat::Clause	typeref:typename:void
strengthenClause	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::strengthenClause(CRef cr, Lit l)$/;"	f	class:SimpSolver	typeref:typename:bool
stretchIO	yosys/passes/cmds/show.cc	/^	bool stretchIO;$/;"	m	struct:ShowWorker	typeref:typename:bool	file:
stringToBigInteger	yosys/libs/bigint/BigIntegerUtils.cc	/^BigInteger stringToBigInteger(const std::string &s) {$/;"	f	typeref:typename:BigInteger
stringToBigUnsigned	yosys/libs/bigint/BigIntegerUtils.cc	/^BigUnsigned stringToBigUnsigned(const std::string &s) {$/;"	f	typeref:typename:BigUnsigned
stringToTime	yosys/passes/sat/sim.cc	/^static double stringToTime(std::string str)$/;"	f	typeref:typename:double	file:
string_buf	yosys/kernel/log.cc	/^vector<shared_str> string_buf;$/;"	v	typeref:typename:vector<shared_str>
string_buf_index	yosys/kernel/log.cc	/^int string_buf_index = -1;$/;"	v	typeref:typename:int
string_compare_nocase	yosys/passes/techmap/attrmap.cc	/^bool string_compare_nocase(const string &str1, const string &str2)$/;"	f	typeref:typename:bool
string_value	yosys/backends/cxxrtl/cxxrtl.h	/^	const std::string string_value = "";$/;"	m	struct:cxxrtl::metadata	typeref:typename:const std::string
string_value	yosys/libs/json11/json11.cpp	/^    const string &string_value() const override { return m_value; }$/;"	f	class:json11::JsonString	typeref:typename:const string &	file:
string_value	yosys/libs/json11/json11.cpp	/^const string &            JsonValue::string_value()              const { return statics().empty_/;"	f	class:json11::JsonValue	typeref:typename:const string &
string_value	yosys/libs/json11/json11.cpp	/^const string & Json::string_value()               const { return m_ptr->string_value(); }$/;"	f	class:json11::Json	typeref:typename:const string &
stringf	yosys/kernel/yosys.cc	/^std::string stringf(const char *fmt, ...)$/;"	f	typeref:typename:std::string
strtok_r	yosys/kernel/yosys.h	/^#  define strtok_r /;"	d
struct_array_packing_error	yosys/frontends/ast/simplify.cc	/^[[noreturn]] static void struct_array_packing_error(AstNode *node)$/;"	f	typeref:typename:void	file:
struct_declarations	yosys/backends/simplec/simplec.cc	/^	vector<string> struct_declarations;$/;"	m	struct:SimplecWorker	typeref:typename:vector<string>	file:
struct_op_error	yosys/frontends/ast/simplify.cc	/^[[noreturn]] static void struct_op_error(AstNode *node)$/;"	f	typeref:typename:void	file:
stubnets.so	yosys/manual/CHAPTER_Prog/Makefile	/^stubnets.so: stubnets.cc$/;"	t
sub	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> sub(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
sub_addr	yosys/kernel/mem.h	/^	SigSpec sub_addr(int sub) {$/;"	f	struct:MemRd	typeref:typename:SigSpec
sub_addr	yosys/kernel/mem.h	/^	SigSpec sub_addr(int sub) {$/;"	f	struct:MemWr	typeref:typename:SigSpec
sub_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> sub_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
sub_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> sub_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
subckt_or_gate	yosys/backends/blif/blif.cc	/^	const char *subckt_or_gate(std::string cell_type)$/;"	f	struct:BlifDumper	typeref:typename:const char *	file:
submodules	yosys/passes/hierarchy/submod.cc	/^	std::map<std::string, SubModule> submodules;$/;"	m	struct:SubmodWorker	typeref:typename:std::map<std::string,SubModule>	file:
subst_lvalue_map	yosys/frontends/ast/genrtlil.cc	/^	stackmap<RTLIL::SigBit, RTLIL::SigBit> subst_lvalue_map;$/;"	m	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:stackmap<RTLIL::SigBit,RTLIL::SigBit>	file:
subst_rvalue_map	yosys/frontends/ast/genrtlil.cc	/^	stackmap<RTLIL::SigBit, RTLIL::SigBit> subst_rvalue_map;$/;"	m	struct:AST_INTERNAL::ProcessGenerator	typeref:typename:stackmap<RTLIL::SigBit,RTLIL::SigBit>	file:
substitute	yosys/libs/minisat/SimpSolver.cc	/^bool SimpSolver::substitute(Var v, Lit x)$/;"	f	class:SimpSolver	typeref:typename:bool
substr	yosys/kernel/rtlil.h	/^		std::string substr(size_t pos = 0, size_t len = std::string::npos) const {$/;"	f	struct:RTLIL::IdString	typeref:typename:std::string
subsumes	yosys/libs/minisat/SolverTypes.h	/^inline Lit Clause::subsumes(const Clause& other) const$/;"	f	class:Minisat::Clause	typeref:typename:Lit
subsumption_lim	yosys/libs/minisat/SimpSolver.h	/^    int     subsumption_lim;   \/\/ Do not check if subsumption against a clause larger than thi/;"	m	class:Minisat::SimpSolver	typeref:typename:int
subsumption_queue	yosys/libs/minisat/SimpSolver.h	/^    Queue<CRef>         subsumption_queue;$/;"	m	class:Minisat::SimpSolver	typeref:typename:Queue<CRef>
subtract	yosys/libs/bigint/BigInteger.cc	/^void BigInteger::subtract(const BigInteger &a, const BigInteger &b) {$/;"	f	class:BigInteger	typeref:typename:void
subtract	yosys/libs/bigint/BigUnsigned.cc	/^void BigUnsigned::subtract(const BigUnsigned &a, const BigUnsigned &b) {$/;"	f	class:BigUnsigned	typeref:typename:void
subtype	yosys/libs/fst/fstapi.h	/^            unsigned char subtype; \/* from fstMiscType, fstArrayType, fstEnumValueType, fstPack/;"	m	struct:fstHier::__anonafd27bad010a::fstHierAttr	typeref:typename:unsigned char
success_counter	yosys/passes/equiv/equiv_induct.cc	/^	int success_counter;$/;"	m	struct:EquivInductWorker	typeref:typename:int	file:
succs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		pool<Vertex*, hash_ptr_ops> preds, succs;$/;"	m	struct:Scheduler::Vertex	typeref:typename:pool<Vertex *,hash_ptr_ops>	file:
sum_best_covers	yosys/passes/techmap/muxcover.cc	/^	int sum_best_covers(tree_t &tree, const vector<SigBit> &bits)$/;"	f	struct:MuxcoverWorker	typeref:typename:int	file:
summand_t	yosys/passes/techmap/maccmap.cc	/^		typedef std::pair<RTLIL::SigSpec, bool> summand_t;$/;"	t	function:maccmap	typeref:typename:std::pair<RTLIL::SigSpec,bool>	file:
supported_adff	yosys/passes/techmap/dfflegalize.cc	/^	int supported_adff;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_adffe	yosys/passes/techmap/dfflegalize.cc	/^	int supported_adffe;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_adlatch	yosys/passes/techmap/dfflegalize.cc	/^	int supported_adlatch;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_aldff	yosys/passes/techmap/dfflegalize.cc	/^	int supported_aldff;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_aldffe	yosys/passes/techmap/dfflegalize.cc	/^	int supported_aldffe;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_cell_types	yosys/passes/opt/wreduce.cc	/^	pool<IdString> supported_cell_types;$/;"	m	struct:WreduceConfig	typeref:typename:pool<IdString>	file:
supported_cells	yosys/passes/techmap/dfflegalize.cc	/^	int supported_cells[NUM_FFTYPES];$/;"	m	struct:DffLegalizePass	typeref:typename:int[]	file:
supported_cells_neg	yosys/passes/techmap/dfflegalize.cc	/^	int supported_cells_neg[NUM_FFTYPES][NUM_NEG];$/;"	m	struct:DffLegalizePass	typeref:typename:int[][]	file:
supported_dff	yosys/passes/techmap/dfflegalize.cc	/^	int supported_dff;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_dffe	yosys/passes/techmap/dfflegalize.cc	/^	int supported_dffe;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_dffsr	yosys/passes/techmap/dfflegalize.cc	/^	int supported_dffsr;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_dlatch	yosys/passes/techmap/dfflegalize.cc	/^	int supported_dlatch;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_dlatch_plain	yosys/passes/techmap/dfflegalize.cc	/^	int supported_dlatch_plain;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_rlatch	yosys/passes/techmap/dfflegalize.cc	/^	int supported_rlatch;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_sdff	yosys/passes/techmap/dfflegalize.cc	/^	int supported_sdff;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_sr	yosys/passes/techmap/dfflegalize.cc	/^	int supported_sr;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
supported_sr_plain	yosys/passes/techmap/dfflegalize.cc	/^	int supported_sr_plain;$/;"	m	struct:DffLegalizePass	typeref:typename:int	file:
sva_posedge_map	yosys/frontends/verific/verific.h	/^	std::map<Verific::Net*, Verific::Net*> sva_posedge_map;$/;"	m	struct:VerificImporter	typeref:typename:std::map<Verific::Net *,Verific::Net * >
svt_workspace	yosys/libs/fst/fstapi.h	/^            unsigned char svt_workspace; \/* zeroed out by FST reader, for client code use *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierVar	typeref:typename:unsigned char
swap	yosys/kernel/hashlib.h	/^	void swap(dict &other)$/;"	f	class:hashlib::dict	typeref:typename:void
swap	yosys/kernel/hashlib.h	/^	void swap(idict &other)$/;"	f	class:hashlib::idict	typeref:typename:void
swap	yosys/kernel/hashlib.h	/^	void swap(mfp &other)$/;"	f	class:hashlib::mfp	typeref:typename:void
swap	yosys/kernel/hashlib.h	/^	void swap(pool &other)$/;"	f	class:hashlib::pool	typeref:typename:void
swap	yosys/kernel/sigtools.h	/^	void swap(SigMap &other)$/;"	f	struct:SigMap	typeref:typename:void
swapPermutations	yosys/libs/subcircuit/subcircuit.cc	/^	std::map<std::string, std::set<std::map<std::string, std::string>>> swapPermutations;$/;"	m	class:SubCircuit::SolverWorker	typeref:typename:std::map<std::string,std::set<std::map<std::string,std::string>>>	file:
swapPorts	yosys/libs/subcircuit/subcircuit.cc	/^	std::map<std::string, std::set<std::set<std::string>>> swapPorts;$/;"	m	class:SubCircuit::SolverWorker	typeref:typename:std::map<std::string,std::set<std::set<std::string>>>	file:
swap_alt	yosys/passes/cmds/qwp.cc	/^		void swap_alt() {$/;"	f	struct:QwpWorker::Node	typeref:typename:void	file:
swap_names	yosys/kernel/rtlil.cc	/^void RTLIL::Module::swap_names(RTLIL::Cell *c1, RTLIL::Cell *c2)$/;"	f	class:RTLIL::Module	typeref:typename:void
swap_names	yosys/kernel/rtlil.cc	/^void RTLIL::Module::swap_names(RTLIL::Wire *w1, RTLIL::Wire *w2)$/;"	f	class:RTLIL::Module	typeref:typename:void
switches	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::SwitchRule*> switches;$/;"	m	struct:RTLIL::CaseRule	typeref:typename:std::vector<RTLIL::SwitchRule * >
sxt_workspace	yosys/libs/fst/fstapi.h	/^            unsigned int sxt_workspace;  \/* zeroed out by FST reader, for client code use *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierVar	typeref:typename:unsigned int
sym_mul.pdf	yosys/manual/PRESENTATION_ExAdv/Makefile	/^sym_mul.pdf: sym_mul_*$/;"	t
sync	yosys/kernel/register.cc	/^		virtual int sync() override$/;"	f	class:gzip_ostream::gzip_streambuf	typeref:typename:int	file:
syncs	yosys/kernel/rtlil.h	/^	std::vector<RTLIL::SyncRule*> syncs;$/;"	m	struct:RTLIL::Process	typeref:typename:std::vector<RTLIL::SyncRule * >
syntax_error	yosys/passes/memory/memory_bram.cc	/^	void syntax_error()$/;"	f	struct:rules_t	typeref:typename:void	file:
synth	yosys/passes/techmap/maccmap.cc	/^	RTLIL::SigSpec synth()$/;"	f	struct:MaccmapWorker	typeref:typename:RTLIL::SigSpec	file:
systemverilog	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
sz	yosys/libs/minisat/Alloc.h	/^    uint32_t  sz;$/;"	m	class:Minisat::RegionAllocator	typeref:typename:uint32_t
sz	yosys/libs/minisat/Vec.h	/^    Size sz;$/;"	m	class:Minisat::vec	typeref:typename:Size
t	yosys/libs/json11/json11.cpp	/^    const std::shared_ptr<JsonValue> t = make_shared<JsonBoolean>(true);$/;"	m	struct:json11::Statics	typeref:typename:const std::shared_ptr<JsonValue>	file:
t_data	yosys/passes/cmds/sta.cc	/^		t_data() : driver(nullptr) {}$/;"	f	struct:StaWorker::t_data	file:
t_data	yosys/passes/cmds/sta.cc	/^	struct t_data {$/;"	s	struct:StaWorker	file:
t_endpoint	yosys/passes/cmds/sta.cc	/^		t_endpoint() : sink(nullptr), required(0) {}$/;"	f	struct:StaWorker::t_endpoint	file:
t_endpoint	yosys/passes/cmds/sta.cc	/^	struct t_endpoint {$/;"	s	struct:StaWorker	file:
t_lut	yosys/passes/techmap/abc9_ops.cc	/^	struct t_lut {$/;"	s	function:prep_lut	file:
table	yosys/backends/cxxrtl/cxxrtl.h	/^	std::map<std::string, std::vector<debug_item>> table;$/;"	m	struct:cxxrtl::debug_items	typeref:typename:std::map<std::string,std::vector<debug_item>>
table	yosys/libs/fst/lz4.h	/^    long long table[LZ4_STREAMSIZE_U64];$/;"	m	struct:__anon78d5d8400108	typeref:typename:long long[]
table	yosys/libs/fst/lz4.h	/^    unsigned long long table[LZ4_STREAMDECODESIZE_U64];$/;"	m	struct:__anon78d5d8400208	typeref:typename:unsigned long long[]
table	yosys/libs/minisat/Map.h	/^    vec<Pair>* table;$/;"	m	class:Minisat::Map	typeref:typename:vec<Pair> *
tableType_t	yosys/libs/fst/lz4.cc	/^} tableType_t;$/;"	t	typeref:enum:__anon9390dffe0403	file:
take	yosys/kernel/bitpattern.h	/^	bool take(RTLIL::SigSpec sig)$/;"	f	struct:BitPatternPool	typeref:typename:bool
take	yosys/passes/proc/proc_rmdead.cc	/^	bool take(RTLIL::SigSpec sig)$/;"	f	struct:FullyDefinedPool	typeref:typename:bool	file:
take_all	yosys/kernel/bitpattern.h	/^	bool take_all()$/;"	f	struct:BitPatternPool	typeref:typename:bool
take_all	yosys/passes/proc/proc_rmdead.cc	/^	void take_all()$/;"	f	struct:FullyDefinedPool	typeref:typename:void	file:
target_name	yosys/kernel/binding.h	/^	RTLIL::IdString target_name;$/;"	m	struct:RTLIL::Binding	typeref:typename:RTLIL::IdString
target_type	yosys/kernel/binding.h	/^	RTLIL::IdString target_type;$/;"	m	struct:RTLIL::Binding	typeref:typename:RTLIL::IdString
tchn_cnt	yosys/libs/fst/fstapi.cc	/^    uint32_t tchn_cnt, tchn_idx;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t	file:
tchn_handle	yosys/libs/fst/fstapi.cc	/^    FILE *tchn_handle;$/;"	m	struct:fstWriterContext	typeref:typename:FILE *	file:
tchn_handle_nam	yosys/libs/fst/fstapi.cc	/^    char *tchn_handle_nam;$/;"	m	struct:fstWriterContext	typeref:typename:char *	file:
tchn_idx	yosys/libs/fst/fstapi.cc	/^    uint32_t tchn_cnt, tchn_idx;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t	file:
tcl_yosys_cmd	yosys/kernel/yosys.cc	/^static int tcl_yosys_cmd(ClientData, Tcl_Interp *interp, int argc, const char *argv[])$/;"	f	typeref:typename:int	file:
tech	yosys/passes/cmds/stat.cc	/^	string tech;$/;"	m	struct:statdata_t	typeref:typename:string	file:
tech	yosys/passes/techmap/shregmap.cc	/^	ShregmapTech *tech;$/;"	m	struct:ShregmapOptions	typeref:typename:ShregmapTech *	file:
techinfo	yosys/passes/cmds/stat.cc	/^	std::map<RTLIL::IdString, int> techinfo;$/;"	m	struct:statdata_t	typeref:typename:std::map<RTLIL::IdString,int>	file:
techmap_cache	yosys/passes/techmap/techmap.cc	/^	dict<std::pair<IdString, dict<IdString, RTLIL::Const>>, RTLIL::Module*> techmap_cache;$/;"	m	struct:TechmapWorker	typeref:typename:dict<std::pair<IdString,dict<IdString,RTLIL::Const>>,RTLIL::Module * >	file:
techmap_do_cache	yosys/passes/techmap/techmap.cc	/^	dict<RTLIL::Module*, bool> techmap_do_cache;$/;"	m	struct:TechmapWorker	typeref:typename:dict<RTLIL::Module *,bool>	file:
techmap_find_special_wires	yosys/passes/techmap/techmap.cc	/^	TechmapWires techmap_find_special_wires(RTLIL::Module *module)$/;"	f	struct:TechmapWorker	typeref:typename:TechmapWires	file:
techmap_module	yosys/passes/techmap/techmap.cc	/^	bool techmap_module(RTLIL::Design *design, RTLIL::Module *module, RTLIL::Design *map, pool<RTLI/;"	f	struct:TechmapWorker	typeref:typename:bool	file:
techmap_module_worker	yosys/passes/techmap/techmap.cc	/^	void techmap_module_worker(RTLIL::Design *design, RTLIL::Module *module, RTLIL::Cell *cell, RTL/;"	f	struct:TechmapWorker	typeref:typename:void	file:
techmap_opts	yosys/passes/equiv/equiv_opt.cc	/^	std::string command, techmap_opts, make_opts;$/;"	m	struct:EquivOptPass	typeref:typename:std::string	file:
temp_signal_value_buf	yosys/libs/fst/fstapi.cc	/^    unsigned char *temp_signal_value_buf; \/* malloced for len in longest_signal_value_len *\/$/;"	m	struct:fstReaderContext	typeref:typename:unsigned char *	file:
tempdir_name	yosys/passes/techmap/abc.cc	/^	std::string tempdir_name;$/;"	m	struct:abc_output_filter	typeref:typename:std::string	file:
tempdir_name	yosys/passes/techmap/abc9_exe.cc	/^	std::string tempdir_name;$/;"	m	struct:abc9_output_filter	typeref:typename:std::string	file:
template_args	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string template_args(const RTLIL::Cell *cell)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
template_param_names	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::vector<std::string> template_param_names(const RTLIL::Module *module)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::vector<std::string>	file:
template_params	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::string template_params(const RTLIL::Module *module, bool is_decl)$/;"	f	struct:CxxrtlWorker	typeref:typename:std::string	file:
temporary	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	int temporary = 0;$/;"	m	struct:CxxrtlWorker	typeref:typename:int	file:
terminal_bits	yosys/passes/opt/share.cc	/^	pool<RTLIL::SigBit> terminal_bits;$/;"	m	struct:ShareWorker	typeref:typename:pool<RTLIL::SigBit>	file:
test	yosys/Makefile	/^test: $(TARGETS) $(EXTRA_TARGETS)$/;"	t
test	yosys/libs/bigint/Makefile	/^test: testsuite testsuite.expected$/;"	t
test	yosys/libs/ezsat/Makefile	/^test: all$/;"	t
test	yosys/libs/ezsat/testbench.cc	/^bool test(ezSAT &sat, int assumption = 0)$/;"	f	typeref:typename:bool
test	yosys/libs/subcircuit/Makefile	/^test: scshell$/;"	t
test	yosys/manual/CHAPTER_Prog/Makefile	/^test: stubnets.so$/;"	t
test0.log	yosys/manual/PRESENTATION_Prog/Makefile	/^test0.log: my_cmd.so$/;"	t
test1.log	yosys/manual/PRESENTATION_Prog/Makefile	/^test1.log: my_cmd.so$/;"	t
test2.log	yosys/manual/PRESENTATION_Prog/Makefile	/^test2.log: my_cmd.so$/;"	t
testForMining	yosys/libs/subcircuit/subcircuit.cc	/^	int testForMining(std::vector<Solver::MineResult> &results, std::set<NodeSet> &usedSets, std::s/;"	f	class:SubCircuit::SolverWorker	typeref:typename:int	file:
test_abcloop	yosys/passes/tests/test_abcloop.cc	/^static void test_abcloop()$/;"	f	typeref:typename:void	file:
test_arith	yosys/libs/ezsat/testbench.cc	/^void test_arith()$/;"	f	typeref:typename:void
test_cmp	yosys/libs/ezsat/demo_cmp.cc	/^void test_cmp(uint32_t a, uint32_t b)$/;"	f	typeref:typename:void
test_count	yosys/libs/ezsat/testbench.cc	/^void test_count(uint32_t x)$/;"	f	typeref:typename:void
test_manyhot	yosys/libs/ezsat/testbench.cc	/^void test_manyhot()$/;"	f	typeref:typename:void
test_onehot	yosys/libs/ezsat/testbench.cc	/^void test_onehot()$/;"	f	typeref:typename:void
test_ordered	yosys/libs/ezsat/testbench.cc	/^void test_ordered()$/;"	f	typeref:typename:void
test_signed	yosys/libs/ezsat/testbench.cc	/^void test_signed(int8_t a, int8_t b, int8_t c)$/;"	f	typeref:typename:void
test_simple	yosys/libs/ezsat/testbench.cc	/^void test_simple()$/;"	f	typeref:typename:void
test_unsigned	yosys/libs/ezsat/testbench.cc	/^void test_unsigned(uint8_t a, uint8_t b, uint8_t c)$/;"	f	typeref:typename:void
test_variable	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	bool test_variable(const variable &var) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:bool
test_xorshift32	yosys/libs/ezsat/testbench.cc	/^void test_xorshift32()$/;"	f	typeref:typename:void
test_xorshift32_try	yosys/libs/ezsat/testbench.cc	/^void test_xorshift32_try(ezSAT &sat, uint32_t input_pattern)$/;"	f	typeref:typename:void
testbench	yosys/libs/ezsat/Makefile	/^testbench: testbench.o ezsat.o ezminisat.o$/;"	t
testsuite	yosys/libs/bigint/Makefile	/^testsuite: testsuite.o $(library-objects)$/;"	t
testsuite-cleanfiles	yosys/libs/bigint/Makefile	/^testsuite-cleanfiles = \\$/;"	m
testsuite.expected	yosys/libs/bigint/Makefile	/^testsuite.expected: testsuite.cc$/;"	t
testsuite.o	yosys/libs/bigint/Makefile	/^testsuite.o: $(library-headers)$/;"	t
tf_node_types_t	yosys/passes/proc/proc_dlatch.cc	/^	enum tf_node_types_t : int {$/;"	g	struct:proc_dlatch_db_t	typeref:typename:int	file:
thaw	yosys/libs/minisat/SimpSolver.h	/^inline void SimpSolver::thaw(){$/;"	f	class:Minisat::SimpSolver	typeref:typename:void
the_false_node	yosys/kernel/cellaigs.cc	/^	int the_false_node;$/;"	m	struct:AigMaker	typeref:typename:int	file:
the_true_node	yosys/kernel/cellaigs.cc	/^	int the_true_node;$/;"	m	struct:AigMaker	typeref:typename:int	file:
thread	yosys/libs/fst/fstapi.cc	/^    pthread_t thread;$/;"	m	struct:fstWriterContext	typeref:typename:pthread_t	file:
thread_attr	yosys/libs/fst/fstapi.cc	/^    pthread_attr_t thread_attr;$/;"	m	struct:fstWriterContext	typeref:typename:pthread_attr_t	file:
throughout_sig	yosys/frontends/verific/verificsva.cc	/^	SigBit throughout_sig = State::S1;$/;"	m	struct:SvaFsm	typeref:typename:SigBit	file:
throughout_stack	yosys/frontends/verific/verificsva.cc	/^	vector<SigBit> throughout_stack;$/;"	m	struct:SvaFsm	typeref:typename:vector<SigBit>	file:
tie	yosys/passes/cmds/qwp.cc	/^		void tie(double v) {$/;"	f	struct:QwpWorker::Node	typeref:typename:void	file:
tied	yosys/passes/cmds/qwp.cc	/^		bool tied, alt_tied;$/;"	m	struct:QwpWorker::Node	typeref:typename:bool	file:
tim	yosys/libs/fst/fstapi.cc	/^    uint64_t tim;$/;"	m	struct:fstBlackoutChain	typeref:typename:uint64_t	file:
timeout	yosys/passes/sat/qbfsat.h	/^	int timeout = 0;$/;"	m	struct:QbfSolveOptions	typeref:typename:int
timeout	yosys/passes/sat/sat.cc	/^	int max_timestep, timeout;$/;"	m	struct:SatHelper	typeref:typename:int	file:
timescale	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	void timescale(unsigned number, const std::string &unit) {$/;"	f	class:cxxrtl::vcd_writer	typeref:typename:void
timescale	yosys/kernel/fstdata.h	/^	double timescale;$/;"	m	class:FstData	typeref:typename:double
timescale	yosys/libs/fst/fstapi.cc	/^    signed char timescale;$/;"	m	struct:fstReaderContext	typeref:typename:signed char	file:
timescale	yosys/passes/sat/sim.cc	/^	std::string timescale;$/;"	m	struct:SimWorker	typeref:typename:std::string	file:
timescale_str	yosys/kernel/fstdata.h	/^	std::string timescale_str;$/;"	m	class:FstData	typeref:typename:std::string
timestep	yosys/passes/sat/sat.cc	/^		int timestep, offset, width;$/;"	m	struct:SatHelper::ModelBlockInfo	typeref:typename:int	file:
timezero	yosys/libs/fst/fstapi.cc	/^    int64_t timezero;$/;"	m	struct:fstReaderContext	typeref:typename:int64_t	file:
timezero	yosys/libs/fst/fstapi.cc	/^    int64_t timezero;$/;"	m	struct:fstWriterContext	typeref:typename:int64_t	file:
tmp_file	yosys/kernel/fstdata.h	/^	std::string tmp_file;$/;"	m	class:FstData	typeref:typename:std::string
tmpfile_close	yosys/libs/fst/fstapi.cc	/^static void tmpfile_close(FILE **f, char **nam)$/;"	f	typeref:typename:void	file:
tmpfile_open	yosys/libs/fst/fstapi.cc	/^static FILE *tmpfile_open(char **nam)$/;"	f	typeref:typename:FILE *	file:
toBit	yosys/libs/subcircuit/subcircuit.cc	/^		int fromBit, toBit;$/;"	m	struct:SubCircuit::SolverWorker::DiBit	typeref:typename:int	file:
toDimacs	yosys/libs/minisat/Solver.cc	/^void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)$/;"	f	class:Solver	typeref:typename:void
toDimacs	yosys/libs/minisat/Solver.cc	/^void Solver::toDimacs(FILE* f, const vec<Lit>& assumps)$/;"	f	class:Solver	typeref:typename:void
toDimacs	yosys/libs/minisat/Solver.cc	/^void Solver::toDimacs(const char *file, const vec<Lit>& assumps)$/;"	f	class:Solver	typeref:typename:void
toDimacs	yosys/libs/minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file){ vec<Lit> as; toDimacs(file, as); }$/;"	f	class:Minisat::Solver	typeref:typename:void
toDimacs	yosys/libs/minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p){ vec<Lit> as; as.push(p); toDimac/;"	f	class:Minisat::Solver	typeref:typename:void
toDimacs	yosys/libs/minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q){ vec<Lit> as; as.push(p); /;"	f	class:Minisat::Solver	typeref:typename:void
toDimacs	yosys/libs/minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.pu/;"	f	class:Minisat::Solver	typeref:typename:void
toInt	yosys/libs/bigint/BigInteger.cc	/^int            BigInteger::toInt          () const { return convertToSignedPrimitive  <int  , un/;"	f	class:BigInteger	typeref:typename:int
toInt	yosys/libs/bigint/BigUnsigned.cc	/^int            BigUnsigned::toInt          () const { return convertToSignedPrimitive<         i/;"	f	class:BigUnsigned	typeref:typename:int
toInt	yosys/libs/minisat/SolverTypes.h	/^inline  int  toInt     (Lit p)              { return p.x; } $/;"	f	namespace:Minisat	typeref:typename:int
toInt	yosys/libs/minisat/SolverTypes.h	/^inline  int  toInt     (Var v)              { return v; } $/;"	f	namespace:Minisat	typeref:typename:int
toInt	yosys/libs/minisat/SolverTypes.h	/^inline int   toInt  (lbool l) { return l.value; }$/;"	f	namespace:Minisat	typeref:typename:int
toLbool	yosys/libs/minisat/SolverTypes.h	/^inline lbool toLbool(int   v) { return lbool((uint8_t)v);  }$/;"	f	namespace:Minisat	typeref:typename:lbool
toLit	yosys/libs/minisat/SolverTypes.h	/^inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } $/;"	f	namespace:Minisat	typeref:typename:Lit
toLong	yosys/libs/bigint/BigInteger.cc	/^long           BigInteger::toLong         () const { return convertToSignedPrimitive  <long , un/;"	f	class:BigInteger	typeref:typename:long
toLong	yosys/libs/bigint/BigUnsigned.cc	/^long           BigUnsigned::toLong         () const { return convertToSignedPrimitive<         l/;"	f	class:BigUnsigned	typeref:typename:long
toNode	yosys/libs/subcircuit/subcircuit.cc	/^		DiNode fromNode, toNode;$/;"	m	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:DiNode	file:
toPort	yosys/libs/subcircuit/subcircuit.cc	/^		std::string fromPort, toPort;$/;"	m	struct:SubCircuit::SolverWorker::DiBit	typeref:typename:std::string	file:
toShort	yosys/libs/bigint/BigInteger.cc	/^short          BigInteger::toShort        () const { return convertToSignedPrimitive  <short, un/;"	f	class:BigInteger	typeref:typename:short
toShort	yosys/libs/bigint/BigUnsigned.cc	/^short          BigUnsigned::toShort        () const { return convertToSignedPrimitive<         s/;"	f	class:BigUnsigned	typeref:typename:short
toString	yosys/libs/subcircuit/subcircuit.cc	/^		std::string toString() const$/;"	f	struct:SubCircuit::SolverWorker::DiBit	typeref:typename:std::string	file:
toString	yosys/libs/subcircuit/subcircuit.cc	/^		std::string toString() const$/;"	f	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:std::string	file:
toString	yosys/libs/subcircuit/subcircuit.cc	/^		std::string toString() const$/;"	f	struct:SubCircuit::SolverWorker::DiNode	typeref:typename:std::string	file:
toUnsignedInt	yosys/libs/bigint/BigInteger.cc	/^unsigned int   BigInteger::toUnsignedInt  () const { return convertToUnsignedPrimitive<unsigned /;"	f	class:BigInteger	typeref:typename:unsigned int
toUnsignedInt	yosys/libs/bigint/BigUnsigned.cc	/^unsigned int   BigUnsigned::toUnsignedInt  () const { return convertToPrimitive      <unsigned i/;"	f	class:BigUnsigned	typeref:typename:unsigned int
toUnsignedLong	yosys/libs/bigint/BigInteger.cc	/^unsigned long  BigInteger::toUnsignedLong () const { return convertToUnsignedPrimitive<unsigned /;"	f	class:BigInteger	typeref:typename:unsigned long
toUnsignedLong	yosys/libs/bigint/BigUnsigned.cc	/^unsigned long  BigUnsigned::toUnsignedLong () const { return convertToPrimitive      <unsigned l/;"	f	class:BigUnsigned	typeref:typename:unsigned long
toUnsignedShort	yosys/libs/bigint/BigInteger.cc	/^unsigned short BigInteger::toUnsignedShort() const { return convertToUnsignedPrimitive<unsigned /;"	f	class:BigInteger	typeref:typename:unsigned short
toUnsignedShort	yosys/libs/bigint/BigUnsigned.cc	/^unsigned short BigUnsigned::toUnsignedShort() const { return convertToPrimitive      <unsigned s/;"	f	class:BigUnsigned	typeref:typename:unsigned short
toVec	yosys/libs/minisat/IntMap.h	/^                 toVec       ()          const  { return xs; }$/;"	f	class:Minisat::IntSet	typeref:typename:const vec<K> &
to_big_endian	yosys/backends/aiger/xaiger.cc	/^inline int32_t to_big_endian(int32_t i32) {$/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN int32_t
to_cell	yosys/kernel/macc.h	/^	void to_cell(RTLIL::Cell *cell) const$/;"	f	struct:Macc	typeref:typename:void
to_pool	yosys/kernel/rtlil.h	/^		pool<T> to_pool() const { return *this; }$/;"	f	struct:RTLIL::ObjRange	typeref:typename:pool<T>
to_sigbit_dict	yosys/kernel/rtlil.cc	/^dict<RTLIL::SigBit, RTLIL::SigBit> RTLIL::SigSpec::to_sigbit_dict(const RTLIL::SigSpec &other) c/;"	f	class:RTLIL::SigSpec	typeref:typename:dict<RTLIL::SigBit,RTLIL::SigBit>
to_sigbit_map	yosys/kernel/rtlil.cc	/^std::map<RTLIL::SigBit, RTLIL::SigBit> RTLIL::SigSpec::to_sigbit_map(const RTLIL::SigSpec &other/;"	f	class:RTLIL::SigSpec	typeref:typename:std::map<RTLIL::SigBit,RTLIL::SigBit>
to_sigbit_pool	yosys/kernel/rtlil.cc	/^pool<RTLIL::SigBit> RTLIL::SigSpec::to_sigbit_pool() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:pool<RTLIL::SigBit>
to_sigbit_set	yosys/kernel/rtlil.cc	/^std::set<RTLIL::SigBit> RTLIL::SigSpec::to_sigbit_set() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:std::set<RTLIL::SigBit>
to_sigbit_vector	yosys/kernel/rtlil.cc	/^std::vector<RTLIL::SigBit> RTLIL::SigSpec::to_sigbit_vector() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:std::vector<RTLIL::SigBit>
to_string	yosys/libs/ezsat/ezsat.cc	/^std::string ezSAT::to_string(int id) const$/;"	f	class:ezSAT	typeref:typename:std::string
to_string	yosys/libs/subcircuit/subcircuit.cc	/^		std::string to_string() const {$/;"	f	struct:SubCircuit::SolverWorker::NodeSet	typeref:typename:std::string	file:
to_vector	yosys/kernel/rtlil.h	/^		std::vector<T> to_vector() const { return *this; }$/;"	f	struct:RTLIL::ObjRange	typeref:typename:std::vector<T>
token_t	yosys/frontends/liberty/liberty.cc	/^	token_t (char t) : type(t) { }$/;"	f	struct:token_t	file:
token_t	yosys/frontends/liberty/liberty.cc	/^	token_t (char t, RTLIL::SigSpec s) : type(t), sig(s) { }$/;"	f	struct:token_t	file:
token_t	yosys/frontends/liberty/liberty.cc	/^struct token_t {$/;"	s	file:
tokens	yosys/passes/memory/memory_bram.cc	/^	vector<string> tokens;$/;"	m	struct:rules_t	typeref:typename:vector<string>	file:
top	yosys/passes/sat/sim.cc	/^	SimInstance *top = nullptr;$/;"	m	struct:SimWorker	typeref:typename:SimInstance *	file:
top	yosys/passes/techmap/flowmap.cc	/^		static NodePrime top(RTLIL::SigBit node)$/;"	f	struct:FlowGraph::NodePrime	typeref:typename:NodePrime	file:
top-all	yosys/Makefile	/^top-all: $(TARGETS) $(EXTRA_TARGETS)$/;"	t
top_module	yosys/kernel/rtlil.cc	/^RTLIL::Module *RTLIL::Design::top_module()$/;"	f	class:RTLIL::Design	typeref:typename:RTLIL::Module *
top_module	yosys/techlibs/common/prep.cc	/^	string top_module, fsm_opts;$/;"	m	struct:PrepPass	typeref:typename:string	file:
top_module	yosys/techlibs/common/synth.cc	/^	string top_module, fsm_opts, memory_opts, abc;$/;"	m	struct:SynthPass	typeref:typename:string	file:
top_opt	yosys/techlibs/achronix/synth_achronix.cc	/^  string top_opt, family_opt, vout_file;$/;"	m	struct:SynthAchronixPass	typeref:typename:string	file:
top_opt	yosys/techlibs/anlogic/synth_anlogic.cc	/^	string top_opt, edif_file, json_file;$/;"	m	struct:SynthAnlogicPass	typeref:typename:string	file:
top_opt	yosys/techlibs/coolrunner2/synth_coolrunner2.cc	/^	string top_opt, json_file;$/;"	m	struct:SynthCoolrunner2Pass	typeref:typename:string	file:
top_opt	yosys/techlibs/easic/synth_easic.cc	/^	string top_opt, vlog_file, etools_path;$/;"	m	struct:SynthEasicPass	typeref:typename:string	file:
top_opt	yosys/techlibs/ecp5/synth_ecp5.cc	/^	string top_opt, blif_file, edif_file, json_file;$/;"	m	struct:SynthEcp5Pass	typeref:typename:string	file:
top_opt	yosys/techlibs/efinix/synth_efinix.cc	/^	string top_opt, edif_file, json_file;$/;"	m	struct:SynthEfinixPass	typeref:typename:string	file:
top_opt	yosys/techlibs/gatemate/synth_gatemate.cc	/^	string top_opt, vlog_file, json_file;$/;"	m	struct:SynthGateMatePass	typeref:typename:string	file:
top_opt	yosys/techlibs/gowin/synth_gowin.cc	/^	string top_opt, vout_file, json_file;$/;"	m	struct:SynthGowinPass	typeref:typename:string	file:
top_opt	yosys/techlibs/greenpak4/synth_greenpak4.cc	/^	string top_opt, part, json_file;$/;"	m	struct:SynthGreenPAK4Pass	typeref:typename:string	file:
top_opt	yosys/techlibs/ice40/synth_ice40.cc	/^	string top_opt, blif_file, edif_file, json_file, device_opt;$/;"	m	struct:SynthIce40Pass	typeref:typename:string	file:
top_opt	yosys/techlibs/intel/synth_intel.cc	/^	string top_opt, family_opt, vout_file, blif_file;$/;"	m	struct:SynthIntelPass	typeref:typename:string	file:
top_opt	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	string top_opt, family_opt, bram_type, vout_file;$/;"	m	struct:SynthIntelALMPass	typeref:typename:string	file:
top_opt	yosys/techlibs/machxo2/synth_machxo2.cc	/^	string top_opt, blif_file, edif_file, json_file;$/;"	m	struct:SynthMachXO2Pass	typeref:typename:string	file:
top_opt	yosys/techlibs/nexus/synth_nexus.cc	/^	string top_opt, json_file, vm_file, family;$/;"	m	struct:SynthNexusPass	typeref:typename:string	file:
top_opt	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	string top_opt, blif_file, family, currmodule, verilog_file;$/;"	m	struct:SynthQuickLogicPass	typeref:typename:string	file:
top_opt	yosys/techlibs/sf2/synth_sf2.cc	/^	string top_opt, edif_file, vlog_file, json_file;$/;"	m	struct:SynthSf2Pass	typeref:typename:string	file:
top_opt	yosys/techlibs/xilinx/synth_xilinx.cc	/^	std::string top_opt, edif_file, blif_file, family;$/;"	m	struct:SynthXilinxPass	typeref:typename:std::string	file:
topo_bit_drivers	yosys/passes/opt/share.cc	/^	std::map<RTLIL::SigBit, std::set<RTLIL::Cell*, cell_ptr_cmp>> topo_bit_drivers;$/;"	m	struct:ShareWorker	typeref:typename:std::map<RTLIL::SigBit,std::set<RTLIL::Cell *,cell_ptr_cmp>>	file:
topo_cell_drivers	yosys/passes/opt/share.cc	/^	std::map<RTLIL::Cell*, std::set<RTLIL::Cell*, cell_ptr_cmp>, cell_ptr_cmp> topo_cell_drivers;$/;"	m	struct:ShareWorker	typeref:typename:std::map<RTLIL::Cell *,std::set<RTLIL::Cell *,cell_ptr_cmp>,cell_ptr_cmp>	file:
topo_sigmap	yosys/passes/opt/share.cc	/^	SigMap topo_sigmap;$/;"	m	struct:ShareWorker	typeref:typename:SigMap	file:
topoidx	yosys/backends/simplec/simplec.cc	/^	dict<Cell*, int> topoidx;$/;"	m	struct:SimplecWorker	typeref:typename:dict<Cell *,int>	file:
tot_literals	yosys/libs/minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literal/;"	m	class:Minisat::Solver	typeref:typename:uint64_t
totalMatchesAfterLimits	yosys/libs/subcircuit/subcircuit.h	/^			int totalMatchesAfterLimits;$/;"	m	struct:SubCircuit::Solver::MineResult	typeref:typename:int
total_count	yosys/passes/opt/opt_merge.cc	/^	int total_count;$/;"	m	struct:OptMergeWorker	typeref:typename:int	file:
total_count	yosys/passes/opt/opt_reduce.cc	/^	int total_count;$/;"	m	struct:OptReduceWorker	typeref:typename:int	file:
total_input_width	yosys/passes/sat/eval.cc	/^	int total_input_width;$/;"	m	struct:VlogHammerReporter	typeref:typename:int	file:
total_ns	yosys/kernel/log.h	/^	int64_t total_ns;$/;"	m	struct:PerformanceTimer	typeref:typename:int64_t
touched	yosys/libs/minisat/SimpSolver.h	/^    VMap<char>          touched;$/;"	m	class:Minisat::SimpSolver	typeref:typename:VMap<char>
trail	yosys/libs/minisat/Solver.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in t/;"	m	class:Minisat::Solver	typeref:typename:vec<Lit>
trailBegin	yosys/libs/minisat/Solver.h	/^inline TrailIterator  Solver::trailBegin  () const { return TrailIterator(&trail[0]); }$/;"	f	class:Minisat::Solver	typeref:typename:TrailIterator
trailEnd	yosys/libs/minisat/Solver.h	/^inline TrailIterator  Solver::trailEnd    () const { $/;"	f	class:Minisat::Solver	typeref:typename:TrailIterator
trail_lim	yosys/libs/minisat/Solver.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels i/;"	m	class:Minisat::Solver	typeref:typename:vec<int>
trans	yosys/backends/smt2/smt2.cc	/^	std::vector<std::string> decls, trans, hier, dtmembers;$/;"	m	struct:Smt2Worker	typeref:typename:std::vector<std::string>	file:
transform	yosys/libs/sha1/sha1.cpp	/^void SHA1::transform(uint32_t block[BLOCK_BYTES])$/;"	f	class:SHA1	typeref:typename:void
transforms	yosys/libs/sha1/sha1.h	/^    uint64_t transforms;$/;"	m	class:SHA1	typeref:typename:uint64_t
transition_t	yosys/passes/fsm/fsmdata.h	/^	struct transition_t { int state_in, state_out; RTLIL::Const ctrl_in, ctrl_out; };$/;"	s	struct:FsmData
transition_table	yosys/passes/fsm/fsmdata.h	/^	std::vector<transition_t> transition_table;$/;"	m	struct:FsmData	typeref:typename:std::vector<transition_t>
translate_rd_feedback_to_en	yosys/passes/opt/opt_mem_feedback.cc	/^	void translate_rd_feedback_to_en(Mem &mem)$/;"	f	struct:OptMemFeedbackWorker	typeref:typename:void	file:
transp	yosys/passes/memory/memory_bram.cc	/^		int wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:int	file:
transp	yosys/passes/memory/memory_bram.cc	/^		vector<int> ports, wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::bram_t	typeref:typename:vector<int>	file:
transparency_mask	yosys/kernel/mem.h	/^	std::vector<bool> transparency_mask;$/;"	m	struct:MemRd	typeref:typename:std::vector<bool>
transparency_mask	yosys/passes/memory/memory_dff.cc	/^	std::vector<bool> transparency_mask;$/;"	m	struct:PortData	typeref:typename:std::vector<bool>	file:
tree_bit_slots	yosys/passes/techmap/maccmap.cc	/^	int tree_bit_slots(int n)$/;"	f	struct:MaccmapWorker	typeref:typename:int	file:
tree_list	yosys/passes/techmap/muxcover.cc	/^	vector<tree_t> tree_list;$/;"	m	struct:MuxcoverWorker	typeref:typename:vector<tree_t>	file:
tree_t	yosys/passes/techmap/muxcover.cc	/^	struct tree_t$/;"	s	struct:MuxcoverWorker	file:
treecover	yosys/passes/techmap/muxcover.cc	/^	void treecover(tree_t &tree)$/;"	f	struct:MuxcoverWorker	typeref:typename:void	file:
treeify	yosys/passes/techmap/muxcover.cc	/^	void treeify()$/;"	f	struct:MuxcoverWorker	typeref:typename:void	file:
trigger_sig	yosys/frontends/verific/verificsva.cc	/^	SigBit trigger_sig = State::S1, disable_sig;$/;"	m	struct:SvaFsm	typeref:typename:SigBit	file:
true_node	yosys/passes/proc/proc_dlatch.cc	/^		true_node = 1,$/;"	e	enum:proc_dlatch_db_t::tf_node_types_t	file:
true_out	yosys/backends/blif/blif.cc	/^	std::string true_type, true_out, false_type, false_out, undef_type, undef_out;$/;"	m	struct:BlifDumperConfig	typeref:typename:std::string	file:
true_type	yosys/backends/blif/blif.cc	/^	std::string true_type, true_out, false_type, false_out, undef_type, undef_out;$/;"	m	struct:BlifDumperConfig	typeref:typename:std::string	file:
trunc	yosys/backends/cxxrtl/cxxrtl.h	/^	value<NewBits> trunc() const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE value<NewBits>
try_expand_macro	yosys/frontends/verilog/preproc.cc	/^static bool try_expand_macro(define_map_t &defines, macro_arg_stack_t &macro_arg_stack, std::str/;"	f	typeref:typename:bool	file:
try_flip	yosys/passes/techmap/dfflegalize.cc	/^	bool try_flip(FfData &ff, int supported_mask) {$/;"	f	struct:DffLegalizePass	typeref:typename:bool	file:
try_pop_module_prefix	yosys/frontends/ast/simplify.cc	/^std::string AstNode::try_pop_module_prefix() const$/;"	f	class:AstNode	typeref:typename:std::string
typ	yosys/libs/fst/fstapi.h	/^            unsigned char typ;           \/* FST_VT_MIN ... FST_VT_MAX *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierVar	typeref:typename:unsigned char
typ	yosys/libs/fst/fstapi.h	/^            unsigned char typ;     \/* FST_AT_MIN ... FST_AT_MAX *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierAttr	typeref:typename:unsigned char
typ	yosys/libs/fst/fstapi.h	/^            unsigned char typ; \/* FST_ST_MIN ... FST_ST_MAX *\/$/;"	m	struct:fstHier::__anonafd27bad010a::fstHierScope	typeref:typename:unsigned char
type	yosys/backends/cxxrtl/cxxrtl.h	/^	using type = T;$/;"	t	struct:cxxrtl::chunk_traits	typeref:typename:T
type	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		Type type;$/;"	m	struct:FlowGraph::Node	typeref:typename:Type	file:
type	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	Type type = UNUSED;$/;"	m	struct:WireType	typeref:typename:Type	file:
type	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	uint32_t type; \/\/ actually `enum cxxrtl_type`$/;"	m	struct:cxxrtl_object	typeref:typename:uint32_t
type	yosys/frontends/ast/ast.h	/^		AstNodeType type;$/;"	m	struct:AST::AstNode	typeref:typename:AstNodeType
type	yosys/frontends/json/jsonparse.cc	/^	char type; \/\/ S=String, N=Number, A=Array, D=Dict$/;"	m	struct:JsonNode	typeref:typename:char	file:
type	yosys/frontends/liberty/liberty.cc	/^	char type;$/;"	m	struct:token_t	typeref:typename:char	file:
type	yosys/kernel/celltypes.h	/^	RTLIL::IdString type;$/;"	m	struct:CellType	typeref:typename:RTLIL::IdString
type	yosys/kernel/rtlil.h	/^	RTLIL::IdString type;$/;"	m	struct:RTLIL::Cell	typeref:typename:RTLIL::IdString
type	yosys/kernel/rtlil.h	/^	RTLIL::SyncType type;$/;"	m	struct:RTLIL::SyncRule	typeref:typename:RTLIL::SyncType
type	yosys/libs/json11/json11.cpp	/^    Json::Type type() const override {$/;"	f	class:json11::Value	typeref:typename:Json::Type	file:
type	yosys/libs/json11/json11.cpp	/^Json::Type Json::type()                           const { return m_ptr->type();         }$/;"	f	class:json11::Json	typeref:typename:Json::Type
type	yosys/passes/equiv/equiv_struct.cc	/^		IdString type;$/;"	m	struct:EquivStructWorker::merge_key_t	typeref:typename:IdString	file:
type	yosys/passes/techmap/abc.cc	/^	gate_type_t type;$/;"	m	struct:gate_t	typeref:typename:gate_type_t	file:
type2str	yosys/frontends/ast/ast.cc	/^std::string AST::type2str(AstNodeType type)$/;"	f	class:AST	typeref:typename:std::string
typeId	yosys/libs/subcircuit/subcircuit.cc	/^		std::string typeId;$/;"	m	struct:SubCircuit::SolverWorker::DiNode	typeref:typename:std::string	file:
typeId	yosys/libs/subcircuit/subcircuit.h	/^			std::string nodeId, typeId;$/;"	m	struct:SubCircuit::Graph::Node	typeref:typename:std::string
type_name	yosys/libs/minisat/Options.h	/^    const char* type_name;$/;"	m	class:Minisat::Option	typeref:typename:const char *
u	yosys/libs/fst/fstapi.h	/^    } u;$/;"	m	struct:fstHier	typeref:union:fstHier::__anonafd27bad010a
ucmp	yosys/backends/cxxrtl/cxxrtl.h	/^	bool ucmp(const value<Bits> &other) const {$/;"	f	struct:cxxrtl::value	typeref:typename:bool
udata	yosys/kernel/hashlib.h	/^		K udata;$/;"	m	struct:hashlib::pool::entry_t	typeref:typename:K
udata	yosys/kernel/hashlib.h	/^		std::pair<K, T> udata;$/;"	m	struct:hashlib::dict::entry_t	typeref:typename:std::pair<K,T>
uint_value	yosys/backends/cxxrtl/cxxrtl.h	/^	const unsigned    uint_value = 0;$/;"	m	struct:cxxrtl::metadata	typeref:typename:const unsigned
ullmannRecursion	yosys/libs/subcircuit/subcircuit.cc	/^	void ullmannRecursion(std::vector<Solver::Result> &results, std::vector<std::set<int>> &enumera/;"	f	class:SubCircuit::SolverWorker	typeref:typename:void	file:
unbuf_types	yosys/backends/blif/blif.cc	/^	std::map<RTLIL::IdString, std::pair<RTLIL::IdString, RTLIL::IdString>> unbuf_types;$/;"	m	struct:BlifDumperConfig	typeref:typename:std::map<RTLIL::IdString,std::pair<RTLIL::IdString,RTLIL::IdString>>	file:
unbuffer_internal	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool unbuffer_internal = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
unbuffer_public	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	bool unbuffer_public = false;$/;"	m	struct:CxxrtlWorker	typeref:typename:bool	file:
uncheckedEnqueue	yosys/libs/minisat/Solver.cc	/^void Solver::uncheckedEnqueue(Lit p, CRef from)$/;"	f	class:Solver	typeref:typename:void
uncollidable_mask	yosys/passes/memory/memory_dff.cc	/^	std::vector<bool> uncollidable_mask;$/;"	m	struct:PortData	typeref:typename:std::vector<bool>	file:
unconn_id	yosys/backends/firrtl/firrtl.cc	/^	string unconn_id;$/;"	m	struct:FirrtlWorker	typeref:typename:string	file:
undef	yosys/passes/equiv/equiv_opt.cc	/^	bool assert, undef, multiclock, async2sync;$/;"	m	struct:EquivOptPass	typeref:typename:bool	file:
undefGating	yosys/kernel/satgen.h	/^	void undefGating(int y, int yy, int undef)$/;"	f	struct:SatGen	typeref:typename:void
undefGating	yosys/kernel/satgen.h	/^	void undefGating(std::vector<int> &vec_y, std::vector<int> &vec_yy, std::vector<int> &vec_undef/;"	f	struct:SatGen	typeref:typename:void
undef_out	yosys/backends/blif/blif.cc	/^	std::string true_type, true_out, false_type, false_out, undef_type, undef_out;$/;"	m	struct:BlifDumperConfig	typeref:typename:std::string	file:
undef_type	yosys/backends/blif/blif.cc	/^	std::string true_type, true_out, false_type, false_out, undef_type, undef_out;$/;"	m	struct:BlifDumperConfig	typeref:typename:std::string	file:
undriven_bits	yosys/passes/equiv/equiv_make.cc	/^	pool<SigBit> undriven_bits;$/;"	m	struct:EquivMakeWorker	typeref:typename:pool<SigBit>	file:
undriven_signals	yosys/passes/equiv/equiv_induct.cc	/^	SigPool undriven_signals;$/;"	m	struct:EquivInductWorker	typeref:typename:SigPool	file:
unescape_id	yosys/kernel/rtlil.h	/^	static inline std::string unescape_id(RTLIL::IdString str) {$/;"	f	namespace:RTLIL	typeref:typename:std::string
unescape_id	yosys/kernel/rtlil.h	/^	static inline std::string unescape_id(const std::string &str) {$/;"	f	namespace:RTLIL	typeref:typename:std::string
unified_param	yosys/passes/techmap/extract.cc	/^	RTLIL::Const unified_param(RTLIL::IdString cell_type, RTLIL::IdString param, RTLIL::Const value/;"	f	class:SubCircuitSolver	typeref:typename:RTLIL::Const	file:
uninstall	yosys/Makefile	/^uninstall:$/;"	t
uniop2rtlil	yosys/frontends/ast/genrtlil.cc	/^static RTLIL::SigSpec uniop2rtlil(AstNode *that, IdString type, int result_width, const RTLIL::S/;"	f	typeref:typename:RTLIL::SigSpec	file:
uniquify	yosys/kernel/rtlil.cc	/^RTLIL::IdString RTLIL::Module::uniquify(RTLIL::IdString name)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::IdString
uniquify	yosys/kernel/rtlil.cc	/^RTLIL::IdString RTLIL::Module::uniquify(RTLIL::IdString name, int &index)$/;"	f	class:RTLIL::Module	typeref:typename:RTLIL::IdString
unit-test	yosys/Makefile	/^unit-test: libyosys.so$/;"	t
unknown	yosys/passes/sat/qbfsat.h	/^	bool unknown = true; \/\/true if neither 'sat' nor 'unsat'$/;"	m	struct:QbfSolutionType	typeref:typename:bool
unknown_cell_area	yosys/passes/cmds/stat.cc	/^	std::set<RTLIL::IdString> unknown_cell_area;$/;"	m	struct:statdata_t	typeref:typename:std::set<RTLIL::IdString>	file:
unlikely	yosys/libs/fst/lz4.cc	/^#define unlikely(/;"	d	file:
unlink	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^		void unlink()$/;"	f	struct:Scheduler::Vertex	typeref:typename:void	file:
unlink	yosys/libs/fst/fstapi.h	/^#define unlink /;"	d
unlink_fopen	yosys/libs/fst/fstapi.cc	/^static FILE *unlink_fopen(const char *nam, const char *mode)$/;"	f	typeref:typename:FILE *	file:
unmap_ce	yosys/kernel/ff.cc	/^void FfData::unmap_ce() {$/;"	f	class:FfData	typeref:typename:void
unmap_ce_srst	yosys/kernel/ff.h	/^	void unmap_ce_srst() {$/;"	f	struct:FfData	typeref:typename:void
unmap_srst	yosys/kernel/ff.cc	/^void FfData::unmap_srst() {$/;"	f	class:FfData	typeref:typename:void
unodes	yosys/frontends/verific/verificsva.cc	/^	vector<SvaUFsmNode> unodes;$/;"	m	struct:SvaFsm	typeref:typename:vector<SvaUFsmNode>	file:
unpack	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::unpack() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
unsat	yosys/passes/sat/qbfsat.h	/^	bool nobisection = false, sat = false, unsat = false, show_smtbmc = false;$/;"	m	struct:QbfSolveOptions	typeref:typename:bool
unset	yosys/kernel/utils.h	/^	void unset(const Key &k)$/;"	f	struct:stackmap	typeref:typename:void
unset	yosys/passes/cmds/setattr.cc	/^	bool unset;$/;"	m	struct:setunset_t	typeref:typename:bool	file:
unsetParam	yosys/kernel/rtlil.cc	/^void RTLIL::Cell::unsetParam(RTLIL::IdString paramname)$/;"	f	class:RTLIL::Cell	typeref:typename:void
unsetPort	yosys/kernel/rtlil.cc	/^void RTLIL::Cell::unsetPort(RTLIL::IdString portname)$/;"	f	class:RTLIL::Cell	typeref:typename:void
unset_dirty	yosys/backends/simplec/simplec.cc	/^	void unset_dirty(Cell *cell)$/;"	f	struct:HierDirtyFlags	typeref:typename:void	file:
unset_dirty	yosys/backends/simplec/simplec.cc	/^	void unset_dirty(SigBit bit)$/;"	f	struct:HierDirtyFlags	typeref:typename:void	file:
unset_drivers	yosys/passes/cmds/connect.cc	/^static void unset_drivers(RTLIL::Design *design, RTLIL::Module *module, SigMap &sigmap, RTLIL::S/;"	f	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN void	file:
unsets_at	yosys/passes/sat/sat.cc	/^	std::map<int, std::vector<std::string>> unsets_at;$/;"	m	struct:SatHelper	typeref:typename:std::map<int,std::vector<std::string>>	file:
up_bit2cells	yosys/passes/equiv/equiv_mark.cc	/^	dict<SigBit, pool<IdString>> up_bit2cells;$/;"	m	struct:EquivMarkWorker	typeref:typename:dict<SigBit,pool<IdString>>	file:
up_cell2bits	yosys/passes/equiv/equiv_mark.cc	/^	dict<IdString, pool<SigBit>> up_cell2bits;$/;"	m	struct:EquivMarkWorker	typeref:typename:dict<IdString,pool<SigBit>>	file:
upd_cells	yosys/passes/sat/sim.cc	/^	dict<SigBit, pool<Cell*>> upd_cells;$/;"	m	struct:SimInstance	typeref:typename:dict<SigBit,pool<Cell * >>	file:
upd_outports	yosys/passes/sat/sim.cc	/^	dict<SigBit, pool<Wire*>> upd_outports;$/;"	m	struct:SimInstance	typeref:typename:dict<SigBit,pool<Wire * >>	file:
update	yosys/backends/cxxrtl/cxxrtl.h	/^	value<Bits> update(const value<Bits> &val, const value<Bits> &mask) const {$/;"	f	struct:cxxrtl::value	typeref:typename:value<Bits>
update	yosys/backends/cxxrtl/cxxrtl.h	/^	void update(size_t index, const value<Width> &val, const value<Width> &mask, int priority = 0) /;"	f	struct:cxxrtl::memory	typeref:typename:void
update	yosys/libs/minisat/Heap.h	/^    void update(K k)$/;"	f	class:Minisat::Heap	typeref:typename:void
update	yosys/libs/sha1/sha1.cpp	/^void SHA1::update(const std::string &s)$/;"	f	class:SHA1	typeref:typename:void
update	yosys/libs/sha1/sha1.cpp	/^void SHA1::update(std::istream &is)$/;"	f	class:SHA1	typeref:typename:void
update	yosys/passes/sat/mutate.cc	/^	void update(const mutate_t &m) {$/;"	f	struct:coverdb_t	typeref:typename:void	file:
update	yosys/passes/sat/sim.cc	/^	void update()$/;"	f	struct:SimWorker	typeref:typename:void	file:
update-manual	yosys/Makefile	/^update-manual: $(TARGETS) $(EXTRA_TARGETS)$/;"	t
updateElimHeap	yosys/libs/minisat/SimpSolver.h	/^inline void SimpSolver::updateElimHeap(Var v) {$/;"	f	class:Minisat::SimpSolver	typeref:typename:void
update_breaking_node_potentials	yosys/passes/techmap/flowmap.cc	/^	void update_breaking_node_potentials(dict<RTLIL::SigBit, dict<RTLIL::SigBit, int>> &potentials,$/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
update_cell	yosys/passes/sat/sim.cc	/^	void update_cell(Cell *cell)$/;"	f	struct:SimInstance	typeref:typename:void	file:
update_lut_critical_outputs	yosys/passes/techmap/flowmap.cc	/^	void update_lut_critical_outputs(dict<RTLIL::SigBit, pool<RTLIL::SigBit>> &lut_critical_outputs/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
update_lut_depths_altitudes	yosys/passes/techmap/flowmap.cc	/^	void update_lut_depths_altitudes(pool<RTLIL::SigBit> worklist = {}, pool<RTLIL::SigBit> *change/;"	f	struct:FlowmapWorker	typeref:typename:void	file:
update_memory	yosys/passes/sat/sim.cc	/^	void update_memory(IdString id) {$/;"	f	struct:SimInstance	typeref:typename:void	file:
update_ph1	yosys/passes/sat/sim.cc	/^	void update_ph1()$/;"	f	struct:SimInstance	typeref:typename:void	file:
update_ph2	yosys/passes/sat/sim.cc	/^	bool update_ph2()$/;"	f	struct:SimInstance	typeref:typename:bool	file:
update_ph3	yosys/passes/sat/sim.cc	/^	void update_ph3()$/;"	f	struct:SimInstance	typeref:typename:void	file:
updhash	yosys/kernel/rtlil.cc	/^void RTLIL::SigSpec::updhash() const$/;"	f	class:RTLIL::SigSpec	typeref:typename:void
upto	yosys/kernel/rtlil.h	/^	bool port_input, port_output, upto, is_signed;$/;"	m	struct:RTLIL::Wire	typeref:typename:bool
uram	yosys/techlibs/xilinx/synth_xilinx.cc	/^	bool flatten, retime, ise, noiopad, noclkbuf, nobram, nolutram, nosrl, nocarry, nowidelut, nods/;"	m	struct:SynthXilinxPass	typeref:typename:bool	file:
usage	yosys/passes/techmap/libparse.cc	/^void usage()$/;"	f	typeref:typename:void
use_asymm	yosys/libs/minisat/SimpSolver.h	/^    bool    use_asymm;         \/\/ Shrink clauses by asymmetric branching.$/;"	m	class:Minisat::SimpSolver	typeref:typename:bool
use_elim	yosys/libs/minisat/SimpSolver.h	/^    bool    use_elim;          \/\/ Perform variable elimination.$/;"	m	class:Minisat::SimpSolver	typeref:typename:bool
use_mux16	yosys/passes/techmap/muxcover.cc	/^	bool use_mux16;$/;"	m	struct:MuxcoverWorker	typeref:typename:bool	file:
use_mux4	yosys/passes/techmap/muxcover.cc	/^	bool use_mux4;$/;"	m	struct:MuxcoverWorker	typeref:typename:bool	file:
use_mux8	yosys/passes/techmap/muxcover.cc	/^	bool use_mux8;$/;"	m	struct:MuxcoverWorker	typeref:typename:bool	file:
use_rcheck	yosys/libs/minisat/SimpSolver.h	/^    bool    use_rcheck;        \/\/ Check if a clause is already implied. Prett costly, and subs/;"	m	class:Minisat::SimpSolver	typeref:typename:bool
use_selection	yosys/backends/json/json.cc	/^	bool use_selection;$/;"	m	struct:JsonWriter	typeref:typename:bool	file:
use_selection_	yosys/backends/protobuf/protobuf.cc	/^	bool use_selection_;$/;"	m	struct:ProtobufDesignSerializer	typeref:typename:bool	file:
use_simplification	yosys/libs/minisat/SimpSolver.h	/^    bool                use_simplification;$/;"	m	class:Minisat::SimpSolver	typeref:typename:bool
use_vcd_extensions	yosys/libs/fst/fstapi.cc	/^    unsigned use_vcd_extensions : 1;$/;"	m	struct:fstReaderContext	typeref:typename:unsigned:1	file:
used	yosys/passes/sat/mutate.cc	/^	bool used = false;$/;"	m	struct:mutate_t	typeref:typename:bool	file:
usedNodes	yosys/libs/subcircuit/subcircuit.cc	/^		std::vector<bool> usedNodes;$/;"	m	struct:SubCircuit::SolverWorker::GraphData	typeref:typename:std::vector<bool>	file:
used_names	yosys/backends/edif/edif.cc	/^	std::set<std::string> generated_names, used_names;$/;"	m	struct:EdifNames	typeref:typename:std::set<std::string>	file:
used_names	yosys/backends/firrtl/firrtl.cc	/^pool<string> used_names;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN pool<string>
used_names	yosys/backends/smv/smv.cc	/^	pool<shared_str> used_names;$/;"	m	struct:SmvWorker	typeref:typename:pool<shared_str>	file:
userAnnotateEdge	yosys/libs/subcircuit/subcircuit.cc	/^std::string Solver::userAnnotateEdge(const std::string&, const std::string&, void*, const std::s/;"	f	class:Solver	typeref:typename:std::string
userAnnotation	yosys/libs/subcircuit/subcircuit.cc	/^		std::string userAnnotation;$/;"	m	struct:SubCircuit::SolverWorker::DiEdge	typeref:typename:std::string	file:
userCheckSolution	yosys/libs/subcircuit/subcircuit.cc	/^bool Solver::userCheckSolution(const Result&)$/;"	f	class:Solver	typeref:typename:bool
userCompareEdge	yosys/libs/subcircuit/subcircuit.cc	/^bool Solver::userCompareEdge(const std::string&, const std::string&, void*, const std::string&, /;"	f	class:Solver	typeref:typename:bool
userCompareNodes	yosys/libs/subcircuit/subcircuit.cc	/^bool Solver::userCompareNodes(const std::string&, const std::string&, void*, const std::string&,/;"	f	class:Solver	typeref:typename:bool
userCompareNodes	yosys/passes/techmap/extract.cc	/^	virtual bool userCompareNodes(const std::string &, const std::string &, void *needleUserData,$/;"	f	class:SubCircuitSolver	typeref:typename:bool	file:
userData	yosys/libs/subcircuit/subcircuit.h	/^			void *userData;$/;"	m	struct:SubCircuit::Graph::Node	typeref:typename:void *
userData	yosys/libs/subcircuit/subcircuit.h	/^			void *userData;$/;"	m	struct:SubCircuit::Solver::MineResultNode	typeref:typename:void *
userSolver	yosys/libs/subcircuit/subcircuit.cc	/^	Solver *userSolver;$/;"	m	class:SubCircuit::SolverWorker	typeref:typename:Solver *	file:
user_info	yosys/libs/fst/fstapi.cc	/^    void *user_info;$/;"	m	struct:fstCurrHier	typeref:typename:void *	file:
user_pol	yosys/libs/minisat/Solver.h	/^    VMap<lbool>         user_pol;         \/\/ The users preferred polarity of each variable.$/;"	m	class:Minisat::Solver	typeref:typename:VMap<lbool>
users	yosys/passes/techmap/alumacc.cc	/^		int users;$/;"	m	struct:AlumaccWorker::maccnode_t	typeref:typename:int	file:
usingExtDict	yosys/libs/fst/lz4.cc	/^    usingExtDict$/;"	e	enum:__anon9390dffe0503	file:
usortint	yosys/frontends/verific/verificsva.cc	/^	void usortint(vector<int> &vec)$/;"	f	struct:SvaFsm	typeref:typename:void	file:
util_declarations	yosys/backends/simplec/simplec.cc	/^	vector<string> util_declarations;$/;"	m	struct:SimplecWorker	typeref:typename:vector<string>	file:
util_get_bit	yosys/backends/simplec/simplec.cc	/^	string util_get_bit(const string &signame, int n, int idx)$/;"	f	struct:SimplecWorker	typeref:typename:string	file:
util_ifdef_guard	yosys/backends/simplec/simplec.cc	/^	void util_ifdef_guard(string s)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
util_set_bit	yosys/backends/simplec/simplec.cc	/^	string util_set_bit(const string &signame, int n, int idx, const string &expr)$/;"	f	struct:SimplecWorker	typeref:typename:string	file:
val	yosys/backends/cxxrtl/cxxrtl.h	/^		value<Width> val;$/;"	m	struct:cxxrtl::memory::write	typeref:typename:value<Width>
val	yosys/backends/cxxrtl/cxxrtl.h	/^	const value<Bits> &val() const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE const value<Bits> &
val	yosys/backends/cxxrtl/cxxrtl.h	/^	value<bits> val() const {$/;"	f	struct:cxxrtl::concat_expr	typeref:typename:CXXRTL_ALWAYS_INLINE value<bits>
val	yosys/backends/cxxrtl/cxxrtl.h	/^	value<bits> val() const {$/;"	f	struct:cxxrtl::slice_expr	typeref:typename:CXXRTL_ALWAYS_INLINE value<bits>
val	yosys/frontends/ast/ast.h	/^			RTLIL::Const val;$/;"	m	struct:AST::AstNode::varinfo_t	typeref:typename:RTLIL::Const
val_arr	yosys/libs/fst/fstapi.h	/^    char **val_arr;$/;"	m	struct:fstETab	typeref:typename:char **
val_arst	yosys/kernel/ff.h	/^	Const val_arst;$/;"	m	struct:FfData	typeref:typename:Const
val_init	yosys/kernel/ff.h	/^	Const val_init;$/;"	m	struct:FfData	typeref:typename:Const
val_srst	yosys/kernel/ff.h	/^	Const val_srst;$/;"	m	struct:FfData	typeref:typename:Const
valid	yosys/backends/cxxrtl/cxxrtl.h	/^	bool valid;$/;"	m	struct:cxxrtl_yosys::memory_index	typeref:typename:bool
validate_design_and_get_inputs	yosys/passes/sat/qbfsat.cc	/^pool<std::string> validate_design_and_get_inputs(RTLIL::Module *module, bool assume_outputs) {$/;"	f	typeref:typename:pool<std::string>
valpos_handle	yosys/libs/fst/fstapi.cc	/^    FILE *valpos_handle;$/;"	m	struct:fstWriterContext	typeref:typename:FILE *	file:
valpos_handle_nam	yosys/libs/fst/fstapi.cc	/^    char *valpos_handle_nam;$/;"	m	struct:fstWriterContext	typeref:typename:char *	file:
valpos_mem	yosys/libs/fst/fstapi.cc	/^    uint32_t *valpos_mem;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t *	file:
value	yosys/backends/cxxrtl/cxxrtl.h	/^	explicit constexpr value(Init ...init) : data{init...} {}$/;"	f	struct:cxxrtl::value
value	yosys/backends/cxxrtl/cxxrtl.h	/^struct value : public expr_base<value<Bits>> {$/;"	s	namespace:cxxrtl
value	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::value(bool val)$/;"	f	class:ezSAT	typeref:typename:int
value	yosys/libs/minisat/Options.h	/^    bool value;$/;"	m	class:Minisat::BoolOption	typeref:typename:bool
value	yosys/libs/minisat/Options.h	/^    const char* value;$/;"	m	class:Minisat::StringOption	typeref:typename:const char *
value	yosys/libs/minisat/Options.h	/^    double      value;$/;"	m	class:Minisat::DoubleOption	typeref:typename:double
value	yosys/libs/minisat/Options.h	/^    int32_t  value;$/;"	m	class:Minisat::IntOption	typeref:typename:int32_t
value	yosys/libs/minisat/Options.h	/^    int64_t  value;$/;"	m	class:Minisat::Int64Option	typeref:typename:int64_t
value	yosys/libs/minisat/Solver.h	/^inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver	typeref:typename:lbool
value	yosys/libs/minisat/Solver.h	/^inline lbool    Solver::value         (Var x) const   { return assigns[x]; }$/;"	f	class:Minisat::Solver	typeref:typename:lbool
value	yosys/libs/minisat/SolverTypes.h	/^    uint8_t value;$/;"	m	class:Minisat::lbool	typeref:typename:uint8_t
value	yosys/passes/cmds/setattr.cc	/^	RTLIL::Const value;$/;"	m	struct:setunset_t	typeref:typename:RTLIL::Const	file:
value	yosys/passes/techmap/attrmap.cc	/^	string name, value;$/;"	m	struct:AttrmapRemove	typeref:typename:string	file:
value	yosys/passes/techmap/libparse.h	/^		std::string id, value;$/;"	m	struct:Yosys::LibertyAst	typeref:typename:std::string
value	yosys/passes/techmap/techmap.cc	/^		RTLIL::SigSpec value;$/;"	m	struct:TechmapWorker::TechmapWireData	typeref:typename:RTLIL::SigSpec	file:
valueOf	yosys/kernel/fstdata.cc	/^std::string FstData::valueOf(fstHandle signal)$/;"	f	class:FstData	typeref:typename:std::string
value_type	yosys/backends/cxxrtl/cxxrtl.h	/^	} value_type;$/;"	m	struct:cxxrtl::metadata	typeref:typename:const enum cxxrtl::metadata::__anon481ec9d40203
value_type	yosys/kernel/rtlil.h	/^		using value_type = T;$/;"	t	struct:RTLIL::ObjIterator	typeref:typename:T
values_map	yosys/frontends/aiger/aigerparse.cc	/^	dict<RTLIL::SigBit, RTLIL::State> values_map;$/;"	m	struct:ConstEvalAig	typeref:typename:dict<RTLIL::SigBit,RTLIL::State>	file:
values_map	yosys/kernel/consteval.h	/^	SigMap values_map;$/;"	m	struct:ConstEval	typeref:typename:SigMap
var	yosys/libs/ezsat/puzzle3d.cc	/^	int var;$/;"	m	struct:blockgeom_t	typeref:typename:int	file:
var	yosys/libs/fst/fstapi.h	/^        } var;$/;"	m	union:fstHier::__anonafd27bad010a	typeref:struct:fstHier::__anonafd27bad010a::fstHierVar
var	yosys/libs/minisat/SolverTypes.h	/^inline  int  var       (Lit p)              { return p.x >> 1; }$/;"	f	namespace:Minisat	typeref:typename:int
varBumpActivity	yosys/libs/minisat/Solver.h	/^inline void Solver::varBumpActivity(Var v) { varBumpActivity(v, var_inc); }$/;"	f	class:Minisat::Solver	typeref:typename:void
varBumpActivity	yosys/libs/minisat/Solver.h	/^inline void Solver::varBumpActivity(Var v, double inc) {$/;"	f	class:Minisat::Solver	typeref:typename:void
varDecayActivity	yosys/libs/minisat/Solver.h	/^inline void Solver::varDecayActivity() { var_inc *= (1 \/ var_decay); }$/;"	f	class:Minisat::Solver	typeref:typename:void
var_Undef	yosys/libs/minisat/SolverTypes.h	/^  const Var var_Undef = -1;$/;"	v	namespace:Minisat	typeref:typename:const Var
var_Undef	yosys/libs/minisat/SolverTypes.h	/^#define var_Undef /;"	d
var_count	yosys/libs/fst/fstapi.cc	/^    uint64_t var_count;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
var_decay	yosys/libs/minisat/Solver.h	/^    double    var_decay;$/;"	m	class:Minisat::Solver	typeref:typename:double
var_inc	yosys/libs/minisat/Solver.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:Minisat::Solver	typeref:typename:double
vardata	yosys/libs/minisat/Solver.h	/^    VMap<VarData>       vardata;          \/\/ Stores reason and level for each variable.$/;"	m	class:Minisat::Solver	typeref:typename:VMap<VarData>
variable	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	struct variable {$/;"	s	class:cxxrtl::vcd_writer
variables	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^	std::vector<variable> variables;$/;"	m	class:cxxrtl::vcd_writer	typeref:typename:std::vector<variable>
variant	yosys/passes/memory/memory_bram.cc	/^		int variant;$/;"	m	struct:rules_t::bram_t	typeref:typename:int	file:
varinfo_t	yosys/frontends/ast/ast.h	/^		struct varinfo_t {$/;"	s	struct:AST::AstNode
vars	yosys/backends/smv/smv.cc	/^	vector<string> inputvars, vars, definitions, assignments, invarspecs;$/;"	m	struct:SmvWorker	typeref:typename:vector<string>	file:
vars	yosys/kernel/fstdata.h	/^	std::vector<FstVar> vars;$/;"	m	class:FstData	typeref:typename:std::vector<FstVar>
vartypes	yosys/libs/fst/fstapi.cc	/^static const char *vartypes[] = {"event",   "integer",  "parameter", "real",   "real_parameter",/;"	v	typeref:typename:const char * []	file:
vc_emitted	yosys/libs/fst/fstapi.cc	/^    unsigned vc_emitted : 1;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned:1	file:
vc_section_count	yosys/libs/fst/fstapi.cc	/^    uint64_t vc_section_count;$/;"	m	struct:fstReaderContext	typeref:typename:uint64_t	file:
vcd_writer	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^class vcd_writer {$/;"	c	namespace:cxxrtl
vcdfile	yosys/passes/sat/sim.cc	/^	std::ofstream vcdfile;$/;"	m	struct:VCDWriter	typeref:typename:std::ofstream	file:
vchg_alloc_siz	yosys/libs/fst/fstapi.cc	/^    uint32_t vchg_alloc_siz;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t	file:
vchg_mem	yosys/libs/fst/fstapi.cc	/^    unsigned char *vchg_mem;$/;"	m	struct:fstWriterContext	typeref:typename:unsigned char *	file:
vchg_siz	yosys/libs/fst/fstapi.cc	/^    uint32_t vchg_siz;$/;"	m	struct:fstWriterContext	typeref:typename:uint32_t	file:
vcxsrc	yosys/Makefile	/^vcxsrc: $(GENFILES) $(EXTRA_TARGETS)$/;"	t
vec	yosys/libs/ezsat/ezsat.cc	/^ezSATvec ezSAT::vec(const std::vector<int> &vec)$/;"	f	class:ezSAT	typeref:typename:ezSATvec
vec	yosys/libs/ezsat/ezsat.h	/^	std::vector<int> vec;$/;"	m	struct:ezSATvec	typeref:typename:std::vector<int>
vec	yosys/libs/minisat/Vec.h	/^    explicit vec(Size size)      : data(NULL), sz(0), cap(0)    { growTo(size); }$/;"	f	class:Minisat::vec
vec	yosys/libs/minisat/Vec.h	/^    vec()                        : data(NULL), sz(0), cap(0)    { }$/;"	f	class:Minisat::vec
vec	yosys/libs/minisat/Vec.h	/^    vec(Size size, const T& pad) : data(NULL), sz(0), cap(0)    { growTo(size, pad); }$/;"	f	class:Minisat::vec
vec	yosys/libs/minisat/Vec.h	/^class vec {$/;"	c	namespace:Minisat
vec_add	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_add(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_and	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_and(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_append	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::vec_append(std::vector<int> &vec, const std::vector<int> &vec1) const$/;"	f	class:ezSAT	typeref:typename:void
vec_append_signed	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::vec_append_signed(std::vector<int> &vec, const std::vector<int> &vec1, int64_t value/;"	f	class:ezSAT	typeref:typename:void
vec_append_unsigned	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::vec_append_unsigned(std::vector<int> &vec, const std::vector<int> &vec1, uint64_t va/;"	f	class:ezSAT	typeref:typename:void
vec_cast	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_cast(const std::vector<int> &vec1, int toBits, bool signExtend)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_cmp	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::vec_cmp(const std::vector<int> &vec1, const std::vector<int> &vec2, int &carry, int /;"	f	class:ezSAT	typeref:typename:void
vec_const	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_const(const std::vector<bool> &bits)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_const_signed	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_const_signed(int64_t value, int numBits)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_const_unsigned	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_const_unsigned(uint64_t value, int numBits)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_count	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_count(const std::vector<int> &vec, int numBits, bool clip)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_eq	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_eq(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:int
vec_ge_signed	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_ge_signed(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:int
vec_ge_unsigned	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_ge_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:int
vec_gt_signed	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_gt_signed(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:int
vec_gt_unsigned	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_gt_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:int
vec_iff	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_iff(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_ite	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_ite(const std::vector<int> &vec1, const std::vector<int> &vec2, cons/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_ite	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_ite(int sel, const std::vector<int> &vec1, const std::vector<int> &v/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_le_signed	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_le_signed(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:int
vec_le_unsigned	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_le_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:int
vec_lt_signed	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_lt_signed(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:int
vec_lt_unsigned	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_lt_unsigned(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:int
vec_model_get_signed	yosys/libs/ezsat/ezsat.cc	/^int64_t ezSAT::vec_model_get_signed(const std::vector<int> &modelExpressions, const std::vector</;"	f	class:ezSAT	typeref:typename:int64_t
vec_model_get_unsigned	yosys/libs/ezsat/ezsat.cc	/^uint64_t ezSAT::vec_model_get_unsigned(const std::vector<int> &modelExpressions, const std::vect/;"	f	class:ezSAT	typeref:typename:uint64_t
vec_ne	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_ne(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:int
vec_neg	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_neg(const std::vector<int> &vec)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_not	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_not(const std::vector<int> &vec1)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_or	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_or(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_reduce_and	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_reduce_and(const std::vector<int> &vec1)$/;"	f	class:ezSAT	typeref:typename:int
vec_reduce_or	yosys/libs/ezsat/ezsat.cc	/^int ezSAT::vec_reduce_or(const std::vector<int> &vec1)$/;"	f	class:ezSAT	typeref:typename:int
vec_set	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::vec_set(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:void
vec_set_signed	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::vec_set_signed(const std::vector<int> &vec1, int64_t value)$/;"	f	class:ezSAT	typeref:typename:void
vec_set_unsigned	yosys/libs/ezsat/ezsat.cc	/^void ezSAT::vec_set_unsigned(const std::vector<int> &vec1, uint64_t value)$/;"	f	class:ezSAT	typeref:typename:void
vec_shift	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_shift(const std::vector<int> &vec1, int shift, int extend_left, int /;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_shift_left	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_shift_left(const std::vector<int> &vec1, const std::vector<int> &vec/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_shift_right	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_shift_right(const std::vector<int> &vec1, const std::vector<int> &ve/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_shl	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_shl(const std::vector<int> &vec1, int shift, bool signExtend)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_shr	yosys/libs/ezsat/ezsat.h	/^	std::vector<int> vec_shr(const std::vector<int> &vec1, int shift, bool signExtend = false) { re/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_srl	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_srl(const std::vector<int> &vec1, int shift)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_srr	yosys/libs/ezsat/ezsat.h	/^	std::vector<int> vec_srr(const std::vector<int> &vec1, int shift) { return vec_srl(vec1, -shift/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_sub	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_sub(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_var	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_var(int numBits)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_var	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_var(std::string name, int numBits)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
vec_xor	yosys/libs/ezsat/ezsat.cc	/^std::vector<int> ezSAT::vec_xor(const std::vector<int> &vec1, const std::vector<int> &vec2)$/;"	f	class:ezSAT	typeref:typename:std::vector<int>
verbose	yosys/backends/btor/btor.cc	/^	bool verbose;$/;"	m	struct:BtorWorker	typeref:typename:bool	file:
verbose	yosys/backends/simplec/simplec.cc	/^	bool verbose = false;$/;"	m	struct:SimplecWorker	typeref:typename:bool	file:
verbose	yosys/backends/smt2/smt2.cc	/^	bool bvmode, memmode, wiresmode, verbose, statebv, statedt, forallmode;$/;"	m	struct:Smt2Worker	typeref:typename:bool	file:
verbose	yosys/backends/smv/smv.cc	/^	bool verbose;$/;"	m	struct:SmvWorker	typeref:typename:bool	file:
verbose	yosys/backends/verilog/verilog_backend.cc	/^bool verbose, norename, noattr, attr2comment, noexpr, nodec, nohex, nostr, extmem, defparam, dec/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN bool
verbose	yosys/libs/subcircuit/subcircuit.cc	/^	bool verbose;$/;"	m	class:SubCircuit::SolverWorker	typeref:typename:bool	file:
verbose	yosys/passes/cmds/qwp.cc	/^	bool verbose;$/;"	m	struct:QwpConfig	typeref:typename:bool	file:
verbose	yosys/passes/equiv/equiv_simple.cc	/^	bool verbose;$/;"	m	struct:EquivSimpleWorker	typeref:typename:bool	file:
verbose	yosys/passes/opt/pmux2shiftx.cc	/^	bool verbose = false;$/;"	m	struct:OnehotDatabase	typeref:typename:bool	file:
verbose	yosys/passes/sat/sim.cc	/^	bool verbose = true;$/;"	m	struct:SimShared	typeref:typename:bool	file:
verbose	yosys/passes/techmap/extract_fa.cc	/^	bool verbose = false;$/;"	m	struct:ExtractFaConfig	typeref:typename:bool	file:
verbose_level	yosys/passes/sat/freduce.cc	/^int verbose_level, reduce_counter, reduce_stop_at;$/;"	v	typeref:typename:int
verbosity	yosys/libs/minisat/Solver.h	/^    int       verbosity;$/;"	m	class:Minisat::Solver	typeref:typename:int
verific_error_msg	yosys/frontends/verific/verific.cc	/^string verific_error_msg;$/;"	v	typeref:typename:string
verific_import	yosys/frontends/verific/verific.cc	/^void verific_import(Design *design, const std::map<std::string,std::string> &parameters, std::st/;"	f	typeref:typename:void
verific_import_pending	yosys/frontends/verific/verific.cc	/^bool verific_import_pending;$/;"	v	typeref:typename:bool
verific_import_sva_assert	yosys/frontends/verific/verificsva.cc	/^void verific_import_sva_assert(VerificImporter *importer, Instance *inst)$/;"	f	typeref:typename:void
verific_import_sva_assume	yosys/frontends/verific/verificsva.cc	/^void verific_import_sva_assume(VerificImporter *importer, Instance *inst)$/;"	f	typeref:typename:void
verific_import_sva_cover	yosys/frontends/verific/verificsva.cc	/^void verific_import_sva_cover(VerificImporter *importer, Instance *inst)$/;"	f	typeref:typename:void
verific_import_sva_trigger	yosys/frontends/verific/verificsva.cc	/^void verific_import_sva_trigger(VerificImporter *importer, Instance *inst)$/;"	f	typeref:typename:void
verific_incdirs	yosys/frontends/verific/verific.cc	/^vector<string> verific_incdirs, verific_libdirs;$/;"	v	typeref:typename:vector<string>
verific_is_sva_net	yosys/frontends/verific/verificsva.cc	/^bool verific_is_sva_net(VerificImporter *importer, Verific::Net *net)$/;"	f	typeref:typename:bool
verific_libdirs	yosys/frontends/verific/verific.cc	/^vector<string> verific_incdirs, verific_libdirs;$/;"	v	typeref:typename:vector<string>
verific_sva_fsm_limit	yosys/frontends/verific/verific.cc	/^int verific_sva_fsm_limit;$/;"	v	typeref:typename:int
verific_sva_prims	yosys/frontends/verific/verificsva.cc	/^pool<int> verific_sva_prims = {$/;"	v	typeref:typename:PRIVATE_NAMESPACE_END YOSYS_NAMESPACE_BEGIN pool<int>
verific_verbose	yosys/frontends/verific/verific.cc	/^int verific_verbose;$/;"	v	typeref:typename:YOSYS_NAMESPACE_BEGIN int
verilog_defaults	yosys/frontends/verilog/verilog_frontend.cc	/^static std::vector<std::string> verilog_defaults;$/;"	v	typeref:typename:std::vector<std::string>	file:
verilog_defaults_stack	yosys/frontends/verilog/verilog_frontend.cc	/^static std::list<std::vector<std::string>> verilog_defaults_stack;$/;"	v	typeref:typename:std::list<std::vector<std::string>>	file:
verilog_defines	yosys/kernel/rtlil.h	/^	std::unique_ptr<define_map_t> verilog_defines;$/;"	m	struct:RTLIL::Design	typeref:typename:std::unique_ptr<define_map_t>
verilog_file	yosys/techlibs/quicklogic/synth_quicklogic.cc	/^	string top_opt, blif_file, family, currmodule, verilog_file;$/;"	m	struct:SynthQuickLogicPass	typeref:typename:string	file:
verilog_globals	yosys/kernel/rtlil.h	/^	std::vector<AST::AstNode*> verilog_packages, verilog_globals;$/;"	m	struct:RTLIL::Design	typeref:typename:std::vector<AST::AstNode * >
verilog_packages	yosys/kernel/rtlil.h	/^	std::vector<AST::AstNode*> verilog_packages, verilog_globals;$/;"	m	struct:RTLIL::Design	typeref:typename:std::vector<AST::AstNode * >
version	yosys/libs/fst/fstapi.cc	/^    char version[FST_HDR_SIM_VERSION_SIZE + 1];$/;"	m	struct:fstReaderContext	typeref:typename:char[]	file:
vertices	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	std::vector<Vertex*> vertices;$/;"	m	struct:Scheduler	typeref:typename:std::vector<Vertex * >	file:
vgtest	yosys/Makefile	/^vgtest: $(TARGETS) $(EXTRA_TARGETS)$/;"	t
visit_connections	yosys/passes/hierarchy/hierarchy.cc	/^	void visit_connections(const RTLIL::Cell &cell,$/;"	f	struct:IFExpander	typeref:typename:void	file:
visited	yosys/passes/equiv/equiv_mark.cc	/^	pool<SigBit> queue, visited;$/;"	m	struct:EquivMarkWorker	typeref:typename:pool<SigBit>	file:
visited_muxes	yosys/passes/opt/opt_muxtree.cc	/^		vector<bool> visited_muxes;$/;"	m	struct:OptMuxtreeWorker::knowledge_t	typeref:typename:vector<bool>	file:
viz.js	yosys/Makefile	/^viz.js:$/;"	t
vlog_file	yosys/techlibs/easic/synth_easic.cc	/^	string top_opt, vlog_file, etools_path;$/;"	m	struct:SynthEasicPass	typeref:typename:string	file:
vlog_file	yosys/techlibs/gatemate/synth_gatemate.cc	/^	string top_opt, vlog_file, json_file;$/;"	m	struct:SynthGateMatePass	typeref:typename:string	file:
vlog_file	yosys/techlibs/sf2/synth_sf2.cc	/^	string top_opt, edif_file, vlog_file, json_file;$/;"	m	struct:SynthSf2Pass	typeref:typename:string	file:
vloghtb	yosys/Makefile	/^vloghtb: $(TARGETS) $(EXTRA_TARGETS)$/;"	t
vm_file	yosys/techlibs/nexus/synth_nexus.cc	/^	string top_opt, json_file, vm_file, family;$/;"	m	struct:SynthNexusPass	typeref:typename:string	file:
vout_file	yosys/techlibs/achronix/synth_achronix.cc	/^  string top_opt, family_opt, vout_file;$/;"	m	struct:SynthAchronixPass	typeref:typename:string	file:
vout_file	yosys/techlibs/gowin/synth_gowin.cc	/^	string top_opt, vout_file, json_file;$/;"	m	struct:SynthGowinPass	typeref:typename:string	file:
vout_file	yosys/techlibs/intel/synth_intel.cc	/^	string top_opt, family_opt, vout_file, blif_file;$/;"	m	struct:SynthIntelPass	typeref:typename:string	file:
vout_file	yosys/techlibs/intel_alm/synth_intel_alm.cc	/^	string top_opt, family_opt, bram_type, vout_file;$/;"	m	struct:SynthIntelALMPass	typeref:typename:string	file:
vpr	yosys/techlibs/ecp5/synth_ecp5.cc	/^	bool noccu2, nodffe, nobram, nolutram, nowidelut, asyncprld, flatten, dff, retime, abc2, abc9, /;"	m	struct:SynthEcp5Pass	typeref:typename:bool	file:
vpr	yosys/techlibs/ice40/synth_ice40.cc	/^	bool nocarry, nodffe, nobram, dsp, flatten, retime, noabc, abc2, vpr, abc9, dff, flowmap;$/;"	m	struct:SynthIce40Pass	typeref:typename:bool	file:
vpr	yosys/techlibs/machxo2/synth_machxo2.cc	/^	bool flatten, vpr, noiopad;$/;"	m	struct:SynthMachXO2Pass	typeref:typename:bool	file:
vstringf	yosys/kernel/yosys.cc	/^std::string vstringf(const char *fmt, va_list ap)$/;"	f	typeref:typename:std::string
w	yosys/libs/ezsat/testbench.cc	/^	uint32_t x, y, z, w;$/;"	m	struct:xorshift128	typeref:typename:uint32_t	file:
w	yosys/passes/sat/mutate.cc	/^	uint32_t y = 0, z = 0, w = 0;$/;"	m	struct:xs128_t	typeref:typename:uint32_t	file:
walk_muxes	yosys/passes/memory/memory_dff.cc	/^	SigSpec walk_muxes(SigSpec data, std::vector<MuxData> &res) {$/;"	f	struct:MemoryDffWorker	typeref:typename:SigSpec	file:
walk_up_mux_cond	yosys/passes/memory/memory_dff.cc	/^	bool walk_up_mux_cond(SigBit sel, bool neg_sel, SigBit &bit) {$/;"	f	struct:MemQueryCache	typeref:typename:bool	file:
was_checked	yosys/frontends/ast/ast.h	/^		bool is_input, is_output, is_reg, is_logic, is_signed, is_string, is_wand, is_wor, range_valid/;"	m	struct:AST::AstNode	typeref:typename:bool
wasted	yosys/libs/minisat/Alloc.h	/^    uint32_t wasted    () const      { return wasted_; }$/;"	f	class:Minisat::RegionAllocator	typeref:typename:uint32_t
wasted	yosys/libs/minisat/SolverTypes.h	/^    uint32_t wasted    () const      { return ra.wasted(); }$/;"	f	class:Minisat::ClauseAllocator	typeref:typename:uint32_t
wasted_	yosys/libs/minisat/Alloc.h	/^    uint32_t  wasted_;$/;"	m	class:Minisat::RegionAllocator	typeref:typename:uint32_t
watches	yosys/libs/minisat/Solver.h	/^                        watches;          \/\/ 'watches[lit]' is a list of constraints watching /;"	m	class:Minisat::Solver	typeref:typename:OccLists<Lit,vec<Watcher>,WatcherDeleted,MkIndexLit>
weight_cover	yosys/passes/sat/mutate.cc	/^	int weight_cover = 500;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
weight_pq_b	yosys/passes/sat/mutate.cc	/^	int weight_pq_b = 100;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
weight_pq_c	yosys/passes/sat/mutate.cc	/^	int weight_pq_c = 100;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
weight_pq_mb	yosys/passes/sat/mutate.cc	/^	int weight_pq_mb = 100;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
weight_pq_mc	yosys/passes/sat/mutate.cc	/^	int weight_pq_mc = 100;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
weight_pq_ms	yosys/passes/sat/mutate.cc	/^	int weight_pq_ms = 100;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
weight_pq_mw	yosys/passes/sat/mutate.cc	/^	int weight_pq_mw = 100;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
weight_pq_s	yosys/passes/sat/mutate.cc	/^	int weight_pq_s = 100;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
weight_pq_w	yosys/passes/sat/mutate.cc	/^	int weight_pq_w = 100;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
whitelist	yosys/passes/techmap/libparse.cc	/^std::set<std::string> LibertyAst::whitelist;$/;"	m	class:LibertyAst	typeref:typename:std::set<std::string>
whitelist	yosys/passes/techmap/libparse.h	/^		static std::set<std::string> whitelist;$/;"	m	struct:Yosys::LibertyAst	typeref:typename:std::set<std::string>
wide_chunk_t	yosys/backends/cxxrtl/cxxrtl.h	/^typedef uint64_t wide_chunk_t;$/;"	t	namespace:cxxrtl	typeref:typename:uint64_t
wide_log2	yosys/kernel/mem.h	/^	int wide_log2;$/;"	m	struct:MemRd	typeref:typename:int
wide_log2	yosys/kernel/mem.h	/^	int wide_log2;$/;"	m	struct:MemWr	typeref:typename:int
widelut_size	yosys/techlibs/xilinx/synth_xilinx.cc	/^	int widelut_size;$/;"	m	struct:SynthXilinxPass	typeref:typename:int	file:
widemux	yosys/techlibs/xilinx/synth_xilinx.cc	/^	int widemux;$/;"	m	struct:SynthXilinxPass	typeref:typename:int	file:
widen_prep	yosys/kernel/mem.cc	/^void Mem::widen_prep(int wide_log2) {$/;"	f	class:Mem	typeref:typename:void
widen_wr_port	yosys/kernel/mem.cc	/^void Mem::widen_wr_port(int idx, int wide_log2) {$/;"	f	class:Mem	typeref:typename:void
wideports	yosys/frontends/aiger/aigerparse.h	/^    bool wideports;$/;"	m	struct:AigerReader	typeref:typename:bool
wideports_split	yosys/frontends/blif/blifparse.cc	/^static std::pair<RTLIL::IdString, int> wideports_split(std::string name)$/;"	f	typeref:typename:std::pair<RTLIL::IdString,int>	file:
width	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	size_t width;$/;"	m	struct:cxxrtl_object	typeref:typename:size_t
width	yosys/backends/cxxrtl/cxxrtl_vcd.h	/^		size_t width;$/;"	m	struct:cxxrtl::vcd_writer::variable	typeref:typename:size_t
width	yosys/kernel/bitpattern.h	/^	int width;$/;"	m	struct:BitPatternPool	typeref:typename:int
width	yosys/kernel/ff.h	/^	int width;$/;"	m	struct:FfData	typeref:typename:int
width	yosys/kernel/fstdata.h	/^	int width;$/;"	m	struct:FstVar	typeref:typename:int
width	yosys/kernel/mem.h	/^	int width, start_offset, size;$/;"	m	struct:Mem	typeref:typename:int
width	yosys/kernel/rtlil.h	/^	int width, offset;$/;"	m	struct:RTLIL::SigChunk	typeref:typename:int
width	yosys/kernel/rtlil.h	/^	int width, start_offset, port_id;$/;"	m	struct:RTLIL::Wire	typeref:typename:int
width	yosys/kernel/rtlil.h	/^	int width, start_offset, size;$/;"	m	struct:RTLIL::Memory	typeref:typename:int
width	yosys/passes/sat/sat.cc	/^		int timestep, offset, width;$/;"	m	struct:SatHelper::ModelBlockInfo	typeref:typename:int	file:
width	yosys/passes/techmap/extract_counter.cc	/^	int width;						\/\/counter width$/;"	m	struct:CounterExtraction	typeref:typename:int	file:
width	yosys/passes/techmap/maccmap.cc	/^	int width;$/;"	m	struct:MaccmapWorker	typeref:typename:int	file:
widthExtend	yosys/frontends/ast/genrtlil.cc	/^static void widthExtend(AstNode *that, RTLIL::SigSpec &sig, int width, bool is_signed)$/;"	f	typeref:typename:void	file:
widthLabel	yosys/passes/cmds/show.cc	/^	std::string widthLabel(int bits)$/;"	f	struct:ShowWorker	typeref:typename:std::string	file:
width_	yosys/kernel/rtlil.h	/^	int width_;$/;"	m	struct:RTLIL::SigSpec	typeref:typename:int
widthparam	yosys/passes/cmds/connwrappers.cc	/^		std::string widthparam, signparam;$/;"	m	struct:ConnwrappersWorker::portdecl_t	typeref:typename:std::string	file:
wire	yosys/backends/cxxrtl/cxxrtl.h	/^	explicit constexpr wire(Init ...init) : curr{init...}, next{init...} {}$/;"	f	struct:cxxrtl::wire
wire	yosys/backends/cxxrtl/cxxrtl.h	/^	explicit constexpr wire(const value<Bits> &init) : curr(init), next(init) {}$/;"	f	struct:cxxrtl::wire
wire	yosys/backends/cxxrtl/cxxrtl.h	/^struct wire {$/;"	s	namespace:cxxrtl
wire	yosys/kernel/rtlil.h	/^	RTLIL::Wire *wire;$/;"	m	struct:RTLIL::SigBit	typeref:typename:RTLIL::Wire *
wire	yosys/kernel/rtlil.h	/^	RTLIL::Wire *wire;$/;"	m	struct:RTLIL::SigChunk	typeref:typename:RTLIL::Wire *
wire	yosys/kernel/rtlil.h	/^	RTLIL::Wire* wire(RTLIL::IdString id) {$/;"	f	struct:RTLIL::Module	typeref:typename:RTLIL::Wire *
wire	yosys/kernel/rtlil.h	/^	const RTLIL::Wire* wire(RTLIL::IdString id) const{$/;"	f	struct:RTLIL::Module	typeref:typename:const RTLIL::Wire *
wire	yosys/passes/sat/mutate.cc	/^	IdString module, cell, port, wire;$/;"	m	struct:mutate_opts_t	typeref:typename:IdString	file:
wire	yosys/passes/sat/mutate.cc	/^	IdString port, wire;$/;"	m	struct:mutate_t	typeref:typename:IdString	file:
wire	yosys/passes/techmap/techmap.cc	/^		RTLIL::Wire *wire;$/;"	m	struct:TechmapWorker::TechmapWireData	typeref:typename:RTLIL::Wire *	file:
wire_attr	yosys/passes/techmap/extract.cc	/^	std::set<RTLIL::IdString> cell_attr, wire_attr;$/;"	m	class:SubCircuitSolver	typeref:typename:std::set<RTLIL::IdString>	file:
wire_comb_defs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Wire*, pool<Node*, hash_ptr_ops>> wire_comb_defs, wire_sync_defs, wire_uses;$/;"	m	struct:FlowGraph	typeref:typename:dict<const RTLIL::Wire *,pool<Node *,hash_ptr_ops>>	file:
wire_db	yosys/passes/sat/mutate.cc	/^	dict<tuple<IdString, IdString>, int> wire_db;$/;"	m	struct:coverdb_t	typeref:typename:dict<tuple<IdString,IdString>,int>	file:
wire_def_inlinable	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Wire*, bool> wire_def_inlinable;$/;"	m	struct:FlowGraph	typeref:typename:dict<const RTLIL::Wire *,bool>	file:
wire_flags	yosys/passes/hierarchy/submod.cc	/^	std::map<RTLIL::Wire*, wire_flags_t> wire_flags;$/;"	m	struct:SubmodWorker	typeref:typename:std::map<RTLIL::Wire *,wire_flags_t>	file:
wire_flags_t	yosys/passes/hierarchy/submod.cc	/^		wire_flags_t(RTLIL::Wire* wire) : new_wire(nullptr), is_int_driven(State::S0, GetSize(wire)), /;"	f	struct:SubmodWorker::wire_flags_t	file:
wire_flags_t	yosys/passes/hierarchy/submod.cc	/^	struct wire_flags_t {$/;"	s	struct:SubmodWorker	file:
wire_init	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Wire*, RTLIL::Const> wire_init;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<const RTLIL::Wire *,RTLIL::Const>	file:
wire_names	yosys/passes/equiv/equiv_make.cc	/^	pool<IdString> wire_names, cell_names;$/;"	m	struct:EquivMakeWorker	typeref:typename:pool<IdString>	file:
wire_sync_defs	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Wire*, pool<Node*, hash_ptr_ops>> wire_comb_defs, wire_sync_defs, wire_uses;$/;"	m	struct:FlowGraph	typeref:typename:dict<const RTLIL::Wire *,pool<Node *,hash_ptr_ops>>	file:
wire_types	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Wire*, WireType> wire_types, debug_wire_types;$/;"	m	struct:CxxrtlWorker	typeref:typename:dict<const RTLIL::Wire *,WireType>	file:
wire_use_inlinable	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Wire*, dict<Node*, bool, hash_ptr_ops>> wire_use_inlinable;$/;"	m	struct:FlowGraph	typeref:typename:dict<const RTLIL::Wire *,dict<Node *,bool,hash_ptr_ops>>	file:
wire_uses	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	dict<const RTLIL::Wire*, pool<Node*, hash_ptr_ops>> wire_comb_defs, wire_sync_defs, wire_uses;$/;"	m	struct:FlowGraph	typeref:typename:dict<const RTLIL::Wire *,pool<Node *,hash_ptr_ops>>	file:
wirebit	yosys/passes/sat/mutate.cc	/^	int wirebit = -1;$/;"	m	struct:mutate_opts_t	typeref:typename:int	file:
wirebit	yosys/passes/sat/mutate.cc	/^	int wirebit = -1;$/;"	m	struct:mutate_t	typeref:typename:int	file:
wirebit_db	yosys/passes/sat/mutate.cc	/^	dict<tuple<IdString, IdString, int>, int> wirebit_db;$/;"	m	struct:coverdb_t	typeref:typename:dict<tuple<IdString,IdString,int>,int>	file:
wires	yosys/kernel/rtlil.h	/^	RTLIL::ObjRange<RTLIL::Wire*> wires() { return RTLIL::ObjRange<RTLIL::Wire*>(&wires_, &refcount/;"	f	struct:RTLIL::Module	typeref:typename:RTLIL::ObjRange<RTLIL::Wire * >
wires_	yosys/kernel/rtlil.h	/^	dict<RTLIL::IdString, RTLIL::Wire*> wires_;$/;"	m	struct:RTLIL::Module	typeref:typename:dict<RTLIL::IdString,RTLIL::Wire * >
wires_p	yosys/kernel/rtlil.cc	/^		const pool<RTLIL::Wire*> *wires_p;$/;"	m	struct:RTLIL::Module::remove::DeleteWireWorker	typeref:typename:const pool<RTLIL::Wire * > *	file:
wiresmode	yosys/backends/smt2/smt2.cc	/^	bool bvmode, memmode, wiresmode, verbose, statebv, statedt, forallmode;$/;"	m	struct:Smt2Worker	typeref:typename:bool	file:
withPrefix64k	yosys/libs/fst/lz4.cc	/^    withPrefix64k,$/;"	e	enum:__anon9390dffe0503	file:
withinBudget	yosys/libs/minisat/Solver.h	/^inline bool     Solver::withinBudget() const {$/;"	f	class:Minisat::Solver	typeref:typename:bool
work	yosys/passes/cmds/connwrappers.cc	/^	void work(RTLIL::Module *module)$/;"	f	struct:ConnwrappersWorker	typeref:typename:void	file:
workQueue	yosys/passes/cmds/scc.cc	/^	std::set<RTLIL::Cell*> workQueue;$/;"	m	struct:SccWorker	typeref:typename:std::set<RTLIL::Cell * >	file:
work_queue_bits	yosys/passes/opt/wreduce.cc	/^	std::set<SigBit> work_queue_bits;$/;"	m	struct:WreduceWorker	typeref:typename:std::set<SigBit>	file:
work_queue_cells	yosys/passes/opt/wreduce.cc	/^	std::set<Cell*, IdString::compare_ptr_by_name<Cell>> work_queue_cells;$/;"	m	struct:WreduceWorker	typeref:typename:std::set<Cell *,IdString::compare_ptr_by_name<Cell>>	file:
work_stack	yosys/passes/cmds/select.cc	/^static std::vector<RTLIL::Selection> work_stack;$/;"	v	typeref:typename:std::vector<RTLIL::Selection>	file:
worker	yosys/libs/subcircuit/subcircuit.h	/^		SolverWorker *worker;$/;"	m	class:SubCircuit::Solver	typeref:typename:SolverWorker *
worker	yosys/passes/sat/sim.cc	/^	SimWorker *worker;$/;"	m	struct:OutputWriter	typeref:typename:SimWorker *	file:
workset	yosys/passes/equiv/equiv_induct.cc	/^	pool<Cell*> workset;$/;"	m	struct:EquivInductWorker	typeref:typename:pool<Cell * >	file:
wr_ports	yosys/kernel/mem.cc	/^		dict<IdString, pool<Cell *>> wr_ports;$/;"	m	struct:__anon62474a9e0111::MemIndex	typeref:typename:dict<IdString,pool<Cell * >>	file:
wr_ports	yosys/kernel/mem.h	/^	std::vector<MemWr> wr_ports;$/;"	m	struct:Mem	typeref:typename:std::vector<MemWr>
wrap_async_control	yosys/passes/sat/clk2fflogic.cc	/^	SigSpec wrap_async_control(Module *module, SigSpec sig, bool polarity, IdString past_sig_id) {$/;"	f	struct:Clk2fflogicPass	typeref:typename:SigSpec	file:
wrap_async_control	yosys/passes/sat/clk2fflogic.cc	/^	SigSpec wrap_async_control(Module *module, SigSpec sig, bool polarity, bool is_fine, IdString p/;"	f	struct:Clk2fflogicPass	typeref:typename:SigSpec	file:
wrap_async_control_gate	yosys/passes/sat/clk2fflogic.cc	/^	SigSpec wrap_async_control_gate(Module *module, SigSpec sig, bool polarity, IdString past_sig_i/;"	f	struct:Clk2fflogicPass	typeref:typename:SigSpec	file:
writable_memories	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	pool<std::pair<const RTLIL::Module*, RTLIL::IdString>> writable_memories;$/;"	m	struct:CxxrtlWorker	typeref:typename:pool<std::pair<const RTLIL::Module *,RTLIL::IdString>>	file:
write	yosys/backends/cxxrtl/cxxrtl.h	/^	struct write {$/;"	s	struct:cxxrtl::memory
write	yosys/backends/simplec/simplec.cc	/^	void write(std::ostream &f)$/;"	f	struct:SimplecWorker	typeref:typename:void	file:
write	yosys/backends/smt2/smt2.cc	/^	void write(std::ostream &f)$/;"	f	struct:Smt2Worker	typeref:typename:void	file:
write	yosys/frontends/rpc/rpc_frontend.cc	/^	void write(const std::string &data) override {$/;"	f	struct:FdRpcServer	typeref:typename:void	file:
write	yosys/frontends/rpc/rpc_frontend.cc	/^	void write(const std::string &data) override {$/;"	f	struct:HandleRpcServer	typeref:typename:void	file:
write	yosys/passes/sat/sim.cc	/^	void write(std::map<int, bool> &) override$/;"	f	struct:AIWWriter	typeref:typename:void	file:
write	yosys/passes/sat/sim.cc	/^	void write(std::map<int, bool> &use_signal) override$/;"	f	struct:FSTWriter	typeref:typename:void	file:
write	yosys/passes/sat/sim.cc	/^	void write(std::map<int, bool> &use_signal) override$/;"	f	struct:VCDWriter	typeref:typename:void	file:
write_aiger	yosys/backends/aiger/aiger.cc	/^	void write_aiger(std::ostream &f, bool ascii_mode, bool miter_mode, bool symbols_mode)$/;"	f	struct:AigerWriter	typeref:typename:void	file:
write_aiger	yosys/backends/aiger/xaiger.cc	/^	void write_aiger(std::ostream &f, bool ascii_mode)$/;"	f	struct:XAigerWriter	typeref:typename:void	file:
write_box	yosys/passes/techmap/abc9_ops.cc	/^void write_box(RTLIL::Module *module, const std::string &dst) {$/;"	f	typeref:typename:void
write_cell	yosys/backends/jny/jny.cc	/^    void write_cell(Cell* cell, uint16_t indent_level = 0) {$/;"	f	struct:JnyWriter	typeref:typename:void	file:
write_cell_conn	yosys/backends/jny/jny.cc	/^    void write_cell_conn(const std::pair<RTLIL::IdString, RTLIL::SigSpec>& sig, uint16_t indent_/;"	f	struct:JnyWriter	typeref:typename:void	file:
write_cell_ports	yosys/backends/jny/jny.cc	/^    void write_cell_ports(RTLIL::Cell* port_cell, uint64_t indent_level = 0) {$/;"	f	struct:JnyWriter	typeref:typename:void	file:
write_cell_sort	yosys/backends/jny/jny.cc	/^    void write_cell_sort(std::pair<const std::string, std::vector<Cell*>>& sort, uint16_t indent/;"	f	struct:JnyWriter	typeref:typename:void	file:
write_design	yosys/backends/json/json.cc	/^	void write_design(Design *design_)$/;"	f	struct:JsonWriter	typeref:typename:void	file:
write_html	yosys/kernel/register.cc	/^	void write_html(FILE *idxf, std::string cmd, std::string title, std::string text)$/;"	f	struct:HelpPass	typeref:typename:void	file:
write_kiss2	yosys/passes/fsm/fsm_export.cc	/^void write_kiss2(struct RTLIL::Module *module, struct RTLIL::Cell *cell, std::string filename, b/;"	f	typeref:typename:void
write_lut	yosys/passes/techmap/abc9_ops.cc	/^void write_lut(RTLIL::Module *module, const std::string &dst) {$/;"	f	typeref:typename:void
write_map	yosys/backends/aiger/aiger.cc	/^	void write_map(std::ostream &f, bool verbose_map, bool no_startoffset)$/;"	f	struct:AigerWriter	typeref:typename:void	file:
write_map	yosys/backends/aiger/xaiger.cc	/^	void write_map(std::ostream &f)$/;"	f	struct:XAigerWriter	typeref:typename:void	file:
write_metadata	yosys/backends/jny/jny.cc	/^    void write_metadata(Design *design, uint16_t indent_level = 0)$/;"	f	struct:JnyWriter	typeref:typename:void	file:
write_mod_conn	yosys/backends/jny/jny.cc	/^    void write_mod_conn(const std::pair<RTLIL::SigSpec, RTLIL::SigSpec>& conn, uint16_t indent_l/;"	f	struct:JnyWriter	typeref:typename:void	file:
write_module	yosys/backends/jny/jny.cc	/^    void write_module(Module* mod, uint16_t indent_level = 0) {$/;"	f	struct:JnyWriter	typeref:typename:void	file:
write_module	yosys/backends/json/json.cc	/^	void write_module(Module *module_)$/;"	f	struct:JsonWriter	typeref:typename:void	file:
write_output_files	yosys/passes/sat/sim.cc	/^	void write_output_files()$/;"	f	struct:SimWorker	typeref:typename:void	file:
write_output_header	yosys/passes/sat/sim.cc	/^	void write_output_header(std::function<void(IdString)> enter_scope, std::function<void()> exit_/;"	f	struct:SimInstance	typeref:typename:void	file:
write_param_val	yosys/backends/jny/jny.cc	/^    void write_param_val(const Const& v) {$/;"	f	struct:JnyWriter	typeref:typename:void	file:
write_parameter_value	yosys/backends/json/json.cc	/^	void write_parameter_value(const Const &value)$/;"	f	struct:JsonWriter	typeref:typename:void	file:
write_parameters	yosys/backends/json/json.cc	/^	void write_parameters(const dict<IdString, Const> &parameters, bool for_module=false)$/;"	f	struct:JsonWriter	typeref:typename:void	file:
write_prams	yosys/backends/jny/jny.cc	/^    void write_prams(dict<RTLIL::IdString, RTLIL::Const>& params, uint16_t indent_level = 0) {$/;"	f	struct:JnyWriter	typeref:typename:void	file:
write_queue	yosys/backends/cxxrtl/cxxrtl.h	/^	std::vector<write> write_queue;$/;"	m	struct:cxxrtl::memory	typeref:typename:std::vector<write>
write_sigspec	yosys/backends/jny/jny.cc	/^    void write_sigspec(const RTLIL::SigSpec& sig, uint16_t indent_level = 0) {$/;"	f	struct:JnyWriter	typeref:typename:void	file:
write_soln_soln_file	yosys/passes/sat/qbfsat.h	/^	std::string write_soln_soln_file = "";$/;"	m	struct:QbfSolveOptions	typeref:typename:std::string
write_solution	yosys/passes/sat/qbfsat.h	/^	bool specialize = false, specialize_from_file = false, write_solution = false, nocleanup = fals/;"	m	struct:QbfSolveOptions	typeref:typename:bool
write_solution	yosys/passes/sat/qbfsat.h	/^	void write_solution(RTLIL::Module *module, const std::string &file) const {$/;"	f	struct:QbfSolutionType	typeref:typename:void
write_tex	yosys/kernel/register.cc	/^	void write_tex(FILE *f, std::string cmd, std::string title, std::string text)$/;"	f	struct:HelpPass	typeref:typename:void	file:
writeback	yosys/passes/sat/sim.cc	/^	bool writeback = false;$/;"	m	struct:SimShared	typeref:typename:bool	file:
writeback	yosys/passes/sat/sim.cc	/^	void writeback(pool<Module*> &wbmods)$/;"	f	struct:SimInstance	typeref:typename:void	file:
writer	yosys/backends/cxxrtl/cxxrtl_vcd_capi.cc	/^	cxxrtl::vcd_writer writer;$/;"	m	struct:_cxxrtl_vcd	typeref:typename:cxxrtl::vcd_writer	file:
writex_buf	yosys/libs/fst/fstapi.cc	/^    unsigned char writex_buf[FST_WRITEX_MAX];$/;"	m	struct:fstReaderContext	typeref:typename:unsigned char[]	file:
writex_fd	yosys/libs/fst/fstapi.cc	/^    int writex_fd;$/;"	m	struct:fstReaderContext	typeref:typename:int	file:
writex_pos	yosys/libs/fst/fstapi.cc	/^    int writex_pos;$/;"	m	struct:fstReaderContext	typeref:typename:int	file:
wrmode	yosys/passes/memory/memory_bram.cc	/^		int wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::portinfo_t	typeref:typename:int	file:
wrmode	yosys/passes/memory/memory_bram.cc	/^		vector<int> ports, wrmode, enable, transp, clocks, clkpol;$/;"	m	struct:rules_t::bram_t	typeref:typename:vector<int>	file:
wrport_idx	yosys/passes/opt/opt_mem_feedback.cc	/^	int wrport_idx;$/;"	m	struct:FeedbackPath	typeref:typename:int	file:
wstr2str	yosys/frontends/rpc/rpc_frontend.cc	/^static std::string wstr2str(const std::wstring &in) {$/;"	f	typeref:typename:std::string	file:
x	yosys/libs/ezsat/testbench.cc	/^	uint32_t x, y, z, w;$/;"	m	struct:xorshift128	typeref:typename:uint32_t	file:
x	yosys/libs/minisat/SolverTypes.h	/^    int     x;$/;"	m	struct:Minisat::Lit	typeref:typename:int
x	yosys/passes/sat/mutate.cc	/^	uint32_t x = 123456789;$/;"	m	struct:xs128_t	typeref:typename:uint32_t	file:
xc_parent	yosys/libs/fst/fstapi.cc	/^    struct fstWriterContext *xc_parent;$/;"	m	struct:fstWriterContext	typeref:struct:fstWriterContext *	file:
xcmp	yosys/passes/techmap/muxcover.cc	/^	bool xcmp(std::initializer_list<SigBit> list)$/;"	f	struct:MuxcoverWorker	typeref:typename:bool	file:
xilinx_dsp48a_pack	yosys/passes/pmgen/xilinx_dsp.cc	/^void xilinx_dsp48a_pack(xilinx_dsp48a_pm &pm)$/;"	f	typeref:typename:void
xilinx_dsp_pack	yosys/passes/pmgen/xilinx_dsp.cc	/^void xilinx_dsp_pack(xilinx_dsp_pm &pm)$/;"	f	typeref:typename:void
xilinx_dsp_packC	yosys/passes/pmgen/xilinx_dsp.cc	/^void xilinx_dsp_packC(xilinx_dsp_CREG_pm &pm)$/;"	f	typeref:typename:void
xilinx_simd_pack	yosys/passes/pmgen/xilinx_dsp.cc	/^void xilinx_simd_pack(Module *module, const std::vector<Cell*> &selected_cells)$/;"	f	typeref:typename:void
xnor2_func	yosys/passes/techmap/extract_fa.cc	/^	const int xor2_func = 0x6, xnor2_func = 0x9;$/;"	m	struct:ExtractFaWorker	typeref:typename:const int	file:
xnor3_func	yosys/passes/techmap/extract_fa.cc	/^	const int xor3_func = 0x96, xnor3_func = 0x69;$/;"	m	struct:ExtractFaWorker	typeref:typename:const int	file:
xnor_gate	yosys/kernel/cellaigs.cc	/^	int xnor_gate(int A, int B)$/;"	f	struct:AigMaker	typeref:typename:int	file:
xnor_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> xnor_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
xnor_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> xnor_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
xor2_func	yosys/passes/techmap/extract_fa.cc	/^	const int xor2_func = 0x6, xnor2_func = 0x9;$/;"	m	struct:ExtractFaWorker	typeref:typename:const int	file:
xor3_func	yosys/passes/techmap/extract_fa.cc	/^	const int xor3_func = 0x96, xnor3_func = 0x69;$/;"	m	struct:ExtractFaWorker	typeref:typename:const int	file:
xor_gate	yosys/kernel/cellaigs.cc	/^	int xor_gate(int A, int B)$/;"	f	struct:AigMaker	typeref:typename:int	file:
xor_ss	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> xor_ss(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
xor_uu	yosys/backends/cxxrtl/cxxrtl.h	/^value<BitsY> xor_uu(const value<BitsA> &a, const value<BitsB> &b) {$/;"	f	namespace:cxxrtl_yosys	typeref:typename:CXXRTL_ALWAYS_INLINE value<BitsY>
xorshift128	yosys/libs/ezsat/demo_cmp.cc	/^uint32_t xorshift128() {$/;"	f	typeref:typename:uint32_t
xorshift128	yosys/libs/ezsat/demo_vec.cc	/^uint32_t xorshift128() {$/;"	f	typeref:typename:uint32_t
xorshift128	yosys/libs/ezsat/testbench.cc	/^	xorshift128() {$/;"	f	struct:xorshift128	file:
xorshift128	yosys/libs/ezsat/testbench.cc	/^struct xorshift128 {$/;"	s	file:
xorshift128_sat	yosys/libs/ezsat/demo_vec.cc	/^void xorshift128_sat(ezSAT &sat, std::vector<int> &x, std::vector<int> &y, std::vector<int> &z, /;"	f	typeref:typename:void
xorshift32	yosys/backends/simplec/test00_tb.c	/^uint32_t xorshift32()$/;"	f	typeref:typename:uint32_t
xorshift32	yosys/libs/ezsat/puzzle3d.cc	/^uint32_t xorshift32() {$/;"	f	typeref:typename:uint32_t
xorshift32	yosys/passes/cmds/qwp.cc	/^static double xorshift32()$/;"	f	typeref:typename:double	file:
xorshift32	yosys/passes/cmds/show.cc	/^	static uint32_t xorshift32(uint32_t x) {$/;"	f	struct:ShowWorker	typeref:typename:uint32_t	file:
xorshift32	yosys/passes/tests/test_abcloop.cc	/^static uint32_t xorshift32(uint32_t limit) {$/;"	f	typeref:typename:uint32_t	file:
xorshift32	yosys/passes/tests/test_cell.cc	/^static uint32_t xorshift32(uint32_t limit) {$/;"	f	typeref:typename:uint32_t	file:
xorshift32_state	yosys/passes/cmds/qwp.cc	/^static uint32_t xorshift32_state;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN uint32_t	file:
xorshift32_state	yosys/passes/tests/test_abcloop.cc	/^static uint32_t xorshift32_state = 123456789;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN uint32_t	file:
xorshift32_state	yosys/passes/tests/test_cell.cc	/^static uint32_t xorshift32_state = 123456789;$/;"	v	typeref:typename:USING_YOSYS_NAMESPACE PRIVATE_NAMESPACE_BEGIN uint32_t	file:
xorxnor2	yosys/passes/techmap/extract_fa.cc	/^	pool<tuple<SigBit, SigBit>> xorxnor2;$/;"	m	struct:ExtractFaWorker	typeref:typename:pool<tuple<SigBit,SigBit>>	file:
xorxnor3	yosys/passes/techmap/extract_fa.cc	/^	pool<tuple<SigBit, SigBit, SigBit>> xorxnor3;$/;"	m	struct:ExtractFaWorker	typeref:typename:pool<tuple<SigBit,SigBit,SigBit>>	file:
xrealloc	yosys/libs/minisat/XAlloc.h	/^static inline void* xrealloc(void *ptr, size_t size)$/;"	f	namespace:Minisat	typeref:typename:void *
xs	yosys/libs/minisat/IntMap.h	/^        vec<K>                   xs;$/;"	m	class:Minisat::IntSet	typeref:typename:vec<K>
xs128_t	yosys/passes/sat/mutate.cc	/^	xs128_t(int seed = 0) : w(seed) {$/;"	f	struct:xs128_t	file:
xs128_t	yosys/passes/sat/mutate.cc	/^struct xs128_t$/;"	s	file:
xtrace_db_dump	yosys/kernel/rtlil.h	/^		static inline void xtrace_db_dump()$/;"	f	struct:RTLIL::IdString	typeref:typename:void
y	yosys/libs/ezsat/testbench.cc	/^	uint32_t x, y, z, w;$/;"	m	struct:xorshift128	typeref:typename:uint32_t	file:
y	yosys/passes/sat/mutate.cc	/^	uint32_t y = 0, z = 0, w = 0;$/;"	m	struct:xs128_t	typeref:typename:uint32_t	file:
y	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec a, b, c, y;$/;"	m	struct:AlumaccWorker::alunode_t	typeref:typename:RTLIL::SigSpec	file:
y	yosys/passes/techmap/alumacc.cc	/^		RTLIL::SigSpec y;$/;"	m	struct:AlumaccWorker::maccnode_t	typeref:typename:RTLIL::SigSpec	file:
yosys.html	yosys/Makefile	/^yosys.html: misc\/yosys.html$/;"	t
yosys.js	yosys/Makefile	/^yosys.js: $(filter-out yosysjs-$(YOSYS_VER).zip,$(EXTRA_TARGETS))$/;"	t
yosys_abc_executable	yosys/kernel/yosys.cc	/^std::string yosys_abc_executable;$/;"	v	typeref:typename:std::string
yosys_already_setup	yosys/kernel/yosys.cc	/^bool yosys_already_setup()$/;"	f	typeref:typename:bool
yosys_banner	yosys/kernel/yosys.cc	/^void yosys_banner()$/;"	f	typeref:typename:void
yosys_celltypes	yosys/kernel/yosys.cc	/^CellTypes yosys_celltypes;$/;"	v	typeref:typename:CellTypes
yosys_design	yosys/kernel/yosys.cc	/^RTLIL::Design *yosys_design = NULL;$/;"	v	typeref:typename:RTLIL::Design *
yosys_get_design	yosys/kernel/yosys.cc	/^RTLIL::Design *yosys_get_design()$/;"	f	typeref:typename:RTLIL::Design *
yosys_get_tcl_interp	yosys/kernel/yosys.cc	/^extern Tcl_Interp *yosys_get_tcl_interp()$/;"	f	typeref:typename:Tcl_Interp *
yosys_input_files	yosys/kernel/yosys.cc	/^std::set<std::string> yosys_input_files, yosys_output_files;$/;"	v	typeref:typename:std::set<std::string>
yosys_output_files	yosys/kernel/yosys.cc	/^std::set<std::string> yosys_input_files, yosys_output_files;$/;"	v	typeref:typename:std::set<std::string>
yosys_satsolver	yosys/kernel/register.cc	/^SatSolver *yosys_satsolver;$/;"	v	typeref:typename:SatSolver *
yosys_satsolver_list	yosys/kernel/register.cc	/^SatSolver *yosys_satsolver_list;$/;"	v	typeref:typename:SatSolver *
yosys_setup	yosys/kernel/yosys.cc	/^void yosys_setup()$/;"	f	typeref:typename:void
yosys_share_dirname	yosys/kernel/yosys.cc	/^std::string yosys_share_dirname;$/;"	v	typeref:typename:std::string
yosys_shutdown	yosys/kernel/yosys.cc	/^void yosys_shutdown()$/;"	f	typeref:typename:void
yosys_tcl_interp	yosys/kernel/yosys.cc	/^Tcl_Interp *yosys_tcl_interp = NULL;$/;"	v	typeref:typename:Tcl_Interp *
yosys_xtrace	yosys/kernel/yosys.cc	/^int yosys_xtrace = 0;$/;"	v	typeref:typename:int
yosysjs-$(YOSYS_VER).zip	yosys/Makefile	/^yosysjs-$(YOSYS_VER).zip: yosys.js yosys.wasm viz.js misc\/yosysjs\/*$/;"	t
ys_debug	yosys/kernel/log.h	/^static inline bool ys_debug(int = 0) { return false; }$/;"	f	typeref:typename:bool
ys_debug	yosys/kernel/log.h	/^static inline bool ys_debug(int n = 0) { if (log_force_debug) return true; log_debug_suppressed /;"	f	typeref:typename:bool
ystests	yosys/Makefile	/^ystests: $(TARGETS) $(EXTRA_TARGETS)$/;"	t
z	yosys/libs/ezsat/testbench.cc	/^	uint32_t x, y, z, w;$/;"	m	struct:xorshift128	typeref:typename:uint32_t	file:
z	yosys/passes/sat/mutate.cc	/^	uint32_t y = 0, z = 0, w = 0;$/;"	m	struct:xs128_t	typeref:typename:uint32_t	file:
zapLeadingZeros	yosys/libs/bigint/BigUnsigned.hh	/^	void zapLeadingZeros() { $/;"	f	class:BigUnsigned	typeref:typename:void
zapLeadingZeros	yosys/libs/bigint/BigUnsignedInABase.hh	/^	void zapLeadingZeros() { $/;"	f	class:BigUnsignedInABase	typeref:typename:void
zcast	yosys/backends/cxxrtl/cxxrtl.h	/^	value<NewBits> zcast() const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE value<NewBits>
zero	yosys/libs/bigint/BigInteger.hh	/^	enum Sign { negative = -1, zero = 0, positive = 1 };$/;"	e	enum:BigInteger::Sign
zero_at	yosys/backends/cxxrtl/cxxrtl_capi.h	/^	size_t zero_at;$/;"	m	struct:cxxrtl_object	typeref:typename:size_t
zext	yosys/backends/cxxrtl/cxxrtl.h	/^	value<NewBits> zext() const {$/;"	f	struct:cxxrtl::value	typeref:typename:CXXRTL_ALWAYS_INLINE value<NewBits>
zext_cast	yosys/backends/cxxrtl/cxxrtl.h	/^	struct zext_cast {$/;"	s	struct:cxxrtl::value
zext_cast	yosys/backends/cxxrtl/cxxrtl.h	/^	struct zext_cast<NewBits, typename std::enable_if<(NewBits < Bits)>::type> {$/;"	s	struct:cxxrtl::value
zinit	yosys/passes/sat/sim.cc	/^	bool zinit = false;$/;"	m	struct:SimShared	typeref:typename:bool	file:
zinit	yosys/passes/sat/sim.cc	/^void zinit(Const &v)$/;"	f	typeref:typename:void
zinit	yosys/passes/sat/sim.cc	/^void zinit(State &v)$/;"	f	typeref:typename:void
zinit	yosys/passes/techmap/shregmap.cc	/^	bool zinit, init, params, ffe;$/;"	m	struct:ShregmapOptions	typeref:typename:bool	file:
zinit_mode	yosys/backends/aiger/aiger.cc	/^	bool zinit_mode;$/;"	m	struct:AigerWriter	typeref:typename:bool	file:
~AIWWriter	yosys/passes/sat/sim.cc	/^	virtual ~AIWWriter()$/;"	f	struct:AIWWriter	file:
~AbstractCellEdgesDatabase	yosys/kernel/celledges.h	/^	virtual ~AbstractCellEdgesDatabase() { }$/;"	f	struct:AbstractCellEdgesDatabase
~AstModule	yosys/frontends/ast/ast.cc	/^AstModule::~AstModule()$/;"	f	class:AstModule
~AstNode	yosys/frontends/ast/ast.cc	/^AstNode::~AstNode()$/;"	f	class:AstNode
~AttrmapAction	yosys/passes/techmap/attrmap.cc	/^	virtual ~AttrmapAction() { }$/;"	f	struct:AttrmapAction	file:
~Backend	yosys/kernel/register.cc	/^Backend::~Backend()$/;"	f	class:Backend
~BigUnsigned	yosys/libs/bigint/BigUnsigned.hh	/^	~BigUnsigned() {}$/;"	f	class:BigUnsigned
~BigUnsignedInABase	yosys/libs/bigint/BigUnsignedInABase.hh	/^	~BigUnsignedInABase() {}$/;"	f	class:BigUnsignedInABase
~Binding	yosys/kernel/binding.h	/^	virtual ~Binding() {}$/;"	f	struct:RTLIL::Binding
~CaseRule	yosys/kernel/rtlil.cc	/^RTLIL::CaseRule::~CaseRule()$/;"	f	class:RTLIL::CaseRule
~Cell	yosys/kernel/rtlil.cc	/^RTLIL::Cell::~Cell()$/;"	f	class:RTLIL::Cell
~Design	yosys/kernel/rtlil.cc	/^RTLIL::Design::~Design()$/;"	f	class:RTLIL::Design
~DesignPass	yosys/passes/cmds/design.cc	/^	~DesignPass() override {$/;"	f	struct:DesignPass	file:
~FSTWriter	yosys/passes/sat/sim.cc	/^	virtual ~FSTWriter()$/;"	f	struct:FSTWriter	file:
~FdRpcServer	yosys/frontends/rpc/rpc_frontend.cc	/^	~FdRpcServer() {$/;"	f	struct:FdRpcServer	file:
~FlowGraph	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	~FlowGraph()$/;"	f	struct:FlowGraph	file:
~Frontend	yosys/kernel/register.cc	/^Frontend::~Frontend()$/;"	f	class:Frontend
~FstData	yosys/kernel/fstdata.cc	/^FstData::~FstData()$/;"	f	class:FstData
~HandleRpcServer	yosys/frontends/rpc/rpc_frontend.cc	/^	~HandleRpcServer() {$/;"	f	struct:HandleRpcServer	file:
~HierDirtyFlags	yosys/backends/simplec/simplec.cc	/^	~HierDirtyFlags()$/;"	f	struct:HierDirtyFlags	file:
~IdString	yosys/kernel/rtlil.h	/^		inline ~IdString() { put_reference(index_); }$/;"	f	struct:RTLIL::IdString
~JsonNode	yosys/frontends/json/jsonparse.cc	/^	~JsonNode()$/;"	f	struct:JsonNode	file:
~JsonValue	yosys/libs/json11/json11.hpp	/^    virtual ~JsonValue() {}$/;"	f	class:json11::JsonValue
~LibertyAst	yosys/passes/techmap/libparse.cc	/^LibertyAst::~LibertyAst()$/;"	f	class:LibertyAst
~LibertyParser	yosys/passes/techmap/libparse.h	/^		~LibertyParser() { if (ast) delete ast; }$/;"	f	struct:Yosys::LibertyParser
~LogMakeDebugHdl	yosys/kernel/log.h	/^	~LogMakeDebugHdl() {$/;"	f	struct:LogMakeDebugHdl
~Map	yosys/libs/minisat/Map.h	/^    ~Map () { delete [] table; }$/;"	f	class:Minisat::Map
~Memory	yosys/kernel/rtlil.cc	/^RTLIL::Memory::~Memory()$/;"	f	class:RTLIL::Memory
~ModIndex	yosys/kernel/modtools.h	/^	~ModIndex()$/;"	f	struct:ModIndex
~Module	yosys/kernel/rtlil.cc	/^RTLIL::Module::~Module()$/;"	f	class:RTLIL::Module
~Monitor	yosys/kernel/rtlil.h	/^	virtual ~Monitor() { }$/;"	f	struct:RTLIL::Monitor
~NumberlikeArray	yosys/libs/bigint/NumberlikeArray.hh	/^	~NumberlikeArray() {$/;"	f	class:NumberlikeArray
~ObjIterator	yosys/kernel/rtlil.h	/^		~ObjIterator() {$/;"	f	struct:RTLIL::ObjIterator
~Option	yosys/libs/minisat/Options.h	/^    virtual ~Option() {}$/;"	f	class:Minisat::Option
~OutputWriter	yosys/passes/sat/sim.cc	/^	virtual ~OutputWriter() {};$/;"	f	struct:OutputWriter	file:
~Pass	yosys/kernel/register.cc	/^Pass::~Pass()$/;"	f	class:Pass
~Process	yosys/kernel/rtlil.cc	/^RTLIL::Process::~Process()$/;"	f	class:RTLIL::Process
~RegionAllocator	yosys/libs/minisat/Alloc.h	/^    ~RegionAllocator()$/;"	f	class:Minisat::RegionAllocator
~RpcServer	yosys/frontends/rpc/rpc_frontend.cc	/^	virtual ~RpcServer() { }$/;"	f	struct:RpcServer	file:
~SatSolver	yosys/kernel/satgen.h	/^	virtual ~SatSolver() {$/;"	f	struct:SatSolver
~Scheduler	yosys/backends/cxxrtl/cxxrtl_backend.cc	/^	~Scheduler()$/;"	f	struct:Scheduler	file:
~ShregmapTech	yosys/passes/techmap/shregmap.cc	/^	virtual ~ShregmapTech() { }$/;"	f	struct:ShregmapTech	file:
~SimInstance	yosys/passes/sat/sim.cc	/^	~SimInstance()$/;"	f	struct:SimInstance	file:
~SimWorker	yosys/passes/sat/sim.cc	/^	~SimWorker()$/;"	f	struct:SimWorker	file:
~SimpSolver	yosys/libs/minisat/SimpSolver.cc	/^SimpSolver::~SimpSolver()$/;"	f	class:SimpSolver
~Smt2Worker	yosys/backends/smt2/smt2.cc	/^	~Smt2Worker()$/;"	f	struct:Smt2Worker	file:
~Solver	yosys/libs/minisat/Solver.cc	/^Solver::~Solver()$/;"	f	class:Solver
~Solver	yosys/libs/subcircuit/subcircuit.cc	/^SubCircuit::Solver::~Solver()$/;"	f	class:SubCircuit::Solver
~StreamBuffer	yosys/libs/minisat/ParseUtils.h	/^    virtual ~StreamBuffer() { }$/;"	f	class:Minisat::StreamBuffer
~SwitchRule	yosys/kernel/rtlil.cc	/^RTLIL::SwitchRule::~SwitchRule()$/;"	f	class:RTLIL::SwitchRule
~Wire	yosys/kernel/rtlil.cc	/^RTLIL::Wire::~Wire()$/;"	f	class:RTLIL::Wire
~define_map_t	yosys/frontends/verilog/preproc.cc	/^define_map_t::~define_map_t()$/;"	f	class:define_map_t
~destruct_guard_t	yosys/kernel/rtlil.h	/^			~destruct_guard_t() { ok = false; }$/;"	f	struct:RTLIL::IdString::destruct_guard_t
~ezMiniSAT	yosys/libs/ezsat/ezminisat.cc	/^ezMiniSAT::~ezMiniSAT()$/;"	f	class:ezMiniSAT
~ezSAT	yosys/libs/ezsat/ezsat.cc	/^ezSAT::~ezSAT()$/;"	f	class:ezSAT
~gzip_streambuf	yosys/kernel/register.cc	/^		virtual ~gzip_streambuf()$/;"	f	class:gzip_ostream::gzip_streambuf	file:
~module	yosys/backends/cxxrtl/cxxrtl.h	/^	virtual ~module() {}$/;"	f	struct:cxxrtl::module
~stackmap	yosys/kernel/utils.h	/^	~stackmap()$/;"	f	struct:stackmap
~vec	yosys/libs/minisat/Vec.h	/^   ~vec()                                                       { clear(true); }$/;"	f	class:Minisat::vec
